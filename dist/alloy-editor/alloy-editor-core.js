window["AlloyEditor"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/adapter/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/adapter/core.js":
/*!*****************************!*\
  !*** ./src/adapter/core.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

__webpack_require__(/*! ../core */ "./src/core/index.js");

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

__webpack_require__(/*! ../components/uibridge/uibridge.js */ "./src/components/uibridge/uibridge.js");

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _base = __webpack_require__(/*! ../oop/base */ "./src/oop/base.js");

var _base2 = _interopRequireDefault(_base);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _main = __webpack_require__(/*! ../components/main.jsx */ "./src/components/main.jsx");

var _main2 = _interopRequireDefault(_main);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * AlloyEditor main class. Creates instance of the editor and provides the user configuration
 * to the UI.
 *
 * @class Core
 * @constructor
 */
function Core(config) {
    Core.superclass.constructor.call(this, config);
}

(0, _oop2.default)(Core, _base2.default, {
    /**
     * Initializer lifecycle implementation for the AlloyEditor class. Creates a CKEditor
     * instance, passing it the provided configuration attributes.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method initializer
     * @param config {Object} Configuration object literal for the editor.
     */
    initializer: function initializer(config) {
        var node = this.get('srcNode');

        if (this.get('enableContentEditable')) {
            node.setAttribute('contenteditable', 'true');
        }

        var editor = CKEDITOR.inline(node);

        editor.config.allowedContent = this.get('allowedContent');

        editor.config.toolbars = this.get('toolbars');

        editor.config.removePlugins = this.get('removePlugins');
        editor.config.extraPlugins = this.get('extraPlugins');
        editor.config.placeholderClass = this.get('placeholderClass');

        editor.config.pasteFromWordRemoveStyles = false;
        editor.config.pasteFromWordRemoveFontStyles = false;

        editor.config.selectionKeystrokes = this.get('selectionKeystrokes');

        _lang2.default.mix(editor.config, config);

        if (CKEDITOR.env.ie && !CKEDITOR.env.edge) {
            editor.config.extraPlugins = editor.config.extraPlugins.replace('ae_dragresize', 'ae_dragresize_ie');
            editor.config.removePlugins = editor.config.removePlugins.replace('ae_dragresize', 'ae_dragresize_ie');
        }

        editor.once('contentDom', function () {

            this._addReadOnlyLinkClickListener(editor);

            var editable = editor.editable();

            editable.addClass('ae-editable');
        }.bind(this));

        this._editor = editor;

        AlloyEditor.loadLanguageResources(this._renderUI.bind(this));
    },

    /**
     * Destructor lifecycle implementation for the AlloyEdtor class. Destroys the CKEditor
     * instance and destroys all created toolbars.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method destructor
     */
    destructor: function destructor() {
        this._destroyed = true;

        if (this._editorUIElement) {
            _reactDom2.default.unmountComponentAtNode(this._editorUIElement);
            this._editorUIElement.parentNode.removeChild(this._editorUIElement);
        }

        var nativeEditor = this.get('nativeEditor');

        if (nativeEditor) {
            var editable = nativeEditor.editable();

            if (editable) {
                editable.removeClass('ae-editable');

                if (this.get('enableContentEditable')) {
                    this.get('srcNode').setAttribute('contenteditable', 'false');
                }
            }

            this._clearSelections();

            nativeEditor.destroy();
        }
    },

    /**
     * Clear selections from window object
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _clearSelections
     */
    _clearSelections: function _clearSelections() {
        var nativeEditor = this.get('nativeEditor');
        var isMSSelection = typeof window.getSelection != 'function';

        if (isMSSelection) {
            nativeEditor.document.$.selection.empty();
        } else {
            nativeEditor.document.getWindow().$.getSelection().removeAllRanges();
        }
    },

    /**
     * Method to set default link behavior
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _addReadOnlyLinkClickListener
     * @param {Object} editor
     */
    _addReadOnlyLinkClickListener: function _addReadOnlyLinkClickListener(editor) {
        editor.editable().on('click', this._defaultReadOnlyClickFn, this, {
            editor: editor
        });
    },

    /**
     * Called on `click` event when the editor is in read only mode. Navigates to link's URL or opens
     * the link in a new window.
     *
     * @memberof Core
     * @instance
     * @event readOnlyClick
     * @protected
     * @method _defaultReadOnlyClickFn
     * @param {Object} event The fired `click` event payload
     */
    _defaultReadOnlyClickFn: function _defaultReadOnlyClickFn(event) {
        var mouseEvent = event.data.$;
        var hasCtrlKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
        var shouldOpen = this._editor.config.readOnly || hasCtrlKey;

        mouseEvent.preventDefault();

        if (!shouldOpen) {
            return;
        }

        if (event.listenerData.editor.editable().editor.fire('readOnlyClick', event.data) !== false) {
            var ckElement = new CKEDITOR.dom.elementPath(event.data.getTarget(), this);
            var link = ckElement.lastElement;

            if (link) {
                var href = link.$.attributes.href ? link.$.attributes.href.value : null;
                var target = hasCtrlKey ? '_blank' : link.$.attributes.target ? link.$.attributes.target.value : null;
                this._redirectLink(href, target);
            }
        }
    },

    /**
     * Retrieves the native CKEditor instance. Having this, the developer may use the API of CKEditor OOTB.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _getNativeEditor
     * @return {Object} The current instance of CKEditor.
     */
    _getNativeEditor: function _getNativeEditor() {
        return this._editor;
    },

    /**
     * Redirects the browser to a given link
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _redirectLink
     * @param {string} href The href to take the browser to
     * @param {string=} target Specifies where to display the link
     */
    _redirectLink: function _redirectLink(href, target) {
        if (target && href) {
            window.open(href, target);
        } else if (href) {
            window.location.href = href;
        }
    },

    /**
     * Renders the specified from the user toolbars.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _renderUI
     */
    _renderUI: function _renderUI() {
        if (!this._destroyed) {
            var editorUIElement = document.createElement('div');
            editorUIElement.className = 'ae-ui';

            var uiNode = this.get('uiNode') || document.body;

            uiNode.appendChild(editorUIElement);

            this._mainUI = _reactDom2.default.render(_react2.default.createElement(_main2.default, {
                editor: this,
                eventsDelay: this.get('eventsDelay'),
                toolbars: this.get('toolbars') }), editorUIElement);

            this._editorUIElement = editorUIElement;

            this.get('nativeEditor').fire('uiReady');
        }
    },

    /**
     * The function returns an HTML element from the passed value. If the passed value is a string, it should be
     * the Id of the element which have to be retrieved from the DOM.
     * If an HTML Element is passed, the element itself will be returned.
     *
     * @memberof Core
     * @instance
     * @method _toElement
     * @protected
     * @param {!(String|HTMLElement)} value String, which have to correspond to an HTML element from the DOM,
     * or the HTML element itself. If Id is passed, the HTML element will be retrieved from the DOM.
     * @return {HTMLElement} An HTML element.
     */
    _toElement: function _toElement(value) {
        if (_lang2.default.isString(value)) {
            value = document.getElementById(value);
        }

        return value;
    },

    /**
     * Validates the allowed content attribute. Look
     * [here](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent) for more information about the
     * supported values.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _validateAllowedContent
     * @param {Any} The value to be checked
     * @return {Boolean} True if the current value is valid configuration, false otherwise
     */
    _validateAllowedContent: function _validateAllowedContent(value) {
        return _lang2.default.isString(value) || _lang2.default.isObject(value) || _lang2.default.isBoolean(value);
    },

    /**
     * Validates the value of toolbars attribute
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _validateToolbars
     * @param {Any} The value to be checked
     * @return {Boolean} True if the current value is valid toolbars configuration, false otherwise
     */
    _validateToolbars: function _validateToolbars(value) {
        return _lang2.default.isObject(value) || _lang2.default.isNull(value);
    }
}, {
    ATTRS: {
        /**
         * Configures the allowed content for the current instance of AlloyEditor.
         * Look on the [official CKEditor API](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent)
         * for more information about the valid values.
         *
         * @memberof Core
         * @instance
         * @property allowedContent
         * @default true
         * @writeOnce
         * @type {Boolean, String, Object}
         */
        allowedContent: {
            validator: '_validateAllowedContent',
            value: true,
            writeOnce: true
        },

        /**
         * Specifies whether AlloyEditor set the contenteditable attribute
         * to "true" on its srcNode.
         *
         * @memberof Core
         * @instance
         * @property enableContentEditable
         * @type Boolean
         * @default true
         * @writeOnce
         */
        enableContentEditable: {
            validator: _lang2.default.isBoolean,
            value: true,
            writeOnce: true
        },

        /**
         * The delay (timeout), in ms, after which events such like key or mouse events will be processed.
         *
         * @memberof Core
         * @instance
         * @property eventsDelay
         * @type {Number}
         */
        eventsDelay: {
            validator: _lang2.default.isNumber,
            value: 100
        },

        /**
         * Specifies the extra plugins which have to be loaded to the current CKEditor instance in order to
         * make AlloyEditor to work properly.
         *
         * @memberof Core
         * @instance
         * @property extraPlugins
         * @default 'uicore,selectionregion,dragresize,addimages,placeholder,tabletools,tableresize,autolink'
         * @writeOnce
         * @type {String}
         */
        extraPlugins: {
            validator: _lang2.default.isString,
            value: 'ae_uicore,ae_selectionregion,ae_selectionkeystrokes,ae_imagealignment,ae_addimages,ae_placeholder,' + 'ae_tabletools,ae_tableresize,ae_autolink,ae_embed,ae_autolist,ae_dragresize,' + 'ae_uibridge',
            //'ae_uibridge,ae_richcombobridge,ae_panelmenubuttonbridge,ae_menubridge,ae_menubuttonbridge,ae_buttonbridge',
            writeOnce: true
        },

        /**
         * Retrieves the native CKEditor instance. Having this, the developer may use the full API of CKEditor.
         *
         * @memberof Core
         * @instance
         * @property nativeEditor
         * @readOnly
         * @type {Object}
         */
        nativeEditor: {
            getter: '_getNativeEditor',
            readOnly: true
        },

        /**
         * Specifies the class, which should be added by Placeholder plugin
         * {{#crossLink "CKEDITOR.plugins.ae_placeholder}}{{/crossLink}}
         * when editor is not focused.
         *
         * @memberof Core
         * @instance
         * @property placeholderClass
         * @default 'ae-placeholder'
         * @writeOnce
         * @type {String}
         */
        placeholderClass: {
            validator: _lang2.default.isString,
            value: 'ae-placeholder',
            writeOnce: true
        },

        /**
         * Specifies the plugins, which come by default with CKEditor, but which are not needed by AlloyEditor.
         * These plugins add the default UI for CKeditor, which is no more needed. Please note that AlloyEdtor
         * comes with its own highly optimized copy of CKEditor (just customized via their official download page).
         * This version does not come with the unneeded plugins, so the value of this property won't be needed.
         * However, if you decide to go with the OOTB version of CKEditor, you will have to remove some of the
         * plugins if you decide to use AlloyEditor. Keep in mind that removing these plugins doesn't remove them
         * entirely from CKEditor. It just removes them from its current instance, in which you will use different
         * UI - those of AlloyEditor. You will be fully able to use both OOTB CKEditor and AlloyEditor on the same
         * page!
         *
         * @memberof Core
         * @instance
         * @property removePlugins
         * @default 'contextmenu,toolbar,elementspath,resize,liststyle,link'
         * @writeOnce
         * @type {String}
         */
        removePlugins: {
            validator: _lang2.default.isString,
            value: 'contextmenu,toolbar,elementspath,resize,liststyle,link',
            writeOnce: true
        },

        /**
         * Array of manual selection triggers. They can be configured to manually show a specific selection toolbar
         * by forcing the selection type. A selectionKeystroke item consists of a keys property with a [CKEditor keystroke
         * definition](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-keystrokes) and a selection property with
         * the selection name to trigger.
         *
         * @memberof Core
         * @instance
         * @property selectionKeystrokes
         * @type {Array}
         */
        selectionKeystrokes: {
            validator: _lang2.default.isArray,
            value: [{
                keys: CKEDITOR.CTRL + 76 /*L*/
                , selection: 'link'
            }, {
                keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /*L*/
                , selection: 'embed'
            }]
        },

        /**
         * The Node ID or HTMl node, which AlloyEditor should use as an editable area.
         *
         * @memberof Core
         * @instance
         * @property srcNode
         * @type String | Node
         * @writeOnce
         */
        srcNode: {
            setter: '_toElement',
            writeOnce: true
        },

        /**
         * The toolbars configuration for this editor instance
         *
         * @memberof Core
         * @instance
         * @property {Object} toolbars
         */
        toolbars: {
            validator: '_validateToolbars',
            value: {
                add: {
                    buttons: ['image', 'embed', 'camera', 'hline', 'table'],
                    tabIndex: 2
                },
                styles: {
                    selections: _selections2.default,
                    tabIndex: 1
                }
            }
        },

        /**
         * The Node ID or HTMl node, where AlloyEditor's UI should be rendered.
         *
         * @memberof Core
         * @instance
         * @property uiNode
         * @type String | Node
         * @writeOnce
         */
        uiNode: {
            setter: '_toElement',
            writeOnce: true
        }
    }
});

CKEDITOR.event.implementOn(Core);

exports.default = Core;

/***/ }),

/***/ "./src/adapter/main.js":
/*!*****************************!*\
  !*** ./src/adapter/main.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Toolbars = exports.SelectionTest = exports.registerBridgeButton = exports.loadLanguageResources = exports.implementEventTarget = exports.getUrl = exports.getButtons = exports.getBasePath = exports.editable = exports.Buttons = undefined;

var _core = __webpack_require__(/*! ./core.js */ "./src/adapter/core.js");

var _core2 = _interopRequireDefault(_core);

var _lang = __webpack_require__(/*! ../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _buttons = __webpack_require__(/*! ../components/buttons */ "./src/components/buttons/index.js");

var _buttons2 = _interopRequireDefault(_buttons);

var _toolbars = __webpack_require__(/*! ../components/toolbars */ "./src/components/toolbars/index.js");

var _toolbars2 = _interopRequireDefault(_toolbars);

var _selectionTest = __webpack_require__(/*! ../selections/selection-test.js */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// An object containing all currently registered plugins in AlloyEditor.
var BRIDGE_BUTTONS = {};

/**
 * Creates an instance of AlloyEditor.
 *
 * @memberof AlloyEditor
 * @method editable
 * @static
 * @param {String|Node} node The Node ID or HTMl node, which AlloyEditor should use as an editable area.
 * @param {Object} config Configuration attributes for the current instance of AlloyEditor.
 * @return {Object} An instance of {{#crossLink "Core"}}{{/crossLink}}
 */
var editable = function editable(node, config) {
    config = config || {};
    config.srcNode = node;

    AlloyEditor.implementEventTarget();

    return new _core2.default(config);
};

/**
 * The full URL for the AlloyEditor installation directory.
 * It is possible to manually provide the base path by setting a
 * global variable named `ALLOYEDITOR_BASEPATH`. This global variable
 * must be set **before** the editor script loading.
 *
 * @memberof AlloyEditor
 * @method getBasePath
 * @static
 * @return {String} The found base path
 */
var getBasePath = function getBasePath() {
    // Find out the editor directory path, based on its <script> tag.
    var path = window.ALLOYEDITOR_BASEPATH || '';

    if (!path) {
        var scripts = document.getElementsByTagName('script');

        for (var i = 0; i < scripts.length; i++) {
            var match = scripts[i].src.match(AlloyEditor.regexBasePath);

            if (match) {
                path = match[1];
                break;
            }
        }
    }

    // In IE (only) the script.src string is the raw value entered in the
    // HTML source. Other browsers return the full resolved URL instead.
    if (path.indexOf(':/') === -1 && path.slice(0, 2) !== '//') {
        // Absolute path.
        if (path.indexOf('/') === 0) {
            path = location.href.match(/^.*?:\/\/[^\/]*/)[0] + path;
        }
        // Relative path.
        else {
                path = location.href.match(/^[^\?]*\/(?:)/)[0] + path;
            }
    }

    if (!path) {
        throw 'The AlloyEditor installation path could not be automatically detected. Please set the global variable "ALLOYEDITOR_BASEPATH" before creating editor instances.';
    }

    return path;
};

/**
 * Detects and load the corresponding language file if AlloyEditor language strings are not already present.
 * The function fires a {{#crossLink "AlloyEditor/languageResourcesLoaded:event"}}{{/crossLink}} event
 *
 * @memberof AlloyEditor
 * @method loadLanguageResources
 * @static
 * @param {Function} callback Optional callback to be called when AlloyEditor loads the language resource.
 */
var loadLanguageResources = function loadLanguageResources(callback) {
    AlloyEditor.implementEventTarget();

    if (_lang2.default.isFunction(callback)) {
        if (AlloyEditor.Strings) {
            setTimeout(callback, 0);
        } else {
            AlloyEditor.once('languageResourcesLoaded', function () {
                setTimeout(callback, 0);
            });
        }
    }

    if (!AlloyEditor._langResourceRequested) {
        AlloyEditor._langResourceRequested = true;

        var languages = ['af', 'ar', 'bg', 'bn', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fo', 'fr-ca', 'fr', 'gl', 'gu', 'he', 'hi', 'hr', 'hu', 'id', 'is', 'it', 'ja', 'ka', 'km', 'ko', 'ku', 'lt', 'lv', 'mk', 'mn', 'ms', 'nb', 'nl', 'no', 'pl', 'pt-br', 'pt', 'ro', 'ru', 'si', 'sk', 'sl', 'sq', 'sr-latn', 'sr', 'sv', 'th', 'tr', 'tt', 'ug', 'uk', 'vi', 'zh-cn', 'zh'];

        var userLanguage = navigator.language || navigator.userLanguage || 'en';

        var parts = userLanguage.toLowerCase().match(/([a-z]+)(?:-([a-z]+))?/);
        var lang = parts[1];
        var locale = parts[2];

        if (languages.indexOf(lang + '-' + locale) >= 0) {
            lang = lang + '-' + locale;
        } else if (languages.indexOf(lang) === -1) {
            lang = 'en';
        }

        CKEDITOR.scriptLoader.load(AlloyEditor.getUrl('lang/alloy-editor/' + lang + '.js'), function (loaded) {
            if (loaded) {
                AlloyEditor.fire('languageResourcesLoaded');
            }
        }, this);
    }
};

/**
 * Gets the full URL for AlloyEditor resources. By default, URLs
 * returned by this function contain a querystring parameter ("t")
 * set to the {@link CKEDITOR#timestamp} value.
 *
 * @memberof AlloyEditor
 * @method getUrl
 * @static
 * @param {String} resource The resource whose full URL we want to get.
 * It may be a full, absolute, or relative URL.
 * @return {String} The full URL.
 */
var getUrl = function getUrl(resource) {
    var basePath = AlloyEditor.getBasePath();

    // If this is not a full or absolute path.
    if (resource.indexOf(':/') === -1 && resource.indexOf('/') !== 0) {
        resource = basePath + resource;
    }

    // Add the timestamp, except for directories.
    if (CKEDITOR.timestamp && resource.charAt(resource.length - 1) !== '/' && !/[&?]t=/.test(resource)) {
        resource += (resource.indexOf('?') >= 0 ? '&' : '?') + 't=' + CKEDITOR.timestamp;
    }

    return resource;
};

/**
 * Implements event firing and subscribing via CKEDITOR.event.
 *
 * @memberof AlloyEditor
 * @method implementEventTarget
 * @static
 */
var implementEventTarget = function implementEventTarget() {
    if (!AlloyEditor.fire && !AlloyEditor.on) {
        CKEDITOR.event.implementOn(AlloyEditor);
    }
};

/**
 * Regular expression which should match the script which have been used to load AlloyEditor.
 *
 * @memberof AlloyEditor
 * @property regexBasePath
 * @type {RegExp}
 * @static
 */
var regexBasePath = /(^|.*[\\\/])(?:alloy-editor[^/]+|alloy-editor)\.js(?:\?.*|;.*)?$/i;

/**
 * Fired when AlloyEditor detects the browser language and loads the corresponding language file. Once this event
 * is fired, AlloyEditor.Strings will be populated with data.
 *
 * @event languageResourcesLoaded
 */

/**
 * Returns the required plugin names needed for a given plugin
 * if it is already registered or an empty array.
 *
 * @memberof AlloyEditor
 * @method getButtons
 * @param {Array} buttons An array of buttons or plugin names.
 * @return {Function} A function that can be invoked to resolve the requested button names.
 * @static
 */
var getButtons = function getButtons(buttons) {
    return function () {
        return buttons.reduce(function (acc, val) {
            val = BRIDGE_BUTTONS[val] || [val];
            return acc.concat(val);
        }, []);
    };
};

/**
 * Register a button and try to get its required plugins.
 *
 * @memberof AlloyEditor
 * @method registerBridgeButton
 * @param {String} buttonName The name of the button.
 * @param {String} pluginName The name of the plugin that registers the button.
 * @static
 */
var registerBridgeButton = function registerBridgeButton(buttonName, pluginName) {
    if (!BRIDGE_BUTTONS[pluginName]) {
        BRIDGE_BUTTONS[pluginName] = [];
    }

    BRIDGE_BUTTONS[pluginName].push(buttonName);
};

exports.Buttons = _buttons2.default;
exports.editable = editable;
exports.getBasePath = getBasePath;
exports.getButtons = getButtons;
exports.getUrl = getUrl;
exports.implementEventTarget = implementEventTarget;
exports.loadLanguageResources = loadLanguageResources;
exports.registerBridgeButton = registerBridgeButton;
exports.SelectionTest = _selectionTest2.default;
exports.Toolbars = _toolbars2.default;

/***/ }),

/***/ "./src/components/base/button-action-style.js":
/*!****************************************************!*\
  !*** ./src/components/base/button-action-style.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonActionStyle is a mixin that provides applying style implementation for a
 * button based on the `applyStyle` and `removeStyle` API of CKEDITOR.
 *
 * To execute properly, the component has to expose the following methods which can be obtained
 * out of the box using the {{#crossLink "ButtonStyle"}}{{/crossLink}} mixin:
 * - `Function` {{#crossLink "ButtonStyle/isActive"}}{{/crossLink}} to check the active state
 * - `Function` {{#crossLink "ButtonStyle/getStyle"}}{{/crossLink}} to return the style that should be applied
 *
 * @class ButtonActionStyle
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'applyStyle',

            /**
             * Removes or applies the component style to the current selection.
             *
             * @instance
             * @memberof ButtonActionStyle
             * @method applyStyle
             */
            value: function applyStyle() {
                if (_lang2.default.isFunction(this.isActive) && _lang2.default.isFunction(this.getStyle)) {
                    var editor = this.props.editor.get('nativeEditor');

                    editor.getSelection().lock();

                    if (this.isActive()) {
                        editor.removeStyle(this.getStyle());
                    } else {
                        editor.applyStyle(this.getStyle());
                    }

                    editor.getSelection().unlock();

                    editor.fire('actionPerformed', this);
                }
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-command-active.js":
/*!******************************************************!*\
  !*** ./src/components/base/button-command-active.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCommandActive is a mixin that provides an `isActive` method to determine if
 * a context-aware command is currently in an active state.
 *
 * @class ButtonCommandActive
 */
exports.default = function (WrappedComponent) {
  return function (_WrappedComponent) {
    _inherits(_class, _WrappedComponent);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'isActive',

      /**
       * Checks if the command is active in the current selection.
       *
       * @instance
       * @memberof ButtonCommandActive
       * @method isActive
       * @return {Boolean} True if the command is active, false otherwise.
       */
      value: function isActive() {
        var editor = this.props.editor.get('nativeEditor');

        var command = editor.getCommand(this.props.command);

        return command ? command.state === CKEDITOR.TRISTATE_ON : false;
      }
    }]);

    return _class;
  }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-command.js":
/*!***********************************************!*\
  !*** ./src/components/base/button-command.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCommand is a mixin that executes a command via CKEDITOR's API.
 *
 * @class ButtonCommand
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'execCommand',

            /**
             * Executes a CKEditor command and fires `actionPerformed` event.
             *
             * @instance
             * @memberof ButtonCommand
             * @param {Object=} data Optional data to be passed to CKEDITOR's `execCommand` method.
             * @method execCommand
             */
            value: function execCommand(data) {
                var editor = this.props.editor.get('nativeEditor');

                editor.execCommand(this.props.command, data);

                if (this.props.modifiesSelection) {
                    editor.selectionChange(true);
                }

                editor.fire('actionPerformed', this);
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-keystroke.js":
/*!*************************************************!*\
  !*** ./src/components/base/button-keystroke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonKeystroke is a mixin that provides a `keystroke` prop that allows configuring
 * a function of the instance to be invoked upon the keystroke activation.
 *
 * @class ButtonKeystroke
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentWillMount',

            /**
             * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
             *
             * @instance
             * @memberof ButtonKeystroke
             * @method componentWillMount
             */
            value: function componentWillMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this).call(this);
                }

                var nativeEditor = this.props.editor.get('nativeEditor');
                var keystroke = this.props.keystroke;

                var commandName = keystroke.name || (Math.random() * 1e9 >>> 0).toString();

                var command = nativeEditor.getCommand(commandName);

                if (!command) {
                    command = new CKEDITOR.command(nativeEditor, {
                        exec: function (editor) {
                            var keystrokeFn = keystroke.fn;

                            if (_lang2.default.isString(keystrokeFn)) {
                                this[keystrokeFn].call(this, editor);
                            } else if (_lang2.default.isFunction(keystrokeFn)) {
                                keystrokeFn.call(this, editor);
                            }
                        }.bind(this)
                    });

                    nativeEditor.addCommand(commandName, command);
                }

                this._defaultKeystrokeCommand = nativeEditor.keystrokeHandler.keystrokes[keystroke.keys];

                nativeEditor.setKeystroke(keystroke.keys, commandName);
            }

            /**
             * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
             *
             * @instance
             * @memberof ButtonKeystroke
             * @method componentWillUnmount
             */

        }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this).call(this);
                }

                this.props.editor.get('nativeEditor').setKeystroke(this.props.keystroke.keys, this._defaultKeystrokeCommand);
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-props.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-props.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCfgProps is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonCfgProps
 */
exports.default = function (WrappedComponent) {
  return function (_WrappedComponent) {
    _inherits(_class, _WrappedComponent);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'mergeButtonCfgProps',

      /**
       * Merges the properties, passed to the current component with user's configuration
       * via `buttonCfg` property.
       *
       * @instance
       * @memberof ButtonCfgProps
       * @method mergeButtonCfgProps
       * @param {Object} props The properties to be merged with the provided configuration for this
       * button. If not passed, the user configuration will be merged with `this.props`
       * @return {Object} The merged properties
       */
      value: function mergeButtonCfgProps(props) {
        props = props || this.props;

        var nativeEditor = this.props.editor.get('nativeEditor');
        var buttonCfg = nativeEditor.config.buttonCfg || {};
        var result = CKEDITOR.tools.merge(props, buttonCfg['linkEdit']);

        return result;
      }
    }]);

    return _class;
  }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-state-classes.js":
/*!*****************************************************!*\
  !*** ./src/components/base/button-state-classes.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonStateClasses is a mixin that decorates the domElement of a component
 * with different CSS classes based on the current state of the element.
 *
 * To check for state, the component can expose the following methods:
 * - `Function` **isActive** to check the active state
 * - `Function` **isDisabled** to check the disabled state
 *
 * @class ButtonStateClasses
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getStateClasses',

            /**
             * Returns the list of state classes associated to the current element's state, according
             * to the results of the isActive and isDisabled methods.
             *
             * @instance
             * @memberof ButtonStateClasses
             * @method getStateClasses
             * @return {String} A string with the state CSS classes.
             */
            value: function getStateClasses() {
                var stateClasses = '';

                // Check for active state
                if (_lang2.default.isFunction(this.isActive) && this.isActive()) {
                    stateClasses += 'ae-button-pressed';
                }

                // Check for disabled state
                if (_lang2.default.isFunction(this.isDisabled) && this.isDisabled()) {
                    stateClasses += ' ae-button-disabled';
                }

                return stateClasses;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-style.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-style.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonStyle is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonStyle
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentWillMount',

            /**
             * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
             *
             * @instance
             * @memberof ButtonStyle
             * @method componentWillMount
             */
            value: function componentWillMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this).call(this);
                }

                var style = this.props.style;

                if (_lang2.default.isString(style)) {
                    var parts = style.split('.');
                    var currentMember = this.props.editor.get('nativeEditor').config;
                    var property = parts.shift();

                    while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
                        currentMember = currentMember[property];
                        property = parts.shift();
                    }

                    if (_lang2.default.isObject(currentMember)) {
                        style = currentMember;
                    }
                }

                this._style = new CKEDITOR.style(style);
            }

            /**
             * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
             *
             * @instance
             * @memberof ButtonStyle
             * @method componentWillUnmount
             */

        }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this).call(this);
                }

                this._style = null;
            }

            /**
             * Returns instance of CKEDITOR.style which represents the current button style.
             *
             * @instance
             * @memberof ButtonStyle
             * @method getStyle
             * @return {CKEDITOR.style} The current style representation.
             */

        }, {
            key: 'getStyle',
            value: function getStyle() {
                return this._style;
            }

            /**
             * Checks if style is active in the current selection.
             *
             * @instance
             * @memberof ButtonStyle
             * @method isActive
             * @return {Boolean} True if style is active, false otherwise.
             */

        }, {
            key: 'isActive',
            value: function isActive() {
                var result;

                var editor = this.props.editor.get('nativeEditor');

                var elementPath = editor.elementPath();

                result = this.getStyle().checkActive(elementPath, editor);

                return result;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/toolbar-buttons.js":
/*!************************************************!*\
  !*** ./src/components/base/toolbar-buttons.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ToolbarButtons is a mixin which provides a list of buttons which have to be
 * displayed on the current toolbar depending on user preferences and given state.
 *
 * @class ToolbarButtons
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getToolbarButtons',

            /**
             * Analyzes the current selection and the buttons exclusive mode value to figure out which
             * buttons should be present in a given state.
             *
             * @instance
             * @memberof ToolbarButtons
             * @method getToolbarButtons
             * @param {Array} buttons The buttons could be shown, prior to the state filtering.
             * @param {Object} additionalProps Additional props that should be passed down to the buttons.
             * @return {Array} An Array which contains the buttons that should be rendered.
             */
            value: function getToolbarButtons(buttons, additionalProps) {
                var buttonProps = {};

                var nativeEditor = this.props.editor.get('nativeEditor');
                var buttonCfg = nativeEditor.config.buttonCfg || {};

                if (_lang2.default.isFunction(buttons)) {
                    buttons = buttons.call(this) || [];
                }

                var toolbarButtons = this.filterExclusive(buttons.filter(function (button) {
                    return button && (AlloyEditor.Buttons[button] || AlloyEditor.Buttons[button.name]);
                }).map(function (button) {
                    if (_lang2.default.isString(button)) {
                        buttonProps[button] = buttonCfg[button];
                        button = AlloyEditor.Buttons[button];
                    } else if (_lang2.default.isString(button.name)) {
                        buttonProps[AlloyEditor.Buttons[button.name].key] = CKEDITOR.tools.merge(buttonCfg[button], button.cfg);
                        button = AlloyEditor.Buttons[button.name];
                    }

                    return button;
                })).map(function (button) {
                    var props = this.mergeExclusiveProps({
                        editor: this.props.editor,
                        key: button.key,
                        tabKey: button.key,
                        tabIndex: this.props.trigger && this.props.trigger.props.tabKey === button.key ? 0 : -1,
                        trigger: this.props.trigger
                    }, button.key);

                    props = this.mergeDropdownProps(props, button.key);

                    if (additionalProps) {
                        props = CKEDITOR.tools.merge(props, additionalProps);
                    }

                    props = CKEDITOR.tools.merge(props, buttonProps[button.key]);

                    return _react2.default.createElement(button, props);
                }, this);

                return toolbarButtons;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-arrow-box.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-arrow-box.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for displaying Widget Arrow box on top or on bottom of the widget
 * depending on the point of user interaction with the editor.
 *
 * @class WidgetArrowBox
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getArrowBoxClasses',

            /**
             * Returns the list of arrow box classes associated to the current element's state. It relies
             * on the getInteractionPoint method to calculate the selection direction.
             *
             * @instance
             * @memberof WidgetArrowBox
             * @method getArrowBoxClasses
             * @return {String} A string with the arrow box CSS classes.
             */
            value: function getArrowBoxClasses() {
                var arrowBoxClasses = 'ae-arrow-box';

                if (_lang2.default.isFunction(this.getInteractionPoint) && this.getInteractionPoint()) {
                    if (this.getInteractionPoint().direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
                        arrowBoxClasses += ' ae-arrow-box-top';
                    } else {
                        arrowBoxClasses += ' ae-arrow-box-bottom';
                    }
                }

                return arrowBoxClasses;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-dropdown.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-dropdown.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for managing different dropdowns inside a widget.
 *
 * @class WidgetDropdown
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class(props) {
            _classCallCheck(this, _class);

            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));

            _this.state = _extends({}, _this.state, {
                dropdownTrigger: null,
                itemDropdown: null
            });
            return _this;
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof WidgetDropdown
         * @method componentWillReceiveProps
         */


        _createClass(_class, [{
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(nextProps) {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this).call(this);
                }

                this.setState({
                    dropdownTrigger: null,
                    itemDropdown: null
                });
            }

            /**
             * Merges the provided object with two more properties:
             * - expanded - boolean flag which indicates if an widget should be rendered exclusively.
             * - toggleDropdown - function, which can be used by an widget in order to obtain exclusive state.
             *
             * @instance
             * @memberof WidgetDropdown
             * @method mergeDropdownProps
             * @param {Object} obj The properties container which should be merged with the properties, related
             *    to dropdown state.
             * @param {Object} itemKey They key of an React Widget which contains the dropdown.
             * @return {Object} The merged object.
             */

        }, {
            key: 'mergeDropdownProps',
            value: function mergeDropdownProps(obj, itemKey) {
                return CKEDITOR.tools.merge(obj, {
                    expanded: this.state.itemDropdown === itemKey ? true : false,
                    tabIndex: this.state.dropdownTrigger === itemKey ? 0 : -1,
                    toggleDropdown: this.toggleDropdown.bind(this, itemKey)
                });
            }

            /**
             * Sets the active dropdown of the widget or discards the toggled item from the state.
             *
             * @instance
             * @memberof WidgetDropdown
             * @method toggleDropdown
             * @param {Object} itemDropdown The widget which requests to toggle its dropdown.
             * @param {Number} toggleDirection User movement direction when toggled via keyboard.
             */

        }, {
            key: 'toggleDropdown',
            value: function toggleDropdown(itemDropdown, toggleDirection) {
                this.setState({
                    dropdownTrigger: itemDropdown,
                    itemDropdown: itemDropdown !== this.state.itemDropdown ? itemDropdown : null
                }, function () {
                    if (!this.state.itemDropdown) {
                        if (this.moveFocus) {
                            this.moveFocus(toggleDirection);
                        } else {
                            _reactDom2.default.findDOMNode(this).focus();
                        }
                    }
                });
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-exclusive.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-exclusive.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for managing exclusive state of an widget.
 * The exclusive state means that a button may request to be the only rendered
 * widget in its parent container. WidgetExclusive will manage this state by
 * filtering and suppressing the other sibling widgets from displaying.
 *
 * @class WidgetExclusive
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'cancelExclusive',

            /**
             * Cancels the exclusive state of an widget.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method cancelExclusive
             * @param {Object} itemExclusive The widget which exclusive state should be canceled.
             */
            value: function cancelExclusive(itemExclusive) {
                if (this.state.itemExclusive === itemExclusive) {
                    this.setState({
                        itemExclusive: null
                    });
                }
            }

            /**
             * Lifecycle. Invoked when a component is receiving new props.
             * This method is not called for the initial render.
             * Calling this.setState() within this function will not trigger an additional render.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method componentWillReceiveProps
             * @param {Object} nextProps Object containing the current set of properties.
             */

        }, {
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(nextProps) {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this).call(this);
                }

                // Receiving properties means that the component is being re-rendered.
                // Re-rendering is triggered by editorInteraction, so we have to
                // reset the exclusive state and render the UI according to the new selection.
                this.setState({
                    itemExclusive: null
                });
            }

            /**
             * Filters the items and returns only those with exclusive state.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method filterExclusive
             * @param {Array} items The widgets to be filtered.
             * @return {Array|Object} The item with executive state.
             */

        }, {
            key: 'filterExclusive',
            value: function filterExclusive(items) {
                return items.filter(function (item) {
                    if (this.state.itemExclusive) {
                        if (this.state.itemExclusive === item.key) {
                            return item;
                        }
                    } else {
                        return item;
                    }
                }.bind(this));
            }

            /**
             * Merges the provided object with three more properties:
             * - cancelExclusive - function, which can be used by a widget in order to cancel executive state.
             * - renderExclusive - boolean flag which indicates if an widget should be rendered exclusively.
             * - requestExclusive - function, which can be used by a widget in order to obtain exclusive state.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method mergeExclusiveProps
             * @param {Object} obj The properties container which should be merged with the properties, related
             *    to exclusive state.
             * @param {Object} itemKey They key of an React Widget which should be rendered exclusively.
             * @return {Object} The merged object.
             */

        }, {
            key: 'mergeExclusiveProps',
            value: function mergeExclusiveProps(obj, itemKey) {
                return CKEDITOR.tools.merge(obj, {
                    cancelExclusive: this.cancelExclusive.bind(this, itemKey),
                    renderExclusive: this.state.itemExclusive === itemKey,
                    requestExclusive: this.requestExclusive.bind(this, itemKey)
                });
            }

            /**
             * Requests and sets exclusive state of an widget.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method requestExclusive
             * @param {Object} itemExclusive The widget which requests exclusive state.
             */

        }, {
            key: 'requestExclusive',
            value: function requestExclusive(itemExclusive) {
                this.setState({
                    itemExclusive: itemExclusive
                });
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-focus-manager.js":
/*!*****************************************************!*\
  !*** ./src/components/base/widget-focus-manager.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DIRECTION_NONE = 0;
var DIRECTION_NEXT = 1;
var DIRECTION_PREV = -1;

var ACTION_NONE = 0;
var ACTION_MOVE_FOCUS = 1;
var ACTION_DISMISS_FOCUS = 2;

/**
 * WidgetFocusManager is a mixin that provides keyboard navigation inside a widget. To do this,
 * it exposes the following props and methods:
 *
 * @class WidgetFocusManager
 */

exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentDidMount',

            /**
             * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method componentDidMount
             */
            value: function componentDidMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidMount', this).call(this);
                }

                this._refresh();
            }

            /**
             * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
             * Refreshes the descendants list.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method componentDidUpdate
             */

        }, {
            key: 'componentDidUpdate',
            value: function componentDidUpdate() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidUpdate', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidUpdate', this).call(this);
                }

                this._refresh();
            }

            /**
             * Focuses the current active descendant.
             *
             * Several Widgets can be nested in a component hierarchy by attaching this focus method to
             * the widget DOM node, transferring the DOM focus control to the inner FocusManager.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method focus
             */

        }, {
            key: 'focus',
            value: function focus(event) {
                if (!event || this._isValidTarget(event.target)) {
                    if (this._descendants && this._descendants.length) {
                        var activeDescendantEl = this._descendants[this._activeDescendant];
                        // When user clicks with the mouse, the activeElement is already set and there
                        // is no need to focus it. Focusing of the active descendant (usually some button) is required
                        // in case of keyboard navigation, because the focused element might be not the first button,
                        // but the div element, which contains the button.
                        if (document.activeElement !== activeDescendantEl && !this.props.focusFirstChild) {
                            if (this._descendants.indexOf(document.activeElement) === -1) {
                                activeDescendantEl.focus();
                            }
                        }

                        if (event) {
                            event.stopPropagation();
                            event.preventDefault();
                        }
                    }
                }
            }

            /**
             * Handles the key events on a DOM node to execute the appropriate navigation when needed.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @param {Object} event The Keyboard event that was detected on the widget DOM node.
             * @method handleKey
             */

        }, {
            key: 'handleKey',
            value: function handleKey(event) {
                if (this._isValidTarget(event.target) && this._descendants) {
                    var action = this._getFocusAction(event);

                    if (action.type) {
                        event.stopPropagation();
                        event.preventDefault();

                        if (action.type === ACTION_MOVE_FOCUS) {
                            this._moveFocus(action.direction);
                        }

                        if (action.type === ACTION_DISMISS_FOCUS) {
                            this.props.onDismiss(action.direction);
                        }
                    }
                }
            }

            /**
             * Moves the focus among descendants in the especified direction.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method moveFocus
             * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
             */

        }, {
            key: 'moveFocus',
            value: function moveFocus(direction) {
                direction = _lang2.default.isNumber(direction) ? direction : 0;

                this._moveFocus(direction);
            }

            /**
             * Returns the action, if any, that a keyboard event in the current focus manager state
             * should produce.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusAction
             * @param {object} event The Keyboard event.
             * @protected
             * @return {Object} An action object with type and direction properties.
             */

        }, {
            key: '_getFocusAction',
            value: function _getFocusAction(event) {
                var action = {
                    type: ACTION_NONE
                };

                if (this.props.keys) {
                    var direction = this._getFocusMoveDirection(event);

                    if (direction) {
                        action.direction = direction;
                        action.type = ACTION_MOVE_FOCUS;
                    }

                    var dismissAction = this._getFocusDismissAction(event, direction);

                    if (dismissAction.dismiss) {
                        action.direction = dismissAction.direction;
                        action.type = ACTION_DISMISS_FOCUS;
                    }
                }

                return action;
            }

            /**
             * Returns the dismiss action, if any, the focus manager should execute to yield the focus. This
             * will happen in any of these scenarios if a dismiss callback has been specified:
             * - A dismiss key has been pressed
             * - In a non-circular focus manager, when:
             *     - The active descendant is the first one and a prev key has been pressed.
             *     - The active descendant is the last one and a next key has been pressed.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusDismissAction
             * @param {Number} focusMoveDirection The focus movement direction (if any).
             * @param {Object} event The Keyboard event.
             * @protected
             * @return {Object} A dismiss action with dismiss and direction properties.
             */

        }, {
            key: '_getFocusDismissAction',
            value: function _getFocusDismissAction(event, focusMoveDirection) {
                var dismissAction = {
                    direction: focusMoveDirection,
                    dismiss: false
                };

                if (this.props.onDismiss) {
                    if (this._isValidKey(event.keyCode, this.props.keys.dismiss)) {
                        dismissAction.dismiss = true;
                    }
                    if (this._isValidKey(event.keyCode, this.props.keys.dismissNext)) {
                        dismissAction.dismiss = true;
                        dismissAction.direction = DIRECTION_NEXT;
                    }
                    if (this._isValidKey(event.keyCode, this.props.keys.dismissPrev)) {
                        dismissAction.dismiss = true;
                        dismissAction.direction = DIRECTION_PREV;
                    }

                    if (!dismissAction.dismiss && !this.props.circular && focusMoveDirection) {
                        dismissAction.dismiss = focusMoveDirection === DIRECTION_PREV && this._activeDescendant === 0 || focusMoveDirection === DIRECTION_NEXT && this._activeDescendant === this._descendants.length - 1;
                    }
                }

                return dismissAction;
            }

            /**
             * Returns the direction, if any, in which the focus should be moved. In presence of the
             * shift key modifier, the direction of the movement is inverted.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusMoveDirection
             * @param {Object} event The Keyboard event.
             * @protected
             * @return {Number} The computed direction of the expected focus movement.
             */

        }, {
            key: '_getFocusMoveDirection',
            value: function _getFocusMoveDirection(event) {
                var direction = DIRECTION_NONE;

                if (this._isValidKey(event.keyCode, this.props.keys.next)) {
                    direction = DIRECTION_NEXT;
                }
                if (this._isValidKey(event.keyCode, this.props.keys.prev)) {
                    direction = DIRECTION_PREV;
                }

                if (event.shifKey) {
                    direction *= -1;
                }

                return direction;
            }

            /**
             * Indicates if a given keyCode is valid for the given set of keys.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _isValidKey
             * @param {Array|Number} keys A key set. Can be a number an array of numbers representing the allowed keyCodes.
             * @param {Number} keyCode An event keyCode.
             * @protected
             * @return {Boolean} A boolean value indicating if the key is valid.
             */

        }, {
            key: '_isValidKey',
            value: function _isValidKey(keyCode, keys) {
                return _lang2.default.isArray(keys) ? keys.indexOf(keyCode) !== -1 : keyCode === keys;
            }

            /**
             * Indicates if a given element is valid for focus management. User input elements such as
             * input, select or textarea are excluded.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _isValidKey
             * @param {DOMNode} element A DOM element.
             * @protected
             * @return {Boolean} A boolean value indicating if the element is valid.
             */

        }, {
            key: '_isValidTarget',
            value: function _isValidTarget(element) {
                var tagName = element.tagName.toLowerCase();

                return tagName !== 'input' && tagName !== 'select' && tagName !== 'textarea';
            }

            /**
             * Moves the focus among descendants in the especified direction.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _moveFocus
             * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
             * @protected
             */

        }, {
            key: '_moveFocus',
            value: function _moveFocus(direction) {
                var numDescendants = this._descendants.length;

                var descendant = this._descendants[this._activeDescendant];

                descendant.setAttribute('tabIndex', -1);

                this._activeDescendant += direction;

                if (this.props.circular) {
                    // Calculate proper modulo result since remainder operator doesn't behave in the
                    // same way for negative numbers
                    this._activeDescendant = (this._activeDescendant % numDescendants + numDescendants) % numDescendants;
                } else {
                    this._activeDescendant = Math.max(Math.min(this._activeDescendant, numDescendants - 1), 0);
                }

                descendant = this._descendants[this._activeDescendant];

                descendant.setAttribute('tabIndex', 0);
                descendant.focus();
            }

            /**
             * Refreshes the descendants list by executing the CSS selector again and resets the descendants tabIndex.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _refresh
             * @protected
             */

        }, {
            key: '_refresh',
            value: function _refresh() {
                var domNode = _reactDom2.default.findDOMNode(this);

                if (domNode) {
                    var descendants = domNode.querySelectorAll(this.props.descendants);

                    var priorityDescendants = [];

                    this._descendants = [];

                    Array.prototype.slice.call(descendants).forEach(function (item) {
                        var dataTabIndex = item.getAttribute('data-tabindex');

                        if (dataTabIndex) {
                            priorityDescendants.push(item);
                        } else {
                            this._descendants.push(item);
                        }
                    }.bind(this));

                    priorityDescendants = priorityDescendants.sort(function (a, b) {
                        return _lang2.default.toInt(a.getAttribute('data-tabindex')) > _lang2.default.toInt(b.getAttribute('data-tabindex'));
                    });

                    this._descendants = priorityDescendants.concat(this._descendants);

                    this._activeDescendant = 0;

                    this._descendants.some(function (item, index) {
                        if (item.getAttribute('tabindex') === '0') {
                            this._activeDescendant = index;
                            this.focus();

                            return true;
                        }
                    }.bind(this));
                }
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-position.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-position.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Calculates the position where an Widget should be displayed based on the point
 * where user interacted with the editor.
 *
 * @class WidgetPosition
 */
exports.default = function (WrappedComponent) {
    var _class, _temp;

    return _temp = _class = function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'cancelAnimation',


            /**
             * Cancels an scheduled animation frame.
             *
             * @instance
             * @memberof WidgetPosition
             * @method cancelAnimation
             */
            value: function cancelAnimation() {
                if (window.cancelAnimationFrame) {
                    window.cancelAnimationFrame(this._animationFrameId);
                }
            }

            /**
             * Returns an object which contains the position of the element in page coordinates,
             * restricted to fit to given viewport.
             *
             * @instance
             * @memberof WidgetPosition
             * @method getConstrainedPosition
             * @param {Object} attrs The following properties, provided as numbers:
             * - height
             * - left
             * - top
             * - width
             * @param {Object} viewPaneSize Optional. If not provided, the current viewport will be used. Should contain at least these properties:
             * - width
             * @return {Object} An object with `x` and `y` properties, which represent the constrained position of the
             * element.
             */

            /**
             * Lifecycle. Returns the default values of the properties used in the widget.
             *
             * @instance
             * @memberof WidgetPosition
             * @method getDefaultProps
             */

        }, {
            key: 'getConstrainedPosition',
            value: function getConstrainedPosition(attrs, viewPaneSize) {
                viewPaneSize = viewPaneSize || new CKEDITOR.dom.window(window).getViewPaneSize();

                var x = attrs.left;
                var y = attrs.top;

                if (attrs.left + attrs.width > viewPaneSize.width) {
                    x -= attrs.left + attrs.width - viewPaneSize.width;
                }

                if (y < 0) {
                    y = 0;
                }

                return {
                    x: x,
                    y: y
                };
            }

            /**
             * Returns the position, in page coordinates, according to which a widget should appear.
             * Depending on the direction of the selection, the wdiget may appear above of or on bottom of the selection.
             *
             * It depends on the props editorEvent to analyze the following user-interaction parameters:
             * - {Object} selectionData The data about the selection in the editor as returned from
             * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * - {Number} pos Contains the coordinates of the position, considered as most appropriate.
             * This may be the point where the user released the mouse, or just the beginning or the end of
             * the selection.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method getInteractionPoint
             * @return {Object} An Object which contains the following properties:
             * direction, x, y, where x and y are in page coordinates and direction can be one of these:
             * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
             */

        }, {
            key: 'getInteractionPoint',
            value: function getInteractionPoint() {
                var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;

                if (!eventPayload) {
                    return;
                }

                var selectionData = eventPayload.selectionData;

                var nativeEvent = eventPayload.nativeEvent;

                var pos = {
                    x: eventPayload.nativeEvent.pageX,
                    y: selectionData.region.top
                };

                var direction = selectionData.region.direction;

                var endRect = selectionData.region.endRect;

                var startRect = selectionData.region.startRect;

                if (endRect && startRect && startRect.top === endRect.top) {
                    direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
                }

                var x;
                var y;

                // If we have the point where user released the mouse, show Toolbar at this point
                // otherwise show it on the middle of the selection.

                if (pos.x && pos.y) {
                    x = this._getXPoint(selectionData, pos.x);

                    if (direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
                        y = Math.min(pos.y, selectionData.region.top);
                    } else {
                        y = Math.max(pos.y, this._getYPoint(selectionData, nativeEvent));
                    }
                } else {
                    x = selectionData.region.left + selectionData.region.width / 2;

                    if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {

                        y = this._getYPoint(selectionData, nativeEvent);
                    } else {
                        y = selectionData.region.top;
                    }
                }

                return {
                    direction: direction,
                    x: x,
                    y: y
                };
            }

            /**
             * Returns the position of the Widget.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method _getXPoint
             * @param {Object} eventX The X coordinate received from the native event (mouseup).
             * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * @protected
             * @return {Number} The calculated X point in page coordinates.
             */

        }, {
            key: '_getXPoint',
            value: function _getXPoint(selectionData, eventX) {
                var region = selectionData.region;

                var left = region.startRect ? region.startRect.left : region.left;
                var right = region.endRect ? region.endRect.right : region.right;

                var x;

                if (left < eventX && right > eventX) {
                    x = eventX;
                } else {
                    var leftDist = Math.abs(left - eventX);
                    var rightDist = Math.abs(right - eventX);

                    if (leftDist < rightDist) {
                        // user raised the mouse on left on the selection
                        x = left;
                    } else {
                        x = right;
                    }
                }

                return x;
            }

            /**
             * Returns the position of the Widget.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method _getYPoint
             * @param {Object} nativeEvent The data about event is fired
             * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * @protected
             * @return {Number} The calculated Y point in page coordinates.
             */

        }, {
            key: '_getYPoint',
            value: function _getYPoint(selectionData, nativeEvent) {
                var y = 0;

                if (selectionData && nativeEvent) {
                    var elementTarget = new CKEDITOR.dom.element(nativeEvent.target);

                    if (elementTarget.$ && elementTarget.getStyle('overflow') === 'auto') {
                        y = nativeEvent.target.offsetTop + nativeEvent.target.offsetHeight;
                    } else {
                        y = selectionData.region.bottom;
                    }
                }

                return y;
            }

            /**
             * Returns the position of the Widget taking in consideration the
             * {{#crossLink "WidgetPosition/gutter:attribute"}}{{/crossLink}} attribute.
             *
             * @instance
             * @memberof WidgetPosition
             * @protected
             * @method  getWidgetXYPoint
             * @param {Number} left The left offset in page coordinates where Toolbar should be shown.
             * @param {Number} top The top offset in page coordinates where Toolbar should be shown.
             * @param {Number} direction The direction of the selection. May be one of the following:
             * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
             * @return {Array} An Array with left and top offsets in page coordinates.
             */

        }, {
            key: 'getWidgetXYPoint',
            value: function getWidgetXYPoint(left, top, direction) {
                var domNode = _reactDom2.default.findDOMNode(this);

                var gutter = this.props.gutter;

                if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM || direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
                    left = left - gutter.left - domNode.offsetWidth / 2;

                    top = direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM ? top + gutter.top : top - domNode.offsetHeight - gutter.top;
                } else if (direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT || direction === CKEDITOR.SELECTION_RIGHT_TO_LEFT) {

                    left = direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT ? left + gutter.left + domNode.offsetHeight / 2 : left - 3 * domNode.offsetHeight / 2 - gutter.left;

                    top = top - gutter.top - domNode.offsetHeight / 2;
                }

                if (left < 0) {
                    left = 0;
                }

                if (top < 0) {
                    top = 0;
                }

                return [left, top];
            }

            /**
             * Returns true if the widget is visible, false otherwise
             *
             * @instance
             * @memberof WidgetPosition
             * @method isVisible
             * @return {Boolean} True if the widget is visible, false otherwise
             */

        }, {
            key: 'isVisible',
            value: function isVisible() {
                var domNode = _reactDom2.default.findDOMNode(this);

                if (domNode) {
                    var domElement = new CKEDITOR.dom.element(domNode);

                    return domElement.hasClass('alloy-editor-visible');
                }

                return false;
            }

            /**
             * Moves a widget from a starting point to a destination point.
             *
             * @instance
             * @memberof WidgetPosition
             * @method moveToPoint
             * @param  {Object} startPoint The starting point for the movement.
             * @param  {Object} endPoint The destination point for the movement.
             */

        }, {
            key: 'moveToPoint',
            value: function moveToPoint(startPoint, endPoint) {
                var domElement = new CKEDITOR.dom.element(_reactDom2.default.findDOMNode(this));

                domElement.setStyles({
                    left: startPoint[0] + 'px',
                    top: startPoint[1] + 'px',
                    opacity: 0
                });

                domElement.removeClass('alloy-editor-invisible');

                this._animate(function () {
                    domElement.addClass('ae-toolbar-transition');
                    domElement.addClass('alloy-editor-visible');
                    domElement.setStyles({
                        left: endPoint[0] + 'px',
                        top: endPoint[1] + 'px',
                        opacity: 1
                    });
                });
            }

            /**
             * Shows the widget with the default animation transition.
             *
             * @instance
             * @memberof WidgetPosition
             * @method show
             */

        }, {
            key: 'show',
            value: function show() {
                var domNode = _reactDom2.default.findDOMNode(this);

                if (!this.isVisible() && domNode) {
                    var interactionPoint = this.getInteractionPoint();

                    if (interactionPoint) {
                        var domElement = new CKEDITOR.dom.element(domNode);

                        var finalX, finalY, initialX, initialY;

                        finalX = initialX = parseFloat(domElement.getStyle('left'));
                        finalY = initialY = parseFloat(domElement.getStyle('top'));

                        if (this.props.constrainToViewport) {
                            var res = this.getConstrainedPosition({
                                height: parseFloat(domNode.offsetHeight),
                                left: finalX,
                                top: finalY,
                                width: parseFloat(domNode.offsetWidth)
                            });

                            finalX = res.x;
                            finalY = res.y;
                        }

                        if (interactionPoint.direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
                            initialY = this.props.selectionData.region.bottom;
                        } else {
                            initialY = this.props.selectionData.region.top;
                        }

                        this.moveToPoint([initialX, initialY], [finalX, finalY]);
                    }
                }
            }

            /**
             * Updates the widget position based on the current interaction point.
             *
             * @instance
             * @memberof WidgetPosition
             * @method updatePosition
             */

        }, {
            key: 'updatePosition',
            value: function updatePosition() {
                var interactionPoint = this.getInteractionPoint();

                var domNode = _reactDom2.default.findDOMNode(this);

                if (interactionPoint && domNode) {
                    var xy = this.getWidgetXYPoint(interactionPoint.x, interactionPoint.y, interactionPoint.direction);

                    new CKEDITOR.dom.element(domNode).setStyles({
                        left: xy[0] + 'px',
                        top: xy[1] + 'px'
                    });
                }
            }

            /**
             * Requests an animation frame, if possible, to simulate an animation.
             *
             * @instance
             * @memberof WidgetPosition
             * @method _animate
             * @param {Function} callback The function to be executed on the scheduled frame.
             * @protected
             */

        }, {
            key: '_animate',
            value: function _animate(callback) {
                if (window.requestAnimationFrame) {
                    this._animationFrameId = window.requestAnimationFrame(callback);
                } else {
                    callback();
                }
            }
        }]);

        return _class;
    }(WrappedComponent), _class.defaultProps = _extends({}, WrappedComponent.defaultProps, {
        gutter: {
            left: 0,
            top: 10
        },
        constrainToViewport: true }), _temp;
};

/***/ }),

/***/ "./src/components/buttons/button-bold.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-bold.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonBold class provides functionality for styling an selection with strong (bold) style.
 *
 * @class ButtonBold
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonBold = function (_React$Component) {
    _inherits(ButtonBold, _React$Component);

    function ButtonBold() {
        _classCallCheck(this, ButtonBold);

        return _possibleConstructorReturn(this, (ButtonBold.__proto__ || Object.getPrototypeOf(ButtonBold)).apply(this, arguments));
    }

    _createClass(ButtonBold, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonBold
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.bold, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-bold', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.bold },
                _react2.default.createElement('span', { className: 'ae-icon-bold' })
            );
        }
    }]);

    return ButtonBold;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default bold
 * @memberof ButtonBold
 * @property {String} key
 * @static
 */


ButtonBold.key = 'bold';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonBold
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonBold.defaultProps = {
    command: 'bold',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 66 /*B*/
    },
    style: 'coreStyles_bold'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonBold))));

/***/ }),

/***/ "./src/components/buttons/button-camera-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-camera-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCameraImage class takes photo from camera and inserts it to the content.
 *
 * @class ButtonCameraImage
 */
var ButtonCameraImage = function (_React$Component) {
    _inherits(ButtonCameraImage, _React$Component);

    function ButtonCameraImage() {
        _classCallCheck(this, ButtonCameraImage);

        return _possibleConstructorReturn(this, (ButtonCameraImage.__proto__ || Object.getPrototypeOf(ButtonCameraImage)).apply(this, arguments));
    }

    _createClass(ButtonCameraImage, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses the take photo button.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this.refs.buttonTakePhoto).focus();
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this._stream) {
                if (this._stream.stop) {
                    this._stream.stop();
                } else if (this._stream.getVideoTracks) {
                    this._stream.getVideoTracks().forEach(function (track) {
                        track.stop();
                    });
                }
                this._stream = null;
            }
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

            getUserMedia.call(navigator, {
                video: true,
                audio: false
            }, this._handleStreamSuccess.bind(this), this._handleStreamError.bind(this));

            return _react2.default.createElement(
                'div',
                { className: 'ae-camera' },
                _react2.default.createElement(
                    'video',
                    { ref: 'videoContainer' },
                    'Video stream not available.'
                ),
                _react2.default.createElement(
                    'button',
                    { className: 'ae-camera-shoot', onClick: this.takePhoto.bind(this), ref: 'buttonTakePhoto' },
                    'Take photo'
                ),
                _react2.default.createElement('canvas', { className: 'ae-camera-canvas', ref: 'canvasContainer' })
            );
        }

        /**
         * Takes photo from the video stream and inserts in into editor's content.
         *
         * @fires ButtonCameraImage#imageCameraAdd
         * @instance
         * @memberof ButtonCameraImage
         * @method takePhoto
         */

    }, {
        key: 'takePhoto',
        value: function takePhoto() {
            var videoEl = _reactDom2.default.findDOMNode(this.refs.videoContainer);
            var canvasEl = _reactDom2.default.findDOMNode(this.refs.canvasContainer);

            var context = canvasEl.getContext('2d');

            var height = this._videoHeight;
            var width = this.props.videoWidth;

            if (width && height) {
                canvasEl.width = width;
                canvasEl.height = height;

                context.drawImage(videoEl, 0, 0, width, height);

                var imgURL = canvasEl.toDataURL('image/png');

                var el = CKEDITOR.dom.element.createFromHtml('<img src="' + imgURL + '">');

                var editor = this.props.editor.get('nativeEditor');

                editor.insertElement(el);

                this.props.cancelExclusive();

                editor.fire('actionPerformed', this);

                editor.fire('imageCameraAdd', el);
            }
        }

        /**
         * Displays error message in case of video stream capturing failure.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method _handleStreamError
         * @param {Event} error The fired event in case of error.
         * @protected
         */

    }, {
        key: '_handleStreamError',
        value: function _handleStreamError(error) {
            window.alert('An error occurred! ' + error);
        }

        /**
         * Starts streaming video in the video element and sets width/height to the video
         * and canvas elements.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method _handleStreamSuccess
         * @param {Object} stream The video stream
         * @protected
         */

    }, {
        key: '_handleStreamSuccess',
        value: function _handleStreamSuccess(stream) {
            var videoEl = _reactDom2.default.findDOMNode(this.refs.videoContainer);
            var canvasEl = _reactDom2.default.findDOMNode(this.refs.canvasContainer);

            videoEl.addEventListener('canplay', function (event) {
                var height = videoEl.videoHeight / (videoEl.videoWidth / this.props.videoWidth);

                if (isNaN(height)) {
                    height = this.props.videoWidth / (4 / 3);
                }

                videoEl.setAttribute('width', this.props.videoWidth);
                videoEl.setAttribute('height', height);
                canvasEl.setAttribute('width', this.props.videoWidth);
                canvasEl.setAttribute('height', height);

                this._videoHeight = height;
            }.bind(this), false);

            this._stream = stream;

            if (navigator.mozGetUserMedia) {
                videoEl.mozSrcObject = stream;
            } else {
                videoEl.src = (window.URL || window.webkitURL).createObjectURL(stream);
            }

            videoEl.play();

            _reactDom2.default.findDOMNode(this.refs.buttonTakePhoto).disabled = false;
        }

        /**
         * Fired when an image is being taken from the camera and added as an element to the editor.
         *
         * @event ButtonCameraImage#imageCameraAdd
         * @memberof ButtonCameraImage
         * @param {CKEDITOR.dom.element} el The created img element in editor.
         */

    }]);

    return ButtonCameraImage;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default cameraImage
 * @memberof ButtonCameraImage
 * @property {String} key
 * @static
 */


ButtonCameraImage.key = 'cameraImage';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCameraImage
 * @method getDefaultProps
 */
ButtonCameraImage.defaultProps = {
    videoWidth: 320
};

exports.default = ButtonCameraImage;

/***/ }),

/***/ "./src/components/buttons/button-camera.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-camera.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCamera class renders in two different ways:
 *
 * - Normal: Just a button that allows to switch to the edition mode.
 * - Exclusive: Renders ButtonCameraImage in order to take photo from the camera.
 *
 * @class ButtonCamera
 */
var ButtonCamera = function (_React$Component) {
    _inherits(ButtonCamera, _React$Component);

    function ButtonCamera() {
        _classCallCheck(this, ButtonCamera);

        return _possibleConstructorReturn(this, (ButtonCamera.__proto__ || Object.getPrototypeOf(ButtonCamera)).apply(this, arguments));
    }

    _createClass(ButtonCamera, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCamera
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonCameraImage2.default, this.props);
            } else {
                var disabled = !(navigator.getUserMedia || navigator.webkitGetUserMedia && location.protocol === 'https' || navigator.mozGetUserMedia || navigator.msGetUserMedia);

                var label = disabled ? AlloyEditor.Strings.cameraDisabled : AlloyEditor.Strings.camera;

                return _react2.default.createElement(
                    'button',
                    { 'aria-label': label, className: 'ae-button', 'data-type': 'button-image-camera', disabled: disabled, onClick: this.props.requestExclusive.bind(ButtonCamera.key), tabIndex: this.props.tabIndex, title: label },
                    _react2.default.createElement('span', { className: 'ae-icon-camera' })
                );
            }
        }
    }]);

    return ButtonCamera;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default camera
 * @memberof ButtonCamera
 * @property {String} key
 * @static
 */


ButtonCamera.key = 'camera';

exports.default = ButtonCamera;

/***/ }),

/***/ "./src/components/buttons/button-code.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-code.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCode class provides wraps a selection in `pre` element.
 *
 * @class ButtonCode
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonCode = function (_React$Component) {
    _inherits(ButtonCode, _React$Component);

    function ButtonCode() {
        _classCallCheck(this, ButtonCode);

        return _possibleConstructorReturn(this, (ButtonCode.__proto__ || Object.getPrototypeOf(ButtonCode)).apply(this, arguments));
    }

    _createClass(ButtonCode, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCode
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.code, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-code', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.code },
                _react2.default.createElement('span', { className: 'ae-icon-code' })
            );
        }
    }]);

    return ButtonCode;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default code
 * @memberof ButtonCode
 * @property {String} key
 * @static
 */


ButtonCode.key = 'code';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCode
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonCode.defaultProps = {
    style: {
        element: 'pre'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonCode)));

/***/ }),

/***/ "./src/components/buttons/button-command-list-item.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-command-list-item.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCommandListItem class is a UI class that renders a ButtonCommand that can be used inside
 * a list as an item, with a string representation of its behaviour.
 *
 * @class ButtonCommandListItem
 * @uses ButtonCommand
 */
var ButtonCommandListItem = function (_React$Component) {
    _inherits(ButtonCommandListItem, _React$Component);

    function ButtonCommandListItem() {
        _classCallCheck(this, ButtonCommandListItem);

        return _possibleConstructorReturn(this, (ButtonCommandListItem.__proto__ || Object.getPrototypeOf(ButtonCommandListItem)).apply(this, arguments));
    }

    _createClass(ButtonCommandListItem, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCommandListItem
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': this.props.description, className: this._getClassName(), onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex },
                this.props.description
            );
        }

        /**
         * Returns the class name of Widget.
         *
         * @instance
         * @memberof ButtonCommandListItem
         * @method _getClassName
         * @protected
         * @return {String} The class name of the Widget.
         */

    }, {
        key: '_getClassName',
        value: function _getClassName() {
            var className = 'ae-toolbar-element';

            if (this.props.icon) {
                className += ' ae-icon-' + this.props.icon;
            }

            return className;
        }
    }]);

    return ButtonCommandListItem;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonCommandListItem
 * @memberof ButtonCommandListItem
 * @property {String} key
 * @static
 */


ButtonCommandListItem.key = 'buttonCommandListItem';

exports.default = (0, _buttonCommand2.default)(ButtonCommandListItem);

/***/ }),

/***/ "./src/components/buttons/button-commands-list.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-commands-list.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCommandsList class provides functionality for showing a list of commands that can be
 * executed to the current selection..
 *
 * @class ButtonCommandsList
 * @uses WidgetFocusManager
 */
var ButtonCommandsList = function (_React$Component) {
    _inherits(ButtonCommandsList, _React$Component);

    function ButtonCommandsList() {
        _classCallCheck(this, ButtonCommandsList);

        return _possibleConstructorReturn(this, (ButtonCommandsList.__proto__ || Object.getPrototypeOf(ButtonCommandsList)).apply(this, arguments));
    }

    _createClass(ButtonCommandsList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses on the list node to allow keyboard interaction.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(
                'div',
                { className: 'ae-dropdown ae-arrow-box ae-arrow-box-top-left', onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), tabIndex: '0' },
                _react2.default.createElement(
                    'ul',
                    { className: 'ae-listbox', id: this.props.listId, role: 'listbox' },
                    this._renderActions(this.props.commands)
                )
            );
        }

        /**
         * Renders instances of ButtonCommandListItem with the description of the row action that will be executed.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method _renderActions
         * @protected
         * @return {Array} Rendered instances of ButtonCommandListItem class
         */

    }, {
        key: '_renderActions',
        value: function _renderActions(commands) {
            var editor = this.props.editor;
            var items;

            if (commands && commands.length) {
                items = commands.map(function (item) {
                    return _react2.default.createElement(
                        'li',
                        { key: item.command, role: 'option' },
                        _react2.default.createElement(_buttonCommandListItem2.default, { command: item.command, description: typeof item.label === 'string' ? item.label : item.label(), editor: editor })
                    );
                });
            }

            return items;
        }
    }]);

    return ButtonCommandsList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonCommandsList
 * @memberof ButtonCommandsList
 * @property {String} key
 * @static
 */


ButtonCommandsList.key = 'buttonCommandsList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCommandsList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonCommandsList.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonCommandsList);

/***/ }),

/***/ "./src/components/buttons/button-dropdown.jsx":
/*!****************************************************!*\
  !*** ./src/components/buttons/button-dropdown.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonDropdown class provides markup and keyboard navigation behaviour to a dropdown
 * opened from a button.
 *
 * @class ButtonDropdown
 */
var ButtonDropdown = function (_React$Component) {
    _inherits(ButtonDropdown, _React$Component);

    function ButtonDropdown() {
        _classCallCheck(this, ButtonDropdown);

        return _possibleConstructorReturn(this, (ButtonDropdown.__proto__ || Object.getPrototypeOf(ButtonDropdown)).apply(this, arguments));
    }

    _createClass(ButtonDropdown, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonDropdown
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'div',
                { className: 'ae-dropdown ae-arrow-box ae-arrow-box-top-left', onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), tabIndex: '0' },
                _react2.default.createElement(
                    'ul',
                    { className: 'ae-listbox', role: 'listbox' },
                    this.props.children
                )
            );
        }
    }]);

    return ButtonDropdown;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the dropdown in the configuration.
 *
 * @default dropdown
 * @memberof ButtonDropdown
 * @property {String} key
 * @static
 */


ButtonDropdown.key = 'dropdown';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonDropdown
 * @method getDefaultProps
 */
ButtonDropdown.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonDropdown);

/***/ }),

/***/ "./src/components/buttons/button-embed-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-embed-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedEdit class provides functionality for creating and editing an embed link in a document.
 * Provides UI for creating and editing an embed link.
 *
 * @class ButtonEmbedEdit
 */

var ButtonEmbedEdit = function (_React$Component) {
    _inherits(ButtonEmbedEdit, _React$Component);

    function ButtonEmbedEdit(props) {
        _classCallCheck(this, ButtonEmbedEdit);

        var _this = _possibleConstructorReturn(this, (ButtonEmbedEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedEdit)).call(this, props));

        _this.linkInput = _react2.default.createRef();
        _this.state = _this.getInitialState();
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing. This should only happen if the component
     * is rendered in exclusive mode to prevent aggressive focus stealing.
     *
     * @instance
     * @memberof ButtonEmbedEdit
     * @method componentDidMount
     */


    _createClass(ButtonEmbedEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.renderExclusive || this.props.manualSelection) {
                // We need to wait for the next rendering cycle before focusing to avoid undesired
                // scrolls on the page
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(this._focusLinkInput.bind(this));
                } else {
                    setTimeout(this._focusLinkInput.bind(this), 0);
                }
            }
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method componentWillReceiveProps
         */

    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps() {
            this.setState(this.getInitialState());
        }

        /**
         * Lifecycle. Invoked once before the component is mounted.
         * The return value will be used as the initial value of this.state.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method getInitialState
         */

    }, {
        key: 'getInitialState',
        value: function getInitialState() {
            var editor = this.props.editor.get('nativeEditor');
            var embed;

            var selection = editor.getSelection();

            if (selection) {
                var selectedElement = selection.getSelectedElement();

                if (selectedElement) {
                    embed = selectedElement.findOne('[data-widget="ae_embed"]');
                }
            }

            var href = embed ? embed.getAttribute('data-ae-embed-url') : '';

            return {
                element: embed,
                initialLink: {
                    href: href
                },
                linkHref: href
            };
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var clearLinkStyle = {
                opacity: this.state.linkHref ? 1 : 0
            };

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link' },
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.deleteEmbed, className: 'ae-button', 'data-type': 'button-embed-remove', disabled: !this.state.element, onClick: this._removeEmbed.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.deleteEmbed },
                    _react2.default.createElement('span', { className: 'ae-icon-bin' })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input xxl' },
                    _react2.default.createElement('input', { className: 'ae-input', onChange: this._handleLinkHrefChange.bind(this), onKeyDown: this._handleKeyDown.bind(this), placeholder: AlloyEditor.Strings.editLink, ref: this.linkInput, type: 'text', value: this.state.linkHref }),
                    _react2.default.createElement('button', { 'aria-label': AlloyEditor.Strings.clearInput, className: 'ae-button ae-icon-remove', onClick: this._clearLink.bind(this), style: clearLinkStyle, title: AlloyEditor.Strings.clear })
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.confirm, className: 'ae-button', disabled: !this._isValidState(), onClick: this._embedLink.bind(this), title: AlloyEditor.Strings.confirm },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }

        /**
         * Clears the link input. This only changes the component internal state, but does not
         * affect the link element of the editor. Only the _removeLink and _updateLink methods
         * are translated to the editor element.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _clearLink
         * @protected
         */

    }, {
        key: '_clearLink',
        value: function _clearLink() {
            this.setState({
                linkHref: ''
            });
        }

        /**
         * Triggers the embedUrl command to transform the link into an embed media object
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _embedLink
         * @protected
         */

    }, {
        key: '_embedLink',
        value: function _embedLink() {
            var nativeEditor = this.props.editor.get('nativeEditor');

            nativeEditor.execCommand('embedUrl', {
                url: this.state.linkHref
            });

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();
        }

        /**
         * Focuses the user cursor on the widget's input.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _focusLinkInput
         * @protected
         */

    }, {
        key: '_focusLinkInput',
        value: function _focusLinkInput() {
            this.linkInput.current.focus();
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates/updates the link.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
                event.preventDefault();
            }

            if (event.keyCode === KEY_ENTER) {
                this._embedLink();
            } else if (event.keyCode === KEY_ESC) {
                var editor = this.props.editor.get('nativeEditor');

                // We need to cancelExclusive with the bound parameters in case the button is used
                // inside another in exclusive mode (such is the case of the link button)
                this.props.cancelExclusive();

                editor.fire('actionPerformed', this);
            }
        }

        /**
         * Updates the component state when the link input changes on user interaction.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _handleLinkHrefChange
         * @param {SyntheticEvent} event The change event.
         * @protected
         */

    }, {
        key: '_handleLinkHrefChange',
        value: function _handleLinkHrefChange(event) {
            this.setState({
                linkHref: event.target.value
            });
        }

        /**
         * Verifies that the current link state is valid so the user can save the link. A valid state
         * means that we have a non-empty href that's different from the original one.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _isValidState
         * @protected
         * @return {Boolean} True if the state is valid, false otherwise
         */

    }, {
        key: '_isValidState',
        value: function _isValidState() {
            var validState = this.state.linkHref && this.state.linkHref !== this.state.initialLink.href;

            return validState;
        }

        /**
         * Removes the embed in the editor element.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _removeEmbed
         * @protected
         */

    }, {
        key: '_removeEmbed',
        value: function _removeEmbed() {
            var editor = this.props.editor.get('nativeEditor');

            var embedWrapper = this.state.element.getAscendant(function (element) {
                return element.hasClass('cke_widget_wrapper');
            });

            embedWrapper.remove();

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonEmbedEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default embedEdit
 * @memberof ButtonEmbedEdit
 * @property {String} key
 * @static
 */


ButtonEmbedEdit.key = 'embedEdit';

exports.default = ButtonEmbedEdit;

/***/ }),

/***/ "./src/components/buttons/button-embed.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-embed.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonEmbed class provides functionality for creating and editing an embed link in a document.
 * ButtonEmbed renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonEmbedEdit UI with all the link edition controls.
 *
 * @class ButtonEmbed
 * @uses ButtonKeystroke
 */
var ButtonEmbed = function (_React$Component) {
    _inherits(ButtonEmbed, _React$Component);

    function ButtonEmbed() {
        _classCallCheck(this, ButtonEmbed);

        return _possibleConstructorReturn(this, (ButtonEmbed.__proto__ || Object.getPrototypeOf(ButtonEmbed)).apply(this, arguments));
    }

    _createClass(ButtonEmbed, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonEmbed
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonEmbedEdit2.default, this.props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.link, className: 'ae-button', 'data-type': 'button-embed', onClick: this._requestExclusive.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.link },
                    _react2.default.createElement('span', { className: 'ae-icon-add' })
                );
            }
        }

        /**
         * Requests the link button to be rendered in exclusive mode to allow the embedding of a link.
         *
         * @instance
         * @memberof ButtonEmbed
         * @method _requestExclusive
         * @protected
         */

    }, {
        key: '_requestExclusive',
        value: function _requestExclusive() {
            this.props.requestExclusive(ButtonEmbed.key);
        }
    }]);

    return ButtonEmbed;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default embed
 * @memberof ButtonEmbed
 * @property {String} key
 * @static
 */


ButtonEmbed.key = 'embed';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonEmbed
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonEmbed.defaultProps = {
    keystroke: {
        fn: '_requestExclusive',
        keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /*L*/
    }
};

exports.default = (0, _buttonKeystroke2.default)(ButtonEmbed);

/***/ }),

/***/ "./src/components/buttons/button-h1.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h1.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonH1 class provides wraps a selection in `h1` element.
 *
 * @class ButtonH1
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH1 = function (_React$Component) {
    _inherits(ButtonH1, _React$Component);

    function ButtonH1() {
        _classCallCheck(this, ButtonH1);

        return _possibleConstructorReturn(this, (ButtonH1.__proto__ || Object.getPrototypeOf(ButtonH1)).apply(this, arguments));
    }

    _createClass(ButtonH1, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonH1
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.h1, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-h1', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.h1 },
                _react2.default.createElement('span', { className: 'ae-icon-h1' })
            );
        }
    }]);

    return ButtonH1;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default h1
 * @memberof ButtonH1
 * @property {String} key
 * @static
 */


ButtonH1.key = 'h1';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonH1
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonH1.defaultProps = {
    style: {
        element: 'h1'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH1)));

/***/ }),

/***/ "./src/components/buttons/button-h2.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h2.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonH2 class provides wraps a selection in `h2` element.
 *
 * @class ButtonH2
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH2 = function (_React$Component) {
    _inherits(ButtonH2, _React$Component);

    function ButtonH2() {
        _classCallCheck(this, ButtonH2);

        return _possibleConstructorReturn(this, (ButtonH2.__proto__ || Object.getPrototypeOf(ButtonH2)).apply(this, arguments));
    }

    _createClass(ButtonH2, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonH2
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.h2, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-h2', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.h2 },
                _react2.default.createElement('span', { className: 'ae-icon-h2' })
            );
        }
    }]);

    return ButtonH2;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default h2
 * @memberof ButtonH2
 * @property {String} key
 * @static
 */


ButtonH2.key = 'h2';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonH2
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonH2.defaultProps = {
    style: {
        element: 'h2'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH2)));

/***/ }),

/***/ "./src/components/buttons/button-hline.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-hline.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonHline class provides inserts horizontal line.
 *
 * @class ButtonHline
 * @uses ButtonCommand
 * @uses ButtonStyle
 */
var ButtonHline = function (_React$Component) {
    _inherits(ButtonHline, _React$Component);

    function ButtonHline() {
        _classCallCheck(this, ButtonHline);

        return _possibleConstructorReturn(this, (ButtonHline.__proto__ || Object.getPrototypeOf(ButtonHline)).apply(this, arguments));
    }

    _createClass(ButtonHline, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonHline
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.horizontalrule, className: 'ae-button', 'data-type': 'button-hline', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.horizontalrule },
                _react2.default.createElement('span', { className: 'ae-icon-separator' })
            );
        }
    }]);

    return ButtonHline;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default hline
 * @memberof ButtonHline
 * @property {String} key
 * @static
 */


ButtonHline.key = 'hline';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonHline
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonHline.defaultProps = {
    command: 'horizontalrule',
    style: {
        element: 'hr'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStyle2.default)(ButtonHline));

/***/ }),

/***/ "./src/components/buttons/button-image-align-center.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-image-align-center.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignCenter class provides functionality for aligning an image in the center.
 *
 * @class ButtonImageAlignCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignCenter = function (_React$Component) {
    _inherits(ButtonImageAlignCenter, _React$Component);

    function ButtonImageAlignCenter() {
        _classCallCheck(this, ButtonImageAlignCenter);

        return _possibleConstructorReturn(this, (ButtonImageAlignCenter.__proto__ || Object.getPrototypeOf(ButtonImageAlignCenter)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignCenter, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignCenter
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignCenter, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-center', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignCenter },
                _react2.default.createElement('span', { className: 'ae-icon-align-center' })
            );
        }
    }]);

    return ButtonImageAlignCenter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageCenter
 * @memberof ButtonImageAlignCenter
 * @property {String} key
 * @static
 */


ButtonImageAlignCenter.key = 'imageCenter';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignCenter
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignCenter.defaultProps = {
    command: 'justifycenter'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignCenter)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-left.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-image-align-left.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignLeft class provides functionality for aligning an image on left.
 *
 * @class ButtonImageAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignLeft = function (_React$Component) {
    _inherits(ButtonImageAlignLeft, _React$Component);

    function ButtonImageAlignLeft() {
        _classCallCheck(this, ButtonImageAlignLeft);

        return _possibleConstructorReturn(this, (ButtonImageAlignLeft.__proto__ || Object.getPrototypeOf(ButtonImageAlignLeft)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignLeft, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignLeft
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignLeft, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-left', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignLeft },
                _react2.default.createElement('span', { className: 'ae-icon-align-left' })
            );
        }
    }]);

    return ButtonImageAlignLeft;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageLeft
 * @memberof ButtonImageAlignLeft
 * @property {String} key
 * @static
 */


ButtonImageAlignLeft.key = 'imageLeft';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignLeft
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignLeft.defaultProps = {
    command: 'justifyleft'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-right.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-image-align-right.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignRight class provides functionality for aligning an image on right.
 *
 * @class ButtonImageAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignRight = function (_React$Component) {
    _inherits(ButtonImageAlignRight, _React$Component);

    function ButtonImageAlignRight() {
        _classCallCheck(this, ButtonImageAlignRight);

        return _possibleConstructorReturn(this, (ButtonImageAlignRight.__proto__ || Object.getPrototypeOf(ButtonImageAlignRight)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignRight, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignRight
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignRight, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-right', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignRight },
                _react2.default.createElement('span', { className: 'ae-icon-align-right' })
            );
        }
    }]);

    return ButtonImageAlignRight;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageRight
 * @memberof ButtonImageAlignRight
 * @property {String} key
 * @static
 */


ButtonImageAlignRight.key = 'imageRight';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignRight
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignRight.defaultProps = {
    command: 'justifyright'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-image.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-image.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImage class inserts an image to the content.
 *
 * @class ButtonImage
 */
var ButtonImage = function (_React$Component) {
    _inherits(ButtonImage, _React$Component);

    function ButtonImage(props) {
        _classCallCheck(this, ButtonImage);

        var _this = _possibleConstructorReturn(this, (ButtonImage.__proto__ || Object.getPrototypeOf(ButtonImage)).call(this, props));

        _this.fileInput = _react2.default.createRef();
        return _this;
    }

    /**
     * Lifecycle. Renders the UI of the button.
     *
     * @instance
     * @memberof ButtonImage
     * @method render
     * @return {Object} The content which should be rendered.
     */


    _createClass(ButtonImage, [{
        key: 'render',
        value: function render() {
            var inputSyle = { display: 'none' };

            return _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.image, className: 'ae-button', 'data-type': 'button-image', onClick: this.handleClick.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.image },
                    _react2.default.createElement('span', { className: 'ae-icon-image' })
                ),
                _react2.default.createElement('input', { accept: 'image/*', onChange: this._onInputChange.bind(this), ref: this.fileInput, style: inputSyle, type: 'file' })
            );
        }

        /**
         * Simulates click on the input element. This will open browser's native file open dialog.
         *
         * @instance
         * @memberof ButtonImage
         * @method handleClick
         * @param {SyntheticEvent} event The received click event on the button.
         */

    }, {
        key: 'handleClick',
        value: function handleClick() {
            this.fileInput.current.click();
        }

        /**
         * On input change, reads the chosen file and fires an event `beforeImageAdd` with the image which will be added
         * to the content. The image file will be passed in the `imageFiles` property.
         * If any of the listeners returns `false` or cancels the event, the image won't be added to the content.
         * Otherwise, an event `imageAdd` will be fired with the inserted element into the editable area.
         * The passed params will be:
         * - `el` - the created img element
         * - `file` - the original image file from the input element
         *
         * @fires ButtonImage#beforeImageAdd
         * @fires ButtonImage#imageAdd
         * @instance
         * @memberof ButtonImage
         * @method _onInputChange
         * @protected
         */

    }, {
        key: '_onInputChange',
        value: function _onInputChange() {
            var inputEl = this.fileInput.current;

            // On IE11 the function might be called with an empty array of
            // files. In such a case, no actions will be taken.
            if (!inputEl.files.length) {
                return;
            }

            var reader = new FileReader();
            var file = inputEl.files[0];

            reader.onload = function (event) {
                var editor = this.props.editor.get('nativeEditor');

                var result = editor.fire('beforeImageAdd', {
                    imageFiles: file
                });

                if (!!result) {
                    var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

                    editor.insertElement(el);

                    editor.fire('actionPerformed', this);

                    var imageData = {
                        el: el,
                        file: file
                    };

                    editor.fire('imageAdd', imageData);
                }
            }.bind(this);

            reader.readAsDataURL(file);

            inputEl.value = '';
        }
    }]);

    return ButtonImage;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default image
 * @memberof ButtonImage
 * @property {String} key
 * @static
 */


ButtonImage.key = 'image';

exports.default = ButtonImage;

/***/ }),

/***/ "./src/components/buttons/button-indent-block.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-indent-block.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonIndentBlock class provides functionality for indenting the selected blocks.
 *
 * @class ButtonIndentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonIndentBlock = function (_React$Component) {
    _inherits(ButtonIndentBlock, _React$Component);

    function ButtonIndentBlock() {
        _classCallCheck(this, ButtonIndentBlock);

        return _possibleConstructorReturn(this, (ButtonIndentBlock.__proto__ || Object.getPrototypeOf(ButtonIndentBlock)).apply(this, arguments));
    }

    _createClass(ButtonIndentBlock, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonIndentBlock
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.indent, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-indent-block', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.indent },
                _react2.default.createElement('span', { className: 'ae-icon-indent-block' })
            );
        }
    }]);

    return ButtonIndentBlock;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default indentBlock
 * @memberof ButtonIndentBlock
 * @property {String} key
 * @static
 */


ButtonIndentBlock.key = 'indentBlock';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonIndentBlock
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonIndentBlock.defaultProps = {
    command: 'indent'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonIndentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-italic.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-italic.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonItalic class provides functionality for styling an selection with italic (em) style.
 *
 * @class ButtonItalic
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonItalic = function (_React$Component) {
    _inherits(ButtonItalic, _React$Component);

    function ButtonItalic() {
        _classCallCheck(this, ButtonItalic);

        return _possibleConstructorReturn(this, (ButtonItalic.__proto__ || Object.getPrototypeOf(ButtonItalic)).apply(this, arguments));
    }

    _createClass(ButtonItalic, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonItalic
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.italic, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-italic', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.italic },
                _react2.default.createElement('span', { className: 'ae-icon-italic' })
            );
        }
    }]);

    return ButtonItalic;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default italic
 * @memberof ButtonItalic
 * @property {String} key
 * @static
 */


ButtonItalic.key = 'italic';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonItalic
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonItalic.defaultProps = {
    command: 'italic',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 73 /*I*/
    },
    style: 'coreStyles_italic'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonItalic))));

/***/ }),

/***/ "./src/components/buttons/button-link-autocomplete-list.jsx":
/*!******************************************************************!*\
  !*** ./src/components/buttons/button-link-autocomplete-list.jsx ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkAutocompleteList class provides functionality for showing a list of
 * items that can be selected for the link.
 *
 * @class ButtonLinkAutocompleteList
 * @uses WidgetFocusManager
 */
var ButtonLinkAutocompleteList = function (_React$Component) {
    _inherits(ButtonLinkAutocompleteList, _React$Component);

    function ButtonLinkAutocompleteList(props) {
        _classCallCheck(this, ButtonLinkAutocompleteList);

        var _this = _possibleConstructorReturn(this, (ButtonLinkAutocompleteList.__proto__ || Object.getPrototypeOf(ButtonLinkAutocompleteList)).call(this, props));

        _this.state = {
            items: []
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked when a component is receiving new props.
     * This method is not called for the initial render.
     *
     * @instance
     * @memberof ButtonLinkAutocompleteList
     * @method componentWillReceiveProps
     */


    _createClass(ButtonLinkAutocompleteList, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (!nextProps.term || nextProps.term !== this.props.term) {
                clearTimeout(this._timeout);

                if (nextProps.term) {
                    this._timeout = setTimeout(this._updateItems, this.props.delay);
                } else {
                    this.setState({
                        items: []
                    });
                }
            }

            if (nextProps.autocompleteSelected) {
                setTimeout(this.focus, 0);
                this.props.setAutocompleteState({
                    selected: false
                });
            }
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            clearTimeout(this._timeout);
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            if (!this.props.expanded || !this.state.items.length) {
                return null;
            }

            return _react2.default.createElement(
                _buttonDropdown2.default,
                null,
                this._renderAutocompleteItems(this.state.items)
            );
        }

        /**
         * Lifecycle. Invoked before rendering when new props or state are being received.
         * This method is not called for the initial render or when forceUpdate is used.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method  shouldComponentUpdate
         * @return {Boolean} Returns false when the transition to the new props and state will not
         * require a component update.
         */

    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps, nextState) {
            return nextProps.expanded !== this.props.expanded || nextProps.term !== this.props.term || nextState.items !== this.state.items;
        }

        /**
         * Renders a set of list items for the provided items
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method _renderAutocompleteItems
         * @param {Array} items List of autocomplete items to render
         * @protected
         * @return {Array} Rendered list item instances
         */

    }, {
        key: '_renderAutocompleteItems',
        value: function _renderAutocompleteItems(items) {
            items = items || [];

            var handleLinkAutocompleteClick = this.props.handleLinkAutocompleteClick;

            return items.map(function (item) {
                var className = this.props.term === item.url ? 'ae-toolbar-element active' : 'ae-toolbar-element';

                return _react2.default.createElement(
                    'li',
                    { key: item.url, role: 'option' },
                    _react2.default.createElement(
                        'button',
                        { className: className, onClick: handleLinkAutocompleteClick, 'data-value': item.url },
                        item.title
                    )
                );
            }.bind(this));
        }

        /**
         * Retrieves the data according to {this.props.term} and calls setState() with the returned data
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method _updateItems
         * @protected
         */

    }, {
        key: '_updateItems',
        value: function _updateItems() {
            var instance = this;

            if (!this.props.term) {
                return;
            }

            var promise = Promise.resolve(this.props.data(this.props.term));

            promise.then(function (items) {
                if (items.length) {
                    !instance.props.expanded && instance.props.toggleDropdown();
                }

                instance.setState({
                    items: items
                });
            });
        }
    }]);

    return ButtonLinkAutocompleteList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonLinkAutocompleteList
 * @memberof ButtonLinkAutocompleteList
 * @property {String} key
 * @static
 */


ButtonLinkAutocompleteList.key = 'buttonLinkAutocompleteList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLinkAutocompleteList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLinkAutocompleteList.defaultProps = {
    circular: false,
    data: [],
    delay: 100,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonLinkAutocompleteList);

/***/ }),

/***/ "./src/components/buttons/button-link-edit.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-link-edit.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonProps = __webpack_require__(/*! ../base/button-props.js */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkEdit class provides functionality for creating and editing a link in a document.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEdit
 * @uses ButtonCfgProps
 * @uses WidgetDropdown
 * @uses WidgetFocusManager
 */
var ButtonLinkEdit = function (_React$Component) {
    _inherits(ButtonLinkEdit, _React$Component);

    function ButtonLinkEdit(props) {
        _classCallCheck(this, ButtonLinkEdit);

        var _this = _possibleConstructorReturn(this, (ButtonLinkEdit.__proto__ || Object.getPrototypeOf(ButtonLinkEdit)).call(this, props));

        _this.linkInput = _react2.default.createRef();
        _this.state = _this._getInitialState();
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing. This should only happen if the component
     * is rendered in exclusive mode to prevent aggressive focus stealing.
     *
     * @instance
     * @memberof ButtonLinkEdit
     * @method componentDidMount
     */


    _createClass(ButtonLinkEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.renderExclusive || this.props.manualSelection) {
                // We need to wait for the next rendering cycle before focusing to avoid undesired
                // scrolls on the page
                this._focusLinkInput();
            }
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method componentWillReceiveProps
         */

    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps() {
            this.setState(this._getInitialState());
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var targetSelector = {
                allowedTargets: this.props.allowedTargets,
                editor: this.props.editor,
                handleLinkTargetChange: this._handleLinkTargetChange.bind(this),
                selectedTarget: this.state.linkTarget || AlloyEditor.Strings.linkTargetDefault
            };

            targetSelector = this.mergeDropdownProps(targetSelector, _buttonLinkTargetEdit2.default.key);

            var autocompleteDropdown;

            if (this.props.data) {
                var dataFn = this.props.data;

                if (!_lang2.default.isFunction(dataFn)) {
                    var items = this.props.data;

                    dataFn = function dataFn() {
                        return items;
                    };
                }

                var autocompleteDropdownProps = {
                    autocompleteSelected: this.state.autocompleteSelected,
                    data: dataFn,
                    editor: this.props.editor,
                    handleLinkAutocompleteClick: this._handleLinkAutocompleteClick,
                    onDismiss: this.props.toggleDropdown,
                    setAutocompleteState: this._setAutocompleteState,
                    term: this.state.linkHref
                };

                autocompleteDropdownProps = this.mergeDropdownProps(autocompleteDropdownProps, _buttonLinkAutocompleteList2.default.key);

                autocompleteDropdown = _react2.default.createElement(_buttonLinkAutocompleteList2.default, autocompleteDropdownProps);
            }

            var buttonClearLink;

            if (this.state.linkHref) {
                buttonClearLink = _react2.default.createElement('button', { 'aria-label': AlloyEditor.Strings.clearInput, className: 'ae-button ae-icon-remove', onClick: this._clearLink.bind(this), title: AlloyEditor.Strings.clear });
            }

            var placeholderProp = {};

            if (!CKEDITOR.env.ie && AlloyEditor.Strings) {
                placeholderProp.placeholder = AlloyEditor.Strings.editLink;
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link' },
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.removeLink, className: 'ae-button', disabled: !this.state.element, onClick: this._removeLink.bind(this), title: AlloyEditor.Strings.remove },
                    _react2.default.createElement('span', { className: 'ae-icon-unlink' })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input xxl' },
                    this.props.showTargetSelector && _react2.default.createElement(_buttonLinkTargetEdit2.default, targetSelector),
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container-input' },
                        _react2.default.createElement('input', _extends({ className: 'ae-input', onChange: this._handleLinkHrefChange.bind(this), onKeyDown: this._handleKeyDown.bind(this) }, placeholderProp, { ref: this.linkInput, type: 'text', value: this.state.linkHref })),
                        autocompleteDropdown
                    ),
                    buttonClearLink
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.confirm, className: 'ae-button', disabled: !this._isValidState(), onClick: this._updateLink.bind(this), title: AlloyEditor.Strings.confirm },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }

        /**
         * The return value will be used as the initial value of this.state.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _getInitialState
         * @protected
         * @return {Object}
         */

    }, {
        key: '_getInitialState',
        value: function _getInitialState() {
            var _props = this.props,
                editor = _props.editor,
                defaultLinkTarget = _props.defaultLinkTarget;


            var link = new CKEDITOR.Link(editor.get('nativeEditor')).getFromSelection();
            var href = link ? link.getAttribute('href') : '';
            var target = link ? link.getAttribute('target') : defaultLinkTarget;

            return {
                autocompleteSelected: false,
                element: link,
                initialLink: {
                    href: href,
                    target: target
                },
                linkHref: href,
                linkTarget: target
            };
        }

        /**
         * Clears the link input. This only changes the component internal state, but does not
         * affect the link element of the editor. Only the _removeLink and _updateLink methods
         * are translated to the editor element.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _clearLink
         * @protected
         */

    }, {
        key: '_clearLink',
        value: function _clearLink() {
            this.setState({
                linkHref: ''
            });

            this._focusLinkInput();
        }

        /**
         * Focuses the user cursor on the widget's input.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _focusLinkInput
         * @protected
         */

    }, {
        key: '_focusLinkInput',
        value: function _focusLinkInput() {
            var instance = this;

            var focusLinkEl = function focusLinkEl() {
                instance.linkInput.current.focus();
            };

            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(focusLinkEl);
            } else {
                setTimeout(focusLinkEl, 0);
            }
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates/updates the link.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === 13 || event.keyCode === 27) {
                event.preventDefault();
            }

            if (event.keyCode === 13) {
                this._updateLink();
            } else if (event.keyCode === 40) {
                this.setState({
                    autocompleteSelected: true
                });
            } else if (event.keyCode === 27) {
                var editor = this.props.editor.get('nativeEditor');

                new CKEDITOR.Link(editor).advanceSelection();

                this.props.editor.get('nativeEditor').fire('actionPerformed', this);
            }
        }

        /**
         * Updates the component state when the link input changes on user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkHrefChange
         * @param {SyntheticEvent} event The change event.
         * @protected
         */

    }, {
        key: '_handleLinkHrefChange',
        value: function _handleLinkHrefChange(event) {
            this.setState({
                linkHref: event.target.value
            });

            this._focusLinkInput();
        }

        /**
         * Updates the component state when the link target changes on user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkTargetChange
         * @param {SyntheticEvent} event The click event.
         * @protected
         */

    }, {
        key: '_handleLinkTargetChange',
        value: function _handleLinkTargetChange(event) {
            this.setState({
                itemDropdown: null,
                linkTarget: event.target.getAttribute('data-value')
            });

            this._focusLinkInput();
        }

        /**
         * Updates the component state when an autocomplete link result is selected by user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkAutocompleteClick
         * @param {SyntheticEvent} event The click event.
         * @protected
         */

    }, {
        key: '_handleLinkAutocompleteClick',
        value: function _handleLinkAutocompleteClick(event) {
            this.setState({
                itemDropdown: null,
                linkHref: event.target.getAttribute('data-value')
            });

            this._focusLinkInput();
        }

        /**
         * Verifies that the current link state is valid so the user can save the link. A valid state
         * means that we have a non-empty href and that either that or the link target are different
         * from the original link.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _isValidState
         * @protected
         * @return {Boolean} [description]
         */

    }, {
        key: '_isValidState',
        value: function _isValidState() {
            var validState = this.state.linkHref && (this.state.linkHref !== this.state.initialLink.href || this.state.linkTarget !== this.state.initialLink.target);

            return validState;
        }

        /**
         * Removes the link in the editor element.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _removeLink
         * @protected
         */

    }, {
        key: '_removeLink',
        value: function _removeLink() {
            var editor = this.props.editor.get('nativeEditor');
            var linkUtils = new CKEDITOR.Link(editor);
            var selection = editor.getSelection();
            var bookmarks = selection.createBookmarks();

            linkUtils.remove(this.state.element, { advance: true });

            selection.selectBookmarks(bookmarks);

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();

            editor.fire('actionPerformed', this);
        }

        /**
         * Update autocompleteSelected state to focus and select autocompletes dropdown
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _setAutocompleteState
         * @protected
         */

    }, {
        key: '_setAutocompleteState',
        value: function _setAutocompleteState(state) {
            this.setState({
                autocompleteSelected: state.selected
            });
        }

        /**
         * Updates the link in the editor element. If the element didn't exist previously, it will
         * create a new <a> element with the href specified in the link input.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _updateLink
         * @protected
         */

    }, {
        key: '_updateLink',
        value: function _updateLink() {
            var editor = this.props.editor.get('nativeEditor');
            var linkUtils = new CKEDITOR.Link(editor, { appendProtocol: this.props.appendProtocol });
            var linkAttrs = {
                target: this.state.linkTarget
            };
            var modifySelection = { advance: true };

            if (this.state.linkHref) {
                if (this.state.element) {
                    linkAttrs.href = this.state.linkHref;

                    linkUtils.update(linkAttrs, this.state.element, modifySelection);
                } else {
                    linkUtils.create(this.state.linkHref, linkAttrs, modifySelection);
                }

                editor.fire('actionPerformed', this);
            }

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();
        }
    }]);

    return ButtonLinkEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkEdit
 * @memberof ButtonLinkEdit
 * @property {String} key
 * @static
 */


ButtonLinkEdit.key = 'linkEdit';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLinkEdit
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLinkEdit.defaultProps = {
    appendProtocol: true,
    autocompleteUrl: '',
    circular: true,
    customIndexStart: true,
    defaultLinkTarget: '',
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    },
    showTargetSelector: true
};

exports.default = (0, _buttonProps2.default)((0, _widgetDropdown2.default)((0, _widgetFocusManager2.default)(ButtonLinkEdit)));

/***/ }),

/***/ "./src/components/buttons/button-link-target-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-target-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkTargetEdit class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonLinkTargetEdit
 */
var ButtonLinkTargetEdit = function (_React$Component) {
    _inherits(ButtonLinkTargetEdit, _React$Component);

    function ButtonLinkTargetEdit() {
        _classCallCheck(this, ButtonLinkTargetEdit);

        return _possibleConstructorReturn(this, (ButtonLinkTargetEdit.__proto__ || Object.getPrototypeOf(ButtonLinkTargetEdit)).apply(this, arguments));
    }

    _createClass(ButtonLinkTargetEdit, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLinkTargetEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var handleLinkTargetChange = this.props.handleLinkTargetChange;
            var allowedLinkTargets = this.props.allowedTargets;

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link-target ae-container-dropdown ae-container-dropdown-medium ae-has-dropdown', tabIndex: '0' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': this.props.selectedTarget, className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: this.props.selectedTarget },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            this.props.selectedTarget
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                this.props.expanded && _react2.default.createElement(_buttonTargetList2.default, { editor: this.props.editor, onDismiss: this.props.toggleDropdown, allowedLinkTargets: allowedLinkTargets, handleLinkTargetChange: handleLinkTargetChange, selectedTarget: this.props.selectedTarget })
            );
        }

        /**
         * Lifecycle. Invoked before rendering when new props or state are being received.
         * This method is not called for the initial render or when forceUpdate is used.
         *
         * @instance
         * @memberof ButtonLinkTargetEdit
         * @method  shouldComponentUpdate
         * @return {Boolean} Returns false when the transition to the new props and state will not
         * require a component update.
         */

    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.expanded !== this.props.expanded || nextProps.selectedTarget !== this.props.selectedTarget;
        }
    }]);

    return ButtonLinkTargetEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkTargetEdit
 * @memberof ButtonLinkTargetEdit
 * @property {String} key
 * @static
 */


ButtonLinkTargetEdit.key = 'linkTargetEdit';

exports.default = ButtonLinkTargetEdit;

/***/ }),

/***/ "./src/components/buttons/button-link.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-link.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonProps = __webpack_require__(/*! ../base/button-props.js */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLink class provides functionality for creating and editing a link in a document. ButtonLink
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonLinkEdit UI with all the link edition controls.
 *
 * @class ButtonLink
 * @uses ButtonCfgProps
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 */
var ButtonLink = function (_React$Component) {
    _inherits(ButtonLink, _React$Component);

    function ButtonLink() {
        _classCallCheck(this, ButtonLink);

        return _possibleConstructorReturn(this, (ButtonLink.__proto__ || Object.getPrototypeOf(ButtonLink)).apply(this, arguments));
    }

    _createClass(ButtonLink, [{
        key: 'isActive',

        /**
         * Checks if the current selection is contained within a link.
         *
         * @instance
         * @memberof ButtonLink
         * @method isActive
         * @return {Boolean} True if the selection is inside a link, false otherwise.
         */
        value: function isActive() {
            return new CKEDITOR.Link(this.props.editor.get('nativeEditor')).getFromSelection() !== null;
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLink
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            if (this.props.renderExclusive) {
                var props = this.mergeButtonCfgProps();

                return _react2.default.createElement(_buttonLinkEdit2.default, props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.link, className: cssClass, 'data-type': 'button-link', onClick: this._requestExclusive.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.link },
                    _react2.default.createElement('span', { className: 'ae-icon-link' })
                );
            }
        }

        /**
         * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
         *
         * @instance
         * @memberof ButtonLink
         * @method _requestExclusive
         * @protected
         */

    }, {
        key: '_requestExclusive',
        value: function _requestExclusive() {
            this.props.requestExclusive(ButtonLink.key);
        }
    }]);

    return ButtonLink;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default link
 * @memberof ButtonLink
 * @property {String} key
 * @static
 */


ButtonLink.key = 'link';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLink
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLink.defaultProps = {
    keystroke: {
        fn: '_requestExclusive',
        keys: CKEDITOR.CTRL + 76 /*L*/
    }
};

exports.default = (0, _buttonProps2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)(ButtonLink)));

/***/ }),

/***/ "./src/components/buttons/button-ol.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ol.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonOrderedList class provides functionality for creating ordered lists in an editor.
 *
 * @class ButtonOrderedList
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonOrderedList = function (_React$Component) {
    _inherits(ButtonOrderedList, _React$Component);

    function ButtonOrderedList() {
        _classCallCheck(this, ButtonOrderedList);

        return _possibleConstructorReturn(this, (ButtonOrderedList.__proto__ || Object.getPrototypeOf(ButtonOrderedList)).apply(this, arguments));
    }

    _createClass(ButtonOrderedList, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonOrderedList
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.numberedlist, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-ol', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.numberedlist },
                _react2.default.createElement('span', { className: 'ae-icon-numbered-list' })
            );
        }
    }]);

    return ButtonOrderedList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default ol
 * @memberof ButtonOrderedList
 * @property {String} key
 * @static
 */


ButtonOrderedList.key = 'ol';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonOrderedList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonOrderedList.defaultProps = {
    command: 'numberedlist',
    style: {
        element: 'ol'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonOrderedList)));

/***/ }),

/***/ "./src/components/buttons/button-outdent-block.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-outdent-block.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonOutdentBlock class provides functionality for outdenting blocks.
 *
 * @class ButtonOutdentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonOutdentBlock = function (_React$Component) {
    _inherits(ButtonOutdentBlock, _React$Component);

    function ButtonOutdentBlock() {
        _classCallCheck(this, ButtonOutdentBlock);

        return _possibleConstructorReturn(this, (ButtonOutdentBlock.__proto__ || Object.getPrototypeOf(ButtonOutdentBlock)).apply(this, arguments));
    }

    _createClass(ButtonOutdentBlock, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonOutdentBlock
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.outdent, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-outdent-block', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.outdent },
                _react2.default.createElement('span', { className: 'ae-icon-outdent-block' })
            );
        }
    }]);

    return ButtonOutdentBlock;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default indentBlock
 * @memberof ButtonOutdentBlock
 * @property {String} key
 * @static
 */


ButtonOutdentBlock.key = 'outdentBlock';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonOutdentBlock
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonOutdentBlock.defaultProps = {
    command: 'outdent'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonOutdentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-left.jsx":
/*!****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-left.jsx ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlignLeft class provides functionality for aligning a paragraph on left.
 *
 * @class ButtonParagraphAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignLeft = function (_React$Component) {
    _inherits(ButtonParagraphAlignLeft, _React$Component);

    function ButtonParagraphAlignLeft() {
        _classCallCheck(this, ButtonParagraphAlignLeft);

        return _possibleConstructorReturn(this, (ButtonParagraphAlignLeft.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignLeft)).apply(this, arguments));
    }

    _createClass(ButtonParagraphAlignLeft, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphAlignLeft
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignLeft, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-align-left', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignLeft },
                _react2.default.createElement('span', { className: 'ae-icon-align-left' })
            );
        }
    }]);

    return ButtonParagraphAlignLeft;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphLeft
 * @memberof ButtonParagraphAlignLeft
 * @property {String} key
 * @static
 */


ButtonParagraphAlignLeft.key = 'paragraphLeft';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphAlignLeft
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphAlignLeft.defaultProps = {
    command: 'justifyleft'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-right.jsx":
/*!*****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-right.jsx ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlignRight class provides functionality for aligning a paragraph on right.
 *
 * @class ButtonParagraphAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignRight = function (_React$Component) {
    _inherits(ButtonParagraphAlignRight, _React$Component);

    function ButtonParagraphAlignRight() {
        _classCallCheck(this, ButtonParagraphAlignRight);

        return _possibleConstructorReturn(this, (ButtonParagraphAlignRight.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignRight)).apply(this, arguments));
    }

    _createClass(ButtonParagraphAlignRight, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphAlignRight
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignRight, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-align-right', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignRight },
                _react2.default.createElement('span', { className: 'ae-icon-align-right' })
            );
        }
    }]);

    return ButtonParagraphAlignRight;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphRight
 * @memberof ButtonParagraphAlignRight
 * @property {String} key
 * @static
 */


ButtonParagraphAlignRight.key = 'paragraphRight';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphAlignRight
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphAlignRight.defaultProps = {
    command: 'justifyright'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-center.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-center.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphCenter class provides functionality for centering a paragraph.
 *
 * @class ButtonParagraphCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphCenter = function (_React$Component) {
    _inherits(ButtonParagraphCenter, _React$Component);

    function ButtonParagraphCenter() {
        _classCallCheck(this, ButtonParagraphCenter);

        return _possibleConstructorReturn(this, (ButtonParagraphCenter.__proto__ || Object.getPrototypeOf(ButtonParagraphCenter)).apply(this, arguments));
    }

    _createClass(ButtonParagraphCenter, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphCenter
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignCenter, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-center', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignCenter },
                _react2.default.createElement('span', { className: 'ae-icon-align-center' })
            );
        }
    }]);

    return ButtonParagraphCenter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphCenter
 * @memberof ButtonParagraphCenter
 * @property {String} key
 * @static
 */


ButtonParagraphCenter.key = 'paragraphCenter';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphCenter
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphCenter.defaultProps = {
    command: 'justifycenter'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphCenter)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-justify.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-justify.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphJustify class provides functionality for justfying a paragraph.
 *
 * @class ButtonParagraphJustify
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphJustify = function (_React$Component) {
    _inherits(ButtonParagraphJustify, _React$Component);

    function ButtonParagraphJustify() {
        _classCallCheck(this, ButtonParagraphJustify);

        return _possibleConstructorReturn(this, (ButtonParagraphJustify.__proto__ || Object.getPrototypeOf(ButtonParagraphJustify)).apply(this, arguments));
    }

    _createClass(ButtonParagraphJustify, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphJustify
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignJustify, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-justify', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignJustify },
                _react2.default.createElement('span', { className: 'ae-icon-align-justified' })
            );
        }
    }]);

    return ButtonParagraphJustify;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphJustify
 * @memberof ButtonParagraphJustify
 * @property {String} key
 * @static
 */


ButtonParagraphJustify.key = 'paragraphJustify';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphJustify
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphJustify.defaultProps = {
    command: 'justifyblock'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphJustify)));

/***/ }),

/***/ "./src/components/buttons/button-quote.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-quote.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonQuote class wraps a selection in `blockquote` element.
 *
 * @class ButtonQuote
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonQuote = function (_React$Component) {
    _inherits(ButtonQuote, _React$Component);

    function ButtonQuote() {
        _classCallCheck(this, ButtonQuote);

        return _possibleConstructorReturn(this, (ButtonQuote.__proto__ || Object.getPrototypeOf(ButtonQuote)).apply(this, arguments));
    }

    _createClass(ButtonQuote, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonQuote
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.quote, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-quote', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.quote },
                _react2.default.createElement('span', { className: 'ae-icon-quote' })
            );
        }
    }]);

    return ButtonQuote;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default quote
 * @memberof ButtonQuote
 * @property {String} key
 * @static
 */


ButtonQuote.key = 'quote';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonQuote
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonQuote.defaultProps = {
    command: 'blockquote',
    style: {
        element: 'blockquote'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonQuote)));

/***/ }),

/***/ "./src/components/buttons/button-remove-format.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-remove-format.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonRemoveFormat class removes style formatting.
 *
 * @class ButtonRemoveFormat
 * @uses ButtonCommand
 */
var ButtonRemoveFormat = function (_React$Component) {
    _inherits(ButtonRemoveFormat, _React$Component);

    function ButtonRemoveFormat() {
        _classCallCheck(this, ButtonRemoveFormat);

        return _possibleConstructorReturn(this, (ButtonRemoveFormat.__proto__ || Object.getPrototypeOf(ButtonRemoveFormat)).apply(this, arguments));
    }

    _createClass(ButtonRemoveFormat, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonRemoveFormat
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.removeformat, className: 'ae-button', 'data-type': 'button-removeformat', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.removeformat },
                _react2.default.createElement('span', { className: 'ae-icon-removeformat' })
            );
        }
    }]);

    return ButtonRemoveFormat;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default removeFormat
 * @memberof ButtonRemoveFormat
 * @property {String} key
 * @static
 */


ButtonRemoveFormat.key = 'removeFormat';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonRemoveFormat
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonRemoveFormat.defaultProps = {
    command: 'removeFormat'
};

exports.default = (0, _buttonCommand2.default)(ButtonRemoveFormat);

/***/ }),

/***/ "./src/components/buttons/button-strike.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-strike.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStrike class styles a selection with strike style.
 *
 * @class ButtonStrike
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonStrike = function (_React$Component) {
    _inherits(ButtonStrike, _React$Component);

    function ButtonStrike() {
        _classCallCheck(this, ButtonStrike);

        return _possibleConstructorReturn(this, (ButtonStrike.__proto__ || Object.getPrototypeOf(ButtonStrike)).apply(this, arguments));
    }

    _createClass(ButtonStrike, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         * @instance
         * @memberof ButtonStrike
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.strike, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-strike', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.strike },
                _react2.default.createElement('span', { className: 'ae-icon-strike' })
            );
        }
    }]);

    return ButtonStrike;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default strike
 * @memberof ButtonStrike
 * @property {String} key
 * @static
 */


ButtonStrike.key = 'strike';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStrike
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStrike.defaultProps = {
    command: 'strike',
    style: 'coreStyles_strike'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonStrike)));

/***/ }),

/***/ "./src/components/buttons/button-styles-list-header.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-header.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonsStylesListHeader class provides the header of an list of style items.
 *
 * @class ButtonsStylesListHeader
 */
var ButtonsStylesListHeader = function (_React$Component) {
    _inherits(ButtonsStylesListHeader, _React$Component);

    function ButtonsStylesListHeader() {
        _classCallCheck(this, ButtonsStylesListHeader);

        return _possibleConstructorReturn(this, (ButtonsStylesListHeader.__proto__ || Object.getPrototypeOf(ButtonsStylesListHeader)).apply(this, arguments));
    }

    _createClass(ButtonsStylesListHeader, [{
        key: "render",

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonsStylesListHeader
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.styles && this.props.styles.length) {
                return _react2.default.createElement(
                    "span",
                    { className: "ae-list-header" },
                    this.props.name
                );
            } else {
                return null;
            }
        }
    }]);

    return ButtonsStylesListHeader;
}(_react2.default.Component);

exports.default = ButtonsStylesListHeader;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item-remove.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item-remove.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesListItemRemove class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItemRemove
 */
var ButtonStylesListItemRemove = function (_React$Component) {
    _inherits(ButtonStylesListItemRemove, _React$Component);

    function ButtonStylesListItemRemove() {
        _classCallCheck(this, ButtonStylesListItemRemove);

        return _possibleConstructorReturn(this, (ButtonStylesListItemRemove.__proto__ || Object.getPrototypeOf(ButtonStylesListItemRemove)).apply(this, arguments));
    }

    _createClass(ButtonStylesListItemRemove, [{
        key: "render",

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStylesListItemRemove
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                "li",
                { role: "option" },
                _react2.default.createElement(
                    "button",
                    { className: "ae-toolbar-element", onClick: this._removeStyles.bind(this), tabIndex: this.props.tabIndex },
                    AlloyEditor.Strings.normal
                )
            );
        }

        /**
         * Removes all inline styles and configured block elements applied to the current selection.
         *
         * @instance
         * @memberof ButtonStylesListItemRemove
         * @method _removeStyles
         * @protected
         */

    }, {
        key: "_removeStyles",
        value: function _removeStyles() {
            var editor = this.props.editor.get('nativeEditor');

            editor.execCommand('removeFormat');

            this.props.removeBlocks.forEach(function (blockItem) {
                var blockStyle = new CKEDITOR.style({ element: blockItem });

                editor.removeStyle(blockStyle);
            });

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonStylesListItemRemove;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonStylesListItemRemove
 * @memberof ButtonStylesListItemRemove
 * @property {String} key
 * @static
 */


ButtonStylesListItemRemove.key = 'buttonStylesListItemRemove';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStylesListItemRemove
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStylesListItemRemove.defaultProps = {
    removeBlocks: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre']
};

exports.default = ButtonStylesListItemRemove;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesListItem class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItem
 * @uses ButtonActionStyle
 * @uses ButtonStyle
 */
var ButtonStylesListItem = function (_React$Component) {
    _inherits(ButtonStylesListItem, _React$Component);

    function ButtonStylesListItem() {
        _classCallCheck(this, ButtonStylesListItem);

        return _possibleConstructorReturn(this, (ButtonStylesListItem.__proto__ || Object.getPrototypeOf(ButtonStylesListItem)).apply(this, arguments));
    }

    _createClass(ButtonStylesListItem, [{
        key: 'componentWillMount',

        /**
         * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method componentWillMount
         */
        value: function componentWillMount() {
            // Styles with wildcard element (*) generate an empty tag in their preview < class="custom-class" />.
            // We default to element span and remove the margins to obtain a more consistent set of previews.
            var styleCfg = {
                element: 'span',
                styles: {
                    margin: 0
                }
            };

            styleCfg = CKEDITOR.tools.merge(styleCfg, this.props.style);

            this._preview = new CKEDITOR.style(styleCfg).buildPreview(this.props.name);
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            // We need to use dangerouselySetInnterHTML since we're not in control of the style
            // preview that is generated by CKEditor.
            var className = this.props.name === this.props.activeStyle ? 'ae-toolbar-element active' : 'ae-toolbar-element';

            return _react2.default.createElement('button', { className: className, dangerouslySetInnerHTML: { __html: this._preview }, onClick: this._onClick.bind(this), tabIndex: this.props.tabIndex });
        }

        /**
         * Applies the item style to the editor selection.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method _onClick
         * @protected
         */

    }, {
        key: '_onClick',
        value: function _onClick() {
            // Typically, we want the style to be the only one applied to the current selection, so
            // we execute the 'removeFormat' command first. Note that block styles won't be cleaned.
            // However, this is consistent with other editors implementations of this feature.
            this.props.editor.get('nativeEditor').execCommand('removeFormat');

            this.applyStyle();
        }
    }]);

    return ButtonStylesListItem;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonStylesListItem
 * @memberof ButtonStylesListItem
 * @property {String} key
 * @static
 */


ButtonStylesListItem.key = 'buttonStylesListItem';

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStyle2.default)(ButtonStylesListItem));

/***/ }),

/***/ "./src/components/buttons/button-styles-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-styles-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesList class provides functionality for showing a list of styles that can be
 * applied to the current selection..
 *
 * @class ButtonStylesList
 * @uses WidgetFocusManager
 */
var ButtonStylesList = function (_React$Component) {
    _inherits(ButtonStylesList, _React$Component);

    function ButtonStylesList() {
        _classCallCheck(this, ButtonStylesList);

        return _possibleConstructorReturn(this, (ButtonStylesList.__proto__ || Object.getPrototypeOf(ButtonStylesList)).apply(this, arguments));
    }

    _createClass(ButtonStylesList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses on the list node to allow keyboard interaction.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method componentWillMount
         */

    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            var blockStyles = [];
            var inlineStyles = [];
            var objectStyles = [];

            this.props.styles.forEach(function (item) {
                var style = new CKEDITOR.style(item.style);

                if (style.type === CKEDITOR.STYLE_BLOCK) {
                    blockStyles.push(item);
                } else if (style.type === CKEDITOR.STYLE_INLINE) {
                    inlineStyles.push(item);
                } else if (style.type === CKEDITOR.STYLE_OBJECT) {
                    objectStyles.push(item);
                }
            });

            this._blockStyles = blockStyles;
            this._inlineStyles = inlineStyles;
            this._objectStyles = objectStyles;
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var removeStylesItem;

            if (this.props.showRemoveStylesItem) {
                removeStylesItem = _react2.default.createElement(_buttonStylesListItemRemove2.default, { editor: this.props.editor, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                _buttonDropdown2.default,
                this.props,
                removeStylesItem,
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.blockStyles, styles: this._blockStyles }),
                this._renderStylesItems(this._blockStyles),
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.inlineStyles, styles: this._inlineStyles }),
                this._renderStylesItems(this._inlineStyles),
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.objectStyles, styles: this._objectStyles }),
                this._renderStylesItems(this._objectStyles)
            );
        }

        /**
         * Renders instances of ButtonStylesListItem with the preview of the correspondent block, inline or object styles.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method _renderStylesItems
         * @param {Array} styles List of styles for which preview should be rendered.
         * @protected
         * @return {Array} Rendered instances of ButtonStylesListItem class
         */

    }, {
        key: '_renderStylesItems',
        value: function _renderStylesItems(styles) {
            var editor = this.props.editor;
            var items;

            if (styles && styles.length) {
                items = styles.map(function (item) {
                    return _react2.default.createElement(
                        'li',
                        { key: item.name, role: 'option' },
                        _react2.default.createElement(_buttonStylesListItem2.default, { activeStyle: this.props.activeStyle, editor: editor, name: item.name, style: item.style })
                    );
                }.bind(this));
            }

            return items;
        }
    }]);

    return ButtonStylesList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @memberof ButtonStylesList
 * @static
 * @property {String} key
 * @default buttonStylesList
 */


ButtonStylesList.key = 'buttonStylesList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStylesList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStylesList.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    },
    showRemoveStylesItem: true
};

exports.default = (0, _widgetFocusManager2.default)(ButtonStylesList);

/***/ }),

/***/ "./src/components/buttons/button-styles.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-styles.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

<<<<<<< HEAD
        widget.parts.image.on('click', function () {
            var selection = editor.getSelection();

            if (selection) {
                var element = selection.getStartElement();

                if (element) {
                    var widgetElement = element.findOne('img');

                    if (widgetElement) {
                        var region = element.getClientRect();

                        var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
                        region.left -= scrollPosition.x;
                        region.top += scrollPosition.y;

                        region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

                        editor.fire('editorInteraction', {
                            nativeEvent: event,
                            selectionData: {
                                element: widgetElement,
                                region: region
                            }
                        });
                    }
                }
            }
        });
    }
=======
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
>>>>>>> Build files (auto-generated)

/**
 * The ButtonStyles class provides functionality for styling a selection with a list of
 * configurable and customizable styles. The allowed styles follow CKEDITOR.Style configuration
 * (http://docs.ckeditor.com/#!/api/CKEDITOR.style)
 *
 * @class ButtonStyles
 */
var ButtonStyles = function (_React$Component) {
    _inherits(ButtonStyles, _React$Component);

    function ButtonStyles() {
        _classCallCheck(this, ButtonStyles);

        return _possibleConstructorReturn(this, (ButtonStyles.__proto__ || Object.getPrototypeOf(ButtonStyles)).apply(this, arguments));
    }

    _createClass(ButtonStyles, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStyles
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var activeStyle = AlloyEditor.Strings.normal;

            var styles = this._getStyles();

            styles.forEach(function (item) {
                if (this._checkActive(item.style)) {
                    activeStyle = item.name;
                }
            }.bind(this));

            var buttonStylesList;

            if (this.props.expanded) {
                buttonStylesList = _react2.default.createElement(_buttonStylesList2.default, { activeStyle: activeStyle, editor: this.props.editor, onDismiss: this.props.toggleDropdown, showRemoveStylesItem: this.props.showRemoveStylesItem, styles: styles });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-dropdown ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.styles + ' ' + activeStyle, className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.styles + ' ' + activeStyle },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            activeStyle
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                buttonStylesList
            );
        }

        /**
         * Checks if the given style definition is applied to the current selection in the editor.
         *
         * @instance
         * @memberof ButtonStyles
         * @method _checkActive
         * @param {Object} styleConfig Style definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
         * @protected
         * @return {Boolean} Returns true if the style is applied to the selection, false otherwise.
         */

    }, {
        key: '_checkActive',
        value: function _checkActive(styleConfig) {
            var nativeEditor = this.props.editor.get('nativeEditor');

            // Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
            // to a 'span' element works for most of those cases with no defined element.
            styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

            var style = new CKEDITOR.style(styleConfig);

            return style.checkActive(nativeEditor.elementPath(), nativeEditor);
        }

        /**
         * Returns an array of styles. Each style consists from two properties:
         * - name - the style name, for example "h1"
         * - style - an object with one property, called `element` which value
         * represents the style which have to be applied to the element.
         *
         * @instance
         * @memberof ButtonStyles
         * @method _getStyles
         * @protected
         * @return {Array<object>} An array of objects containing the styles.
         */

    }, {
        key: '_getStyles',
        value: function _getStyles() {
            return this.props.styles || [{
                name: AlloyEditor.Strings.h1,
                style: {
                    element: 'h1'
                }
            }, {
                name: AlloyEditor.Strings.h2,
                style: {
                    element: 'h2'
                }
            }, {
                name: AlloyEditor.Strings.formatted,
                style: {
                    element: 'pre'
                }
            }, {
                name: AlloyEditor.Strings.cite,
                style: {
                    element: 'cite'
                }
            }, {
                name: AlloyEditor.Strings.code,
                style: {
                    element: 'code'
                }
            }];
        }
    }]);

    return ButtonStyles;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default styles
 * @memberof ButtonStyles
 * @property {String} key
 * @static
 */


ButtonStyles.key = 'styles';

exports.default = ButtonStyles;

/***/ }),

/***/ "./src/components/buttons/button-subscript.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-subscript.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSubscript class provides functionality for applying subscript style to a text selection.
 *
 * @class ButtonSubscript
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSubscript = function (_React$Component) {
    _inherits(ButtonSubscript, _React$Component);

    function ButtonSubscript() {
        _classCallCheck(this, ButtonSubscript);

        return _possibleConstructorReturn(this, (ButtonSubscript.__proto__ || Object.getPrototypeOf(ButtonSubscript)).apply(this, arguments));
    }

    _createClass(ButtonSubscript, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonSubscript
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.subscript, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-subscript', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.subscript },
                _react2.default.createElement('span', { className: 'ae-icon-subscript' })
            );
        }
    }]);

    return ButtonSubscript;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default subscript
 * @memberof ButtonSubscript
 * @property {String} key
 * @static
 */


ButtonSubscript.key = 'subscript';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonSubscript
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonSubscript.defaultProps = {
    command: 'subscript',
    style: 'coreStyles_subscript'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSubscript)));

/***/ }),

/***/ "./src/components/buttons/button-superscript.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-superscript.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSuperscript class provides functionality for applying superscript style to a text selection.
 *
 * @class ButtonSuperscript
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSuperscript = function (_React$Component) {
    _inherits(ButtonSuperscript, _React$Component);

    function ButtonSuperscript() {
        _classCallCheck(this, ButtonSuperscript);

        return _possibleConstructorReturn(this, (ButtonSuperscript.__proto__ || Object.getPrototypeOf(ButtonSuperscript)).apply(this, arguments));
    }

    _createClass(ButtonSuperscript, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonSuperscript
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.superscript, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-superscript', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.superscript },
                _react2.default.createElement('span', { className: 'ae-icon-superscript' })
            );
        }
    }]);

    return ButtonSuperscript;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default superscript
 * @memberof ButtonSuperscript
 * @property {String} key
 * @static
 */


ButtonSuperscript.key = 'superscript';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonSuperscript
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonSuperscript.defaultProps = {
    command: 'superscript',
    style: 'coreStyles_superscript'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSuperscript)));

/***/ }),

/***/ "./src/components/buttons/button-table-cell.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-cell.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableCell class provides functionality to work with table cells.
 *
 * @class ButtonTableCell
 */
var ButtonTableCell = function (_React$Component) {
    _inherits(ButtonTableCell, _React$Component);

    function ButtonTableCell() {
        _classCallCheck(this, ButtonTableCell);

        return _possibleConstructorReturn(this, (ButtonTableCell.__proto__ || Object.getPrototypeOf(ButtonTableCell)).apply(this, arguments));
    }

    _createClass(ButtonTableCell, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableCell
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableCell.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.cell, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.cell },
                    _react2.default.createElement('span', { className: 'ae-icon-cell' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableCell
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'cellInsertBefore',
                label: AlloyEditor.Strings.cellInsertBefore
            }, {
                command: 'cellInsertAfter',
                label: AlloyEditor.Strings.cellInsertAfter
            }, {
                command: 'cellDelete',
                label: AlloyEditor.Strings.cellDelete
            }, {
                command: 'cellMerge',
                label: AlloyEditor.Strings.cellMerge
            }, {
                command: 'cellMergeDown',
                label: AlloyEditor.Strings.cellMergeDown
            }, {
                command: 'cellMergeRight',
                label: AlloyEditor.Strings.cellMergeRight
            }, {
                command: 'cellHorizontalSplit',
                label: AlloyEditor.Strings.cellSplitHorizontal
            }, {
                command: 'cellVerticalSplit',
                label: AlloyEditor.Strings.cellSplitVertical
            }];
        }
    }]);

    return ButtonTableCell;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableCell
 * @memberof ButtonTableCell
 * @property {String} key
 * @static
 */


ButtonTableCell.key = 'tableCell';

exports.default = ButtonTableCell;

/***/ }),

/***/ "./src/components/buttons/button-table-column.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-column.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableColumn class provides functionality to work with table columns.
 *
 * @class ButtonTableColumn
 */
var ButtonTableColumn = function (_React$Component) {
    _inherits(ButtonTableColumn, _React$Component);

    function ButtonTableColumn() {
        _classCallCheck(this, ButtonTableColumn);

        return _possibleConstructorReturn(this, (ButtonTableColumn.__proto__ || Object.getPrototypeOf(ButtonTableColumn)).apply(this, arguments));
    }

    _createClass(ButtonTableColumn, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableColumn
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList, buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableColumn.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.column, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), role: 'listbox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.column },
                    _react2.default.createElement('span', { className: 'ae-icon-column' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableColumn
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'columnInsertBefore',
                label: AlloyEditor.Strings.columnInsertBefore
            }, {
                command: 'columnInsertAfter',
                label: AlloyEditor.Strings.columnInsertAfter
            }, {
                command: 'columnDelete',
                label: AlloyEditor.Strings.columnDelete
            }];
        }
    }]);

    return ButtonTableColumn;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableColumn
 * @memberof ButtonTableColumn
 * @property {String} key
 * @static
 */


ButtonTableColumn.key = 'tableColumn';

exports.default = ButtonTableColumn;

/***/ }),

/***/ "./src/components/buttons/button-table-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonTableEdit class provides functionality for creating and editing a table in a document.
 * Provides UI for creating a table.
 *
 * @class ButtonTableEdit
 */

var ButtonTableEdit = function (_React$Component) {
    _inherits(ButtonTableEdit, _React$Component);

    /**
     * Lifecycle. Invoked once before the component is mounted.
     *
     * @instance
     * @memberof ButtonTableEdit
     * @method getInitialState
     */
    function ButtonTableEdit(props) {
        _classCallCheck(this, ButtonTableEdit);

        var _this = _possibleConstructorReturn(this, (ButtonTableEdit.__proto__ || Object.getPrototypeOf(ButtonTableEdit)).call(this, props));

        _this.rowsRef = _react2.default.createRef();
        _this.colsRef = _react2.default.createRef();
        _this.state = {
            cols: 3,
            rows: 3
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing.
     *
     * @instance
     * @memberof ButtonTableEdit
     * @method componentDidMount
     */


    _createClass(ButtonTableEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.rowsRef.current.focus();
        }

        /**
         * Creates a table.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _createTable
         * @protected
         */

    }, {
        key: '_createTable',
        value: function _createTable() {
            var editor = this.props.editor.get('nativeEditor');
            var tableUtils = new CKEDITOR.Table(editor);

            tableUtils.create({
                attrs: this.props.tableAttributes,
                cols: this.state.cols,
                rows: this.state.rows
            });

            this.props.cancelExclusive();

            editor.fire('actionPerformed', this);
        }

        /**
         * Handles a change in input value. Sets the provided value from the user back to the input.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _handleChange
         * @param {String} inputName The name of the input which value should be updated.
         * @param {SyntheticEvent} event The provided event.
         * @protected
         */

    }, {
        key: '_handleChange',
        value: function _handleChange(inputName, event) {
            var state = {};
            state[inputName] = event.target.value;

            this.setState(state);
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates the table.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
                event.preventDefault();
            }

            if (event.keyCode === KEY_ENTER) {
                this._createTable();
            } else if (event.keyCode === KEY_ESC) {
                this.props.cancelExclusive();
            }
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var time = Date.now();
            var rowsId = time + 'rows';
            var colsId = time + 'cols';

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-table' },
                _react2.default.createElement(
                    'label',
                    { htmlFor: rowsId },
                    AlloyEditor.Strings.rows
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input small' },
                    _react2.default.createElement('input', { className: 'ae-input', id: rowsId, onChange: this._handleChange.bind(this, 'rows'), min: '1', onKeyDown: this._handleKeyDown.bind(this), placeholder: 'Rows', ref: this.rowsRef, type: 'number', value: this.state.rows })
                ),
                _react2.default.createElement(
                    'label',
                    { htmlFor: colsId },
                    AlloyEditor.Strings.columns
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input small' },
                    _react2.default.createElement('input', { className: 'ae-input', id: colsId, onChange: this._handleChange.bind(this, 'cols'), min: '1', onKeyDown: this._handleKeyDown.bind(this), placeholder: 'Colums', ref: this.colsRef, type: 'number', value: this.state.cols })
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': 'Confirm', className: 'ae-button', onClick: this._createTable.bind(this) },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }
    }]);

    return ButtonTableEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableEdit
 * @memberof ButtonTableEdit
 * @property {String} key
 * @static
 */


ButtonTableEdit.key = 'tableEdit';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonTableEdit
 * @method getDefaultProps
 */
ButtonTableEdit.defaultProps = {
    tableAttributes: {
        border: 1,
        cellPadding: 0,
        cellSpacing: 0,
        style: 'width: 100%'
    }
};

exports.default = ButtonTableEdit;

/***/ }),

/***/ "./src/components/buttons/button-table-heading.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-table-heading.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableHeading class provides functionality to work with table heading.
 *
 * @class ButtonTableHeading
 */
var ButtonTableHeading = function (_React$Component) {
    _inherits(ButtonTableHeading, _React$Component);

    function ButtonTableHeading() {
        _classCallCheck(this, ButtonTableHeading);

        return _possibleConstructorReturn(this, (ButtonTableHeading.__proto__ || Object.getPrototypeOf(ButtonTableHeading)).apply(this, arguments));
    }

    _createClass(ButtonTableHeading, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableHeading
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableHeading.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            var activeHeading = new CKEDITOR.Table(this.props.editor.get('nativeEditor')).getHeading();
            var activeHeadingIntro = AlloyEditor.Strings.headers + ':';
            var activeHeadingLabel = AlloyEditor.Strings['headers' + activeHeading];

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-dropdown-xl ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': '', className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: '' },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            activeHeadingIntro,
                            ' ',
                            _react2.default.createElement(
                                'strong',
                                null,
                                activeHeadingLabel
                            )
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableHeading
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'tableHeadingNone',
                label: AlloyEditor.Strings.headersNone
            }, {
                command: 'tableHeadingRow',
                label: AlloyEditor.Strings.headersRow
            }, {
                command: 'tableHeadingColumn',
                label: AlloyEditor.Strings.headersColumn
            }, {
                command: 'tableHeadingBoth',
                label: AlloyEditor.Strings.headersBoth
            }];
        }
    }]);

    return ButtonTableHeading;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRow
 * @memberof ButtonTableHeading
 * @property {String} key
 * @static
 */


ButtonTableHeading.key = 'tableHeading';

exports.default = ButtonTableHeading;

/***/ }),

/***/ "./src/components/buttons/button-table-remove.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-remove.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableRemove class provides functionality for removing a table
 *
 * @class ButtonTableRemove
 */
var ButtonTableRemove = function (_React$Component) {
    _inherits(ButtonTableRemove, _React$Component);

    function ButtonTableRemove() {
        _classCallCheck(this, ButtonTableRemove);

        return _possibleConstructorReturn(this, (ButtonTableRemove.__proto__ || Object.getPrototypeOf(ButtonTableRemove)).apply(this, arguments));
    }

    _createClass(ButtonTableRemove, [{
        key: "render",

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableRemove
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                "button",
                { "aria-label": AlloyEditor.Strings.deleteTable, className: "ae-button", "data-type": "button-table-remove", onClick: this._removeTable.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.deleteTable },
                _react2.default.createElement("span", { className: "ae-icon-bin" })
            );
        }

        /**
         * Removes the table in the editor element.
         *
         * @instance
         * @memberof ButtonTableRemove
         * @method _removeTable
         * @protected
         */

    }, {
        key: "_removeTable",
        value: function _removeTable() {
            var editor = this.props.editor.get('nativeEditor');
            var tableUtils = new CKEDITOR.Table(editor);

            tableUtils.remove();

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonTableRemove;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRemove
 * @memberof ButtonTableRemove
 * @property {String} key
 * @static
 */


ButtonTableRemove.key = 'tableRemove';

exports.default = ButtonTableRemove;

/***/ }),

/***/ "./src/components/buttons/button-table-row.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-table-row.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableRow class provides functionality to work with table rows.
 *
 * @class ButtonTableRow
 */
var ButtonTableRow = function (_React$Component) {
    _inherits(ButtonTableRow, _React$Component);

    function ButtonTableRow() {
        _classCallCheck(this, ButtonTableRow);

        return _possibleConstructorReturn(this, (ButtonTableRow.__proto__ || Object.getPrototypeOf(ButtonTableRow)).apply(this, arguments));
    }

    _createClass(ButtonTableRow, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableRow
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableRow.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.row, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.row },
                    _react2.default.createElement('span', { className: 'ae-icon-row' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableRow
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'rowInsertBefore',
                label: AlloyEditor.Strings.rowInsertBefore
            }, {
                command: 'rowInsertAfter',
                label: AlloyEditor.Strings.rowInsertAfter
            }, {
                command: 'rowDelete',
                label: AlloyEditor.Strings.rowDelete
            }];
        }
    }]);

    return ButtonTableRow;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRow
 * @memberof ButtonTableRow
 * @property {String} key
 * @static
 */


ButtonTableRow.key = 'tableRow';

exports.default = ButtonTableRow;

/***/ }),

/***/ "./src/components/buttons/button-table.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-table.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTable class provides functionality for creating and editing a table in a document. ButtonTable
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonTableEdit UI with all the table edition controls.
 *
 * @class ButtonTable
 */
var ButtonTable = function (_React$Component) {
    _inherits(ButtonTable, _React$Component);

    function ButtonTable() {
        _classCallCheck(this, ButtonTable);

        return _possibleConstructorReturn(this, (ButtonTable.__proto__ || Object.getPrototypeOf(ButtonTable)).apply(this, arguments));
    }

    _createClass(ButtonTable, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTable
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonTableEdit2.default, this.props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.table, className: 'ae-button', 'data-type': 'button-table', onClick: this.props.requestExclusive, tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.table },
                    _react2.default.createElement('span', { className: 'ae-icon-table' })
                );
            }
        }
    }]);

    return ButtonTable;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default table
 * @memberof ButtonTable
 * @property {String} key
 * @static
 */


ButtonTable.key = 'table';

exports.default = ButtonTable;

/***/ }),

/***/ "./src/components/buttons/button-target-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-target-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTargetList class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonTargetList
 * @uses WidgetFocusManager
 */
var ButtonTargetList = function (_React$Component) {
    _inherits(ButtonTargetList, _React$Component);

    function ButtonTargetList() {
        _classCallCheck(this, ButtonTargetList);

        return _possibleConstructorReturn(this, (ButtonTargetList.__proto__ || Object.getPrototypeOf(ButtonTargetList)).apply(this, arguments));
    }

    _createClass(ButtonTargetList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var listTargets = this._renderListTargets();

            return _react2.default.createElement(
                _buttonDropdown2.default,
                this.props,
                listTargets
            );
        }

        /**
         * Returns the the allowed link target items.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method _getAllowedTargetItems
         * @protected
         * @return {Array} The allowed target items.
         */

    }, {
        key: '_getAllowedTargetItems',
        value: function _getAllowedTargetItems() {
            return this.props.allowedLinkTargets || [{
                label: AlloyEditor.Strings.linkTargetDefault,
                value: ''
            }, {
                label: AlloyEditor.Strings.linkTargetSelf,
                value: '_self'
            }, {
                label: AlloyEditor.Strings.linkTargetBlank,
                value: '_blank'
            }, {
                label: AlloyEditor.Strings.linkTargetParent,
                value: '_parent'
            }, {
                label: AlloyEditor.Strings.linkTargetTop,
                value: '_top'
            }];
        }

        /**
         * Renders the allowed link target items.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method _renderListTargets
         * @protected
         * @return {Object} Returns the rendered link items
         */

    }, {
        key: '_renderListTargets',
        value: function _renderListTargets() {
            var targets = this._getAllowedTargetItems();

            var handleLinkTargetChange = this.props.handleLinkTargetChange;

            targets = targets.map(function (target) {
                var className = this.props.selectedTarget === target.value ? 'ae-toolbar-element active' : 'ae-toolbar-element';

                return _react2.default.createElement(
                    'li',
                    { key: target.value, role: 'option' },
                    _react2.default.createElement(
                        'button',
                        { className: className, 'data-value': target.value, onClick: handleLinkTargetChange },
                        target.label
                    )
                );
            }.bind(this));

            return targets;
        }
    }]);

    return ButtonTargetList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkTargetEdit
 * @memberof ButtonTargetList
 * @property {String} key
 * @static
 */


ButtonTargetList.key = 'targetList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonTargetList
 * @method getDefaultProps
 */
ButtonTargetList.defaultProps = {
    circular: true,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonTargetList);

/***/ }),

/***/ "./src/components/buttons/button-twitter.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-twitter.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTwitter class provides functionality for creating a link which
 * allows people to tweet part of the content in the editor.
 *
 * @class ButtonTwitter
 * @uses ButtonStateClasses
 */
var ButtonTwitter = function (_React$Component) {
    _inherits(ButtonTwitter, _React$Component);

    function ButtonTwitter() {
        _classCallCheck(this, ButtonTwitter);

        return _possibleConstructorReturn(this, (ButtonTwitter.__proto__ || Object.getPrototypeOf(ButtonTwitter)).apply(this, arguments));
    }

    _createClass(ButtonTwitter, [{
        key: 'handleClick',

        /**
         * Creates or removes the twitter link on the selection.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method handleClick
         */
        value: function handleClick() {
            var editor = this.props.editor.get('nativeEditor');

            var linkUtils = new CKEDITOR.Link(editor);

            if (this.isActive()) {
                linkUtils.remove(linkUtils.getFromSelection());
            } else {
                linkUtils.create(this._getHref(), {
                    'class': 'ae-twitter-link',
                    'target': '_blank'
                });
            }

            editor.fire('actionPerformed', this);
        }

        /**
         * Checks if the current selection is contained within a link that points to twitter.com/intent/tweet.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method isActive
         * @return {Boolean} True if the selection is inside a twitter link, false otherwise.
         */

    }, {
        key: 'isActive',
        value: function isActive() {
            var link = new CKEDITOR.Link(this.props.editor.get('nativeEditor')).getFromSelection();

            return link && link.getAttribute('href').indexOf('twitter.com/intent/tweet') !== -1;
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.twitter, className: cssClass, 'data-type': 'button-twitter', onClick: this.handleClick.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.twitter },
                _react2.default.createElement('span', { className: 'ae-icon-twitter' })
            );
        }

        /**
         * Generates the appropriate twitter url based on the selected text and the configuration
         * options received via props.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method _getHref
         * @protected
         * @return {String} A valid twitter url with the selected text and given configuration.
         */

    }, {
        key: '_getHref',
        value: function _getHref() {
            var nativeEditor = this.props.editor.get('nativeEditor');
            var selectedText = nativeEditor.getSelection().getSelectedText();
            var url = this.props.url;
            var via = this.props.via;
            var twitterHref = 'https://twitter.com/intent/tweet?text=' + selectedText;

            if (url) {
                twitterHref += '&url=' + url;
            }

            if (via) {
                twitterHref += '&via=' + via;
            }

            return twitterHref;
        }
    }]);

    return ButtonTwitter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default twitter
 * @memberof ButtonTwitter
 * @property {String} key
 * @static
 */


ButtonTwitter.key = 'twitter';

exports.default = (0, _buttonStateClasses2.default)(ButtonTwitter);

/***/ }),

/***/ "./src/components/buttons/button-ul.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ul.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonUnorderedlist class provides functionality for creating unordered lists in an editor.
 *
 * @class ButtonUnorderedlist
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnorderedlist = function (_React$Component) {
    _inherits(ButtonUnorderedlist, _React$Component);

    function ButtonUnorderedlist() {
        _classCallCheck(this, ButtonUnorderedlist);

        return _possibleConstructorReturn(this, (ButtonUnorderedlist.__proto__ || Object.getPrototypeOf(ButtonUnorderedlist)).apply(this, arguments));
    }

    _createClass(ButtonUnorderedlist, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonUnorderedlist
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.bulletedlist, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-ul', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.bulletedlist },
                _react2.default.createElement('span', { className: 'ae-icon-bulleted-list' })
            );
        }
    }]);

    return ButtonUnorderedlist;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default ul
 * @memberof ButtonUnorderedlist
 * @property {String} key
 * @static
 */


ButtonUnorderedlist.key = 'ul';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonUnorderedlist
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonUnorderedlist.defaultProps = {
    command: 'bulletedlist',
    style: {
        element: 'ul'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnorderedlist)));

/***/ }),

/***/ "./src/components/buttons/button-underline.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-underline.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonUnderline class provides functionality for underlying a text selection.
 *
 * @class ButtonUnderline
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnderline = function (_React$Component) {
    _inherits(ButtonUnderline, _React$Component);

    function ButtonUnderline() {
        _classCallCheck(this, ButtonUnderline);

        return _possibleConstructorReturn(this, (ButtonUnderline.__proto__ || Object.getPrototypeOf(ButtonUnderline)).apply(this, arguments));
    }

    _createClass(ButtonUnderline, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonUnderline
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.underline, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-underline', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.underline },
                _react2.default.createElement('span', { className: 'ae-icon-underline' })
            );
        }
    }]);

    return ButtonUnderline;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default underline
 * @memberof ButtonUnderline
 * @property {String} key
 * @static
 */


ButtonUnderline.key = 'underline';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonUnderline
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonUnderline.defaultProps = {
    command: 'underline',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 85 /*U*/
    },
    style: 'coreStyles_underline'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnderline))));

/***/ }),

/***/ "./src/components/buttons/index.js":
/*!*****************************************!*\
  !*** ./src/components/buttons/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ButtonBold$key$Butto;

var _buttonBold = __webpack_require__(/*! ./button-bold.jsx */ "./src/components/buttons/button-bold.jsx");

var _buttonBold2 = _interopRequireDefault(_buttonBold);

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonCamera = __webpack_require__(/*! ./button-camera.jsx */ "./src/components/buttons/button-camera.jsx");

var _buttonCamera2 = _interopRequireDefault(_buttonCamera);

var _buttonCode = __webpack_require__(/*! ./button-code.jsx */ "./src/components/buttons/button-code.jsx");

var _buttonCode2 = _interopRequireDefault(_buttonCode);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonEmbed = __webpack_require__(/*! ./button-embed.jsx */ "./src/components/buttons/button-embed.jsx");

var _buttonEmbed2 = _interopRequireDefault(_buttonEmbed);

var _buttonH = __webpack_require__(/*! ./button-h1.jsx */ "./src/components/buttons/button-h1.jsx");

var _buttonH2 = _interopRequireDefault(_buttonH);

var _buttonH3 = __webpack_require__(/*! ./button-h2.jsx */ "./src/components/buttons/button-h2.jsx");

var _buttonH4 = _interopRequireDefault(_buttonH3);

var _buttonHline = __webpack_require__(/*! ./button-hline.jsx */ "./src/components/buttons/button-hline.jsx");

var _buttonHline2 = _interopRequireDefault(_buttonHline);

var _buttonImageAlignCenter = __webpack_require__(/*! ./button-image-align-center.jsx */ "./src/components/buttons/button-image-align-center.jsx");

var _buttonImageAlignCenter2 = _interopRequireDefault(_buttonImageAlignCenter);

var _buttonImageAlignLeft = __webpack_require__(/*! ./button-image-align-left.jsx */ "./src/components/buttons/button-image-align-left.jsx");

var _buttonImageAlignLeft2 = _interopRequireDefault(_buttonImageAlignLeft);

var _buttonImageAlignRight = __webpack_require__(/*! ./button-image-align-right.jsx */ "./src/components/buttons/button-image-align-right.jsx");

var _buttonImageAlignRight2 = _interopRequireDefault(_buttonImageAlignRight);

var _buttonImage = __webpack_require__(/*! ./button-image.jsx */ "./src/components/buttons/button-image.jsx");

var _buttonImage2 = _interopRequireDefault(_buttonImage);

var _buttonIndentBlock = __webpack_require__(/*! ./button-indent-block.jsx */ "./src/components/buttons/button-indent-block.jsx");

var _buttonIndentBlock2 = _interopRequireDefault(_buttonIndentBlock);

var _buttonItalic = __webpack_require__(/*! ./button-italic.jsx */ "./src/components/buttons/button-italic.jsx");

var _buttonItalic2 = _interopRequireDefault(_buttonItalic);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

var _buttonOl = __webpack_require__(/*! ./button-ol.jsx */ "./src/components/buttons/button-ol.jsx");

var _buttonOl2 = _interopRequireDefault(_buttonOl);

var _buttonOutdentBlock = __webpack_require__(/*! ./button-outdent-block.jsx */ "./src/components/buttons/button-outdent-block.jsx");

var _buttonOutdentBlock2 = _interopRequireDefault(_buttonOutdentBlock);

var _buttonParagraphAlignLeft = __webpack_require__(/*! ./button-paragraph-align-left.jsx */ "./src/components/buttons/button-paragraph-align-left.jsx");

var _buttonParagraphAlignLeft2 = _interopRequireDefault(_buttonParagraphAlignLeft);

var _buttonParagraphAlignRight = __webpack_require__(/*! ./button-paragraph-align-right.jsx */ "./src/components/buttons/button-paragraph-align-right.jsx");

var _buttonParagraphAlignRight2 = _interopRequireDefault(_buttonParagraphAlignRight);

var _buttonParagraphCenter = __webpack_require__(/*! ./button-paragraph-center.jsx */ "./src/components/buttons/button-paragraph-center.jsx");

var _buttonParagraphCenter2 = _interopRequireDefault(_buttonParagraphCenter);

var _buttonParagraphJustify = __webpack_require__(/*! ./button-paragraph-justify.jsx */ "./src/components/buttons/button-paragraph-justify.jsx");

var _buttonParagraphJustify2 = _interopRequireDefault(_buttonParagraphJustify);

var _buttonQuote = __webpack_require__(/*! ./button-quote.jsx */ "./src/components/buttons/button-quote.jsx");

var _buttonQuote2 = _interopRequireDefault(_buttonQuote);

var _buttonRemoveFormat = __webpack_require__(/*! ./button-remove-format.jsx */ "./src/components/buttons/button-remove-format.jsx");

var _buttonRemoveFormat2 = _interopRequireDefault(_buttonRemoveFormat);

var _buttonStrike = __webpack_require__(/*! ./button-strike.jsx */ "./src/components/buttons/button-strike.jsx");

var _buttonStrike2 = _interopRequireDefault(_buttonStrike);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _buttonStyles = __webpack_require__(/*! ./button-styles.jsx */ "./src/components/buttons/button-styles.jsx");

var _buttonStyles2 = _interopRequireDefault(_buttonStyles);

var _buttonSubscript = __webpack_require__(/*! ./button-subscript.jsx */ "./src/components/buttons/button-subscript.jsx");

var _buttonSubscript2 = _interopRequireDefault(_buttonSubscript);

var _buttonSuperscript = __webpack_require__(/*! ./button-superscript.jsx */ "./src/components/buttons/button-superscript.jsx");

var _buttonSuperscript2 = _interopRequireDefault(_buttonSuperscript);

var _buttonTableCell = __webpack_require__(/*! ./button-table-cell.jsx */ "./src/components/buttons/button-table-cell.jsx");

var _buttonTableCell2 = _interopRequireDefault(_buttonTableCell);

var _buttonTableColumn = __webpack_require__(/*! ./button-table-column.jsx */ "./src/components/buttons/button-table-column.jsx");

var _buttonTableColumn2 = _interopRequireDefault(_buttonTableColumn);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _buttonTableHeading = __webpack_require__(/*! ./button-table-heading.jsx */ "./src/components/buttons/button-table-heading.jsx");

var _buttonTableHeading2 = _interopRequireDefault(_buttonTableHeading);

var _buttonTableRemove = __webpack_require__(/*! ./button-table-remove.jsx */ "./src/components/buttons/button-table-remove.jsx");

var _buttonTableRemove2 = _interopRequireDefault(_buttonTableRemove);

var _buttonTableRow = __webpack_require__(/*! ./button-table-row.jsx */ "./src/components/buttons/button-table-row.jsx");

var _buttonTableRow2 = _interopRequireDefault(_buttonTableRow);

var _buttonTable = __webpack_require__(/*! ./button-table.jsx */ "./src/components/buttons/button-table.jsx");

var _buttonTable2 = _interopRequireDefault(_buttonTable);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _buttonTwitter = __webpack_require__(/*! ./button-twitter.jsx */ "./src/components/buttons/button-twitter.jsx");

var _buttonTwitter2 = _interopRequireDefault(_buttonTwitter);

var _buttonUl = __webpack_require__(/*! ./button-ul.jsx */ "./src/components/buttons/button-ul.jsx");

var _buttonUl2 = _interopRequireDefault(_buttonUl);

var _buttonUnderline = __webpack_require__(/*! ./button-underline.jsx */ "./src/components/buttons/button-underline.jsx");

var _buttonUnderline2 = _interopRequireDefault(_buttonUnderline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = (_ButtonBold$key$Butto = {}, _defineProperty(_ButtonBold$key$Butto, _buttonBold2.default.key, _buttonBold2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCameraImage2.default.key, _buttonCameraImage2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCamera2.default.key, _buttonCamera2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCode2.default.key, _buttonCode2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCommandListItem2.default.key, _buttonCommandListItem2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCommandsList2.default.key, _buttonCommandsList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonDropdown2.default.key, _buttonDropdown2.default), _defineProperty(_ButtonBold$key$Butto, _buttonEmbedEdit2.default.key, _buttonEmbedEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonEmbed2.default.key, _buttonEmbed2.default), _defineProperty(_ButtonBold$key$Butto, _buttonH2.default.key, _buttonH2.default), _defineProperty(_ButtonBold$key$Butto, _buttonH4.default.key, _buttonH4.default), _defineProperty(_ButtonBold$key$Butto, _buttonHline2.default.key, _buttonHline2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignCenter2.default.key, _buttonImageAlignCenter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignLeft2.default.key, _buttonImageAlignLeft2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignRight2.default.key, _buttonImageAlignRight2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImage2.default.key, _buttonImage2.default), _defineProperty(_ButtonBold$key$Butto, _buttonIndentBlock2.default.key, _buttonIndentBlock2.default), _defineProperty(_ButtonBold$key$Butto, _buttonItalic2.default.key, _buttonItalic2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkAutocompleteList2.default.key, _buttonLinkAutocompleteList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkEdit2.default.key, _buttonLinkEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkTargetEdit2.default.key, _buttonLinkTargetEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLink2.default.key, _buttonLink2.default), _defineProperty(_ButtonBold$key$Butto, _buttonOl2.default.key, _buttonOl2.default), _defineProperty(_ButtonBold$key$Butto, _buttonOutdentBlock2.default.key, _buttonOutdentBlock2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphAlignLeft2.default.key, _buttonParagraphAlignLeft2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphAlignRight2.default.key, _buttonParagraphAlignRight2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphCenter2.default.key, _buttonParagraphCenter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphJustify2.default.key, _buttonParagraphJustify2.default), _defineProperty(_ButtonBold$key$Butto, _buttonQuote2.default.key, _buttonQuote2.default), _defineProperty(_ButtonBold$key$Butto, _buttonRemoveFormat2.default.key, _buttonRemoveFormat2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStrike2.default.key, _buttonStrike2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListHeader2.default.key, _buttonStylesListHeader2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListItemRemove2.default.key, _buttonStylesListItemRemove2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListItem2.default.key, _buttonStylesListItem2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesList2.default.key, _buttonStylesList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStyles2.default.key, _buttonStyles2.default), _defineProperty(_ButtonBold$key$Butto, _buttonSubscript2.default.key, _buttonSubscript2.default), _defineProperty(_ButtonBold$key$Butto, _buttonSuperscript2.default.key, _buttonSuperscript2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableCell2.default.key, _buttonTableCell2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableColumn2.default.key, _buttonTableColumn2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableEdit2.default.key, _buttonTableEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableHeading2.default.key, _buttonTableHeading2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableRemove2.default.key, _buttonTableRemove2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableRow2.default.key, _buttonTableRow2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTable2.default.key, _buttonTable2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTargetList2.default.key, _buttonTargetList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTwitter2.default.key, _buttonTwitter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonUl2.default.key, _buttonUl2.default), _defineProperty(_ButtonBold$key$Butto, _buttonUnderline2.default.key, _buttonUnderline2.default), _ButtonBold$key$Butto);

/***/ }),

/***/ "./src/components/main.jsx":
/*!*********************************!*\
  !*** ./src/components/main.jsx ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetExclusive = __webpack_require__(/*! ./base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ./base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The main editor UI class manages a hierarchy of widgets (toolbars and buttons).
 *
 * @class UI
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */
var UI = function (_React$Component) {
    _inherits(UI, _React$Component);

    function UI(props) {
        _classCallCheck(this, UI);

        var _this = _possibleConstructorReturn(this, (UI.__proto__ || Object.getPrototypeOf(UI)).call(this, props));

        _this.state = {
            hidden: false
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof UI
     * @method componentDidMount
     */


    _createClass(UI, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var editor = this.props.editor.get('nativeEditor');

            editor.on('editorInteraction', this._onEditorInteraction, this);
            editor.on('actionPerformed', this._onActionPerformed, this);
            editor.on('key', this._onEditorKey, this);

            // Set up events for hiding the UI when user stops interacting with the editor.
            // This may happen when he just clicks outside of the editor. However,
            // this does not include a situation when he clicks on some button, part of
            // editor's UI.

            // It is not easy to debounce _setUIHidden on mousedown, because if we
            // debounce it, when the handler is being invoked, the target might be no more part
            // of the editor's UI - onActionPerformed causes re-render.
            this._mousedownListener = function (event) {
                this._setUIHidden(event.target);
            }.bind(this);

            this._keyDownListener = CKEDITOR.tools.debounce(function (event) {
                this._setUIHidden(document.activeElement);
            }, this.props.eventsDelay, this);

            document.addEventListener('mousedown', this._mousedownListener);
            document.addEventListener('keydown', this._keyDownListener);
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * Fires `ariaUpdate` event passing ARIA related messages.
         * Fires `editorUpdate` event passing the previous and current properties and state.
         *
         * @instance
         * @memberof UI
         * @method componentDidUpdate
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            var domNode = _reactDom2.default.findDOMNode(this);

            var editor = this.props.editor.get('nativeEditor');

            if (domNode) {
                editor.fire('ariaUpdate', {
                    message: this._getAvailableToolbarsMessage(domNode)
                });
            }

            editor.fire('editorUpdate', {
                prevProps: prevProps,
                prevState: prevState,
                props: this.props,
                state: this.state
            });
        }
    }, {
        key: '_getAriaUpdateTemplate',
        value: function _getAriaUpdateTemplate(ariaUpdate) {
            if (!this._ariaUpdateTemplates) {
                this._ariaUpdateTemplates = {};
            }

            if (!this._ariaUpdateTemplates[ariaUpdate]) {
                this._ariaUpdateTemplates[ariaUpdate] = new CKEDITOR.template(this._getAriaUpdates()[ariaUpdate]);
            }

            return this._ariaUpdateTemplates[ariaUpdate];
        }

        /**
         * Returns the templates for ARIA messages.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _getAriaUpdates
         * @return {Object} ARIA relates messages. Default:
         * {
         *      noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
         *      oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
         *      manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
         *  }
         */

    }, {
        key: '_getAriaUpdates',
        value: function _getAriaUpdates() {
            return this.props.ariaUpdates || {
                noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
                oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
                manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
            };
        }

        /**
         * Returns an ARIA message which represents the number of currently available toolbars.
         *
         * @instance
         * @memberof UI
         * @method _getAvailableToolbarsMessage
         * @protected
         * @param {CKEDITOR.dom.element} domNode The DOM node from which the available toolbars will be retrieved.
         * @return {String} The ARIA message for the number of available toolbars
         */

    }, {
        key: '_getAvailableToolbarsMessage',
        value: function _getAvailableToolbarsMessage(domNode) {
            var toolbarsNodeList = domNode.querySelectorAll('[role="toolbar"]');

            if (!toolbarsNodeList.length) {
                return this._getAriaUpdates().noToolbar;
            } else {
                var toolbarNames = Array.prototype.slice.call(toolbarsNodeList).map(function (toolbar) {
                    return toolbar.getAttribute('aria-label');
                });

                var ariaUpdate = toolbarNames.length === 1 ? 'oneToolbar' : 'manyToolbars';

                return this._getAriaUpdateTemplate(ariaUpdate).output({
                    toolbars: toolbarNames.join(',').replace(/,([^,]*)$/, ' and ' + '$1')
                });
            }
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof UI
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this._mousedownListener) {
                document.removeEventListener('mousedown', this._mousedownListener);
            }

            if (this._keyDownListener) {
                this._keyDownListener.detach();
                document.removeEventListener('keydown', this._keyDownListener);
            }
        }

        /**
         * Lifecycle. Renders the UI of the editor. This may include several toolbars and buttons.
         * The editor's UI also takes care of rendering the items in exclusive mode.
         *
         * @instance
         * @memberof UI
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            if (this.state.hidden) {
                return null;
            }

            var toolbars = Object.keys(this.props.toolbars).map(function (toolbar) {
                return AlloyEditor.Toolbars[toolbar] || window[toolbar];
            });

            toolbars = this.filterExclusive(toolbars).map(function (toolbar) {
                var props = this.mergeExclusiveProps({
                    config: this.props.toolbars[toolbar.key],
                    editor: this.props.editor,
                    editorEvent: this.state.editorEvent,
                    key: toolbar.key,
                    onDismiss: this._onDismissToolbarFocus,
                    selectionData: this.state.selectionData
                }, toolbar.key);

                return _react2.default.createElement(toolbar, props);
            }.bind(this));

            return _react2.default.createElement(
                'div',
                { className: 'ae-toolbars', onKeyDown: this.handleKey.bind(this) },
                toolbars
            );
        }

        /**
         * Listener to the editor's `actionPerformed` event. Sets state and redraws the UI of the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onActionPerformed
         * @param {SynteticEvent} event The provided event
         */

    }, {
        key: '_onActionPerformed',
        value: function _onActionPerformed(event) {
            var editor = this.props.editor.get('nativeEditor');

            editor.focus();

            this.setState({
                itemExclusive: null,
                selectionData: editor.getSelectionData()
            });
        }

        /**
         * Executed when a dismiss key is pressed over a toolbar to return the focus to the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onDismissToolbarFocus
         */

    }, {
        key: '_onDismissToolbarFocus',
        value: function _onDismissToolbarFocus() {
            var editor = this.props.editor.get('nativeEditor');

            editor.focus();
        }

        /**
         * Listener to the editor's `userInteraction` event. Retrieves the data about the user selection and
         * provides it via component's state property.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onEditorInteraction
         * @param {SynteticEvent} event The provided event
         */

    }, {
        key: '_onEditorInteraction',
        value: function _onEditorInteraction(event) {
            this.setState({
                editorEvent: event,
                hidden: false,
                itemExclusive: null,
                selectionData: event.data.selectionData
            });
        }

        /**
         * Focuses on the active toolbar when the combination ALT+F10 is pressed inside the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onEditorKey
         */

    }, {
        key: '_onEditorKey',
        value: function _onEditorKey(event) {
            var nativeEvent = event.data.domEvent.$;

            if (nativeEvent.altKey && nativeEvent.keyCode === 121) {
                this.focus();
            }
        }

        /**
         * Checks if the target with which the user interacted is part of editor's UI or it is
         * the editable area. If none of these, sets the state of editor's UI to be hidden.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _setUIHidden
         * @param {DOMElement} target The DOM element with which user interacted lastly.
         */

    }, {
        key: '_setUIHidden',
        value: function _setUIHidden(target) {
            var domNode = _reactDom2.default.findDOMNode(this);

            if (domNode) {
                var editable = this.props.editor.get('nativeEditor').editable();
                var targetNode = new CKEDITOR.dom.node(target);

                if (!editable) {
                    this.setState({
                        hidden: true
                    });
                } else {
                    var res = editable.$ === target || editable.contains(targetNode) || new CKEDITOR.dom.element(domNode).contains(targetNode);

                    if (!res) {
                        this.setState({
                            hidden: true
                        });
                    }
                }
            }
        }
    }]);

    return UI;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof UI
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


UI.defaultProps = {
    circular: true,
    descendants: '[class^=ae-toolbar-]',
    eventsDelay: 0,
    keys: {
        next: 9
    }
};

/**
 * Fired when component updates and when it is rendered in the DOM.
 * The payload consists from a `message` property containing the ARIA message.
 *
 * @event ariaUpdate
 */

/**
 * Fired when component updates. The payload consists from an object with the following
 * properties:
 * - prevProps - The previous properties of the component
 * - prevState - The previous state of the component
 * - props - The current properties of the component
 * - state - The current state of the component
 *
 * @event ariaUpdate
 */

exports.default = (0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)(UI));

/***/ }),

/***/ "./src/components/toolbars/index.js":
/*!******************************************!*\
  !*** ./src/components/toolbars/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ToolbarAdd$key$Toolb;

var _toolbarAdd = __webpack_require__(/*! ./toolbar-add.jsx */ "./src/components/toolbars/toolbar-add.jsx");

var _toolbarAdd2 = _interopRequireDefault(_toolbarAdd);

var _toolbarStyles = __webpack_require__(/*! ./toolbar-styles.jsx */ "./src/components/toolbars/toolbar-styles.jsx");

var _toolbarStyles2 = _interopRequireDefault(_toolbarStyles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = (_ToolbarAdd$key$Toolb = {}, _defineProperty(_ToolbarAdd$key$Toolb, _toolbarAdd2.default.key, _toolbarAdd2.default), _defineProperty(_ToolbarAdd$key$Toolb, _toolbarStyles2.default.key, _toolbarStyles2.default), _ToolbarAdd$key$Toolb);

/***/ }),

/***/ "./src/components/toolbars/toolbar-add.jsx":
/*!*************************************************!*\
  !*** ./src/components/toolbars/toolbar-add.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons.js */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetArrowBox = __webpack_require__(/*! ../base/widget-arrow-box.js */ "./src/components/base/widget-arrow-box.js");

var _widgetArrowBox2 = _interopRequireDefault(_widgetArrowBox);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _widgetPosition = __webpack_require__(/*! ../base/widget-position.js */ "./src/components/base/widget-position.js");

var _widgetPosition2 = _interopRequireDefault(_widgetPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var POSITION_LEFT = 1;
var POSITION_RIGHT = 2;

/**
 * The ToolbarAdd class provides functionality for adding content to the editor.
 *
 * @class ToolbarAdd
 * @uses ToolbarButtons
 * @uses WidgetArrowBox
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 * @uses WidgetPosition
 */

var ToolbarAdd = function (_React$Component) {
    _inherits(ToolbarAdd, _React$Component);

    function ToolbarAdd(props) {
        _classCallCheck(this, ToolbarAdd);

        var _this = _possibleConstructorReturn(this, (ToolbarAdd.__proto__ || Object.getPrototypeOf(ToolbarAdd)).call(this, props));

        _this.state = {};
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof ToolbarAdd
     * @method componentDidMount
     */


    _createClass(ToolbarAdd, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this._updatePosition();
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method componentDidUpdate
         * @param {Object} prevProps The previous state of the component's properties.
         * @param {Object} prevState Component's previous state.
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this._updatePosition();

            // In case of exclusive rendering, focus the first descendant (button)
            // so the user will be able to start interacting with the buttons immediately.
            if (this.props.renderExclusive) {
                this.focus();
            }
        }

        /**
         * Lifecycle. Renders the buttons for adding content or hides the toolbar
         * if user interacted with a non-editable element.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method render
         * @return {Object|null} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            // Some operations such as `requestExclusive` may force editor to blur which will
            // invalidate the `props.editorEvent` stored value, without causing a `props` change.
            // For example, if the editor is empty, `ae_placeholder` plugin will remove
            // the target from the DOM and will prevent `add` toolbar from rendering.
            //
            // It should be safe to assume that if you have been able to render the toolbar
            // and request the exclusive mode, then rendering might be kept until the exclusive mode is left.
            if (!this.state.itemExclusive && this.props.editorEvent && this.props.editorEvent.data.nativeEvent.target && !this.props.editorEvent.data.nativeEvent.target.isContentEditable) {
                return null;
            }

            var buttons = this._getButtons();
            var className = this._getToolbarClassName();

            return _react2.default.createElement(
                'div',
                { 'aria-label': AlloyEditor.Strings.add, className: className, 'data-tabindex': this.props.config.tabIndex || 0, onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), role: 'toolbar', tabIndex: '-1' },
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container' },
                    buttons
                )
            );
        }

        /**
         * Returns a list of buttons that will eventually render to HTML.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _getButtons
         * @protected
         * @return {Object} The buttons which have to be rendered.
         */

    }, {
        key: '_getButtons',
        value: function _getButtons() {
            var buttons;

            if (this.props.renderExclusive) {
                buttons = this.getToolbarButtons(this.props.config.buttons);
            } else {
                if (this.props.selectionData && this.props.selectionData.region) {
                    buttons = _react2.default.createElement(
                        'button',
                        { 'aria-label': AlloyEditor.Strings.add, className: 'ae-button ae-button-add', onClick: this.props.requestExclusive.bind(this, ToolbarAdd.key), title: AlloyEditor.Strings.add },
                        _react2.default.createElement('span', { className: 'ae-icon-add' })
                    );
                }
            }

            return buttons;
        }

        /**
         * Returns the class name of the toolbar in case of both exclusive and normal mode.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _getToolbarClassName
         * @protected
         * @return {String} The class name which have to be applied to the DOM element.
         */

    }, {
        key: '_getToolbarClassName',
        value: function _getToolbarClassName() {
            var cssClass = 'ae-toolbar-add';

            if (this.props.renderExclusive) {
                cssClass = 'ae-toolbar ' + this.getArrowBoxClasses();
            }

            return cssClass;
        }

        /**
         * Calculates and sets the position of the toolbar in exclusive or normal mode.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _updatePosition
         * @protected
         */

    }, {
        key: '_updatePosition',
        value: function _updatePosition() {
            var region;

            // If component is not mounted, there is nothing to do
            if (!_reactDom2.default.findDOMNode(this)) {
                return;
            }

            if (this.props.renderExclusive) {
                this.updatePosition();
                this.show();
            } else {
                if (this.props.selectionData) {
                    region = this.props.selectionData.region;
                }

                if (region) {
                    var domNode = _reactDom2.default.findDOMNode(this);

                    var domElement = new CKEDITOR.dom.element(domNode);

                    var startRect = region.startRect || region;

                    var nativeEditor = this.props.editor.get('nativeEditor');

                    var clientRect = nativeEditor.editable().getClientRect();

                    var offsetLeft;

                    var position = this.props.config.position || this.props.position;

                    if (position === POSITION_LEFT) {
                        offsetLeft = clientRect.left - domNode.offsetWidth - this.props.gutterExclusive.left + 'px';
                    } else {
                        offsetLeft = clientRect.right + this.props.gutterExclusive.left + 'px';
                    }

                    domNode.style.left = offsetLeft;

                    domNode.style.top = Math.floor((region.bottom + region.top) / 2) + 'px';

                    if (nativeEditor.element.getStyle('overflow') !== 'auto') {
                        domNode.style.top = Math.floor(region.top - domNode.offsetHeight / 2 + startRect.height / 2) + 'px';
                    } else {
                        domNode.style.top = Math.floor(nativeEditor.element.$.offsetTop + startRect.height / 2 - domNode.offsetHeight / 2) + 'px';
                    }

                    domNode.style.opacity = 1;

                    domElement.removeClass('ae-arrow-box');

                    this.cancelAnimation();
                }
            }
        }
    }]);

    return ToolbarAdd;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default add
 * @memberof ToolbarAdd
 * @property {String} key
 * @static
 */


ToolbarAdd.key = 'add';

/**
 * Defines the constant for positioning the Toolbar on left of the editable area.
 *
 * @default 1
 * @memberof ToolbarAdd
 * @property {String} left
 * @static
 */
ToolbarAdd.left = POSITION_LEFT;

/**
 * Defines the constant for positioning the Toolbar on right of the editable area.
 *
 * @default 2
 * @memberof ToolbarAdd
 * @property {String} right
 * @static
 */
ToolbarAdd.right = POSITION_RIGHT;

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarAdd
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ToolbarAdd.defaultProps = {
    circular: true,
    descendants: '.ae-button',
    gutterExclusive: {
        left: 10,
        top: 0
    },
    keys: {
        dismiss: [27],
        next: [39, 40],
        prev: [37, 38]
    },
    position: POSITION_LEFT
};

exports.default = (0, _widgetArrowBox2.default)((0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _widgetPosition2.default)((0, _toolbarButtons2.default)(ToolbarAdd))))));

/***/ }),

/***/ "./src/components/toolbars/toolbar-styles.jsx":
/*!****************************************************!*\
  !*** ./src/components/toolbars/toolbar-styles.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons.js */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetArrowBox = __webpack_require__(/*! ../base/widget-arrow-box.js */ "./src/components/base/widget-arrow-box.js");

var _widgetArrowBox2 = _interopRequireDefault(_widgetArrowBox);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _widgetPosition = __webpack_require__(/*! ../base/widget-position.js */ "./src/components/base/widget-position.js");

var _widgetPosition2 = _interopRequireDefault(_widgetPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ToolbarStyles class hosts the buttons for styling a text selection.
 *
 * @class ToolbarStyles
 * @uses ToolbarButtons
 * @uses WidgetArrowBox
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 * @uses WidgetPosition
 */
var ToolbarStyles = function (_React$Component) {
    _inherits(ToolbarStyles, _React$Component);

    function ToolbarStyles(props) {
        _classCallCheck(this, ToolbarStyles);

        var _this = _possibleConstructorReturn(this, (ToolbarStyles.__proto__ || Object.getPrototypeOf(ToolbarStyles)).call(this, props));

        _this.state = {};
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof ToolbarStyles
     * @method componentDidMount
     */


    _createClass(ToolbarStyles, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this._updatePosition();
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method componentDidUpdate
         * @param {Object} prevProps The previous state of the component's properties.
         * @param {Object} prevState Component's previous state.
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this._updatePosition();
        }

        /**
         * Lifecycle. Renders the buttons for adding content or hides the toolbar
         * if user interacted with a non-editable element.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method render
         * @return {Object|null} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var currentSelection = this._getCurrentSelection();

            if (currentSelection) {
                var getArrowBoxClassesFn = this._getSelectionFunction(currentSelection.getArrowBoxClasses);
                var arrowBoxClasses;

                if (getArrowBoxClassesFn) {
                    arrowBoxClasses = getArrowBoxClassesFn();
                } else {
                    arrowBoxClasses = this.getArrowBoxClasses();
                }

                var cssClasses = 'ae-toolbar-styles ' + arrowBoxClasses;

                var buttons = this.getToolbarButtons(currentSelection.buttons, {
                    manualSelection: this.props.editorEvent ? this.props.editorEvent.data.manualSelection : null,
                    selectionType: currentSelection.name
                });

                return _react2.default.createElement(
                    'div',
                    { 'aria-label': AlloyEditor.Strings.styles, className: cssClasses, 'data-tabindex': this.props.config.tabIndex || 0, onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), role: 'toolbar', tabIndex: '-1' },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        buttons
                    )
                );
            }

            return null;
        }

        /**
         * Retrieve a function from String. It converts a fully qualified string into the mapped function.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _getSelectionFunction
         * @param {Function|String} selectionFn A function, or a fully qualified string pointing to the desired one (e.g. 'AlloyEditor.SelectionTest.image').
         * @protected
         * @return {Function} The mapped function.
         */

    }, {
        key: '_getSelectionFunction',
        value: function _getSelectionFunction(selectionFn) {
            var selectionFunction;

            if (_lang2.default.isFunction(selectionFn)) {
                selectionFunction = selectionFn;
            } else if (_lang2.default.isString(selectionFn)) {
                var parts = selectionFn.split('.');
                var currentMember = window;
                var property = parts.shift();

                while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
                    currentMember = currentMember[property];
                    property = parts.shift();
                }

                if (_lang2.default.isFunction(currentMember)) {
                    selectionFunction = currentMember;
                }
            }

            return selectionFunction;
        }

        /**
         * Analyzes the current editor selection and returns the selection configuration that matches.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _getCurrentSelection
         * @protected
         * @return {Object} The matched selection configuration.
         */

    }, {
        key: '_getCurrentSelection',
        value: function _getCurrentSelection() {
            var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;
            var selection;

            if (eventPayload) {
                this.props.config.selections.some(function (item) {
                    var testFn = this._getSelectionFunction(item.test);
                    var result;

                    if (testFn) {
                        result = eventPayload.manualSelection === item.name || testFn({
                            data: eventPayload,
                            editor: this.props.editor
                        });
                    }

                    if (result) {
                        selection = item;
                    }

                    return result;
                }, this);
            }

            return selection;
        }

        /**
         * Calculates and sets the position of the toolbar.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _updatePosition
         * @protected
         */

    }, {
        key: '_updatePosition',
        value: function _updatePosition() {
            // If component is not mounted, there is nothing to do
            if (!_reactDom2.default.findDOMNode(this)) {
                return;
            }

            var currentSelection = this._getCurrentSelection();
            var result;

            // If current selection has a function called `setPosition`, call it
            // and check the returned value. If false, fallback to the default positioning logic.
            if (currentSelection) {
                var setPositionFn = this._getSelectionFunction(currentSelection.setPosition);

                if (setPositionFn) {
                    result = setPositionFn.call(this, {
                        editor: this.props.editor,
                        editorEvent: this.props.editorEvent,
                        selectionData: this.props.selectionData
                    });
                }
            }

            if (!result) {
                this.updatePosition();
                this.show();
            }
        }
    }]);

    return ToolbarStyles;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarStyles
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


ToolbarStyles.defaultProps = {
    circular: true,
    descendants: '.ae-input, .ae-button:not([disabled]), .ae-toolbar-element',
    keys: {
        dismiss: [27],
        next: [39, 40],
        prev: [37, 38]
    }
};

/**
* The name which will be used as an alias of the button in the configuration.
*
* @default styles
* @memberof ToolbarStyles
* @property {String} key
* @static
*/
ToolbarStyles.key = 'styles';

exports.default = (0, _widgetArrowBox2.default)((0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _widgetPosition2.default)((0, _toolbarButtons2.default)(ToolbarStyles))))));

/***/ }),

/***/ "./src/components/uibridge/uibridge.js":
/*!*********************************************!*\
  !*** ./src/components/uibridge/uibridge.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_uibridge')) {
        return;
    }

    /**
     * CKEditor plugin that extends CKEDITOR.ui.add function so an add handler can be specified
     * on top of the original ones. It bridges the calls to add components via:
     * - editor.ui.add(name, type, definition)
     *
     * @class CKEDITOR.plugins.ae_uibridge
     * @constructor
     */
    CKEDITOR.plugins.add('ae_uibridge', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         *
         * @method beforeInit
         * @param {Object} editor The current editor instance
         */
        beforeInit: function beforeInit(editor) {
            var originalUIAddFn = editor.ui.add;

            editor.ui.add = function (name, type, definition) {
                originalUIAddFn.apply(this, arguments);

                var typeHandler = this._.handlers[type];

                if (typeHandler && typeHandler.add) {
                    typeHandler.add(name, definition, editor);
                    AlloyEditor.registerBridgeButton(name, editor.__processingPlugin__.plugin.name);
                }
            };
        }
    });
})();

/***/ }),

/***/ "./src/core/debounce.js":
/*!******************************!*\
  !*** ./src/core/debounce.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /**
     * Debounce util function. If a function execution is expensive, it might be debounced. This means
     * that it will be executed after some amount of time after its last call. For example, if we attach a
     * a function on scroll event, it might be called hundreds times per second. In this case it may be
     * debounced with, let's say 100ms. The real execution of this function will happen 100ms after last
     * scroll event.
     *
     * @memberof CKEDITOR.tools
     * @method debounce
     * @param {Array} args An array of arguments which the callback will receive.
     * @param {Function} callback The callback which has to be called after given timeout.
     * @param {Number} timeout Timeout in milliseconds after which the callback will be called.
     * @param {Object} context The context in which the callback will be called. This argument is optional.
     * @static
     */

    CKEDITOR.tools.debounce = CKEDITOR.tools.debounce || function (callback, timeout, context, args) {
        var debounceHandle;

        var callFn = function callFn() {
            var callContext = context || this;

            clearTimeout(debounceHandle);

            var result = [];

            for (var len = arguments.length, startIndex = 0; startIndex < len; ++startIndex) {
                result.push(arguments[startIndex]);
            }

            var callArgs = result.concat(args || []);

            debounceHandle = setTimeout(function () {
                callback.apply(callContext, callArgs);
            }, timeout);
        };

        callFn.detach = function () {
            clearTimeout(debounceHandle);
        };

        return callFn;
    };
})();

/***/ }),

/***/ "./src/core/index.js":
/*!***************************!*\
  !*** ./src/core/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uicore = exports.tools = exports.table = exports.selectionRegion = exports.plugins = exports.link = exports.debounce = undefined;

var _debounce = __webpack_require__(/*! ./debounce */ "./src/core/debounce.js");

var _debounce2 = _interopRequireDefault(_debounce);

var _link = __webpack_require__(/*! ./link */ "./src/core/link.js");

var _link2 = _interopRequireDefault(_link);

var _plugins = __webpack_require__(/*! ./plugins */ "./src/core/plugins.js");

var _plugins2 = _interopRequireDefault(_plugins);

var _selectionRegion = __webpack_require__(/*! ./selection-region */ "./src/core/selection-region.js");

var _selectionRegion2 = _interopRequireDefault(_selectionRegion);

var _table = __webpack_require__(/*! ./table */ "./src/core/table.js");

var _table2 = _interopRequireDefault(_table);

var _tools = __webpack_require__(/*! ./tools */ "./src/core/tools.js");

var _tools2 = _interopRequireDefault(_tools);

var _uicore = __webpack_require__(/*! ./uicore */ "./src/core/uicore.js");

var _uicore2 = _interopRequireDefault(_uicore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.debounce = _debounce2.default;
exports.link = _link2.default;
exports.plugins = _plugins2.default;
exports.selectionRegion = _selectionRegion2.default;
exports.table = _table2.default;
exports.tools = _tools2.default;
exports.uicore = _uicore2.default;

/***/ }),

/***/ "./src/core/link.js":
/*!**************************!*\
  !*** ./src/core/link.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {
    'use strict';

    var REGEX_BOOKMARK_SCHEME = /^#.*/i;
    var REGEX_EMAIL_SCHEME = /^[a-z0-9\u0430-\u044F\._-]+@/i;
    var REGEX_URI_SCHEME = /^(?:[a-z][a-z0-9+\-.]*)\:|^\//i;

    /**
     * Link class utility. Provides methods for create, delete and update links.
     *
     * @class CKEDITOR.Link
     * @constructor
     * @param {Object} editor The CKEditor instance.
     */
    function Link(editor, config) {
        this._editor = editor;
        this.appendProtocol = config && config.appendProtocol === false ? false : true;
    }

    Link.prototype = {
        constructor: Link,

        /**
         * Advances the editor selection to the next available position after a
         * given link or the one in the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method advanceSelection
         * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
         */
        advanceSelection: function advanceSelection(link) {
            link = link || this.getFromSelection();

            var range = this._editor.getSelection().getRanges()[0];

            if (link) {
                range.moveToElementEditEnd(link);

                var nextNode = range.getNextEditableNode();

                if (nextNode && !this._editor.element.equals(nextNode.getCommonAncestor(link))) {
                    var whitespace = /\s/.exec(nextNode.getText());

                    var offset = whitespace ? whitespace.index + 1 : 0;

                    range.setStart(nextNode, offset);
                    range.setEnd(nextNode, offset);
                }
            }

            this._editor.getSelection().selectRanges([range]);
        },

        /**
         * Create a link with given URI as href.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method create
         * @param {Object} attrs A config object with link attributes. These might be arbitrary DOM attributes.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         * @param {String} URI The URI of the link.
         */
        create: function create(URI, attrs, modifySelection) {
            var selection = this._editor.getSelection();

            var range = selection.getRanges()[0];

            if (range.collapsed) {
                var text = new CKEDITOR.dom.text(URI, this._editor.document);
                range.insertNode(text);
                range.selectNodeContents(text);
            }

            URI = this._getCompleteURI(URI);

            var linkAttrs = CKEDITOR.tools.merge({
                'data-cke-saved-href': URI,
                href: URI
            }, attrs);

            var style = new CKEDITOR.style({
                attributes: linkAttrs,
                element: 'a'
            });

            style.type = CKEDITOR.STYLE_INLINE;
            style.applyToRange(range, this._editor);

            if (modifySelection && modifySelection.advance) {
                this.advanceSelection();
            } else {
                range.select();
            }
        },

        /**
         * Retrieves a link from the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method getFromSelection
         * @return {CKEDITOR.dom.element} The retrieved link or null if not found.
         */
        getFromSelection: function getFromSelection() {
            var selection = this._editor.getSelection();

            var selectedElement = selection.getSelectedElement();

            if (selectedElement && selectedElement.is('a')) {
                return selectedElement;
            }

            var range = selection.getRanges()[0];

            if (range) {
                range.shrink(CKEDITOR.SHRINK_TEXT);

                return this._editor.elementPath(range.getCommonAncestor()).contains('a', 1);
            }

            return null;
        },

        /**
         * Removes a link from the editor.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method remove
         * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         */
        remove: function remove(link, modifySelection) {
            var editor = this._editor;

            if (link) {
                if (modifySelection && modifySelection.advance) {
                    this.advanceSelection();
                }

                link.remove(editor);
            } else {
                var style = new CKEDITOR.style({
                    alwaysRemoveElement: 1,
                    element: 'a',
                    type: CKEDITOR.STYLE_INLINE
                });

                // 'removeStyle()' removes the style from the editor's current selection.
                //  We need to force the selection to be the whole link element
                //  to remove it properly.

                var selection = editor.getSelection();
                selection.selectElement(selection.getStartElement());

                editor.removeStyle(style);
            }
        },

        /**
         * Updates the href of an already existing link.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method update
         * @param {CKEDITOR.dom.element} link The link element which href should be removed.
         * @param {Object|String} attrs The attributes to update or remove. Attributes with null values will be removed.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         */
        update: function update(attrs, link, modifySelection) {
            var instance = this;

            link = link || this.getFromSelection();

            if (typeof attrs === 'string') {
                var uri = instance._getCompleteURI(attrs);

                link.setAttributes({
                    'data-cke-saved-href': uri,
                    href: uri
                });
            } else if ((typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) === 'object') {
                var removeAttrs = [];

                var setAttrs = {};

                Object.keys(attrs).forEach(function (key) {
                    if (attrs[key] === null) {
                        if (key === 'href') {
                            removeAttrs.push('data-cke-saved-href');
                        }

                        removeAttrs.push(key);
                    } else {
                        if (key === 'href') {
                            var uri = instance._getCompleteURI(attrs[key]);

                            setAttrs['data-cke-saved-href'] = uri;
                            setAttrs[key] = uri;
                        } else {
                            setAttrs[key] = attrs[key];
                        }
                    }
                });

                link.removeAttributes(removeAttrs);
                link.setAttributes(setAttrs);
            }

            if (modifySelection && modifySelection.advance) {
                this.advanceSelection(link);
            }
        },

        /**
         * Checks if the URI begins with a '#' symbol to determine if it's an on page bookmark.
         * If it doesn't, it then checks if the URI has an '@' symbol. If it does and the URI
         * looks like an email and doesn't have 'mailto:', 'mailto:' is added to the URI.
         * If it doesn't and the URI doesn't have a scheme, the default 'http' scheme with
         * hierarchical path '//' is added to the URI.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method _getCompleteURI
         * @param {String} URI The URI of the link.
         * @protected
         * @return {String} The URI updated with the protocol.
         */
        _getCompleteURI: function _getCompleteURI(URI) {
            if (REGEX_BOOKMARK_SCHEME.test(URI)) {
                return URI;
            } else if (REGEX_EMAIL_SCHEME.test(URI)) {
                URI = 'mailto:' + URI;
            } else if (!REGEX_URI_SCHEME.test(URI)) {
                URI = this.appendProtocol ? 'http://' + URI : URI;
            }

            return URI;
        }
    };

    CKEDITOR.Link = CKEDITOR.Link || Link;
})();

/***/ }),

/***/ "./src/core/plugins.js":
/*!*****************************!*\
  !*** ./src/core/plugins.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    // Wraps each of the plugin lifecycle methods in a closure that will
    // set up the editor.__processingPlugin__ variable so it can be globally
    // accessed exposing the plugin being processed and the lifecycle phase
    // in which it is happening
    //
    // @param {Object} plugin The plugin to wrap lifecycle methods

    var wrapPluginLifecycle = function wrapPluginLifecycle(plugin) {
        var methods = ['beforeInit', 'init', 'afterInit'];

        methods.forEach(function (methodName) {
            if (plugin[methodName]) {
                plugin[methodName] = CKEDITOR.tools.override(plugin[methodName], function (originalPluginMethod) {
                    var payload = {
                        phase: methodName,
                        plugin: plugin
                    };

                    return function (editor) {
                        editor.__processingPlugin__ = payload;

                        originalPluginMethod.call(this, editor);

                        editor.__processingPlugin__ = null;
                    };
                });
            }
        });
    };

    // Filters the requires object to remove unwanted dependencies. At this point
    // only 'toolbar' has been identified, but more can appear. An unwanted plugin
    // dependency is one that prevents a necessary plugin from being removed
    //
    // @param {string|Array<string>} requires The requires object
    // @return {string} The filtered requires object
    var filterUnwantedDependencies = function filterUnwantedDependencies(requires) {
        if (typeof requires === 'string') {
            requires = requires.split(',');
        }

        return requires.filter(function (require) {
            return require !== 'toolbar';
        });
    };

    /**
     * CKEDITOR.plugins class utility which adds additional methods to those of CKEditor.
     *
     * @class CKEDITOR.plugins
     */

    /**
     * Overrides CKEDITOR.plugins.load method so we can extend the lifecycle methods of
     * the loaded plugins to add some metainformation about the plugin being processed
     *
    * @param {String/Array} names The name of the resource to load. It may be a
    * string with a single resource name, or an array with several names.
    * @param {Function} callback A function to be called when all resources
    * are loaded. The callback will receive an array containing all loaded names.
    * @param {Object} [scope] The scope object to be used for the callback call.
     * @memberof CKEDITOR.plugins
     * @method load
     * @static
     */
    CKEDITOR.plugins.load = CKEDITOR.tools.override(CKEDITOR.plugins.load, function (pluginsLoad) {
        // Wrap original load function so we can transform the plugin input parameter
        // before passing it down to the original callback
        return function (names, callback, scope) {
            pluginsLoad.call(this, names, function (plugins) {
                if (callback) {
                    Object.keys(plugins).forEach(function (pluginName) {
                        var plugin = plugins[pluginName];

                        if (plugin.requires) {
                            plugin.requires = filterUnwantedDependencies(plugin.requires);
                        }

                        wrapPluginLifecycle(plugin);
                    });

                    callback.call(scope, plugins);
                }
            });
        };
    });
})();

/***/ }),

/***/ "./src/core/selection-region.js":
/*!**************************************!*\
  !*** ./src/core/selection-region.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_selectionregion')) {
        return;
    }

    CKEDITOR.SELECTION_TOP_TO_BOTTOM = 0;
    CKEDITOR.SELECTION_BOTTOM_TO_TOP = 1;
    CKEDITOR.SELECTION_LEFT_TO_RIGHT = 2;
    CKEDITOR.SELECTION_RIGHT_TO_LEFT = 3;

    /**
     * SelectionRegion utility class which provides metadata about the selection. The metadata may be the start and end
     * rectangles, caret region, etc. **This class is not intended to be used standalone. Its functions will
     * be merged into each editor instance, so the developer may use them directly via the editor, without making
     * an instance of this class**.
     *
     * @class SelectionRegion
     * @constructor
     */
    function SelectionRegion() {}

    SelectionRegion.prototype = {
        constructor: SelectionRegion,

        /**
         * Creates selection from two points in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method createSelectionFromPoint
         * @param {Number} x X point in page coordinates.
         * @param {Number} y Y point in page coordinates.
         */
        createSelectionFromPoint: function createSelectionFromPoint(x, y) {
            this.createSelectionFromRange(x, y, x, y);
        },

        /**
         * Creates selection from range. A range consists from two points in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method createSelectionFromRange
         * @param {Number} startX X coordinate of the first point.
         * @param {Number} startY Y coordinate of the first point.
         * @param {Number} endX X coordinate of the second point.
         * @param {Number} endY Y coordinate of the second point.
         */
        createSelectionFromRange: function createSelectionFromRange(startX, startY, endX, endY) {
            var end;
            var endContainer;
            var endOffset;
            var range;
            var start;
            var startContainer;
            var startOffset;

            if (typeof document.caretPositionFromPoint === 'function') {
                start = document.caretPositionFromPoint(startX, startY);
                end = document.caretPositionFromPoint(endX, endY);

                startContainer = start.offsetNode;
                endContainer = end.offsetNode;

                startOffset = start.offset;
                endOffset = end.offset;

                range = this.createRange();
            } else if (typeof document.caretRangeFromPoint === 'function') {
                start = document.caretRangeFromPoint(startX, startY);
                end = document.caretRangeFromPoint(endX, endY);

                startContainer = start.startContainer;
                endContainer = end.startContainer;

                startOffset = start.startOffset;
                endOffset = end.startOffset;

                range = this.createRange();
            }

            if (range && document.getSelection) {
                range.setStart(new CKEDITOR.dom.node(startContainer), startOffset);
                range.setEnd(new CKEDITOR.dom.node(endContainer), endOffset);

                this.getSelection().selectRanges([range]);
            } else if (typeof document.body.createTextRange === 'function') {
                var selection = this.getSelection();

                selection.unlock();

                range = document.body.createTextRange();
                range.moveToPoint(startX, startY);

                var endRange = range.duplicate();
                endRange.moveToPoint(endX, endY);

                range.setEndPoint('EndToEnd', endRange);
                range.select();

                this.getSelection().lock();
            }
        },

        /**
         * Returns the region of the current position of the caret. The points are in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getCaretRegion
         * @return {Object} Returns object with the following properties:
         * - bottom
         * - left
         * - right
         * - top
         */
        getCaretRegion: function getCaretRegion() {
            var selection = this.getSelection();

            var region = {
                bottom: 0,
                left: 0,
                right: 0,
                top: 0
            };

            var bookmarks = selection.createBookmarks();

            if (!bookmarks.length) {
                return region;
            }

            var bookmarkNodeEl = bookmarks[0].startNode.$;

            bookmarkNodeEl.style.display = 'inline-block';

            region = new CKEDITOR.dom.element(bookmarkNodeEl).getClientRect();

            bookmarkNodeEl.parentNode.removeChild(bookmarkNodeEl);

            var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

            region.bottom = scrollPos.y + region.bottom;
            region.left = scrollPos.x + region.left;
            region.right = scrollPos.x + region.right;
            region.top = scrollPos.y + region.top;

            return region;
        },

        /**
         * Returns data for the current selection.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionData
         * @return {Object|null} Returns an object with the following data:
         * - element - The currently selected element, if any
         * - text - The selected text
         * - region - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionRegion:method"}}{{/crossLink}}
         */
        getSelectionData: function getSelectionData() {
            var selection = this.getSelection();

            if (!selection.getNative()) {
                return null;
            }

            var result = {
                element: selection.getSelectedElement(),
                text: selection.getSelectedText()
            };

            result.region = this.getSelectionRegion(selection);

            return result;
        },

        /**
         * Returns the region of the current selection.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionRegion
         * @return {Object} Returns object which is being returned from
         * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getClientRectsRegion:method"}}{{/crossLink}} with three more properties:
         * - direction - the direction of the selection. Can be one of these:
         *   1. CKEDITOR.SELECTION_TOP_TO_BOTTOM
         *   2. CKEDITOR.SELECTION_BOTTOM_TO_TOP
         * - height - The height of the selection region
         * - width - The width of the selection region
         */
        getSelectionRegion: function getSelectionRegion() {
            var region = this.getClientRectsRegion();

            region.direction = this.getSelectionDirection();

            region.height = region.bottom - region.top;
            region.width = region.right - region.left;

            return region;
        },

        /**
         * Returns true if the current selection is empty, false otherwise.
         *
         * @instance
         * @memberof SelectionRegion
         * @method isSelectionEmpty
         * @return {Boolean} Returns true if the current selection is empty, false otherwise.
         */
        isSelectionEmpty: function isSelectionEmpty() {
            var ranges;

            var selection = this.getSelection();

            return selection.getType() === CKEDITOR.SELECTION_NONE || (ranges = selection.getRanges()) && ranges.length === 1 && ranges[0].collapsed;
        },

        /**
         * Returns object with data about the [client rectangles](https://developer.mozilla.org/en-US/docs/Web/API/Element.getClientRects) of the selection,
         * normalized across browses. All offsets below are in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getClientRectsRegion
         * @return {Object} Returns object with the following data:
         * - bottom - bottom offset of all client rectangles
         * - left - left offset of all client rectangles
         * - right - right offset of all client rectangles
         * - top - top offset of all client rectangles
         * - startRect - An Object, which contains the following information:
         *     + bottom - bottom offset
         *     + height - the height of the rectangle
         *     + left - left offset of the selection
         *     + right - right offset of the selection
         *     + top - top offset of the selection
         *     + width - the width of the rectangle
         * - endRect - An Object, which contains the following information:
         *     + bottom - bottom offset
         *     + height - the height of the rectangle
         *     + left - left offset of the selection
         *     + right - right offset of the selection
         *     + top - top offset of the selection
         *     + width - the width of the rectangle
         *
         * If there is no native selection, the objects will be filled with 0.
         */
        getClientRectsRegion: function getClientRectsRegion() {
            var selection = this.getSelection();
            var nativeSelection = selection.getNative();

            var defaultRect = {
                bottom: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                width: 0
            };

            var region = {
                bottom: 0,
                endRect: defaultRect,
                left: 0,
                right: 0,
                top: 0,
                startRect: defaultRect
            };

            if (!nativeSelection) {
                return region;
            }

            var bottom = 0;
            var clientRects;
            var left = Infinity;
            var rangeCount;
            var right = -Infinity;
            var top = Infinity;

            if (nativeSelection.createRange) {
                clientRects = nativeSelection.createRange().getClientRects();
            } else {
                rangeCount = nativeSelection.rangeCount;
                clientRects = nativeSelection.rangeCount > 0 ? nativeSelection.getRangeAt(0).getClientRects() : [];
            }

            if (clientRects.length === 0) {
                region = this.getCaretRegion();
            } else {
                for (var i = 0, length = clientRects.length; i < length; i++) {
                    var item = clientRects[i];

                    if (item.left < left) {
                        left = item.left;
                    }

                    if (item.right > right) {
                        right = item.right;
                    }

                    if (item.top < top) {
                        top = item.top;
                    }

                    if (item.bottom > bottom) {
                        bottom = item.bottom;
                    }
                }

                var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

                region.bottom = scrollPos.y + bottom;
                region.left = scrollPos.x + left;
                region.right = scrollPos.x + right;
                region.top = scrollPos.y + top;

                if (clientRects.length) {
                    var endRect = clientRects[clientRects.length - 1];
                    var startRect = clientRects[0];

                    region.endRect = {
                        bottom: scrollPos.y + endRect.bottom,
                        height: endRect.height,
                        left: scrollPos.x + endRect.left,
                        right: scrollPos.x + endRect.right,
                        top: scrollPos.y + endRect.top,
                        width: endRect.width
                    };

                    region.startRect = {
                        bottom: scrollPos.y + startRect.bottom,
                        height: startRect.height,
                        left: scrollPos.x + startRect.left,
                        right: scrollPos.x + startRect.right,
                        top: scrollPos.y + startRect.top,
                        width: startRect.width
                    };
                }
            }

            return region;
        },

        /**
         * Retrieves the direction of the selection. The direction is from top to bottom or from bottom to top.
         * For IE < 9 it is not possible, so the direction for these browsers will be always CKEDITOR.SELECTION_TOP_TO_BOTTOM.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionDirection
         * @return {Number} Returns a number which represents selection direction. It might be one of these:
         * - CKEDITOR.SELECTION_TOP_TO_BOTTOM;
         * - CKEDITOR.SELECTION_BOTTOM_TO_TOP;
         */
        getSelectionDirection: function getSelectionDirection() {
            var direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;
            var selection = this.getSelection();
            var nativeSelection = selection.getNative();

            if (!nativeSelection) {
                return direction;
            }

            var anchorNode;

            if ((anchorNode = nativeSelection.anchorNode) && anchorNode.compareDocumentPosition) {
                var position = anchorNode.compareDocumentPosition(nativeSelection.focusNode);

                if (!position && nativeSelection.anchorOffset > nativeSelection.focusOffset || position === Node.DOCUMENT_POSITION_PRECEDING) {
                    direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
                }
            }

            return direction;
        }
    };

    CKEDITOR.plugins.add('ae_selectionregion', {
        init: function init(editor) {
            var attr, hasOwnProperty;

            hasOwnProperty = Object.prototype.hasOwnProperty;

            for (attr in SelectionRegion.prototype) {
                if (hasOwnProperty.call(SelectionRegion.prototype, attr) && typeof editor[attr] === 'undefined') {
                    editor[attr] = SelectionRegion.prototype[attr];
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/core/table.js":
/*!***************************!*\
  !*** ./src/core/table.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    var IE_NON_DIRECTLY_EDITABLE_ELEMENT = {
        'table': 1,
        'col': 1,
        'colgroup': 1,
        'tbody': 1,
        'td': 1,
        'tfoot': 1,
        'th': 1,
        'thead': 1,
        'tr': 1
    };

    /**
     * Table class utility. Provides methods for create, delete and update tables.
     *
     * @class CKEDITOR.Table
     * @constructor
     * @param {Object} editor The CKEditor instance.
     */

    function Table(editor) {
        this._editor = editor;
    }

    Table.HEADING_BOTH = 'Both';
    Table.HEADING_COL = 'Column';
    Table.HEADING_NONE = 'None';
    Table.HEADING_ROW = 'Row';

    Table.prototype = {
        constructor: Table,

        /**
         * Creates a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method create
         * @param {Object} config Table configuration object
         * @return {Object} The created table
         */
        create: function create(config) {
            var editor = this._editor;
            var table = this._createElement('table');

            config = config || {};

            // Generate the rows and cols.
            var tbody = table.append(this._createElement('tbody'));
            var rows = config.rows || 1;
            var cols = config.cols || 1;

            for (var i = 0; i < rows; i++) {
                var row = tbody.append(this._createElement('tr'));
                for (var j = 0; j < cols; j++) {
                    var cell = row.append(this._createElement('td'));

                    cell.appendBogus();
                }
            }

            this.setAttributes(table, config.attrs);
            this.setHeading(table, config.heading);

            // Insert the table element if we're creating one.
            editor.insertElement(table);

            var firstCell = new CKEDITOR.dom.element(table.$.rows[0].cells[0]);
            var range = editor.createRange();
            range.moveToPosition(firstCell, CKEDITOR.POSITION_AFTER_START);
            range.select();

            return table;
        },

        /**
         * Retrieves a table from the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method getFromSelection
         * @return {CKEDITOR.dom.element} The retrieved table or null if not found.
         */
        getFromSelection: function getFromSelection() {
            var table;
            var selection = this._editor.getSelection();
            var selected = selection.getSelectedElement();

            if (selected && selected.is('table')) {
                table = selected;
            } else {
                var ranges = selection.getRanges();

                if (ranges.length > 0) {
                    // Webkit could report the following range on cell selection (#4948):
                    // <table><tr><td>[&nbsp;</td></tr></table>]

                    /* istanbul ignore else */
                    if (CKEDITOR.env.webkit) {
                        ranges[0].shrink(CKEDITOR.NODE_ELEMENT);
                    }

                    table = this._editor.elementPath(ranges[0].getCommonAncestor(true)).contains('table', 1);
                }
            }

            return table;
        },

        /**
         * Checks if a given table can be considered as editable. This method
         * workarounds a limitation of IE where for some elements (like table),
         * `isContentEditable` returns always false. This is because IE does not support
         * `contenteditable` on such elements. However, despite such elements
         * cannot be set as content editable directly, a content editable SPAN,
         * or DIV element can be placed inside the individual table cells.
         * See https://msdn.microsoft.com/en-us/library/ms537837%28v=VS.85%29.aspx
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method isEditable
         * @param {CKEDITOR.dom.element} el The table element to test if editable
         * @return {Boolean}
         */
        isEditable: function isEditable(el) {
            if (!CKEDITOR.env.ie || !el.is(IE_NON_DIRECTLY_EDITABLE_ELEMENT)) {
                return !el.isReadOnly();
            }

            if (el.hasAttribute('contenteditable')) {
                return el.getAttribute('contenteditable') !== 'false';
            }

            return this.isEditable(el.getParent());
        },

        /**
         * Returns which heading style is set for the given table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method getHeading
         * @param {CKEDITOR.dom.element} table The table to gather the heading from. If null, it will be retrieved from the current selection.
         * @return {String} The heading of the table. Expected values are `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
         */
        getHeading: function getHeading(table) {
            table = table || this.getFromSelection();

            if (!table) {
                return null;
            }

            var rowHeadingSettings = table.$.tHead !== null;

            var colHeadingSettings = true;

            // Check if all of the first cells in every row are TH
            for (var row = 0; row < table.$.rows.length; row++) {
                // If just one cell isn't a TH then it isn't a header column
                var cell = table.$.rows[row].cells[0];

                if (cell && cell.nodeName.toLowerCase() !== 'th') {
                    colHeadingSettings = false;
                    break;
                }
            }

            var headingSettings = Table.HEADING_NONE;

            if (rowHeadingSettings) {
                headingSettings = Table.HEADING_ROW;
            }

            if (colHeadingSettings) {
                headingSettings = headingSettings === Table.HEADING_ROW ? Table.HEADING_BOTH : Table.HEADING_COL;
            }

            return headingSettings;
        },

        /**
         * Removes a table from the editor.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method remove
         * @param {CKEDITOR.dom.element} table The table element which table style should be removed.
         */
        remove: function remove(table) {
            var editor = this._editor;

            if (table) {
                table.remove();
            } else {
                table = editor.elementPath().contains('table', 1);

                if (table) {
                    // If the table's parent has only one child remove it as well (unless it's a table cell, or the editable element) (#5416, #6289, #12110)
                    var parent = table.getParent();
                    var editable = editor.editable();

                    if (parent.getChildCount() === 1 && !parent.is('td', 'th') && !parent.equals(editable)) {
                        table = parent;
                    }

                    var range = editor.createRange();
                    range.moveToPosition(table, CKEDITOR.POSITION_BEFORE_START);
                    table.remove();
                    range.select();
                }
            }
        },

        /**
         * Assigns provided attributes to a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method setAttributes
         * @param {Object} table The table to which the attributes should be assigned
         * @param {Object} attrs The attributes which have to be assigned to the table
         */
        setAttributes: function setAttributes(table, attrs) {
            if (attrs) {
                Object.keys(attrs).forEach(function (attr) {
                    table.setAttribute(attr, attrs[attr]);
                });
            }
        },

        /**
         * Sets the appropriate table heading style to a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method setHeading
         * @param {CKEDITOR.dom.element} table The table element to which the heading should be set. If null, it will be retrieved from the current selection.
         * @param {String} heading The table heading to be set. Accepted values are: `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
         */
        setHeading: function setHeading(table, heading) {
            table = table || this.getFromSelection();

            var i, newCell;
            var tableHead;
            var tableBody = table.getElementsByTag('tbody').getItem(0);

            var tableHeading = this.getHeading(table);
            var hadColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

            var needColHeading = heading === Table.HEADING_COL || heading === Table.HEADING_BOTH;
            var needRowHeading = heading === Table.HEADING_ROW || heading === Table.HEADING_BOTH;

            // If we need row heading and don't have a <thead> element yet, move the
            // first row of the table to the head and convert the nodes to <th> ones.
            if (!table.$.tHead && needRowHeading) {
                var tableFirstRow = tableBody.getElementsByTag('tr').getItem(0);
                var tableFirstRowChildCount = tableFirstRow.getChildCount();

                // Change TD to TH:
                for (i = 0; i < tableFirstRowChildCount; i++) {
                    var cell = tableFirstRow.getChild(i);

                    // Skip bookmark nodes. (#6155)
                    if (cell.type === CKEDITOR.NODE_ELEMENT && !cell.data('cke-bookmark')) {
                        cell.renameNode('th');
                        cell.setAttribute('scope', 'col');
                    }
                }

                tableHead = this._createElement(table.$.createTHead());
                tableHead.append(tableFirstRow.remove());
            }

            // If we don't need row heading and we have a <thead> element, move the
            // row out of there and into the <tbody> element.
            if (table.$.tHead !== null && !needRowHeading) {
                // Move the row out of the THead and put it in the TBody:
                tableHead = this._createElement(table.$.tHead);

                var previousFirstRow = tableBody.getFirst();

                while (tableHead.getChildCount() > 0) {
                    var newFirstRow = tableHead.getFirst();
                    var newFirstRowChildCount = newFirstRow.getChildCount();

                    for (i = 0; i < newFirstRowChildCount; i++) {
                        newCell = newFirstRow.getChild(i);

                        if (newCell.type === CKEDITOR.NODE_ELEMENT) {
                            newCell.renameNode('td');
                            newCell.removeAttribute('scope');
                        }
                    }

                    newFirstRow.insertBefore(previousFirstRow);
                }

                tableHead.remove();
            }

            tableHeading = this.getHeading(table);
            var hasColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

            // If we need column heading and the table doesn't have it, convert every first cell in
            // every row into a `<th scope="row">` element.
            if (!hasColHeading && needColHeading) {
                for (i = 0; i < table.$.rows.length; i++) {
                    if (table.$.rows[i].cells[0].nodeName.toLowerCase() !== 'th') {
                        newCell = new CKEDITOR.dom.element(table.$.rows[i].cells[0]);
                        newCell.renameNode('th');
                        newCell.setAttribute('scope', 'row');
                    }
                }
            }

            // If we don't need column heading but the table has it, convert every first cell in every
            // row back into a `<td>` element.
            if (hadColHeading && !needColHeading) {
                for (i = 0; i < table.$.rows.length; i++) {
                    var row = new CKEDITOR.dom.element(table.$.rows[i]);

                    if (row.getParent().getName() === 'tbody') {
                        newCell = new CKEDITOR.dom.element(row.$.cells[0]);
                        newCell.renameNode('td');
                        newCell.removeAttribute('scope');
                    }
                }
            }
        },

        /**
         * Creates a new CKEDITOR.dom.element using the passed tag name.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @protected
         * @method _createElement
         * @param {String} name The tag name from which an element should be created
         * @return {CKEDITOR.dom.element} Instance of CKEDITOR DOM element class
         */
        _createElement: function _createElement(name) {
            return new CKEDITOR.dom.element(name, this._editor.document);
        }
    };

    CKEDITOR.on('instanceReady', function (event) {
        var headingCommands = [Table.HEADING_NONE, Table.HEADING_ROW, Table.HEADING_COL, Table.HEADING_BOTH];

        var tableUtils = new Table(event.editor);

        headingCommands.forEach(function (heading) {
            event.editor.addCommand('tableHeading' + heading, {
                exec: function exec(editor) {
                    tableUtils.setHeading(null, heading);
                }
            });
        });
    });

    CKEDITOR.Table = CKEDITOR.Table || Table;
})();

/***/ }),

/***/ "./src/core/tools.js":
/*!***************************!*\
  !*** ./src/core/tools.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /**
     * CKEDITOR.tools class utility which adds additional methods to those of CKEditor.
     *
     * @class CKEDITOR.tools
     */

    /**
     * Sends a request using the JSONP technique.
     *
     * @memberof CKEDITOR.tools
     * @method jsonp
     * @param {CKEDITOR.template} urlTemplate The template of the URL to be requested. All properties passed in `urlParams` can be used, plus a `{callback}`, which represent a JSONP callback, must be defined.
     * @param {Function} callback A function to be called in case of success.
     * @param {Function} errorCallback A function to be called in case of failure.
     * @param {Object} urlParams Parameters to be passed to the `urlTemplate`.
     * @return {Object} An object with the following properties:
     *  - id: the transaction ID
     *  - a `cancel()` method
     * @static
     */

    CKEDITOR.tools.jsonp = function (urlTemplate, urlParams, callback, errorCallback) {
        var callbackKey = CKEDITOR.tools.getNextNumber();

        urlParams = urlParams || {};
        urlParams.callback = 'CKEDITOR._.jsonpCallbacks[' + callbackKey + ']';

        if (!CKEDITOR._.jsonpCallbacks) {
            CKEDITOR._.jsonpCallbacks = {};
        }

        CKEDITOR._.jsonpCallbacks[callbackKey] = function (response) {
            setTimeout(function () {
                cleanUp();

                callback(response);
            });
        };

        var scriptElement = new CKEDITOR.dom.element('script');
        scriptElement.setAttribute('src', urlTemplate.output(urlParams));
        scriptElement.on('error', function () {
            cleanUp();

            if (errorCallback) {
                errorCallback();
            }
        });

        function cleanUp() {
            if (scriptElement) {
                scriptElement.remove();
                delete CKEDITOR._.jsonpCallbacks[callbackKey];
                scriptElement = null;
            }
        }

        CKEDITOR.document.getBody().append(scriptElement);

        return {
            cancel: cleanUp,
            id: callbackKey
        };
    };

    /**
     * Returns a new object containing all of the properties of all the supplied
     * objects. The properties from later objects will overwrite those in earlier
     * objects.
     *
     * Passing in a single object will create a shallow copy of it.
     *
     * @memberof CKEDITOR.tools
     * @method merge
     * @param {Object} objects* One or more objects to merge.
     * @return {Object} A new merged object.
     * @static
     */
    CKEDITOR.tools.merge = CKEDITOR.tools.merge || function () {
        var result = {};

        for (var i = 0; i < arguments.length; ++i) {
            var obj = arguments[i];

            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    result[key] = obj[key];
                }
            }
        }

        return result;
    };

    /**
     * Simulates event on a DOM element.
     *
     * @memberof CKEDITOR.tools
     * @method simulate
     * @param {DOMElement} element The element on which the event shoud be simualted.
     * @param {String} event The name of the event which have to be simulated.
     * @static
     */
    CKEDITOR.tools.simulate = function (element, event) {
        var eventInstance = document.createEvent('Events');
        eventInstance.initEvent(event, true, false);
        element.dispatchEvent(eventInstance);
    };
})();

/***/ }),

/***/ "./src/core/uicore.js":
/*!****************************!*\
  !*** ./src/core/uicore.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_uicore')) {
        return;
    }

    /**
     * UICore class which will handle user interactions with the editor. These interactions
     * might be triggered via mouse, keyboard or touch devices. The class fill fire an event via
     * CKEditor's event system - "editorInteraction". The UI may listen to this event and
     * execute some actions - for example to show/hide toolbars.
     *
     * By default if user presses the Esc key, 'editorInteraction' event won't be fired. However, this behaviour can be changed
     * by setting {{#crossLink "CKEDITOR.plugins.ae_uicore/allowEsc:attribute"}}{{/crossLink}} config property in editor's configuration to true.
     *
     * @class ae_uicore
     */

    /**
     * Fired when user interacts somehow with the browser. This may be clicking with the mouse, pressing keyboard button,
     * or touching screen. This even will be not fired after each interaction. It will be debounced. By default the timeout
     * is 50ms. This value can be overwritten via {{#crossLink "CKEDITOR.plugins.ae_uicore/timeout:attribute"}}{{/crossLink}}
     * property of editor's configuration, like: editor.config.uicore.timeout = 100
     *
     * @memberof ae_uicore
     * @event ae_uicore#editorInteraction
     * @param {Object} data An object which contains the following properties:
     * - nativeEvent - The event as received from CKEditor.
     * - selectionData - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
     */

    /**
     * Fired by UI elements like Toolbars or Buttons when their state changes. The listener updates the live region with the provided data.
     *
     * @memberof ae_uicore
     * @event ae_uicore#ariaUpdate
     * @param {Object} data An object which contains the following properties:
     * - message - The provided message from the UI element.
     */

    /**
     * If set to true, the editor will still fire {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event,
     * if user presses Esc key.
     *
     * @memberof ae_uicore
     * @attribute allowEsc
     * @default false
     * @type Boolean
     */

    /**
     * Specifies the default timeout after which the {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event
     * will be fired.
     *
     * @memberof ae_uicore
     * @attribute timeout
     * @default 50 (ms)
     * @type Number
     */

    CKEDITOR.plugins.add('ae_uicore', {
        /**
         * Initializer lifecycle implementation for the UICore plugin.
         *
         * @memberof ae_uicore
         * @method init
         * @param {Object} editor The current CKEditor instance.
         * @protected
         */
        init: function init(editor) {
            var ariaState = [];

            var ariaElement = this._createAriaElement(editor.id);

            var uiTasksTimeout = editor.config.uicore ? editor.config.uicore.timeout : 50;

            var handleUI = CKEDITOR.tools.debounce(function (event) {
                ariaState = [];

                if (event.name !== 'keyup' || event.data.$.keyCode !== 27 || editor.config.allowEsc) {
                    var selectionData = editor.getSelectionData();

                    if (selectionData) {
                        editor.fire('editorInteraction', {
                            nativeEvent: event.data.$,
                            selectionData: selectionData
                        });
                    }
                }
            }, uiTasksTimeout);

            var handleAria = CKEDITOR.tools.debounce(function (event) {
                ariaElement.innerHTML = ariaState.join('. ');
            }, uiTasksTimeout);

            var handleMouseLeave = CKEDITOR.tools.debounce(function (event) {
                var aeUINodes = document.querySelectorAll('.ae-ui');

                var found;

                for (var i = 0; i < aeUINodes.length; i++) {
                    if (aeUINodes[i].contains(event.data.$.relatedTarget)) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    handleUI(event);
                }
            }, uiTasksTimeout);

            editor.on('ariaUpdate', function (event) {
                // handleAria is debounced function, so if it is being called multiple times, it will
                // be canceled until some time passes.
                // For that reason here we explicitly append the current message to the list of messages
                // and call handleAria. Since it is debounced, when some timeout passes,
                // all the messages will be applied to the live region and not only the last one.

                ariaState.push(event.data.message);

                handleAria();
            });

            editor.once('contentDom', function () {
                var editable = editor.editable();

                var focusHandler = editable.attachListener(editable, 'focus', function (event) {
                    focusHandler.removeListener();

                    editable.attachListener(editable, 'keyup', handleUI);
                    editable.attachListener(editable, 'mouseup', handleUI);
                    editable.attachListener(editable, 'mouseleave', handleMouseLeave);

                    handleUI(event);
                });
            });

            editor.on('destroy', function (event) {
                ariaElement.parentNode.removeChild(ariaElement);

                handleUI.detach();
            });
        },

        /**
         * Creates and applies an HTML element to the body of the document which will contain ARIA messages.
         *
         * @memberof ae_uicore
         * @method _createAriaElement
         * @param {String} id The provided id of the element. It will be used as prefix for the final element Id.
         * @protected
         * @return {HTMLElement} The created and applied to DOM element.
         */
        _createAriaElement: function _createAriaElement(id) {
            var statusElement = document.createElement('div');

            statusElement.className = 'ae-sr-only';

            statusElement.setAttribute('aria-live', 'polite');
            statusElement.setAttribute('role', 'status');
            statusElement.setAttribute('id', id + 'LiveRegion');

            document.body.appendChild(statusElement);

            return statusElement;
        }
    });
})();

/***/ }),

/***/ "./src/oop/attribute.js":
/*!******************************!*\
  !*** ./src/oop/attribute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _lang = __webpack_require__(/*! ./lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Attribute implementation.
 *
 * @class Attribute
 * @constructor
*/
function Attribute(config) {
    this.__config__ = config || {};
    this.__ATTRS__ = {};
}

Attribute.prototype = {
    constructor: Attribute,

    /**
     * Retrieves the value of an attribute.
     *
     * @instance
     * @memberof Attribute
     * @method get
     * @param {String} attr The attribute which value should be retrieved.
     * @return {Any} The value of the attribute.
     */
    get: function get(attr) {
        var currentAttr = this.constructor.ATTRS[attr];

        if (!currentAttr) {
            return;
        }

        if (!this._isInitialized(attr)) {
            this._init(attr);
        }

        var curValue = this.__ATTRS__[attr];

        if (currentAttr.getter) {
            curValue = this._callStringOrFunction(currentAttr.getter, curValue);
        }

        return curValue;
    },

    /**
     * Sets the value of an attribute.
     *
     * @instance
     * @memberof Attribute
     * @method set
     * @param {String} attr The attribute which value should be set.
     * @param {Any} value The value which should be set to the attribute.
     */
    set: function set(attr, value) {
        var currentAttr = this.constructor.ATTRS[attr];

        if (!currentAttr) {
            return;
        }

        if (!this._isInitialized(attr)) {
            this._init(attr);
        }

        if (currentAttr.readOnly) {
            return;
        }

        if (currentAttr.writeOnce && this._isInitialized(attr)) {
            return;
        }

        if (currentAttr.validator && !this._callStringOrFunction(currentAttr.validator, value)) {
            return;
        }

        if (currentAttr.setter) {
            value = this._callStringOrFunction(currentAttr.setter, value);
        }

        this.__ATTRS__[attr] = value;
    },

    /**
     * Calls the provided param as function with the supplied arguments.
     * If param provided as string, a corresponding function in this object will
     * be called. If provided param is a function, it will be directly called.
     *
     * @instance
     * @memberof Attribute
     * @method _callStringOrFunction
     * @param  {Any|Array} args The arguments which will be provided to the called function
     * @param  {String|Function} stringOrFunction The function which should be called
     * @protected
     * @return {Any} The returned value from the called function
     */
    _callStringOrFunction: function _callStringOrFunction(stringOrFunction, args) {
        var result = null;

        if (!_lang2.default.isArray(args)) {
            args = [args];
        }

        if (_lang2.default.isString(stringOrFunction) && _lang2.default.isFunction(this[stringOrFunction])) {
            result = this[stringOrFunction].apply(this, args);
        } else if (_lang2.default.isFunction(stringOrFunction)) {
            result = stringOrFunction.apply(this, args);
        }

        return result;
    },

    /**
     * Initializes an attribute. Sets its default value depending on the flags of the
     * attribute and the passed configuration object to the constructor.
     *
     * @instance
     * @memberof Attribute
     * @method _init
     * @param {String} attr The name of the attribute which have to be initialized.
     * @protected
     */
    _init: function _init(attr) {
        var value;

        var currentAttr = this.constructor.ATTRS[attr];

        // Check if there is default value or passed one via configuration object
        var hasDefaultValue = Object.prototype.hasOwnProperty.call(currentAttr, 'value');
        var hasPassedValueViaConfig = Object.prototype.hasOwnProperty.call(this.__config__, attr);

        // If there is valueFn, set the value to be the result of invocation of this function
        if (currentAttr.valueFn) {
            value = this._callStringOrFunction(currentAttr.valueFn, value);

            this.__ATTRS__[attr] = value;
        }
        // else if the attribute has readOnly flag, set the default value from the attribute,
        // regardless if there is value or not
        else if (currentAttr.readOnly) {
                value = currentAttr.value;
            }
            // else if the attribute has writeOnce value, set it from the passed configuration or from the
            // default value, in this order. Otherwise, return miserable.
            else if (currentAttr.writeOnce) {
                    if (hasPassedValueViaConfig) {
                        value = this.__config__[attr];
                    } else if (hasDefaultValue) {
                        value = currentAttr.value;
                    } else {
                        return;
                    }
                }
                // These two cases below are easy - set the value to be from the passed config or
                // from the default value, in this order.
                else if (hasPassedValueViaConfig) {
                        value = this.__config__[attr];
                    } else if (hasDefaultValue) {
                        value = currentAttr.value;
                    }

        // If there is validator, and user passed config object - check the returned value.
        // If it is false, then set as initial value the default one.
        // However, if there is no default value, just return.
        if (currentAttr.validator && hasPassedValueViaConfig && !this._callStringOrFunction(currentAttr.validator, value)) {
            if (hasDefaultValue) {
                value = currentAttr.value;
            } else {
                return;
            }
        }

        // If there is setter and user passed config object - pass the value thought the setter.
        // The value might be one from defaultFn, default value or provided from the config.
        if (currentAttr.setter && hasPassedValueViaConfig) {
            value = this._callStringOrFunction(currentAttr.setter, value);
        }

        // Finally, set the value as initial value to the storage with values.
        this.__ATTRS__[attr] = value;
    },

    /**
     * Checks if an attribute is initialized. An attribute is considered as initialized
     * when there is an own property with this name in the local collection of attribute values
     * for the current instance.
     *
     * @instance
     * @memberof Attribute
     * @method _isInitialized
     * @param {String} attr The attribute which should be checked if it is initialized.
     * @protected
     * @return {Boolean} Returns true if the attribute has been initialized, false otherwise.
     */
    _isInitialized: function _isInitialized(attr) {
        return Object.prototype.hasOwnProperty.call(this.__ATTRS__, attr);
    }
};

exports.default = Attribute;

/***/ }),

/***/ "./src/oop/base.js":
/*!*************************!*\
  !*** ./src/oop/base.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _attribute = __webpack_require__(/*! ./attribute.js */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _lang = __webpack_require__(/*! ./lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ./oop.js */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Quick and dirty impl of Base class.
 *
 * @class Base
 * @constructor
 */
function Base(config) {
    Base.superclass.constructor.call(this, config);

    this.init(config);
}

(0, _oop2.default)(Base, _attribute2.default, {
    /**
     * Calls the `initializer` method of each class which extends Base starting from the parent to the child.
     * Will pass the configuration object to each initializer method.
     *
     * @instance
     * @memberof Base
     * @method init
     * @param {Object} config Configuration object
     */
    init: function init(config) {
        this._callChain('initializer', config);
    },

    /**
     * Calls the `destructor` method of each class which extends Base starting from the parent to the child.
     *
     * @instance
     * @memberof Base
     * @method destroy
     */
    destroy: function destroy() {
        this._callChain('destructor');
    },

    /**
     * Calls a method of each class, which is being present in the hierarchy starting from parent to the child.
     *
     * @instance
     * @memberof Base
     * @method _callChain
     * @param {Object|Array} args The arguments with which the method should be invoked
     * @param {String} wat  The method, which should be invoked
     * @protected
     */
    _callChain: function _callChain(wat, args) {
        var arr = [];

        var ctor = this.constructor;

        while (ctor) {
            if (_lang2.default.isFunction(ctor.prototype[wat])) {
                arr.push(ctor.prototype[wat]);
            }

            ctor = ctor.superclass ? ctor.superclass.constructor : null;
        }

        arr = arr.reverse();

        args = _lang2.default.isArray(args) ? args : [args];

        for (var i = 0; i < arr.length; i++) {
            var item = arr[i];

            item.apply(this, args);
        }
    }
});

exports.default = Base;

/***/ }),

/***/ "./src/oop/lang.js":
/*!*************************!*\
  !*** ./src/oop/lang.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Provides core language utilities.
 *
 * @class Lang
 */
var Lang = {
    /**
     * Check if the passed value is an array.
     *
     * @memberof Lang
     * @method isArray
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is an array, false otherwise.
     * @static
     */
    isArray: function isArray(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    },

    /**
     * Check if the passed value is boolean.
     *
     * @memberof Lang
     * @method isBoolean
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is boolean, false otherwise.
     * @static
     */
    isBoolean: function isBoolean(value) {
        return typeof value === 'boolean';
    },

    /**
     * Check if the passed value is a function.
     *
     * @memberof Lang
     * @method isFunction
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is a function, false otherwise.
     * @static
     */
    isFunction: function isFunction(value) {
        return typeof value === 'function';
    },

    /**
     * Check if the passed value is NULL.
     *
     * @memberof Lang
     * @method isNull
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is NULL, false otherwise.
     * @static
     */
    isNull: function isNull(value) {
        return value === null;
    },

    /**
     * Check if the passed value is number.
     *
     * @memberof Lang
     * @method isNumber
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is number, false otherwise.
     * @static
     */
    isNumber: function isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    },

    /**
     * Check if the passed value is an object
     *
     * @memberof Lang
     * @method isObject
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is an object, false otherwise.
     * @static
     */
    isObject: function isObject(value) {
        var valueType = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        return value && (valueType === 'object' || Lang.isFunction(value));
    },

    /**
     * Check if the passed value is a string.
     *
     * @memberof Lang
     * @method isString
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is a string, false otherwise.
     * @static
     */
    isString: function isString(value) {
        return typeof value === 'string';
    },

    /**
     * Adds all properties from the supplier to the receiver.
     * The function will add all properties, not only these owned by the supplier.
     *
     * @memberof Lang
     * @method mix
     * @param {Object} receiver The object which will receive properties.
     * @param {Object} supplier The object which provides properties.
     * @return {Object} The modified receiver.
     * @static
     */
    mix: function mix(receiver, supplier) {
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var key in supplier) {
            if (hasOwnProperty.call(supplier, key)) {
                receiver[key] = supplier[key];
            }
        }
    },

    /**
     * Converts value to Integer.
     *
     * @memberof Lang
     * @method toInt
     * @param {Any} value The value which have to be converted to Integer.
     * @return {Integer} The converted value.
     * @static
     */
    toInt: function toInt(value) {
        return parseInt(value, 10);
    }
};

exports.default = Lang;

/***/ }),

/***/ "./src/oop/oop.js":
/*!************************!*\
  !*** ./src/oop/oop.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the prototype, constructor and superclass properties to support an inheritance strategy
 * that can chain constructors and methods. Static members will not be inherited.
 *
 * @memberof OOP
 * @method extend
 * @param {Function} receiver The class which will extend another class.
 * @param {Function} supplier The class which will provide the properties the child class.
 * @param {Object} protoProps Prototype properties to add/override.
 * @param {Object} staticProps Static properties to add/overwrite.
 * @return {Function} The extended class.
 * @static
 */
var extend = function extend(receiver, supplier, protoProps, staticProps) {
    if (!supplier || !receiver) {
        throw 'extend failed, verify dependencies';
    }

    var supplierProto = supplier.prototype,
        receiverProto = Object.create(supplierProto);
    receiver.prototype = receiverProto;

    receiverProto.constructor = receiver;
    receiver.superclass = supplierProto;

    // assign constructor property
    if (supplier !== Object && supplierProto.constructor === Object.prototype.constructor) {
        supplierProto.constructor = supplier;
    }

    // add prototype overrides
    if (protoProps) {
        _lang2.default.mix(receiverProto, protoProps);
    }

    // add object overrides
    if (staticProps) {
        _lang2.default.mix(receiver, staticProps);
    }

    return receiver;
};

exports.default = extend;

/***/ }),

/***/ "./src/plugins/addimages.js":
/*!**********************************!*\
  !*** ./src/plugins/addimages.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    var isIE = CKEDITOR.env.ie;

    if (CKEDITOR.plugins.get('ae_addimages')) {
        return;
    }

    /**
     * CKEditor plugin which allows Drag&Drop of images directly into the editable area. The image will be encoded
     * as Data URI. An event `beforeImageAdd` will be fired with the list of dropped images. If any of the listeners
     * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
     * an event `imageAdd` will be fired with the inserted element into the editable area.
     *
     * @class CKEDITOR.plugins.ae_addimages
     */

    /**
     * Fired before adding images to the editor.
     *
     * @event CKEDITOR.plugins.ae_addimages#beforeImageAdd
     * @instance
     * @memberof CKEDITOR.plugins.ae_addimages
     * @param {Array} imageFiles Array of image files
     */

    /**
     * Fired when an image is being added to the editor successfully.
     *
     * @event CKEDITOR.plugins.ae_addimages#imageAdd
     * @instance
     * @memberof CKEDITOR.plugins.ae_addimages
     * @param {CKEDITOR.dom.element} el The created image with src as Data URI
     * @param {File} file The image file
     */

    CKEDITOR.plugins.add('ae_addimages', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'dragenter', 'dragover', 'drop' and `paste` events on the editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'dragenter', this._onDragEnter, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'dragover', this._onDragOver, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'drop', this._onDragDrop, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'paste', this._onPaste, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * Accepts an array of dropped files to the editor. Then, it filters the images and sends them for further
         * processing to {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}}
         *
         * @fires CKEDITOR.plugins.ae_addimages#beforeImageAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _handleFiles
         * @param {Array} files Array of dropped files. Only the images from this list will be processed.
         * @param {Object} editor The current editor instance
         * @protected
         */
        _handleFiles: function _handleFiles(files, editor) {
            var file;
            var i;

            var imageFiles = [];

            for (i = 0; i < files.length; i++) {
                file = files[i];

                if (file.type.indexOf('image') === 0) {
                    imageFiles.push(file);
                }
            }

            var result = editor.fire('beforeImageAdd', {
                imageFiles: imageFiles
            });

            if (!!result) {
                for (i = 0; i < imageFiles.length; i++) {
                    file = imageFiles[i];

                    this._processFile(file, editor);
                }
            }

            return false;
        },

        /**
         * Handles drag drop event. The function will create a selection from the current
         * point and will send a list of files to be processed to
         * {{#crossLink "CKEDITOR.plugins.ae_addimages/_handleFiles:method"}}{{/crossLink}} method.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragDrop
         * @param {CKEDITOR.dom.event} event dragdrop event, as received natively from CKEditor
         * @protected
         */
        _onDragDrop: function _onDragDrop(event) {
            var nativeEvent = event.data.$;

            new CKEDITOR.dom.event(nativeEvent).preventDefault();

            var editor = event.listenerData.editor;

            event.listenerData.editor.createSelectionFromPoint(nativeEvent.clientX, nativeEvent.clientY);

            this._handleFiles(nativeEvent.dataTransfer.files, editor);
        },

        /**
         * Handles drag enter event. In case of IE, this function will prevent the event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragEnter
         * @param {DOM event} event dragenter event, as received natively from CKEditor
         * @protected
         */
        _onDragEnter: function _onDragEnter(event) {
            if (isIE) {
                this._preventEvent(event);
            }
        },

        /**
         * Handles drag over event. In case of IE, this function will prevent the event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragOver
         * @param {DOM event} event dragover event, as received natively from CKEditor
         * @protected
         */
        _onDragOver: function _onDragOver(event) {
            if (isIE) {
                this._preventEvent(event);
            }
        },

        /**
         * Checks if the pasted data is image and passes it to
         * {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}} for processing.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onPaste
         * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
         * @protected
         */
        _onPaste: function _onPaste(event) {
            if (event.data && event.data.$ && event.data.$.clipboardData && event.data.$.clipboardData.items && event.data.$.clipboardData.items.length > 0) {
                var pastedData = event.data.$.clipboardData.items[0];

                if (pastedData.type.indexOf('image') === 0) {
                    var imageFile = pastedData.getAsFile();

                    this._processFile(imageFile, event.listenerData.editor);
                }
            }
        },

        /**
         * Prevents a native event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _preventEvent
         * @param {DOM event} event The event to be prevented.
         * @protected
         */
        _preventEvent: function _preventEvent(event) {
            event = new CKEDITOR.dom.event(event.data.$);

            event.preventDefault();
            event.stopPropagation();
        },

        /**
         * Processes an image file. The function creates an img element and sets as source
         * a Data URI, then fires an 'imageAdd' event via CKEditor's event system.
         *
         * @fires CKEDITOR.plugins.ae_addimages#imageAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _preventEvent
         * @param {DOM event} event The event to be prevented.
         * @protected
         */
        _processFile: function _processFile(file, editor) {
            var reader = new FileReader();

            reader.addEventListener('loadend', function () {
                var bin = reader.result;

                var el = CKEDITOR.dom.element.createFromHtml('<img src="' + bin + '">');

                editor.insertElement(el);

                var imageData = {
                    el: el,
                    file: file
                };

                editor.fire('imageAdd', imageData);
            });

            reader.readAsDataURL(file);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/autolink.js":
/*!*********************************!*\
  !*** ./src/plugins/autolink.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_autolink')) {
        return;
    }

    // Disables the auto URL detection feature in IE, their lacks functionality:
    // They convert the links only on space. We do on space, comma, semicolon and Enter.
    if (/MSIE ([^;]*)|Trident.*; rv:([0-9.]+)/.test(navigator.userAgent)) {
        document.execCommand('AutoUrlDetect', false, false);
    }

    var KEY_BACK = 8;

    var KEY_COMMA = 188;

    var KEY_ENTER = 13;

    var KEY_SEMICOLON = 186;

    var KEY_SPACE = 32;

    var DELIMITERS = [KEY_COMMA, KEY_ENTER, KEY_SEMICOLON, KEY_SPACE];

    var REGEX_LAST_WORD = /[^\s]+/mg;

    var REGEX_URL = /(https?\:\/\/|www\.)(-\.)?([^(\s/?\.#-)]+\.?)+(\b\/[^\s]*)?$/i;

    /**
     * CKEditor plugin which automatically generates links when user types text which looks like URL.
     *
     * @class CKEDITOR.plugins.ae_autolink
     * @constructor
     */
    CKEDITOR.plugins.add('ae_autolink', {

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers the `keyup` event on the editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'keyup', this._onKeyUp, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * Retrieves the last word introduced by the user. Reads from the current
         * caret position backwards until it finds the first white space.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _getLastWord
         * @protected
         * @return {String} The last word introduced by user
         */
        _getLastWord: function _getLastWord(editor) {
            var range = editor.getSelection().getRanges()[0];

            var offset = range.startOffset;

            var previousText = '';

            // The user pressed Enter, so we have to look on the previous node
            if (this._currentKeyCode === KEY_ENTER) {
                var previousNode = range.startContainer.getPrevious();

                var lastChild;

                if (previousNode) {
                    // If previous node is a SPACE, (it does not have 'getLast' method),
                    // ignore it and find the previous text node
                    while (!previousNode.getLast) {
                        previousNode = previousNode.getPrevious();
                    }

                    lastChild = previousNode.getLast();

                    // Depending on the browser, the last child node may be a <BR>
                    // (which does not have 'getText' method),
                    // so ignore it and find the previous text node
                    while (lastChild && !lastChild.getText()) {
                        lastChild = lastChild.getPrevious();
                    }
                }

                // Check if the lastChild is already a link
                if (!(lastChild && lastChild.$.href)) {
                    this._startContainer = lastChild;
                    previousText = lastChild ? lastChild.getText() : '';
                    this._offset = previousText.length;
                }
            } else {
                this._startContainer = range.startContainer;

                // Last character is the delimiter, ignore it
                previousText = this._startContainer.getText().substring(0, offset - 1);

                this._offset = offset - 1;
            }

            var lastWord = '';

            var match = previousText.match(REGEX_LAST_WORD);

            if (match) {
                lastWord = match.pop();
            }

            return lastWord;
        },

        /**
         * Checks if the given link is a valid URL.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method isValidURL
         * @param {String} link The link we want to know if it is a valid URL
         * @protected
         * @return {Boolean} Returns true if the link is a valid URL, false otherwise
         */
        _isValidURL: function _isValidURL(link) {
            return REGEX_URL.test(link);
        },

        /**
         * Listens to the `keydown` event and if the keycode is `Backspace`, removes the previously
         * created link.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _onKeyDown
         * @param {EventFacade} event EventFacade object
         * @protected
         */
        _onKeyDown: function _onKeyDown(event) {
            var nativeEvent = event.data.$;

            var editor = event.listenerData.editor;

            var editable = editor.editable();

            editable.removeListener('keydown', this._onKeyDown);

            if (nativeEvent.keyCode === KEY_BACK) {
                event.cancel();
                event.data.preventDefault();

                this._removeLink(editor);
            }

            this._ckLink = null;
        },

        /**
         * Listens to the `Enter` and `Space` key events in order to check if the last word
         * introduced by the user should be replaced by a link element.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _onKeyUp
         * @param {EventFacade} event EventFacade object
         * @protected
         */
        _onKeyUp: function _onKeyUp(event) {
            var nativeEvent = event.data.$;

            this._currentKeyCode = nativeEvent.keyCode;

            if (DELIMITERS.indexOf(this._currentKeyCode) !== -1) {
                var editor = event.listenerData.editor;

                var lastWord = this._getLastWord(editor);

                if (this._isValidURL(lastWord)) {
                    this._replaceContentByLink(editor, lastWord);
                }
            }
        },

        /**
         * Replaces content by a link element.
         *
         * @fires CKEDITOR.plugins.ae_autolink#autolinkAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _replaceContentByLink
         * @param {String} content The text that has to be replaced by an link element
         * @protected
         */
        _replaceContentByLink: function _replaceContentByLink(editor, content) {
            var range = editor.createRange();
            var node = CKEDITOR.dom.element.get(this._startContainer);
            var offset = this._offset;

            // Select the content, so CKEDITOR.Link can properly replace it
            range.setStart(node, offset - content.length);
            range.setEnd(node, offset);
            range.select();

            var ckLink = new CKEDITOR.Link(editor);
            ckLink.create(content);
            this._ckLink = ckLink;

            var linkNode = ckLink.getFromSelection();
            editor.fire('autolinkAdd', linkNode);

            this._subscribeToKeyEvent(editor);

            // Now range is on the link and it is selected. We have to
            // return focus to the caret position.
            range = editor.getSelection().getRanges()[0];

            // If user pressed `Enter`, get the next editable node at position 0,
            // otherwise set the cursor at the next character of the link (the white space)
            if (this._currentKeyCode === KEY_ENTER) {
                var nextEditableNode = range.getNextEditableNode();

                range.setStart(nextEditableNode, 0);
                range.setEnd(nextEditableNode, 0);
            } else {
                var nextNode = range.getNextNode();

                range.setStart(nextNode, 1);
                range.setEnd(nextNode, 1);
            }

            range.select();
        },

        /**
         * Fired when a URL is detected in text and converted to a link.
         *
         * @event CKEDITOR.plugins.ae_autolink#autolinkAdd
         * @memberof CKEDITOR.plugins.ae_autolink
         * @param {CKEDITOR.dom.element} el Node of the created link.
         */

        /**
         * Removes the created link element, and replaces it by its text.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _removeLink
         * @protected
         */
        _removeLink: function _removeLink(editor) {
            var range = editor.getSelection().getRanges()[0];
            var caretOffset = range.startOffset;

            // Select the link, so CKEDITOR.Link can properly remove it
            var linkNode = this._startContainer.getNext() || this._startContainer;

            var newRange = editor.createRange();
            newRange.setStart(linkNode, 0);
            newRange.setEndAfter(linkNode);
            newRange.select();

            this._ckLink.remove();

            // Return focus to the caret position
            range.setEnd(range.startContainer, caretOffset);
            range.setStart(range.startContainer, caretOffset);

            range.select();
        },

        /**
         * Subscribe to a key event of the editable aria.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _subscribeToKeyEvent
         * @protected
         */
        _subscribeToKeyEvent: function _subscribeToKeyEvent(editor) {
            var editable = editor.editable();

            // Change the priority of keydown listener - 1 means the highest priority.
            // In Chrome on pressing `Enter` the listener is not being invoked.
            // See http://dev.ckeditor.com/ticket/11861 for more information.
            editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
                editor: editor
            }, 1);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/autolist.js":
/*!*********************************!*\
  !*** ./src/plugins/autolist.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_autolist')) {
        return;
    }

    var KEY_BACK = 8;

    var KEY_SPACE = 32;

    var DEFAULT_CONFIG = [{
        regex: /^\*$/,
        type: 'bulletedlist'
    }, {
        regex: /^1\.$/,
        type: 'numberedlist'
    }];

    /**
        * CKEditor plugin which automatically generates ordered/unordered list when user types text which looks like a list.
        *
        * @class CKEDITOR.plugins.ae_autolist
        * @constructor
        */
    CKEDITOR.plugins.add('ae_autolist', {

        /**
         * Initialization of the plugin, part of CKeditor plugin lifecycle.
         * The function registers the `keydown` event on the content editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * Checks for pressing the `Backspace` key in order to undo the list creation.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method _checkForBackspaceAndUndo
         * @param {Event} event Event object
         * @protected
         */
        _checkForBackspaceAndUndo: function _checkForBackspaceAndUndo(event) {
            var editor = event.listenerData.editor;

            var nativeEvent = event.data.$;

            var editable = editor.editable();

            editable.removeListener('keydown', this._checkForBackspaceAndUndo);

            if (nativeEvent.keyCode === KEY_BACK) {
                editor.execCommand('undo');
                editor.insertHtml(event.listenerData.bullet + '&nbsp;');
                event.data.preventDefault();
            }
        },

        /**
         * Checks current line to find match with MATCHES object to create OL or UL.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method _checkLine
         * @param {editor} Editor object
         * @protected
         * @return {Object|null} Returns an object which contains the detected list config if any
         */
        _getListConfig: function _getListConfig(editor) {
            var configRegex = editor.config.autolist || DEFAULT_CONFIG;

            var range = editor.getSelection().getRanges()[0];

            var textContainer = range.endContainer.getText();

            var bullet = textContainer.substring(0, range.startOffset);

            var text = textContainer.substring(range.startOffset, textContainer.length);

            var index = 0;

            var regexLen = configRegex.length;

            var autolistCfg = null;

            while (!autolistCfg && regexLen > index) {
                var regexItem = configRegex[index];

                if (regexItem.regex.test(bullet)) {
                    autolistCfg = {
                        bullet: bullet,
                        editor: editor,
                        text: text,
                        type: regexItem.type
                    };

                    break;
                }

                index++;
            }

            return autolistCfg;
        },

        /**
                  * Create list with different types: Bulleted or Numbered list
                  *
                  * @instance
                  * @memberof CKEDITOR.plugins.ae_autolist
                  * @method _createList
                  * @param {Object} listConfig Object that contains bullet, text and type for creating the list
                  * @protected
         */
        _createList: function _createList(listConfig) {
            var editor = listConfig.editor;

            var range = editor.getSelection().getRanges()[0];

            range.endContainer.setText(listConfig.text);
            editor.execCommand(listConfig.type);

            var editable = editor.editable();

            // Subscribe to keydown in order to check if the next key press is `Backspace`.
            // If so, the creation of the list will be discarded.
            editable.attachListener(editable, 'keydown', this._checkForBackspaceAndUndo, this, {
                editor: editor,
                bullet: listConfig.bullet
            }, 1);
        },

        /**
                  * Listens to the `Space` key events to check if the last word
                  * introduced by the user should be replaced by a list (OL or UL)
                  *
                  * @instance
                  * @memberof CKEDITOR.plugins.ae_autolist
                  * @method _onKeyDown
                  * @param {Event} event Event object
                  * @protected
                  */
        _onKeyDown: function _onKeyDown(event) {
            var nativeEvent = event.data.$;

            if (nativeEvent.keyCode === KEY_SPACE) {
                var listConfig = this._getListConfig(event.listenerData.editor);

                if (listConfig) {
                    event.data.preventDefault();
                    this._createList(listConfig);
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/dragresize.js":
/*!***********************************!*\
  !*** ./src/plugins/dragresize.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEditor plugin: Dragable image resizing
 * https://github.com/sstur/ck-dragresize
 * - Shows semi-transparent overlay while resizing
 * - Enforces Aspect Ratio (unless holding shift)
 * - Snap to size of other images in editor
 * - Escape while dragging cancels resize
 */
(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_dragresize')) {
        return;
    }

    var IMAGE_HANDLES = {
        both: ['tl', 'tm', 'tr', 'lm', 'rm', 'bl', 'bm', 'br'],
        height: ['tl', 'tm', 'tr', 'bl', 'bm', 'br'],
        scale: ['tl', 'tr', 'bl', 'br'],
        width: ['tl', 'tr', 'lm', 'rm', 'bl', 'br']
    };

    var POSITION_ELEMENT_FN = {
        bl: function bl(handle, left, top, box) {
            positionElement(handle, -3 + left, box.height - 4 + top);
        },
        bm: function bm(handle, left, top, box) {
            positionElement(handle, Math.round(box.width / 2) - 3 + left, box.height - 4 + top);
        },
        br: function br(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, box.height - 4 + top);
        },
        lm: function lm(handle, left, top, box) {
            positionElement(handle, -3 + left, Math.round(box.height / 2) - 3 + top);
        },
        tl: function tl(handle, left, top, box) {
            positionElement(handle, left - 3, top - 3);
        },
        tm: function tm(handle, left, top, box) {
            positionElement(handle, Math.round(box.width / 2) - 3 + left, -3 + top);
        },
        tr: function tr(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, -3 + top);
        },
        rm: function rm(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
        }
    };

    var IMAGE_SNAP_TO_SIZE = 7;

    var isFirefox = 'MozAppearance' in document.documentElement.style;

    var isWebKit = 'WebkitAppearance' in document.documentElement.style;

    var enablePlugin = isWebKit || isFirefox;

    if (enablePlugin) {
        // CSS is added in a compressed form
        CKEDITOR.addCss('img::selection{color:rgba(0,0,0,0)}img.ckimgrsz{outline:1px dashed #000}#ckimgrsz{position:absolute;width:0;height:0;cursor:default;z-index:10001}#ckimgrsz span{display:none;position:absolute;top:0;left:0;width:0;height:0;background-size:100% 100%;opacity:.65;outline:1px dashed #000}#ckimgrsz i{position:absolute;display:block;width:5px;height:5px;background:#fff;border:1px solid #000}#ckimgrsz i.active,#ckimgrsz i:hover{background:#000}#ckimgrsz i.br,#ckimgrsz i.tl{cursor:nwse-resize}#ckimgrsz i.bm,#ckimgrsz i.tm{cursor:ns-resize}#ckimgrsz i.bl,#ckimgrsz i.tr{cursor:nesw-resize}#ckimgrsz i.lm,#ckimgrsz i.rm{cursor:ew-resize}body.dragging-br,body.dragging-br *,body.dragging-tl,body.dragging-tl *{cursor:nwse-resize!important}body.dragging-bm,body.dragging-bm *,body.dragging-tm,body.dragging-tm *{cursor:ns-resize!important}body.dragging-bl,body.dragging-bl *,body.dragging-tr,body.dragging-tr *{cursor:nesw-resize!important}body.dragging-lm,body.dragging-lm *,body.dragging-rm,body.dragging-rm *{cursor:ew-resize!important}');
    }

    /**
     * Initializes the plugin
     */
    CKEDITOR.plugins.add('ae_dragresize', {
        onLoad: function onLoad() {
            if (!enablePlugin) {
                return;
            }
        },
        init: function init(editor) {
            if (!enablePlugin) {
                return;
            }

            editor.once('contentDom', function (evt) {
                _init(editor);
            });
        }
    });

    function _init(editor) {
        var window = editor.window.$,
            document = editor.document.$;

        if (isFirefox) {
            // Disable the native image resizing
            document.execCommand('enableObjectResizing', false, false);
        }

        var snapToSize = typeof IMAGE_SNAP_TO_SIZE === 'undefined' ? null : IMAGE_SNAP_TO_SIZE;

        editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

        var resizer = new Resizer(editor, {
            imageScaleResize: editor.config.imageScaleResize,
            snapToSize: snapToSize
        });

        var mouseDownListener = function mouseDownListener(e) {
            if (resizer.isHandle(e.target)) {
                resizer.initDrag(e);
            }
        };

        document.addEventListener('mousedown', mouseDownListener, false);

        function selectionChange() {
            var selection = editor.getSelection();

            if (!selection) return;
            // If an element is selected and that element is an IMG
            if (selection.getType() !== CKEDITOR.SELECTION_NONE && selection.getStartElement().is('img')) {
                // And we're not right or middle clicking on the image
                if (!window.event || !window.event.button || window.event.button === 0) {
                    resizer.show(selection.getStartElement().$);
                }
            } else {
                resizer.hide();
            }
        }

        editor.on('selectionChange', selectionChange);

        editor.on('getData', function (e) {
            var html = e.data.dataValue || '';
            html = html.replace(/<div id="ckimgrsz"([\s\S]*?)<\/div>/i, '');
            html = html.replace(/\b(ckimgrsz)\b/g, '');
            e.data.dataValue = html;
        });

        editor.on('beforeUndoImage', function () {
            // Remove the handles before undo images are saved
            resizer.hide();
        });

        editor.on('afterUndoImage', function () {
            // Restore the handles after undo images are saved
            selectionChange();
        });

        editor.on('blur', function () {
            // Remove the handles when editor loses focus
            resizer.hide();
        });

        editor.on('beforeModeUnload', function self() {
            editor.removeListener('beforeModeUnload', self);
            resizer.hide();
        });

        editor.on('destroy', function () {
            var resizeElement = document.getElementById('ckimgrsz');

            if (resizeElement) {
                resizeElement.remove();
            }

            if (isFirefox) {
                document.execCommand('enableObjectResizing', false, true);
            }

            document.removeEventListener('mousedown', mouseDownListener);
        });

        // Update the selection when the browser window is resized
        var resizeTimeout;
        editor.window.on('resize', function () {
            // Cancel any resize waiting to happen
            clearTimeout(resizeTimeout);
            // Delay resize to "debounce"
            resizeTimeout = setTimeout(selectionChange, 50);
        });
    }

    function Resizer(editor, cfg) {
        this.editor = editor;
        this.window = editor.window.$;
        this.document = editor.document.$;
        this.cfg = cfg || {};
        this.init();
    }

    Resizer.prototype = {
        init: function init() {
            var instance = this;

            var container = this.container = this.document.createElement('div');

            container.id = 'ckimgrsz';
            this.preview = this.document.createElement('span');
            container.appendChild(this.preview);

            var handles = this.handles = {};

            IMAGE_HANDLES[this.cfg.imageScaleResize].forEach(function (handleName, index) {
                handles[handleName] = instance.handles[handleName] = instance.createHandle(handleName);
            });

            for (var n in handles) {
                container.appendChild(handles[n]);
            }
        },
        createHandle: function createHandle(name) {
            var el = this.document.createElement('i');
            el.classList.add(name);
            return el;
        },
        isHandle: function isHandle(el) {
            var handles = this.handles;
            for (var n in handles) {
                if (handles[n] === el) {
                    return true;
                }
            }
            return false;
        },
        show: function show(el) {
            this.el = el;
            if (this.cfg.snapToSize) {
                this.otherImages = toArray(this.document.getElementsByTagName('img'));
                this.otherImages.splice(this.otherImages.indexOf(el), 1);
            }
            var box = this.box = getBoundingBox(this.window, el);
            positionElement(this.container, box.left, box.top);
            this.document.body.appendChild(this.container);
            this.el.classList.add('ckimgrsz');
            this.showHandles();
        },
        hide: function hide() {
            // Remove class from all img.ckimgrsz
            var elements = this.document.getElementsByClassName('ckimgrsz');
            for (var i = 0; i < elements.length; ++i) {
                elements[i].classList.remove('ckimgrsz');
            }
            this.hideHandles();
            if (this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
            }
        },
        initDrag: function initDrag(e) {
            if (e.button !== 0) {
                //right-click or middle-click
                return;
            }
            var resizer = this;
            var drag = new DragEvent(this.window, this.document);
            drag.onStart = function () {
                resizer.showPreview();
                resizer.isDragging = true;
                resizer.editor.getSelection().lock();
            };
            drag.onDrag = function () {
                resizer.calculateSize(this);
                resizer.updatePreview();
                var box = resizer.previewBox;
                resizer.updateHandles(box, box.left, box.top);
            };
            drag.onRelease = function () {
                resizer.isDragging = false;
                resizer.hidePreview();
                resizer.hide();
                resizer.editor.getSelection().unlock();
                // Save an undo snapshot before the image is permanently changed
                resizer.editor.fire('saveSnapshot');
            };
            drag.onComplete = function () {
                resizer.resizeComplete();
                // Save another snapshot after the image is changed
                resizer.editor.fire('saveSnapshot');
            };
            drag.start(e);
        },
        updateHandles: function updateHandles(box, left, top) {
            left = left || 0;
            top = top || 0;
            var handles = this.handles;

            for (var handle in handles) {
                POSITION_ELEMENT_FN[handle](handles[handle], left, top, box);
            }
        },
        showHandles: function showHandles() {
            var handles = this.handles;
            this.updateHandles(this.box);
            for (var n in handles) {
                handles[n].style.display = 'block';
            }
        },
        hideHandles: function hideHandles() {
            var handles = this.handles;
            for (var n in handles) {
                handles[n].style.display = 'none';
            }
        },
        showPreview: function showPreview() {
            this.preview.style.backgroundImage = 'url("' + this.el.src + '")';
            this.calculateSize();
            this.updatePreview();
            this.preview.style.display = 'block';
        },
        updatePreview: function updatePreview() {
            var box = this.previewBox;
            positionElement(this.preview, box.left, box.top);
            this.preview.style.width = this.previewBox.width + 'px';
            this.preview.style.height = this.previewBox.height + 'px';
        },
        hidePreview: function hidePreview() {
            var box = getBoundingBox(this.window, this.preview);
            this.result = {
                width: box.width,
                height: box.height
            };
            this.preview.style.display = 'none';
        },
        calculateSize: function calculateSize(data) {
            var box = this.previewBox = {
                top: 0,
                left: 0,
                width: this.box.width,
                height: this.box.height
            };

            if (!data) return;

            var attr = data.target.className;

            if (~attr.indexOf('r')) {
                box.width = Math.max(32, this.box.width + data.delta.x);
            }
            if (~attr.indexOf('b')) {
                box.height = Math.max(32, this.box.height + data.delta.y);
            }
            if (~attr.indexOf('l')) {
                box.width = Math.max(32, this.box.width - data.delta.x);
            }
            if (~attr.indexOf('t')) {
                box.height = Math.max(32, this.box.height - data.delta.y);
            }
            //if dragging corner, enforce aspect ratio (unless shift key is being held)
            if (attr.indexOf('m') < 0 && !data.keys.shift) {
                var ratio = this.box.width / this.box.height;
                if (box.width / box.height > ratio) {
                    box.height = Math.round(box.width / ratio);
                } else {
                    box.width = Math.round(box.height * ratio);
                }
            }

            var snapToSize = this.cfg.snapToSize;

            if (snapToSize) {
                var others = this.otherImages;
                for (var i = 0; i < others.length; i++) {
                    var other = getBoundingBox(this.window, others[i]);
                    if (Math.abs(box.width - other.width) <= snapToSize && Math.abs(box.height - other.height) <= snapToSize) {
                        box.width = other.width;
                        box.height = other.height;
                        break;
                    }
                }
            }

            //recalculate left or top position
            if (~attr.indexOf('l')) {
                box.left = this.box.width - box.width;
            }
            if (~attr.indexOf('t')) {
                box.top = this.box.height - box.height;
            }
        },
        resizeComplete: function resizeComplete() {
            resizeElement.call(this, this.el, this.result.width, this.result.height);
        }
    };

    function DragEvent(window, document) {
        this.window = window;
        this.document = document;
        this.events = {
            mousemove: bind(this.mousemove, this),
            keydown: bind(this.keydown, this),
            mouseup: bind(this.mouseup, this)
        };
    }

    DragEvent.prototype = {
        start: function start(e) {
            e.preventDefault();
            e.stopPropagation();
            this.target = e.target;
            this.attr = e.target.className;
            this.startPos = {
                x: e.clientX,
                y: e.clientY
            };
            this.update(e);
            var events = this.events;
            this.document.addEventListener('mousemove', events.mousemove, false);
            this.document.addEventListener('keydown', events.keydown, false);
            this.document.addEventListener('mouseup', events.mouseup, false);
            this.document.body.classList.add('dragging-' + this.attr);
            this.onStart && this.onStart();
        },
        update: function update(e) {
            this.currentPos = {
                x: e.clientX,
                y: e.clientY
            };
            this.delta = {
                x: e.clientX - this.startPos.x,
                y: e.clientY - this.startPos.y
            };
            this.keys = {
                shift: e.shiftKey,
                ctrl: e.ctrlKey,
                alt: e.altKey
            };
        },
        mousemove: function mousemove(e) {
            this.update(e);
            this.onDrag && this.onDrag();
            if (e.which === 0) {
                //mouse button released outside window; mouseup wasn't fired (Chrome)
                this.mouseup(e);
            }
        },
        keydown: function keydown(e) {
            //escape key cancels dragging
            if (e.keyCode === 27) {
                this.release();
            }
        },
        mouseup: function mouseup(e) {
            this.update(e);
            this.release();
            this.onComplete && this.onComplete();
        },
        release: function release() {
            this.document.body.classList.remove('dragging-' + this.attr);
            var events = this.events;
            this.document.removeEventListener('mousemove', events.mousemove, false);
            this.document.removeEventListener('keydown', events.keydown, false);
            this.document.removeEventListener('mouseup', events.mouseup, false);
            this.onRelease && this.onRelease();
        }
    };

    //helper functions
    function toArray(obj) {
        var len = obj.length,
            arr = new Array(len);
        for (var i = 0; i < len; i++) {
            arr[i] = obj[i];
        }
        return arr;
    }

    function bind(fn, ctx) {
        if (fn.bind) {
            return fn.bind(ctx);
        }
        return function () {
            fn.apply(ctx, arguments);
        };
    }

    function positionElement(el, left, top) {
        el.style.left = String(left) + 'px';
        el.style.top = String(top) + 'px';
    }

    function resizeElement(el, width, height) {
        var imageScaleResize = this.editor.config.imageScaleResize;
        if (imageScaleResize === 'both') {
            el.style.width = String(width) + 'px';
            el.style.height = String(height) + 'px';
        } else if (imageScaleResize === 'width' || imageScaleResize === 'scale') {
            el.style.height = 'auto';
            el.style.width = String(width) + 'px';
        } else if (imageScaleResize === 'height') {
            el.style.height = String(height) + 'px';
            el.style.width = 'auto';
        }
    }

    function getBoundingBox(window, el) {
        var rect = el.getBoundingClientRect();
        return {
            left: rect.left + window.pageXOffset,
            top: rect.top + window.pageYOffset,
            width: rect.width,
            height: rect.height
        };
    }
})();

/***/ }),

/***/ "./src/plugins/dragresize_ie.js":
/*!**************************************!*\
  !*** ./src/plugins/dragresize_ie.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEditor plugin: Image2
 * - Show gripper to resize images on IE
 */
(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_dragresize_ie')) {
        return;
    }

    var alignmentsObj = {
        center: 1,
        left: 0,
        right: 2
    };

    /*
     * Set cursor css depend on imageScaleResize config
     **/

    var cursor = {
        both: 'nwse-resize',
        height: 'ns-resize',
        scale: 'nwse-resize',
        width: 'ew-resize'
    };

    var regexPercent = /^\s*(\d+\%)\s*$/i;

    var template = '<img alt="" src="" />';

    CKEDITOR.plugins.add('ae_dragresize_ie', {
        hidpi: true,

        icons: 'image',

        init: function init(editor) {
            var image = widgetDef(editor);

            // Register the widget.
            editor.widgets.add('image', image);
        },

        onLoad: function onLoad() {
            CKEDITOR.addCss('.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ns-resize{' + 'cursor: ns-resize;' + '}' + '.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ew-resize{' + 'cursor: ew-resize;' + '}' + '.cke_image_nocaption{' +
            // This is to remove unwanted space so resize
            // wrapper is displayed property.
            'line-height:0' + '}' + '.cke_image_resizer{' + 'display:none;' + 'position:absolute;' + 'width:10px;' + 'height:10px;' + 'bottom:-5px;' + 'right:-5px;' + 'background:#000;' + 'outline:1px solid #fff;' +
            // Prevent drag handler from being misplaced (#11207).
            'line-height:0;' + 'cursor:nwse-resize;' + '}' + '.cke_image_resizer_wrapper{' + 'position:relative;' + 'display:inline-block;' + 'line-height:0;' + '}' + '.cke_widget_wrapper:hover .cke_image_resizer,' + '.cke_image_resizer.cke_image_resizing{' + 'display:block' + '}');
        },

        requires: 'widget'
    });

    // Wiget states (forms) depending on alignment and configuration.
    //
    // Non-captioned widget (inline styles)
    // 		
    // 		Align Internal form                  Data                         
    // 		
    // 		none  <wrapper>                      <img />                      
    // 		       <img />                                                    
    // 		      </wrapper>                                                  
    // 		
    // 		left  <wrapper style=float:left>   <img style=float:left />   
    // 		       <img />                                                    
    // 		      </wrapper>                                                  
    // 		
    // 		center<wrapper>                      <p style=text-align:center>
    // 		       <p style=text-align:center>   <img />                    
    // 		         <img />                     </p>                         
    // 		       </p>                                                       
    // 		      </wrapper>                                                  
    // 		
    // 		right <wrapper style=float:right>  <img style=float:right />  
    // 		       <img />                                                    
    // 		      </wrapper>                                                  
    // 		
    //
    // Non-captioned widget (config.image2_alignClasses defined)
    // 		
    // 		Align Internal form                  Data                         
    // 		
    // 		none  <wrapper>                      <img />                      
    // 		       <img />                                                    
    // 		      </wrapper>                                                  
    // 		
    // 		left  <wrapper class=left>         <img class=left />         
    // 		       <img />                                                    
    // 		      </wrapper>                                                  
    // 		
    // 		center<wrapper>                      <p class=center>           
    // 		       <p class=center>             <img />                     
    // 		         <img />                     </p>                         
    // 		       </p>                                                       
    // 		      </wrapper>                                                  
    // 		
    // 		right <wrapper class=right>        <img class=right />        
    // 		       <img />                                                    
    // 		      </wrapper>                                                  
    // 		
    //
    // Captioned widget (inline styles)
    // 		
    // 		Align Internal form                           Data                                    
    // 		
    // 		none  <wrapper>                               <figure />                              
    // 		       <figure />                                                                     
    // 		      </wrapper>                                                                      
    // 		
    // 		left  <wrapper style=float:left>            <figure style=float:left />           
    // 		       <figure />                                                                     
    // 		      </wrapper>                                                                      
    // 		
    // 		center<wrapper style=text-align:center>     <div style=text-align:center>         
    // 		       <figure style=display:inline-block /> <figure style=display:inline-block />
    // 		      </wrapper>                              </p>                                    
    // 		
    // 		right <wrapper style=float:right>           <figure style=float:right />          
    // 		       <figure />                                                                     
    // 		      </wrapper>                                                                      
    // 		
    //
    // Captioned widget (config.image2_alignClasses defined)
    // 		
    // 		Align Internal form                           Data                                    
    // 		
    // 		none  <wrapper>                               <figure />                              
    // 		       <figure />                                                                     
    // 		      </wrapper>                                                                      
    // 		
    // 		left  <wrapper class=left>                  <figure class=left />                 
    // 		       <figure />                                                                     
    // 		      </wrapper>                                                                      
    // 		
    // 		center<wrapper class=center>                <div class=center>                    
    // 		       <figure />                              <figure />                             
    // 		      </wrapper>                              </p>                                    
    // 		
    // 		right <wrapper class=right>                 <figure class=right />                
    // 		       <figure />                                                                     
    // 		      </wrapper>                                                                      
    // 		
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function widgetDef(editor) {
        editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

        editor.on('imageAdd', function (imageData) {
            editor.widgets.initOn(imageData.data.el, 'image');
        });

        var alignClasses = editor.config.image2_alignClasses;

        var captionedClass = editor.config.image2_captionedClass;

        return {
            init: function init() {
                var helpers = CKEDITOR.plugins.image2;

                var image = this.parts.image;

                var data = {
                    alt: image.getAttribute('alt') || '',
                    hasCaption: !!this.parts.caption,
                    height: image.getAttribute('height') || '',
                    // Lock ratio is on by default (#10833).
                    lock: this.ready ? helpers.checkHasNaturalRatio(image) : true,
                    src: image.getAttribute('src'),
                    width: image.getAttribute('width') || ''
                };

                // If we used 'a' in widget#parts definition, it could happen that
                // selected element is a child of widget.parts#caption. Since there's no clever
                // way to solve it with CSS selectors, it's done like that. (#11783).
                var link = image.getAscendant('a');

                if (link && this.wrapper.contains(link)) {
                    this.parts.link = link;
                }

                // Depending on configuration, read style/class from element and
                // then remove it. Removed style/class will be set on wrapper in #data listener.
                // Note: Center alignment is detected during upcast, so only left/right cases
                // are checked below.
                if (!data.align) {
                    var alignElement = data.hasCaption ? this.element : image;

                    // Read the initial left/right alignment from the class set on element.
                    if (alignClasses) {
                        if (alignElement.hasClass(alignClasses[0])) {
                            data.align = 'left';
                        } else if (alignElement.hasClass(alignClasses[2])) {
                            data.align = 'right';
                        }

                        if (data.align) {
                            alignElement.removeClass(alignClasses[alignmentsObj[data.align]]);
                        } else {
                            data.align = 'none';
                        }
                    }
                    // Read initial float style from figure/image and then remove it.
                    else {
                            data.align = alignElement.getStyle('float') || 'none';
                            alignElement.removeStyle('float');
                        }
                }

                // Get rid of extra vertical space when there's no caption.
                // It will improve the look of the resizer.
                this.wrapper[(data.hasCaption ? 'remove' : 'add') + 'Class']('cke_image_nocaption');

                this.setData(data);

                if (editor.config.image2_disableResizer !== true) {
                    setupResizer(this);
                }
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#addClass
            addClass: function addClass(className) {
                getStyleableElement(this).addClass(className);
            },

            allowedContent: getWidgetAllowedContent(editor),

            // This widget converts style-driven dimensions to attributes.
            contentTransformations: [['img[width]: sizeToAttribute']],

            data: function data() {
                var features = this.features;

                // Image can't be captioned when figcaption is disallowed (#11004).
                if (this.data.hasCaption && !editor.filter.checkFeature(features.caption)) {
                    this.data.hasCaption = false;
                }

                // Image can't be aligned when floating is disallowed (#11004).
                if (this.data.align != 'none' && !editor.filter.checkFeature(features.align)) {
                    this.data.align = 'none';
                }

                // Update widget.parts.link since it will not auto-update unless widget
                // is destroyed and re-inited.
                if (!this.data.link) {
                    if (this.parts.link) {
                        delete this.parts.link;
                    }
                } else {
                    if (!this.parts.link) {
                        this.parts.link = this.parts.image.getParent();
                    }
                }

                this.parts.image.setAttributes({
                    alt: this.data.alt,

                    contenteditable: this.parts.image.getAttribute('contenteditable') ? this.parts.image.getAttribute('contenteditable') : true,

                    // This internal is required by the editor.
                    'data-cke-saved-src': this.data.src,

                    src: this.data.src
                });

                // If shifting non-captioned -> captioned, remove classes
                // related to styles from <img/>.
                if (this.oldData && !this.oldData.hasCaption && this.data.hasCaption) {
                    for (var c in this.data.classes) {
                        this.parts.image.removeClass(c);
                    }
                }

                // Set dimensions of the image according to gathered data.
                // Do it only when the attributes are allowed (#11004).
                if (editor.filter.checkFeature(features.dimension)) {
                    setDimensions(this);
                }

                // Cache current data.
                this.oldData = CKEDITOR.tools.extend({}, this.data);
            },

            downcast: downcastWidgetElement(editor),

            draggable: false,

            // This widget has an editable caption.
            editables: {
                caption: {
                    selector: 'figcaption',
                    allowedContent: 'br em strong sub sup u s; a[!href,target]'
                }
            },

            features: getWidgetFeatures(editor),

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#getClasses
            getClasses: function () {
                var classRegex = new RegExp('^(' + [].concat(captionedClass, alignClasses).join('|') + ')$');

                return function () {
                    var classes = this.repository.parseElementClasses(getStyleableElement(this).getAttribute('class'));

                    // Neither config.image2_captionedClass nor config.image2_alignClasses
                    // do not belong to style classes.
                    for (var c in classes) {
                        if (classRegex.test(c)) {
                            delete classes[c];
                        }
                    }

                    return classes;
                };
            }(),

            getLabel: function getLabel() {
                var label = (this.data.alt || '') + ' ' + this.pathName;

                return label;
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#hasClass
            hasClass: function hasClass(className) {
                return getStyleableElement(this).hasClass(className);
            },

            parts: {
                caption: 'figcaption',
                image: 'img'
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#removeClass
            removeClass: function removeClass(className) {
                getStyleableElement(this).removeClass(className);
            },

            requiredContent: 'img[src,alt]',

            styleableElements: 'img figure',

            // Template of the widget: plain image.
            template: template,

            upcast: upcastWidgetElement(editor)
        };
    }

    /**
     * A set of Enhanced Image (image2) plugin helpers.
     *
     * @class
     * @singleton
     */
    CKEDITOR.plugins.image2 = {
        /**
         * Checks whether the current image ratio matches the natural one
         * by comparing dimensions.
         *
         * @param {CKEDITOR.dom.element} image
         * @returns {Boolean}
         */
        checkHasNaturalRatio: function checkHasNaturalRatio(image) {
            var $ = image.$,
                natural = this.getNatural(image);

            // The reason for two alternative comparisons is that the rounding can come from
            // both dimensions, e.g. there are two cases:
            // 	1. height is computed as a rounded relation of the real height and the value of width,
            //	2. width is computed as a rounded relation of the real width and the value of heigh.
            return Math.round($.clientWidth / natural.width * natural.height) == $.clientHeight || Math.round($.clientHeight / natural.height * natural.width) == $.clientWidth;
        },

        /**
         * Returns natural dimensions of the image. For modern browsers
         * it uses natural(Width|Height). For old ones (IE8) it creates
         * a new image and reads the dimensions.
         *
         * @param {CKEDITOR.dom.element} image
         * @returns {Object}
         */
        getNatural: function getNatural(image) {
            var dimensions;

            if (image.$.naturalWidth) {
                dimensions = {
                    height: image.$.naturalHeigh,
                    width: image.$.naturalWidth
                };
            } else {
                var img = new Image();

                img.src = image.getAttribute('src');

                dimensions = {
                    height: img.heigh,
                    width: img.width
                };
            }

            return dimensions;
        }
    };

    // Returns a function that creates widgets from all <img> and
    // <figure class="{config.image2_captionedClass}"> elements.
    //
    // @param {CKEDITOR.editor} editor
    // @returns {Function}
    function upcastWidgetElement(editor) {
        var isCenterWrapper = centerWrapperChecker(editor);

        var captionedClass = editor.config.image2_captionedClass;

        // @param {CKEDITOR.htmlParser.element} el
        // @param {Object} data
        return function (el, data) {
            var dimensions = {
                height: 1,
                width: 1
            };

            var name = el.name;

            var image;

            // #11110 Don't initialize on pasted fake objects.
            if (el.attributes['data-cke-realelement']) {
                return;
            }

            // If a center wrapper is found, there are 3 possible cases:
            //
            // 1. <div style="text-align:center"><figure>...</figure></div>.
            //    In this case centering is done with a class set on widget.wrapper.
            //    Simply replace centering wrapper with figure (it's no longer necessary).
            //
            // 2. <p style="text-align:center"><img/></p>.
            //    Nothing to do here: <p> remains for styling purposes.
            //
            // 3. <div style="text-align:center"><img/></div>.
            //    Nothing to do here (2.) but that case is only possible in enterMode different
            //    than ENTER_P.
            if (isCenterWrapper(el)) {
                if (name == 'div') {
                    var figure = el.getFirst('figure');

                    // Case #1.
                    if (figure) {
                        el.replaceWith(figure);
                        el = figure;
                    }
                }
                // Cases #2 and #3 (handled transparently)

                // If there's a centering wrapper, save it in data.
                data.align = 'center';

                // Image can be wrapped in link <a><img/></a>.
                image = el.getFirst('img') || el.getFirst('a').getFirst('img');
            }

            // No center wrapper has been found.
            else if (name == 'figure' && el.hasClass(captionedClass)) {
                    image = el.getFirst('img') || el.getFirst('a').getFirst('img');

                    // Upcast linked image like <a><img/></a>.
                } else if (isLinkedOrStandaloneImage(el)) {
                    image = el.name == 'a' ? el.children[0] : el;
                }

            if (!image) {
                return;
            }

            // If there's an image, then cool, we got a widget.
            // Now just remove dimension attributes expressed with %.
            for (var d in dimensions) {
                var dimension = image.attributes[d];

                if (dimension && dimension.match(regexPercent)) {
                    delete image.attributes[d];
                }
            }

            return el;
        };
    }

    // Returns a function which transforms the widget to the external format
    // according to the current configuration.
    //
    // @param {CKEDITOR.editor}
    function downcastWidgetElement(editor) {
        var alignClasses = editor.config.image2_alignClasses;

        // @param {CKEDITOR.htmlParser.element} el
        return function (el) {
            // In case of <a><img/></a>, <img/> is the element to hold
            // inline styles or classes (image2_alignClasses).
            var attrsHolder = el.name == 'a' ? el.getFirst() : el;

            var attrs = attrsHolder.attributes;

            var align = this.data.align;

            // De-wrap the image from resize handle wrapper.
            // Only block widgets have one.
            if (!this.inline) {
                var resizeWrapper = el.getFirst('span');

                if (resizeWrapper) {
                    resizeWrapper.replaceWith(resizeWrapper.getFirst({
                        a: 1,
                        img: 1
                    }));
                }
            }

            if (align && align != 'none') {
                var styles = CKEDITOR.tools.parseCssText(attrs.style || '');

                // When the widget is captioned (<figure>) and internally centering is done
                // with widget's wrapper style/class, in the external data representation,
                // <figure> must be wrapped with an element holding an style/class:
                //
                // 	<div style="text-align:center">
                // 		<figure class="image" style="display:inline-block">...</figure>
                // 	</div>
                // or
                // 	<div class="some-center-class">
                // 		<figure class="image">...</figure>
                // 	</div>
                //
                if (align == 'center' && el.name == 'figure') {
                    el = el.wrapWith(new CKEDITOR.htmlParser.element('div', alignClasses ? {
                        'class': alignClasses[1]
                    } : {
                        style: 'text-align:center'
                    }));
                }

                // If left/right, add float style to the downcasted element.
                else if (align in {
                        left: 1,
                        right: 1
                    }) {
                        if (alignClasses) {
                            attrsHolder.addClass(alignClasses[alignmentsObj[align]]);
                        } else {
                            styles['float'] = align;
                        }
                    }

                // Update element styles.
                if (!alignClasses && !CKEDITOR.tools.isEmpty(styles)) {
                    attrs.style = CKEDITOR.tools.writeCssText(styles);
                }
            }

            return el;
        };
    }

    // Returns a function that checks if an element is a centering wrapper.
    //
    // @param {CKEDITOR.editor} editor
    // @returns {Function}
    function centerWrapperChecker(editor) {
        var captionedClass = editor.config.image2_captionedClass;

        var alignClasses = editor.config.image2_alignClasses;

        var validChildren = {
            a: 1,
            figure: 1,
            img: 1
        };

        return function (el) {
            // Wrapper must be either <div> or <p>.
            if (!(el.name in {
                div: 1,
                p: 1
            })) {
                return false;
            }

            var children = el.children;

            // Centering wrapper can have only one child.
            if (children.length !== 1) {
                return false;
            }

            var child = children[0];

            // Only <figure> or <img /> can be first (only) child of centering wrapper,
            // regardless of its type.
            if (!(child.name in validChildren)) {
                return false;
            }

            // If centering wrapper is <p>, only <img /> can be the child.
            //   <p style="text-align:center"><img /></p>
            if (el.name == 'p') {
                if (!isLinkedOrStandaloneImage(child)) {
                    return false;
                }
            }
            // Centering <div> can hold <img/> or <figure>, depending on enterMode.
            else {
                    // If a <figure> is the first (only) child, it must have a class.
                    //   <div style="text-align:center"><figure>...</figure><div>
                    if (child.name == 'figure') {
                        if (!child.hasClass(captionedClass)) {
                            return false;
                        }
                    } else {
                        // Centering <div> can hold <img/> or <a><img/></a> only when enterMode
                        // is ENTER_(BR|DIV).
                        //   <div style="text-align:center"><img /></div>
                        //   <div style="text-align:center"><a><img /></a></div>
                        if (editor.enterMode == CKEDITOR.ENTER_P) {
                            return false;
                        }

                        // Regardless of enterMode, a child which is not <figure> must be
                        // either <img/> or <a><img/></a>.
                        if (!isLinkedOrStandaloneImage(child)) {
                            return false;
                        }
                    }
                }

            // Centering wrapper got to be... centering. If image2_alignClasses are defined,
            // check for centering class. Otherwise, check the style.
            if (alignClasses ? el.hasClass(alignClasses[1]) : CKEDITOR.tools.parseCssText(el.attributes.style || '', true)['text-align'] == 'center') {
                return true;
            }

            return false;
        };
    }

    // Checks whether element is <img/> or <a><img/></a>.
    //
    // @param {CKEDITOR.htmlParser.element}
    function isLinkedOrStandaloneImage(el) {
        if (el.name == 'img') {
            return true;
        } else if (el.name == 'a') {
            return el.children.length == 1 && el.getFirst('img');
        }

        return false;
    }

    // Sets width and height of the widget image according to current widget data.
    //
    // @param {CKEDITOR.plugins.widget} widget
    function setDimensions(widget) {
        var data = widget.data;

        var dimensions = {
            height: data.height,
            width: data.width
        };

        var image = widget.parts.image;

        for (var d in dimensions) {
            if (dimensions[d]) {
                image.setAttribute(d, dimensions[d]);
            } else {
                image.removeAttribute(d);
            }
        }
    }

    // Defines all features related to drag-driven image resizing.
    //
    // @param {CKEDITOR.plugins.widget} widget
    function setupResizer(widget) {
        var editor = widget.editor;

        var editable = editor.editable();

        var doc = editor.document;

        // Store the resizer in a widget for testing (#11004).
        var resizer = widget.resizer = doc.createElement('span');

        resizer.addClass('cke_image_resizer');
        resizer.addClass('cke_image_resizer_' + cursor[editor.config.imageScaleResize]);
        resizer.append(new CKEDITOR.dom.text('\u200B', doc));

        // Inline widgets don't need a resizer wrapper as an image spans the entire widget.
        if (!widget.inline) {
            var imageOrLink = widget.parts.link || widget.parts.image;

            var oldResizeWrapper = imageOrLink.getParent();

            var resizeWrapper = doc.createElement('span');

            resizeWrapper.addClass('cke_image_resizer_wrapper');
            resizeWrapper.append(imageOrLink);
            resizeWrapper.append(resizer);
            widget.element.append(resizeWrapper, true);

            // Remove the old wrapper which could came from e.g. pasted HTML
            // and which could be corrupted (e.g. resizer span has been lost).
            if (oldResizeWrapper.is('span')) {
                oldResizeWrapper.remove();
            }
        } else {
            widget.wrapper.append(resizer);
        }

        // Calculate values of size variables and mouse offsets.
        resizer.on('mousedown', function (evt) {
            var image = widget.parts.image;

            // "factor" can be either 1 or -1. I.e.: For right-aligned images, we need to
            // subtract the difference to get proper width, etc. Without "factor",
            // resizer starts working the opposite way.
            var factor = widget.data.align == 'right' ? -1 : 1;

            // The x-coordinate of the mouse relative to the screen
            // when button gets pressed.
            var startX = evt.data.$.screenX;

            var startY = evt.data.$.screenY;

            // The initial dimensions and aspect ratio of the image.
            var startWidth = image.$.clientWidth;

            var startHeight = image.$.clientHeight;

            var listeners = [];

            // A class applied to editable during resizing.
            var cursorClass = 'cke_image_s' + (!~factor ? 'w' : 'e');

            var nativeEvt, newWidth, newHeight, updateData;

            var moveDiffX, moveDiffY, moveRatio;

            // Save the undo snapshot first: before resizing.
            editor.fire('saveSnapshot');

            // Mousemove listeners are removed on mouseup.
            attachToDocuments('mousemove', onMouseMove, listeners);

            // Clean up the mousemove listener. Update widget data if valid.
            attachToDocuments('mouseup', onMouseUp, listeners);

            // The entire editable will have the special cursor while resizing goes on.
            editable.addClass(cursorClass);

            // This is to always keep the resizer element visible while resizing.
            resizer.addClass('cke_image_resizing');

            // Attaches an event to a global document if inline editor.
            // Additionally, if classic (`iframe`-based) editor, also attaches the same event to `iframe`'s document.
            function attachToDocuments(name, callback, collection) {
                var globalDoc = CKEDITOR.document;

                var listeners = [];

                if (!doc.equals(globalDoc)) {
                    listeners.push(globalDoc.on(name, callback));
                }

                listeners.push(doc.on(name, callback));

                if (collection) {
                    for (var i = listeners.length; i--;) {
                        collection.push(listeners.pop());
                    }
                }
            }

            // This is how variables refer to the geometry.
            // Note: x corresponds to moveOffset, this is the position of mouse
            // Note: o corresponds to [startX, startY].
            //
            // 	+--------------+--------------+
            // 	|              |              |
            // 	|      I       |      II      |
            // 	|              |              |
            // 	+------------- o -------------+ _ _ _
            // 	|              |              |      ^

            // 	|      VI      |     III      |      | moveDiffY
            // 	|              |         x _ _ _ _ _ v
            // 	+--------------+---------|----+
            // 	               |         |
            // 	                <------->
            // 	                moveDiffX
            function onMouseMove(evt) {
                var imageScaleResize = editor.config.imageScaleResize;

                nativeEvt = evt.data.$;

                // This is how far the mouse is from the point the button was pressed.
                moveDiffX = nativeEvt.screenX - startX;
                moveDiffY = startY - nativeEvt.screenY;

                // This is the aspect ratio of the move difference.
                moveRatio = Math.abs(moveDiffX / moveDiffY);

                if (imageScaleResize === 'width' || imageScaleResize === 'both' || imageScaleResize === 'scale') {
                    newWidth = startWidth + factor * moveDiffX;
                }

                if (imageScaleResize === 'height' || imageScaleResize === 'both') {
                    newHeight = startHeight - moveDiffY;
                }

                if (imageScaleResize === 'scale') {
                    newHeight = 'auto';
                }

                newWidth = newWidth || startWidth;
                newHeight = newHeight || startHeight;

                // Don't update attributes if less than 10.
                // This is to prevent images to visually disappear.
                if (newWidth >= 15 && (newHeight >= 15 || newHeight === 'auto')) {
                    image.setAttributes({
                        width: newWidth,
                        height: newHeight
                    });
                    updateData = true;
                } else {
                    updateData = false;
                }
            }

            function onMouseUp() {
                var l;

                while (l = listeners.pop()) {
                    l.removeListener();
                }

                // Restore default cursor by removing special class.
                editable.removeClass(cursorClass);

                // This is to bring back the regular behaviour of the resizer.
                resizer.removeClass('cke_image_resizing');

                if (updateData) {
                    widget.setData({
                        height: newHeight,
                        width: newWidth
                    });

                    // Save another undo snapshot: after resizing.
                    editor.fire('saveSnapshot');
                }

                // Don't update data twice or more.
                updateData = false;
            }
        });

        // Change the position of the widget resizer when data changes.
        widget.on('data', function () {
            resizer[widget.data.align == 'right' ? 'addClass' : 'removeClass']('cke_image_resizer_left');
        });

        widget.parts.image.on('click', function () {

            editor._.editable.editor.getSelection().selectElement(this);

            var selectionData = editor._.editable.editor.getSelectionData();
            if (selectionData) {
                editor.fire('editorInteraction', {
                    nativeEvent: event,
                    selectionData: selectionData
                });
            }
        });
    }

    // Returns a set of widget allowedContent rules, depending
    // on configurations like config#image2_alignClasses or
    // config#image2_captionedClass.
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function getWidgetAllowedContent(editor) {
        var rules = {
            figcaption: true,
            figure: {
                classes: '!' + editor.config.image2_captionedClass
            },
            img: {
                attributes: '!src,alt,width,height'
            }
        };

        return rules;
    }

    // Returns a set of widget feature rules, depending
    // on editor configuration. Note that the following may not cover
    // all the possible cases since requiredContent supports a single
    // tag only.
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function getWidgetFeatures(editor) {
        var alignClasses = editor.config.image2_alignClasses;

        var features = {
            align: {
                requiredContent: 'img' + (alignClasses ? '(' + alignClasses[0] + ')' : '{float}')
            },
            caption: {
                requiredContent: 'figcaption'
            },
            dimension: {
                requiredContent: 'img[width,height]'
            }
        };

        return features;
    }

    // Returns element which is styled, considering current
    // state of the widget.
    //
    // @see CKEDITOR.plugins.widget#applyStyle
    // @param {CKEDITOR.plugins.widget} widget
    // @returns {CKEDITOR.dom.element}
    function getStyleableElement(widget) {
        return widget.data.hasCaption ? widget.element : widget.parts.image;
    }
})();

CKEDITOR.config.image2_captionedClass = 'image';

/***/ }),

/***/ "./src/plugins/embed.js":
/*!******************************!*\
  !*** ./src/plugins/embed.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_embed')) {
        return;
    }

    var REGEX_HTTP = /^https?/;

    var REGEX_DEFAULT_LINK = /<a href=/;

    var PROVIDERS = ['youtube', 'twitter'];

    CKEDITOR.DEFAULT_AE_EMBED_URL_TPL = 'http://alloy.iframe.ly/api/oembed?url={url}&callback={callback}';
    CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL = '<div data-ae-embed-url="{url}"></div>';
    CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL = '<a href="{url}">{url}</a>';
    /**
     * CKEditor plugin which adds the infrastructure to embed urls as media objects using an oembed
     * service. By default, and for demoing purposes only, the oembed service is hosted in iframe.ly
     * at //alloy.iframe.ly/api/oembed?url={url}&callback={callback}. Note this should be changed to
     * a self-hosted or paid service in production environments. Access to the alloy.iframe.ly endpoint
     * may be restricted per domain due to significant traffic.
     *
     * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
     * to an embedded content.
     *
     * @class CKEDITOR.plugins.ae_embed
     */
    CKEDITOR.plugins.add('ae_embed', {
        requires: 'widget',
        init: function init(editor) {
            var AE_EMBED_URL_TPL = new CKEDITOR.template(editor.config.embedUrlTemplate || CKEDITOR.DEFAULT_AE_EMBED_URL_TPL);
            var AE_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL);
            var AE_EMBED_DEFAULT_LINK_TPL = new CKEDITOR.template(editor.config.embedLinkDefaultTpl || CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL);

            // Default function to upcast DOM elements to embed widgets.
            // It matches CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL
            var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
                if (element.name === 'div' && element.attributes['data-ae-embed-url']) {
                    data.url = element.attributes['data-ae-embed-url'];

                    return true;
                }
            };

            // Create a embedUrl command that can be invoked to easily embed media URLs
            editor.addCommand('embedUrl', {
                exec: function exec(editor, data) {
                    editor.insertHtml(AE_EMBED_WIDGET_TPL.output({
                        url: data.url
                    }));
                }
            });

            // Create a widget to properly handle embed operations
            editor.widgets.add('ae_embed', {

                mask: true,
                requiredContent: 'div[data-ae-embed-url]',

                /**
                 * Listener to be executed every time the widget's data changes. It takes care of
                 * requesting the embed object to the configured oembed service and render it in
                 * the editor
                 *
                 * @method data
                 * @param {event} event Data change event
                 */
                data: function data(event) {
                    var widget = this;

                    var url = event.data.url;

                    if (url) {
                        CKEDITOR.tools.jsonp(AE_EMBED_URL_TPL, {
                            url: encodeURIComponent(url)
                        }, function (response) {
                            if (response.html) {
                                if (REGEX_DEFAULT_LINK.test(response.html)) {
                                    widget.createATag(url);
                                } else {
                                    widget.element.setHtml(response.html);
                                }
                            } else {
                                widget.createATag(url);
                            }
                        }, function (msg) {
                            widget.createATag(url);
                        });
                    }
                },

                createATag: function createATag(url) {
                    this.editor.execCommand('undo');

                    var currentSelection = this.editor.getSelection().getSelectedElement();

                    var aTagHtml = AE_EMBED_DEFAULT_LINK_TPL.output({
                        url: url
                    });

                    this.editor.insertHtml(aTagHtml);
                    this.editor.fire('actionPerformed', this);
                },

                /**
                 * Function used to upcast an element to ae_embed widgets.
                 *
                 * @method upcast
                 * @param {CKEDITOR.htmlParser.element} element The element to be checked
                 * @param {Object} data The object that will be passed to the widget
                 */
                upcast: function upcast(element, data) {
                    var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

                    return embedWidgetUpcastFn(element, data);
                }
            });

            // Add a listener to handle paste events and turn links into embed objects
            editor.once('contentDom', function () {
                editor.on('paste', function (event) {
                    var link = event.data.dataValue;

                    if (REGEX_HTTP.test(link)) {
                        event.stop();

                        editor.execCommand('embedUrl', {
                            url: event.data.dataValue
                        });
                    }
                });
            });

            // Add a listener to handle selection change events and properly detect editor
            // interactions on the widgets without messing with widget native selection
            editor.on('selectionChange', function (event) {
                var selection = editor.getSelection();

                if (selection) {
                    var element = selection.getSelectedElement();

                    if (element) {
                        var widgetElement = element.findOne('[data-widget="ae_embed"]');

                        if (widgetElement) {
                            var region = element.getClientRect();

                            var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
                            region.left -= scrollPosition.x;
                            region.top += scrollPosition.y;

                            region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

                            editor.fire('editorInteraction', {
                                nativeEvent: {},
                                selectionData: {
                                    element: widgetElement,
                                    region: region
                                }
                            });
                        }
                    }
                }
            });

            // Add a filter to skip filtering widget elements
            editor.filter.addElementCallback(function (element) {
                if ('data-ae-embed-url' in element.attributes) {
                    return CKEDITOR.FILTER_SKIP_TREE;
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/imagealignment.js":
/*!***************************************!*\
  !*** ./src/plugins/imagealignment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _selectionTest = __webpack_require__(/*! ../selections/selection-test.js */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_imagealignment')) {
        return;
    }

    /**
     * Enum for supported image alignments
     * @type {Object}
     */
    var IMAGE_ALIGNMENT = {
        CENTER: 'center',
        LEFT: 'left',
        RIGHT: 'right'
    };

    /**
     * Enum values for supported image alignments
     * @type {Array}
     */
    var ALIGN_VALUES = [IMAGE_ALIGNMENT.LEFT, IMAGE_ALIGNMENT.RIGHT, IMAGE_ALIGNMENT.CENTER];

    /**
     * Necessary styles for the center alignment
     * @type {Array.<Object>}
     */
    var CENTERED_IMAGE_STYLE = [{
        name: 'display',
        value: 'block'
    }, {
        name: 'margin-left',
        value: 'auto'
    }, {
        name: 'margin-right',
        value: 'auto'
    }];

    /**
     * Retrieves the alignment value of an image.
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @return {String} The alignment value
     */
    var getImageAlignment = function getImageAlignment(image) {
        var imageAlignment = image.getStyle('float');

        if (!imageAlignment || imageAlignment === 'inherit' || imageAlignment === 'none') {
            imageAlignment = image.getAttribute('align');
        }

        if (!imageAlignment) {
            var centeredImage = CENTERED_IMAGE_STYLE.every(function (style) {
                var styleCheck = image.getStyle(style.name) === style.value;

                if (!styleCheck && style.vendorPrefixes) {
                    styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
                        return image.getStyle(vendorPrefix + style.name) === style.value;
                    });
                }

                return styleCheck;
            });

            imageAlignment = centeredImage ? IMAGE_ALIGNMENT.CENTER : null;
        }

        return imageAlignment;
    };

    /**
     * Removes the alignment value of an image
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @param {String} imageAlignment The image alignment value to be removed
     */
    var removeImageAlignment = function removeImageAlignment(image, imageAlignment) {
        if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
            image.removeStyle('float');

            if (imageAlignment === getImageAlignment(image)) {
                image.removeAttribute('align');
            }
        } else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
            CENTERED_IMAGE_STYLE.forEach(function (style) {
                image.removeStyle(style.name);

                if (style.vendorPrefixes) {
                    style.vendorPrefixes.forEach(function (vendorPrefix) {
                        image.removeStyle(vendorPrefix + style.name);
                    });
                }
            });
        }
    };

    /**
     * Sets the alignment value of an image
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @param {String} imageAlignment The image alignment value to be set
     */
    var setImageAlignment = function setImageAlignment(image, imageAlignment) {
        removeImageAlignment(image, getImageAlignment(image));

        if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
            image.setStyle('float', imageAlignment);
        } else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
            CENTERED_IMAGE_STYLE.forEach(function (style) {
                image.setStyle(style.name, style.value);

                if (style.vendorPrefixes) {
                    style.vendorPrefixes.forEach(function (vendorPrefix) {
                        image.setStyle(vendorPrefix + style.name, style.value);
                    });
                }
            });
        }
    };

    /**
     * CKEditor plugin which modifies the justify commands to properly align images. This
     * plugin is an excerpt of CKEditor's original image one that can be found at
     * https://github.com/ckeditor/ckeditor-dev/blob/master/plugins/image/plugin.js
     *
     * @class CKEDITOR.plugins.ae_imagealignment
     */
    CKEDITOR.plugins.add('ae_imagealignment', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'paste' event on the editing area.
         *
         * @method afterInit
         * @param {Object} editor The current editor instance
         */
        afterInit: function afterInit(editor) {
            var self = this;

            ALIGN_VALUES.forEach(function (value) {
                var command = editor.getCommand('justify' + value);

                if (command) {
                    command.on('exec', function (event) {
                        var selectionData = editor.getSelectionData();

                        if (selectionData && _selectionTest2.default.image({ data: { selectionData: selectionData } })) {
                            var image = selectionData.element;

                            var imageAlignment = getImageAlignment(image);

                            if (imageAlignment === value) {
                                removeImageAlignment(image, value);
                            } else {
                                setImageAlignment(image, value);
                            }

                            event.cancel();

                            self.refreshCommands(editor, new CKEDITOR.dom.elementPath(image));
                        }
                    });

                    command.on('refresh', function (event) {
                        var selectionData = {
                            element: event.data.path.lastElement
                        };

                        if (_selectionTest2.default.image({ data: { selectionData: selectionData } })) {
                            var imageAlignment = getImageAlignment(selectionData.element);

                            this.setState(imageAlignment === value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

                            event.cancel();
                        }
                    });
                }
            });
        },

        /**
         * Forces a refresh of the modified justify commands. This is needed because the applied changes
         * do not modify the selection, so the refresh is never triggered and the UI does not update
         * properly until the next selectionChange event.
         *
         * @param {CKEDITOR.editor} editor The editor instance
         * @param {CKEDITOR.dom.elementPath} elementPath The path of the selected image
         */
        refreshCommands: function refreshCommands(editor, elementPath) {
            ALIGN_VALUES.forEach(function (value) {
                var command = editor.getCommand('justify' + value);

                if (command) {
                    command.refresh(editor, elementPath);
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/index.js":
/*!******************************!*\
  !*** ./src/plugins/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tabletools = exports.tableresize = exports.selectionkeystrokes = exports.placeholder = exports.pasteimages = exports.imagealignment = exports.embed = exports.dragresizeie = exports.dragresize = exports.autolist = exports.autolink = exports.addimages = undefined;

var _addimages = __webpack_require__(/*! ./addimages */ "./src/plugins/addimages.js");

var _addimages2 = _interopRequireDefault(_addimages);

var _autolink = __webpack_require__(/*! ./autolink */ "./src/plugins/autolink.js");

var _autolink2 = _interopRequireDefault(_autolink);

var _autolist = __webpack_require__(/*! ./autolist */ "./src/plugins/autolist.js");

var _autolist2 = _interopRequireDefault(_autolist);

var _dragresize = __webpack_require__(/*! ./dragresize */ "./src/plugins/dragresize.js");

var _dragresize2 = _interopRequireDefault(_dragresize);

var _dragresize_ie = __webpack_require__(/*! ./dragresize_ie */ "./src/plugins/dragresize_ie.js");

var _dragresize_ie2 = _interopRequireDefault(_dragresize_ie);

var _embed = __webpack_require__(/*! ./embed */ "./src/plugins/embed.js");

var _embed2 = _interopRequireDefault(_embed);

var _imagealignment = __webpack_require__(/*! ./imagealignment */ "./src/plugins/imagealignment.js");

var _imagealignment2 = _interopRequireDefault(_imagealignment);

var _pasteimages = __webpack_require__(/*! ./pasteimages */ "./src/plugins/pasteimages.js");

var _pasteimages2 = _interopRequireDefault(_pasteimages);

var _placeholder = __webpack_require__(/*! ./placeholder */ "./src/plugins/placeholder.js");

var _placeholder2 = _interopRequireDefault(_placeholder);

var _selectionkeystrokes = __webpack_require__(/*! ./selectionkeystrokes */ "./src/plugins/selectionkeystrokes.js");

var _selectionkeystrokes2 = _interopRequireDefault(_selectionkeystrokes);

var _tableresize = __webpack_require__(/*! ./tableresize */ "./src/plugins/tableresize.js");

var _tableresize2 = _interopRequireDefault(_tableresize);

var _tabletools = __webpack_require__(/*! ./tabletools */ "./src/plugins/tabletools.js");

var _tabletools2 = _interopRequireDefault(_tabletools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.addimages = _addimages2.default;
exports.autolink = _autolink2.default;
exports.autolist = _autolist2.default;
exports.dragresize = _dragresize2.default;
exports.dragresizeie = _dragresize_ie2.default;
exports.embed = _embed2.default;
exports.imagealignment = _imagealignment2.default;
exports.pasteimages = _pasteimages2.default;
exports.placeholder = _placeholder2.default;
exports.selectionkeystrokes = _selectionkeystrokes2.default;
exports.tableresize = _tableresize2.default;
exports.tabletools = _tabletools2.default;

/***/ }),

/***/ "./src/plugins/pasteimages.js":
/*!************************************!*\
  !*** ./src/plugins/pasteimages.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_pasteimages')) {
        return;
    }

    /**
     * CKEditor plugin which allows pasting images directly into the editable area. The image will be encoded
     * as Data URI. An event `beforeImageAdd` will be fired with the list of pasted images. If any of the listeners
     * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
     * an event `imageAdd` will be fired with the inserted element into the editable area.
     *
     * @class CKEDITOR.plugins.ae_pasteimages
     */

    /**
     * Fired before adding images to the editor.
     * @event beforeImageAdd
     * @param {Array} imageFiles Array of image files
     */

    /**
     * Fired when an image is being added to the editor successfully.
     *
     * @event imageAdd
     * @param {CKEDITOR.dom.element} el The created image with src as Data URI
     * @param {File} file The image file
     */

    CKEDITOR.plugins.add('ae_pasteimages', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'paste' event on the editing area.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'paste', this._onPaste, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * The function creates an img element with src the image data as Data URI.
         * Then, it fires an 'imageAdd' event via CKEditor's event system. The passed
         * params will be:
         * - `el` - the created img element
         * - `file` - the original pasted data
         *
         * @method _onPaste
         * @protected
         * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
         */
        _onPaste: function _onPaste(event) {
            if (event.data.$.clipboardData) {
                var pastedData = event.data.$.clipboardData.items[0];
                var editor = event.listenerData.editor;

                if (pastedData.type.indexOf('image') === 0) {
                    var reader = new FileReader();
                    var imageFile = pastedData.getAsFile();

                    reader.onload = function (event) {
                        var result = editor.fire('beforeImageAdd', {
                            imageFiles: imageFile
                        });

                        if (!!result) {
                            var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

                            editor.insertElement(el);

                            var imageData = {
                                el: el,
                                file: imageFile
                            };

                            editor.fire('imageAdd', imageData);
                        }
                    }.bind(this);

                    reader.readAsDataURL(imageFile);
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/placeholder.js":
/*!************************************!*\
  !*** ./src/plugins/placeholder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_placeholder')) {
        return;
    }

    /**
     * CKEDITOR enterMode config set the behavior of paragraphs
     * When the content is empty CKEDITOR keeps the enterMode string
     * into the content
     * @property
     * @type {string}
     */
    var brFiller = CKEDITOR.env.needsBrFiller ? '<br>' : '';

    var enterModeEmptyValue = {
        1: ['<p>' + brFiller + '</p>'],
        2: ['', ' ', brFiller],
        3: ['<div>' + brFiller + '</div>']
    };

    /**
     * CKEditor plugin which allows adding a placeholder to the editor. In this case, if there
     * is no content to the editor, there will be hint to the user.
     *
     * @class CKEDITOR.plugins.ae_placeholder
     */

    /**
     * Specifies the placeholder class which have to be aded to editor when editor is not focused.
     *
     * @attribute placeholderClass
     * @default ae_placeholder
     * @type String
     */

    CKEDITOR.plugins.add('ae_placeholder', {

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'blur' and 'contentDom' event listeners.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.on('blur', this._checkEmptyData, this);
            editor.on('change', this._checkEmptyData, this);
            editor.on('focus', this._removePlaceholderClass, this);
            editor.once('contentDom', this._checkEmptyData, this);
        },

        /**
         * Removes any data from the content and adds a class,
         * specified by the "placeholderClass" config attribute.
         *
         * @protected
         * @method _checkEmptyData
         * @param {CKEDITOR.dom.event} editor event, fired from CKEditor
         */
        _checkEmptyData: function _checkEmptyData(event) {
            var editor = event.editor;

            var editableNode = editor.editable();

            var innerHtml = editableNode.$.innerHTML.trim();

            var isEmpty = enterModeEmptyValue[editor.config.enterMode].some(function (element) {
                return innerHtml === element;
            });

            if (isEmpty) {
                editableNode.addClass(editor.config.placeholderClass);
            } else {
                editableNode.removeClass(editor.config.placeholderClass);
            }
        },

        /**
         * Remove placeholder class when input is focused
         *
         * @protected
         * @method _removePlaceholderClass
         + @param {CKEDITOR.dom.event} editor event, fired from CKEditor
         */
        _removePlaceholderClass: function _removePlaceholderClass(event) {
            var editor = event.editor;

            var editorNode = new CKEDITOR.dom.element(editor.element.$);

            editorNode.removeClass(editor.config.placeholderClass);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/selectionkeystrokes.js":
/*!********************************************!*\
  !*** ./src/plugins/selectionkeystrokes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_selectionkeystrokes')) {
        return;
    }

    /**
     * CKEditor plugin that simulates editor interaction events based on manual keystrokes. This
     * can be used to trigger different reactions in the editor.
     *
     * @class CKEDITOR.plugins.ae_selectionkeystrokes
     */
    CKEDITOR.plugins.add('ae_selectionkeystrokes', {
        requires: 'ae_selectionregion',

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function adds a command to the editor for every defined selectionKeystroke
         * in the configuration and maps it to the specified keystroke.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            if (editor.config.selectionKeystrokes) {
                editor.config.selectionKeystrokes.forEach(function (selectionKeystroke) {
                    var command = new CKEDITOR.command(editor, {
                        exec: function exec(editor) {
                            editor.fire('editorInteraction', {
                                manualSelection: selectionKeystroke.selection,
                                nativeEvent: {},
                                selectionData: editor.getSelectionData()
                            });
                        }
                    });

                    var commandName = 'selectionKeystroke' + selectionKeystroke.selection;

                    editor.addCommand(commandName, command);
                    editor.setKeystroke(selectionKeystroke.keys, commandName);
                });
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/tableresize.js":
/*!************************************!*\
  !*** ./src/plugins/tableresize.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_tableresize')) {
        return;
    }

    var pxUnit = CKEDITOR.tools.cssLength;

    function getWidth(el) {
        return CKEDITOR.env.ie ? el.$.clientWidth : parseInt(el.getComputedStyle('width'), 10);
    }

    function getBorderWidth(element, side) {
        var computed = element.getComputedStyle('border-' + side + '-width'),
            borderMap = {
            thin: '0px',
            medium: '1px',
            thick: '2px'
        };

        if (computed.indexOf('px') < 0) {
            // look up keywords
            if (computed in borderMap && element.getComputedStyle('border-style') != 'none') {
                computed = borderMap[computed];
            } else {
                computed = 0;
            }
        }

        return parseInt(computed, 10);
    }

    // Gets the table row that contains the most columns.
    function getMasterPillarRow(table) {
        var $rows = table.$.rows,
            maxCells = 0,
            cellsCount,
            $elected,
            $tr;

        for (var i = 0, len = $rows.length; i < len; i++) {
            $tr = $rows[i];
            cellsCount = $tr.cells.length;

            if (cellsCount > maxCells) {
                maxCells = cellsCount;
                $elected = $tr;
            }
        }

        return $elected;
    }

    function buildTableColumnPillars(table) {
        var pillars = [],
            pillarIndex = -1,
            rtl = table.getComputedStyle('direction') === 'rtl';

        // Get the raw row element that cointains the most columns.
        var $tr = getMasterPillarRow(table);

        // Get the tbody element and position, which will be used to set the
        // top and bottom boundaries.
        var tbody = new CKEDITOR.dom.element(table.$.tBodies[0]),
            tbodyPosition = tbody.getDocumentPosition();

        // Loop thorugh all cells, building pillars after each one of them.
        for (var i = 0, len = $tr.cells.length; i < len; i++) {
            // Both the current cell and the successive one will be used in the
            // pillar size calculation.
            var td = new CKEDITOR.dom.element($tr.cells[i]),
                nextTd = $tr.cells[i + 1] && new CKEDITOR.dom.element($tr.cells[i + 1]);

            pillarIndex += td.$.colSpan || 1;

            // Calculate the pillar boundary positions.
            var pillarLeft, pillarRight, pillarWidth;

            var x = td.getDocumentPosition().x;

            // Calculate positions based on the current cell.
            rtl ? pillarRight = x + getBorderWidth(td, 'left') : pillarLeft = x + td.$.offsetWidth - getBorderWidth(td, 'right');

            // Calculate positions based on the next cell, if available.
            if (nextTd) {
                x = nextTd.getDocumentPosition().x;

                rtl ? pillarLeft = x + nextTd.$.offsetWidth - getBorderWidth(nextTd, 'right') : pillarRight = x + getBorderWidth(nextTd, 'left');
            }
            // Otherwise calculate positions based on the table (for last cell).
            else {
                    x = table.getDocumentPosition().x;

                    rtl ? pillarLeft = x : pillarRight = x + table.$.offsetWidth;
                }

            pillarWidth = Math.max(pillarRight - pillarLeft, 4);

            // The pillar should reflects exactly the shape of the hovered
            // column border line.
            pillars.push({
                table: table,
                index: pillarIndex,
                x: pillarLeft,
                y: tbodyPosition.y,
                width: pillarWidth,
                height: tbody.$.offsetHeight,
                rtl: rtl
            });
        }

        return pillars;
    }

    function getPillarAtPosition(pillars, positionX) {
        for (var i = 0, len = pillars.length; i < len; i++) {
            var pillar = pillars[i];

            if (positionX >= pillar.x && positionX <= pillar.x + pillar.width) {
                return pillar;
            }
        }

        return null;
    }

    function cancel(evt) {
        (evt.data || evt).preventDefault();
    }

    function columnResizer(editor) {
        var pillar, document, resizer, isResizing, startOffset, currentShift;

        var leftSideCells, rightSideCells, leftShiftBoundary, rightShiftBoundary;

        function detach() {
            pillar = null;
            currentShift = 0;
            isResizing = 0;

            document.removeListener('mouseup', onMouseUp);
            resizer.removeListener('mousedown', onMouseDown);
            resizer.removeListener('mousemove', onMouseMove);

            document.getBody().setStyle('cursor', 'auto');
        }

        function resizeStart() {
            // Before starting to resize, figure out which cells to change
            // and the boundaries of this resizing shift.

            var columnIndex = pillar.index,
                map = CKEDITOR.tools.buildTableMap(pillar.table),
                leftColumnCells = [],
                rightColumnCells = [],
                leftMinSize = Number.MAX_VALUE,
                rightMinSize = leftMinSize,
                rtl = pillar.rtl;

            for (var i = 0, len = map.length; i < len; i++) {
                var row = map[i],
                    leftCell = row[columnIndex + (rtl ? 1 : 0)],
                    rightCell = row[columnIndex + (rtl ? 0 : 1)];

                leftCell = leftCell && new CKEDITOR.dom.element(leftCell);
                rightCell = rightCell && new CKEDITOR.dom.element(rightCell);

                if (!leftCell || !rightCell || !leftCell.equals(rightCell)) {
                    leftCell && (leftMinSize = Math.min(leftMinSize, getWidth(leftCell)));
                    rightCell && (rightMinSize = Math.min(rightMinSize, getWidth(rightCell)));

                    leftColumnCells.push(leftCell);
                    rightColumnCells.push(rightCell);
                }
            }

            // Cache the list of cells to be resized.
            leftSideCells = leftColumnCells;
            rightSideCells = rightColumnCells;

            // Cache the resize limit boundaries.
            leftShiftBoundary = pillar.x - leftMinSize;
            rightShiftBoundary = pillar.x + rightMinSize;

            resizer.setOpacity(0.5);
            startOffset = parseInt(resizer.getStyle('left'), 10);
            currentShift = 0;
            isResizing = 1;

            resizer.on('mousemove', onMouseMove);

            // Prevent the native drag behavior otherwise 'mousemove' won't fire.
            document.on('dragstart', cancel);
        }

        function resizeEnd() {
            isResizing = 0;

            resizer.setOpacity(0);

            currentShift && resizeColumn();

            var table = pillar.table;
            setTimeout(function () {
                table.removeCustomData('_cke_table_pillars');
            }, 0);

            document.removeListener('dragstart', cancel);
        }

        function resizeColumn() {
            var rtl = pillar.rtl,
                cellsCount = rtl ? rightSideCells.length : leftSideCells.length;

            // Perform the actual resize to table cells, only for those by side of the pillar.
            for (var i = 0; i < cellsCount; i++) {
                var leftCell = leftSideCells[i],
                    rightCell = rightSideCells[i],
                    table = pillar.table;

                // Defer the resizing to avoid any interference among cells.
                CKEDITOR.tools.setTimeout(function (leftCell, leftOldWidth, rightCell, rightOldWidth, tableWidth, sizeShift) {
                    // 1px is the minimum valid width (#11626).
                    leftCell && leftCell.setStyle('width', pxUnit(Math.max(leftOldWidth + sizeShift, 1)));
                    rightCell && rightCell.setStyle('width', pxUnit(Math.max(rightOldWidth - sizeShift, 1)));

                    // If we're in the last cell, we need to resize the table as well
                    if (tableWidth) {
                        table.setStyle('width', pxUnit(tableWidth + sizeShift * (rtl ? -1 : 1)));
                    }
                }, 0, this, [leftCell, leftCell && getWidth(leftCell), rightCell, rightCell && getWidth(rightCell), (!leftCell || !rightCell) && getWidth(table) + getBorderWidth(table, 'left') + getBorderWidth(table, 'right'), currentShift]);
            }
        }

        function onMouseDown(evt) {
            cancel(evt);

            resizeStart();

            document.on('mouseup', onMouseUp, this);
        }

        function onMouseUp(evt) {
            evt.removeListener();

            resizeEnd();
        }

        function onMouseMove(evt) {
            move(evt.data.getPageOffset().x);
        }

        document = editor.document;

        resizer = CKEDITOR.dom.element.createFromHtml('<div data-cke-temp=1 contenteditable=false unselectable=on ' + 'style="position:absolute;cursor:col-resize;filter:alpha(opacity=0);opacity:0;' + 'padding:0;background-color:#004;background-image:none;border:0px none;z-index:10"></div>', document);

        // Clean DOM when editor is destroyed.
        editor.on('destroy', function () {
            resizer.remove();
        });

        // Place the resizer after body to prevent it
        // from being editable.
        document.getDocumentElement().append(resizer);

        this.attachTo = function (targetPillar) {
            // Accept only one pillar at a time.
            if (isResizing) {
                return;
            }

            pillar = targetPillar;

            resizer.setStyles({
                width: pxUnit(targetPillar.width),
                height: pxUnit(targetPillar.height),
                left: pxUnit(targetPillar.x),
                top: pxUnit(targetPillar.y)
            });

            resizer.on('mousedown', onMouseDown, this);

            document.getBody().setStyle('cursor', 'col-resize');

            // Display the resizer to receive events but don't show it,
            // only change the cursor to resizable shape.
            resizer.show();
        };

        var move = this.move = function (posX) {
            if (!pillar) {
                return 0;
            }

            if (!isResizing && (posX < pillar.x || posX > pillar.x + pillar.width)) {
                detach();
                return 0;
            }

            var resizerNewPosition = posX - Math.round(resizer.$.offsetWidth / 2);

            if (isResizing) {
                if (resizerNewPosition === leftShiftBoundary || resizerNewPosition === rightShiftBoundary) {
                    return 1;
                }

                resizerNewPosition = Math.max(resizerNewPosition, leftShiftBoundary);
                resizerNewPosition = Math.min(resizerNewPosition, rightShiftBoundary);

                currentShift = resizerNewPosition - startOffset;
            }

            resizer.setStyle('left', pxUnit(resizerNewPosition));

            return 1;
        };
    }

    function clearPillarsCache(evt) {
        var target = evt.data.getTarget();

        if (evt.name === 'mouseout') {
            // Bypass interal mouse move.
            if (!target.is('table')) {
                return;
            }

            var dest = new CKEDITOR.dom.element(evt.data.$.relatedTarget || evt.data.$.toElement);
            while (dest && dest.$ && !dest.equals(target) && !dest.is('body')) {
                dest = dest.getParent();
            }
            if (!dest || dest.equals(target)) {
                return;
            }
        }

        target.getAscendant('table', 1).removeCustomData('_cke_table_pillars');
        evt.removeListener();
    }

    CKEDITOR.plugins.add('ae_tableresize', {
        requires: 'ae_tabletools',

        init: function init(editor) {
            editor.on('contentDom', function () {
                var resizer,
                    editable = editor.editable();

                // In Classic editor it is better to use document
                // instead of editable so event will work below body.
                editable.attachListener(editable.isInline() ? editable : editor.document, 'mousemove', function (evt) {
                    evt = evt.data;

                    var target = evt.getTarget();

                    // FF may return document and IE8 some UFO (object with no nodeType property...)
                    // instead of an element (#11823).
                    if (target.type !== CKEDITOR.NODE_ELEMENT) {
                        return;
                    }

                    var pageX = evt.getPageOffset().x;

                    // If we're already attached to a pillar, simply move the
                    // resizer.
                    if (resizer && resizer.move(pageX)) {
                        cancel(evt);
                        return;
                    }

                    // Considering table, tr, td, tbody but nothing else.
                    var table, pillars;

                    if (!target.is('table') && !target.getAscendant('tbody', 1)) {
                        return;
                    }

                    table = target.getAscendant('table', 1);

                    // Make sure the table we found is inside the container
                    // (eg. we should not use tables the editor is embedded within)
                    if (!editor.editable().contains(table)) {
                        return;
                    }

                    if (!(pillars = table.getCustomData('_cke_table_pillars'))) {
                        // Cache table pillars calculation result.
                        table.setCustomData('_cke_table_pillars', pillars = buildTableColumnPillars(table));
                        table.on('mouseout', clearPillarsCache);
                        table.on('mousedown', clearPillarsCache);
                    }

                    var pillar = getPillarAtPosition(pillars, pageX);
                    if (pillar) {
                        !resizer && (resizer = new columnResizer(editor));
                        resizer.attachTo(pillar);
                    }
                });
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/tabletools.js":
/*!***********************************!*\
  !*** ./src/plugins/tabletools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
	'use strict';

	if (CKEDITOR.plugins.get('ae_tabletools')) {
		return;
	}

	var cellNodeRegex = /^(?:td|th)$/;

	function getSelectedCells(selection) {
		var ranges = selection.getRanges();
		var retval = [];
		var database = {};

		function moveOutOfCellGuard(node) {
			// Apply to the first cell only.
			if (retval.length > 0) return;

			// If we are exiting from the first </td>, then the td should definitely be
			// included.
			if (node.type == CKEDITOR.NODE_ELEMENT && cellNodeRegex.test(node.getName()) && !node.getCustomData('selected_cell')) {
				CKEDITOR.dom.element.setMarker(database, node, 'selected_cell', true);
				retval.push(node);
			}
		}

		for (var i = 0; i < ranges.length; i++) {
			var range = ranges[i];

			if (range.collapsed) {
				// Walker does not handle collapsed ranges yet - fall back to old API.
				var startNode = range.getCommonAncestor();
				var nearestCell = startNode.getAscendant('td', true) || startNode.getAscendant('th', true);
				if (nearestCell) retval.push(nearestCell);
			} else {
				var walker = new CKEDITOR.dom.walker(range);
				var node;
				walker.guard = moveOutOfCellGuard;

				while (node = walker.next()) {
					// If may be possible for us to have a range like this:
					// <td>^1</td><td>^2</td>
					// The 2nd td shouldn't be included.
					//
					// So we have to take care to include a td we've entered only when we've
					// walked into its children.

					if (node.type != CKEDITOR.NODE_ELEMENT || !node.is(CKEDITOR.dtd.table)) {
						var parent = node.getAscendant('td', true) || node.getAscendant('th', true);
						if (parent && !parent.getCustomData('selected_cell')) {
							CKEDITOR.dom.element.setMarker(database, parent, 'selected_cell', true);
							retval.push(parent);
						}
					}
				}
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		return retval;
	}

	function getFocusElementAfterDelCells(cellsToDelete) {
		var i = 0,
		    last = cellsToDelete.length - 1,
		    database = {},
		    cell,
		    focusedCell,
		    tr;

		while (cell = cellsToDelete[i++]) {
			CKEDITOR.dom.element.setMarker(database, cell, 'delete_cell', true);
		} // 1.first we check left or right side focusable cell row by row;
		i = 0;
		while (cell = cellsToDelete[i++]) {
			if ((focusedCell = cell.getPrevious()) && !focusedCell.getCustomData('delete_cell') || (focusedCell = cell.getNext()) && !focusedCell.getCustomData('delete_cell')) {
				CKEDITOR.dom.element.clearAllMarkers(database);
				return focusedCell;
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		// 2. then we check the toppest row (outside the selection area square) focusable cell
		tr = cellsToDelete[0].getParent();
		if (tr = tr.getPrevious()) return tr.getLast();

		// 3. last we check the lowerest  row focusable cell
		tr = cellsToDelete[last].getParent();
		if (tr = tr.getNext()) return tr.getChild(0);

		return null;
	}

	function insertRow(selection, insertBefore) {
		var cells = getSelectedCells(selection),
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    doc = firstCell.getDocument(),
		    startRow = cells[0].getParent(),
		    startRowIndex = startRow.$.rowIndex,
		    lastCell = cells[cells.length - 1],
		    endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1,
		    endRow = new CKEDITOR.dom.element(table.$.rows[endRowIndex]),
		    rowIndex = insertBefore ? startRowIndex : endRowIndex,
		    row = insertBefore ? startRow : endRow;

		var map = CKEDITOR.tools.buildTableMap(table),
		    cloneRow = map[rowIndex],
		    nextRow = insertBefore ? map[rowIndex - 1] : map[rowIndex + 1],
		    width = map[0].length;

		var newRow = doc.createElement('tr');
		for (var i = 0; cloneRow[i] && i < width; i++) {
			var cell;
			// Check whether there's a spanning row here, do not break it.
			if (cloneRow[i].rowSpan > 1 && nextRow && cloneRow[i] == nextRow[i]) {
				cell = cloneRow[i];
				cell.rowSpan += 1;
			} else {
				cell = new CKEDITOR.dom.element(cloneRow[i]).clone();
				cell.removeAttribute('rowSpan');
				cell.appendBogus();
				newRow.append(cell);
				cell = cell.$;
			}

			i += cell.colSpan - 1;
		}

		insertBefore ? newRow.insertBefore(row) : newRow.insertAfter(row);
	}

	function deleteRows(selectionOrRow) {
		if (selectionOrRow instanceof CKEDITOR.dom.selection) {
			var cells = getSelectedCells(selectionOrRow),
			    firstCell = cells[0],
			    table = firstCell.getAscendant('table'),
			    map = CKEDITOR.tools.buildTableMap(table),
			    startRow = cells[0].getParent(),
			    startRowIndex = startRow.$.rowIndex,
			    lastCell = cells[cells.length - 1],
			    endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1,
			    rowsToDelete = [];

			// Delete cell or reduce cell spans by checking through the table map.
			for (var i = startRowIndex; i <= endRowIndex; i++) {
				var mapRow = map[i],
				    row = new CKEDITOR.dom.element(table.$.rows[i]);

				for (var j = 0; j < mapRow.length; j++) {
					var cell = new CKEDITOR.dom.element(mapRow[j]),
					    cellRowIndex = cell.getParent().$.rowIndex;

					if (cell.$.rowSpan == 1) cell.remove();
					// Row spanned cell.
					else {
							// Span row of the cell, reduce spanning.
							cell.$.rowSpan -= 1;
							// Root row of the cell, root cell to next row.
							if (cellRowIndex == i) {
								var nextMapRow = map[i + 1];
								nextMapRow[j - 1] ? cell.insertAfter(new CKEDITOR.dom.element(nextMapRow[j - 1])) : new CKEDITOR.dom.element(table.$.rows[i + 1]).append(cell, 1);
							}
						}

					j += cell.$.colSpan - 1;
				}

				rowsToDelete.push(row);
			}

			var rows = table.$.rows;

			// Where to put the cursor after rows been deleted?
			// 1. Into next sibling row if any;
			// 2. Into previous sibling row if any;
			// 3. Into table's parent element if it's the very last row.
			var cursorPosition = new CKEDITOR.dom.element(rows[endRowIndex + 1] || (startRowIndex > 0 ? rows[startRowIndex - 1] : null) || table.$.parentNode);

			for (i = rowsToDelete.length; i >= 0; i--) {
				deleteRows(rowsToDelete[i]);
			}return cursorPosition;
		} else if (selectionOrRow instanceof CKEDITOR.dom.element) {
			table = selectionOrRow.getAscendant('table');

			if (table.$.rows.length == 1) table.remove();else selectionOrRow.remove();
		}

		return null;
	}

	function getCellColIndex(cell, isStart) {
		var row = cell.getParent(),
		    rowCells = row.$.cells;

		var colIndex = 0;
		for (var i = 0; i < rowCells.length; i++) {
			var mapCell = rowCells[i];
			colIndex += isStart ? 1 : mapCell.colSpan;
			if (mapCell == cell.$) break;
		}

		return colIndex - 1;
	}

	function getColumnsIndices(cells, isStart) {
		var retval = isStart ? Infinity : 0;
		for (var i = 0; i < cells.length; i++) {
			var colIndex = getCellColIndex(cells[i], isStart);
			if (isStart ? colIndex < retval : colIndex > retval) retval = colIndex;
		}
		return retval;
	}

	function insertColumn(selection, insertBefore) {
		var cells = getSelectedCells(selection),
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    startCol = getColumnsIndices(cells, 1),
		    lastCol = getColumnsIndices(cells),
		    colIndex = insertBefore ? startCol : lastCol;

		var map = CKEDITOR.tools.buildTableMap(table),
		    cloneCol = [],
		    nextCol = [],
		    height = map.length;

		for (var i = 0; i < height; i++) {
			cloneCol.push(map[i][colIndex]);
			var nextCell = insertBefore ? map[i][colIndex - 1] : map[i][colIndex + 1];
			nextCol.push(nextCell);
		}

		for (i = 0; i < height; i++) {
			var cell;

			if (!cloneCol[i]) continue;

			// Check whether there's a spanning column here, do not break it.
			if (cloneCol[i].colSpan > 1 && nextCol[i] == cloneCol[i]) {
				cell = cloneCol[i];
				cell.colSpan += 1;
			} else {
				cell = new CKEDITOR.dom.element(cloneCol[i]).clone();
				cell.removeAttribute('colSpan');
				cell.appendBogus();
				cell[insertBefore ? 'insertBefore' : 'insertAfter'].call(cell, new CKEDITOR.dom.element(cloneCol[i]));
				cell = cell.$;
			}

			i += cell.rowSpan - 1;
		}
	}

	function deleteColumns(selectionOrCell) {
		var cells = getSelectedCells(selectionOrCell),
		    firstCell = cells[0],
		    lastCell = cells[cells.length - 1],
		    table = firstCell.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    startColIndex,
		    endColIndex,
		    rowsToDelete = [];

		// Figure out selected cells' column indices.
		for (var i = 0, rows = map.length; i < rows; i++) {
			for (var j = 0, cols = map[i].length; j < cols; j++) {
				if (map[i][j] == firstCell.$) startColIndex = j;
				if (map[i][j] == lastCell.$) endColIndex = j;
			}
		}

		// Delete cell or reduce cell spans by checking through the table map.
		for (i = startColIndex; i <= endColIndex; i++) {
			for (j = 0; j < map.length; j++) {
				var mapRow = map[j],
				    row = new CKEDITOR.dom.element(table.$.rows[j]),
				    cell = new CKEDITOR.dom.element(mapRow[i]);

				if (cell.$) {
					if (cell.$.colSpan == 1) cell.remove();
					// Reduce the col spans.
					else cell.$.colSpan -= 1;

					j += cell.$.rowSpan - 1;

					if (!row.$.cells.length) rowsToDelete.push(row);
				}
			}
		}

		var firstRowCells = table.$.rows[0] && table.$.rows[0].cells;

		// Where to put the cursor after columns been deleted?
		// 1. Into next cell of the first row if any;
		// 2. Into previous cell of the first row if any;
		// 3. Into table's parent element;
		var cursorPosition = new CKEDITOR.dom.element(firstRowCells[startColIndex] || (startColIndex ? firstRowCells[startColIndex - 1] : table.$.parentNode));

		// Delete table rows only if all columns are gone (do not remove empty row).
		if (rowsToDelete.length == rows) table.remove();

		return cursorPosition;
	}

	function insertCell(selection, insertBefore) {
		var startElement = selection.getStartElement();
		var cell = startElement.getAscendant('td', 1) || startElement.getAscendant('th', 1);

		if (!cell) return;

		// Create the new cell element to be added.
		var newCell = cell.clone();
		newCell.appendBogus();

		if (insertBefore) newCell.insertBefore(cell);else newCell.insertAfter(cell);
	}

	function deleteCells(selectionOrCell) {
		if (selectionOrCell instanceof CKEDITOR.dom.selection) {
			var cellsToDelete = getSelectedCells(selectionOrCell);
			var table = cellsToDelete[0] && cellsToDelete[0].getAscendant('table');
			var cellToFocus = getFocusElementAfterDelCells(cellsToDelete);

			for (var i = cellsToDelete.length - 1; i >= 0; i--) {
				deleteCells(cellsToDelete[i]);
			}if (cellToFocus) placeCursorInCell(cellToFocus, true);else if (table) table.remove();
		} else if (selectionOrCell instanceof CKEDITOR.dom.element) {
			var tr = selectionOrCell.getParent();
			if (tr.getChildCount() == 1) tr.remove();else selectionOrCell.remove();
		}
	}

	// Remove filler at end and empty spaces around the cell content.
	function trimCell(cell) {
		var bogus = cell.getBogus();
		bogus && bogus.remove();
		cell.trim();
	}

	function placeCursorInCell(cell, placeAtEnd) {
		var docInner = cell.getDocument(),
		    docOuter = CKEDITOR.document;

		// Fixing "Unspecified error" thrown in IE10 by resetting
		// selection the dirty and shameful way (#10308).
		// We can not apply this hack to IE8 because
		// it causes error (#11058).
		if (CKEDITOR.env.ie && CKEDITOR.env.version == 10) {
			docOuter.focus();
			docInner.focus();
		}

		var range = new CKEDITOR.dom.range(docInner);
		if (!range['moveToElementEdit' + (placeAtEnd ? 'End' : 'Start')](cell)) {
			range.selectNodeContents(cell);
			range.collapse(placeAtEnd ? false : true);
		}
		range.select(true);
	}

	function cellInRow(tableMap, rowIndex, cell) {
		var oRow = tableMap[rowIndex];
		if (typeof cell == 'undefined') return oRow;

		for (var c = 0; oRow && c < oRow.length; c++) {
			if (cell.is && oRow[c] == cell.$) return c;else if (c == cell) return new CKEDITOR.dom.element(oRow[c]);
		}
		return cell.is ? -1 : null;
	}

	function cellInCol(tableMap, colIndex) {
		var oCol = [];
		for (var r = 0; r < tableMap.length; r++) {
			var row = tableMap[r];
			oCol.push(row[colIndex]);

			// Avoid adding duplicate cells.
			if (row[colIndex].rowSpan > 1) r += row[colIndex].rowSpan - 1;
		}
		return oCol;
	}

	function mergeCells(selection, mergeDirection, isDetect) {
		var cells = getSelectedCells(selection);

		// Invalid merge request if:
		// 1. In batch mode despite that less than two selected.
		// 2. In solo mode while not exactly only one selected.
		// 3. Cells distributed in different table groups (e.g. from both thead and tbody).
		var commonAncestor;
		if ((mergeDirection ? cells.length != 1 : cells.length < 2) || (commonAncestor = selection.getCommonAncestor()) && commonAncestor.type == CKEDITOR.NODE_ELEMENT && commonAncestor.is('table')) return false;

		var cell,
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    mapHeight = map.length,
		    mapWidth = map[0].length,
		    startRow = firstCell.getParent().$.rowIndex,
		    startColumn = cellInRow(map, startRow, firstCell);

		if (mergeDirection) {
			var targetCell;
			try {
				var rowspan = parseInt(firstCell.getAttribute('rowspan'), 10) || 1;
				var colspan = parseInt(firstCell.getAttribute('colspan'), 10) || 1;

				targetCell = map[mergeDirection == 'up' ? startRow - rowspan : mergeDirection == 'down' ? startRow + rowspan : startRow][mergeDirection == 'left' ? startColumn - colspan : mergeDirection == 'right' ? startColumn + colspan : startColumn];
			} catch (er) {
				return false;
			}

			// 1. No cell could be merged.
			// 2. Same cell actually.
			if (!targetCell || firstCell.$ == targetCell) return false;

			// Sort in map order regardless of the DOM sequence.
			cells[mergeDirection == 'up' || mergeDirection == 'left' ? 'unshift' : 'push'](new CKEDITOR.dom.element(targetCell));
		}

		// Start from here are merging way ignorance (merge up/right, batch merge).
		var doc = firstCell.getDocument(),
		    lastRowIndex = startRow,
		    totalRowSpan = 0,
		    totalColSpan = 0,

		// Use a documentFragment as buffer when appending cell contents.
		frag = !isDetect && new CKEDITOR.dom.documentFragment(doc),
		    dimension = 0;

		for (var i = 0; i < cells.length; i++) {
			cell = cells[i];

			var tr = cell.getParent(),
			    cellFirstChild = cell.getFirst(),
			    colSpan = cell.$.colSpan,
			    rowSpan = cell.$.rowSpan,
			    rowIndex = tr.$.rowIndex,
			    colIndex = cellInRow(map, rowIndex, cell);

			// Accumulated the actual places taken by all selected cells.
			dimension += colSpan * rowSpan;
			// Accumulated the maximum virtual spans from column and row.
			totalColSpan = Math.max(totalColSpan, colIndex - startColumn + colSpan);
			totalRowSpan = Math.max(totalRowSpan, rowIndex - startRow + rowSpan);

			if (!isDetect) {
				// Trim all cell fillers and check to remove empty cells.
				if (trimCell(cell), cell.getChildren().count()) {
					// Merge vertically cells as two separated paragraphs.
					if (rowIndex != lastRowIndex && cellFirstChild && !(cellFirstChild.isBlockBoundary && cellFirstChild.isBlockBoundary({ br: 1 }))) {
						var last = frag.getLast(CKEDITOR.dom.walker.whitespaces(true));
						if (last && !(last.is && last.is('br'))) frag.append('br');
					}

					cell.moveChildren(frag);
				}
				i ? cell.remove() : cell.setHtml('');
			}
			lastRowIndex = rowIndex;
		}

		if (!isDetect) {
			frag.moveChildren(firstCell);

			firstCell.appendBogus();

			if (totalColSpan >= mapWidth) firstCell.removeAttribute('rowSpan');else firstCell.$.rowSpan = totalRowSpan;

			if (totalRowSpan >= mapHeight) firstCell.removeAttribute('colSpan');else firstCell.$.colSpan = totalColSpan;

			// Swip empty <tr> left at the end of table due to the merging.
			var trs = new CKEDITOR.dom.nodeList(table.$.rows),
			    count = trs.count();

			for (i = count - 1; i >= 0; i--) {
				var tailTr = trs.getItem(i);
				if (!tailTr.$.cells.length) {
					tailTr.remove();
					count++;
					continue;
				}
			}

			return firstCell;
		}
		// Be able to merge cells only if actual dimension of selected
		// cells equals to the caculated rectangle.
		else {
				return totalRowSpan * totalColSpan == dimension;
			}
	}

	function verticalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0],
		    tr = cell.getParent(),
		    table = tr.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    rowIndex = tr.$.rowIndex,
		    colIndex = cellInRow(map, rowIndex, cell),
		    rowSpan = cell.$.rowSpan,
		    newCell,
		    newRowSpan,
		    newCellRowSpan,
		    newRowIndex;

		if (rowSpan > 1) {
			newRowSpan = Math.ceil(rowSpan / 2);
			newCellRowSpan = Math.floor(rowSpan / 2);
			newRowIndex = rowIndex + newRowSpan;
			var newCellTr = new CKEDITOR.dom.element(table.$.rows[newRowIndex]),
			    newCellRow = cellInRow(map, newRowIndex),
			    candidateCell;

			newCell = cell.clone();

			// Figure out where to insert the new cell by checking the vitual row.
			for (var c = 0; c < newCellRow.length; c++) {
				candidateCell = newCellRow[c];
				// Catch first cell actually following the column.
				if (candidateCell.parentNode == newCellTr.$ && c > colIndex) {
					newCell.insertBefore(new CKEDITOR.dom.element(candidateCell));
					break;
				} else {
					candidateCell = null;
				}
			}

			// The destination row is empty, append at will.
			if (!candidateCell) newCellTr.append(newCell);
		} else {
			newCellRowSpan = newRowSpan = 1;

			newCellTr = tr.clone();
			newCellTr.insertAfter(tr);
			newCellTr.append(newCell = cell.clone());

			var cellsInSameRow = cellInRow(map, rowIndex);
			for (var i = 0; i < cellsInSameRow.length; i++) {
				cellsInSameRow[i].rowSpan++;
			}
		}

		newCell.appendBogus();

		cell.$.rowSpan = newRowSpan;
		newCell.$.rowSpan = newCellRowSpan;
		if (newRowSpan == 1) cell.removeAttribute('rowSpan');
		if (newCellRowSpan == 1) newCell.removeAttribute('rowSpan');

		return newCell;
	}

	function horizontalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0],
		    tr = cell.getParent(),
		    table = tr.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    rowIndex = tr.$.rowIndex,
		    colIndex = cellInRow(map, rowIndex, cell),
		    colSpan = cell.$.colSpan,
		    newCell,
		    newColSpan,
		    newCellColSpan;

		if (colSpan > 1) {
			newColSpan = Math.ceil(colSpan / 2);
			newCellColSpan = Math.floor(colSpan / 2);
		} else {
			newCellColSpan = newColSpan = 1;
			var cellsInSameCol = cellInCol(map, colIndex);
			for (var i = 0; i < cellsInSameCol.length; i++) {
				cellsInSameCol[i].colSpan++;
			}
		}
		newCell = cell.clone();
		newCell.insertAfter(cell);
		newCell.appendBogus();

		cell.$.colSpan = newColSpan;
		newCell.$.colSpan = newCellColSpan;
		if (newColSpan == 1) cell.removeAttribute('colSpan');
		if (newCellColSpan == 1) newCell.removeAttribute('colSpan');

		return newCell;
	}

	CKEDITOR.plugins.add('ae_tabletools', {
		init: function init(editor) {
			var lang = editor.lang.table;

			function createDef(def) {
				return CKEDITOR.tools.extend(def || {}, {
					contextSensitive: 1,
					refresh: function refresh(editor, path) {
						this.setState(path.contains({ td: 1, th: 1 }, 1) ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
					}
				});
			}
			function addCmd(name, def) {
				var cmd = editor.getCommand(name);

				if (cmd) {
					return;
				}

				cmd = editor.addCommand(name, def);
				editor.addFeature(cmd);
			}

			addCmd('rowDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					placeCursorInCell(deleteRows(selection));
				}
			}));

			addCmd('rowInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertRow(selection, true);
				}
			}));

			addCmd('rowInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertRow(selection);
				}
			}));

			addCmd('columnDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					var element = deleteColumns(selection);
					element && placeCursorInCell(element, true);
				}
			}));

			addCmd('columnInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertColumn(selection, true);
				}
			}));

			addCmd('columnInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertColumn(selection);
				}
			}));

			addCmd('cellDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					deleteCells(selection);
				}
			}));

			addCmd('cellMerge', createDef({
				allowedContent: 'td[colspan,rowspan]',
				requiredContent: 'td[colspan,rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection()), true);
				}
			}));

			addCmd('cellMergeRight', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'right'), true);
				}
			}));

			addCmd('cellMergeDown', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'down'), true);
				}
			}));

			addCmd('cellVerticalSplit', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(verticalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellHorizontalSplit', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(horizontalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection, true);
				}
			}));

			addCmd('cellInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection);
				}
			}));
		},

		getSelectedCells: getSelectedCells

	});
})();

/**
 * Create a two-dimension array that reflects the actual layout of table cells,
 * with cell spans, with mappings to the original td elements.
 *
 * @param {CKEDITOR.dom.element} table
 * @member CKEDITOR.tools
 */
CKEDITOR.tools.buildTableMap = function (table) {
	var aRows = table.$.rows;

	// Row and Column counters.
	var r = -1;

	var aMap = [];

	for (var i = 0; i < aRows.length; i++) {
		r++;
		!aMap[r] && (aMap[r] = []);

		var c = -1;

		for (var j = 0; j < aRows[i].cells.length; j++) {
			var oCell = aRows[i].cells[j];

			c++;
			while (aMap[r][c]) {
				c++;
			}var iColSpan = isNaN(oCell.colSpan) ? 1 : oCell.colSpan;
			var iRowSpan = isNaN(oCell.rowSpan) ? 1 : oCell.rowSpan;

			for (var rs = 0; rs < iRowSpan; rs++) {
				if (!aMap[r + rs]) aMap[r + rs] = [];

				for (var cs = 0; cs < iColSpan; cs++) {
					aMap[r + rs][c + cs] = aRows[i].cells[j];
				}
			}

			c += iColSpan - 1;
		}
	}
	return aMap;
};

/***/ }),

/***/ "./src/selections/selection-arrowbox.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-arrowbox.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var tableSelectionGetArrowBoxClasses = function tableSelectionGetArrowBoxClasses() {
    return 'ae-arrow-box ae-arrow-box-bottom';
};

var SelectionGetArrowBoxClasses = {
    table: tableSelectionGetArrowBoxClasses
};

exports.default = SelectionGetArrowBoxClasses;

/***/ }),

/***/ "./src/selections/selection-position.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-position.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default gutter value for toolbar positioning
var DEFAULT_GUTTER = {
    left: 0,
    top: 0
};

/**
 * Centers a Toolbar according to given rectangle
 *
 * @method centerToolbar
 * @param {Object} toolbar The toolbar to be centered
 * @param {Object} rect The rectangle according to which the Toolbar will be centered
 */
var centerToolbar = function centerToolbar(toolbar, rect) {
    var toolbarNode = _reactDom2.default.findDOMNode(toolbar);

    var halfNodeWidth = toolbarNode.offsetWidth / 2;
    var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

    var gutter = toolbar.props.gutter || DEFAULT_GUTTER;

    var widgetXY = toolbar.getWidgetXYPoint(rect.left + rect.width / 2 - scrollPosition.x, rect.top + scrollPosition.y, CKEDITOR.SELECTION_BOTTOM_TO_TOP);

    toolbar.moveToPoint([widgetXY[0], widgetXY[1]], [rect.left + rect.width / 2 - halfNodeWidth - scrollPosition.x, rect.top - toolbarNode.offsetHeight + scrollPosition.y - gutter.top]);
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method imageSelectionSetPosition
 * @param {Object} payload Payload, should contain the selection data for retrieving the
 * client rectangle of the selected image
 * @return {Boolean} True, in all cases
 */
var imageSelectionSetPosition = function imageSelectionSetPosition(payload) {
    centerToolbar(this, payload.selectionData.element.getClientRect());

    return true;
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method tableSelectionSetPosition
 * @param {Object} payload Object, which contains the selection data for retrieving the
 * client rectangle of the selected table
 * @return {Boolean} True, in all cases
 */
var tableSelectionSetPosition = function tableSelectionSetPosition(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');

    var table = new CKEDITOR.Table(nativeEditor).getFromSelection();

    centerToolbar(this, table.getClientRect());

    return true;
};

var SelectionSetPosition = {
    image: imageSelectionSetPosition,
    table: tableSelectionSetPosition
};

exports.default = SelectionSetPosition;

/***/ }),

/***/ "./src/selections/selection-test.js":
/*!******************************************!*\
  !*** ./src/selections/selection-test.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var _isRangeAtElementEnd = function _isRangeAtElementEnd(range, element) {
    // Finding if a range is at the end of an element is somewhat tricky due to how CKEditor handles
    // ranges. It might depend on wether a source node inside the element is selected or not. For now,
    // we need to cover the following cases:
    //
    // - The text length of the element is the same as the endOffset of the range
    // - Both start and end containers match the element and the start and end offsets are 1

    return element.getText().length === range.endOffset || element.equals(range.startContainer) && element.equals(range.endContainer) && range.startOffset === range.endOffset && range.endOffset === 1;
};

var embedSelectionTest = function embedSelectionTest(payload) {
    var selectionData = payload.data.selectionData;

    return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'ae_embed');
};

var linkSelectionTest = function linkSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');
    var range = nativeEditor.getSelection().getRanges()[0];

    var element;

    return !!(nativeEditor.isSelectionEmpty() && (element = new CKEDITOR.Link(nativeEditor).getFromSelection()) && element.getText().length !== range.endOffset && !element.isReadOnly() && !_isRangeAtElementEnd(range, element));
};

var imageSelectionTest = function imageSelectionTest(payload) {
    var selectionData = payload.data.selectionData;

    return !!(selectionData.element && selectionData.element.getName() === 'img' && !selectionData.element.isReadOnly());
};

var textSelectionTest = function textSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');

    var selectionEmpty = nativeEditor.isSelectionEmpty();

    var selectionData = payload.data.selectionData;

    return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly());
};

var tableSelectionTest = function tableSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');

    var table = new CKEDITOR.Table(nativeEditor);
    var element = table.getFromSelection();

    return !!(element && table.isEditable(element));
};

var SelectionTest = {
    embed: embedSelectionTest,
    image: imageSelectionTest,
    link: linkSelectionTest,
    table: tableSelectionTest,
    text: textSelectionTest
};

exports.default = SelectionTest;

/***/ }),

/***/ "./src/selections/selections.js":
/*!**************************************!*\
  !*** ./src/selections/selections.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _selectionArrowbox = __webpack_require__(/*! ./selection-arrowbox.js */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selectionPosition = __webpack_require__(/*! ./selection-position.js */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ./selection-test.js */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Selections = [{
    name: 'embed',
    buttons: ['embedRemove', 'embedEdit'],
    test: _selectionTest2.default.embed
}, {
    name: 'link',
    buttons: ['linkEdit'],
    test: _selectionTest2.default.link
}, {
    name: 'image',
    buttons: ['imageLeft', 'imageCenter', 'imageRight'],
    setPosition: _selectionPosition2.default.image,
    test: _selectionTest2.default.image
}, {
    name: 'text',
    buttons: ['styles', 'bold', 'italic', 'underline', 'link', 'twitter'],
    test: _selectionTest2.default.text
}, {
    name: 'table',
    buttons: ['tableHeading', 'tableRow', 'tableColumn', 'tableCell', 'tableRemove'],
    getArrowBoxClasses: _selectionArrowbox2.default.table,
    setPosition: _selectionPosition2.default.table,
    test: _selectionTest2.default.table
}];

exports.default = Selections;

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window["React"]; }());

/***/ }),

/***/ "react-dom":
/*!***************************!*\
  !*** external "ReactDOM" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window["ReactDOM"]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BbGxveUVkaXRvci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL2NvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvYWRhcHRlci9tYWluLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1jb21tYW5kLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tcHJvcHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL3Rvb2xiYXItYnV0dG9ucy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWFycm93LWJveC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtZXhjbHVzaXZlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LXBvc2l0aW9uLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tYm9sZC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jYW1lcmEtaW1hZ2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY2FtZXJhLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNvZGUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY29tbWFuZHMtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1kcm9wZG93bi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1lbWJlZC1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWVtYmVkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWgxLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWgyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWhsaW5lLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLWNlbnRlci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWluZGVudC1ibG9jay5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pdGFsaWMuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWVkaXQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay10YXJnZXQtZWRpdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLW9sLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLW91dGRlbnQtYmxvY2suanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWFsaWduLXJpZ2h0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXBhcmFncmFwaC1jZW50ZXIuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWp1c3RpZnkuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcXVvdGUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcmVtb3ZlLWZvcm1hdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdHJpa2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QtaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN1YnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdXBlcnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1jZWxsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWNvbHVtbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWhlYWRpbmcuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFibGUtcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLXJvdy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YXJnZXQtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10d2l0dGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVuZGVybGluZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvbWFpbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy90b29sYmFycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItYWRkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL3VpYnJpZGdlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL2xpbmsuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9wbHVnaW5zLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvc2VsZWN0aW9uLXJlZ2lvbi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL3RhYmxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvdG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS91aWNvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvb29wL2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvYmFzZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvbGFuZy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3Avb29wLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvYWRkaW1hZ2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvYXV0b2xpbmsuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9hdXRvbGlzdC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2RyYWdyZXNpemUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9kcmFncmVzaXplX2llLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvZW1iZWQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9pbWFnZWFsaWdubWVudC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvcGFzdGVpbWFnZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9wbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3NlbGVjdGlvbmtleXN0cm9rZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy90YWJsZXJlc2l6ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3RhYmxldG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tYXJyb3dib3guanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9zZWxlY3Rpb25zL3NlbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvZXh0ZXJuYWwgXCJSZWFjdFwiIiwid2VicGFjazovL0FsbG95RWRpdG9yL2V4dGVybmFsIFwiUmVhY3RET01cIiJdLCJuYW1lcyI6WyJDb3JlIiwiY29uZmlnIiwic3VwZXJjbGFzcyIsImNvbnN0cnVjdG9yIiwiY2FsbCIsImluaXRpYWxpemVyIiwibm9kZSIsImdldCIsInNldEF0dHJpYnV0ZSIsImVkaXRvciIsIkNLRURJVE9SIiwiaW5saW5lIiwiYWxsb3dlZENvbnRlbnQiLCJ0b29sYmFycyIsInJlbW92ZVBsdWdpbnMiLCJleHRyYVBsdWdpbnMiLCJwbGFjZWhvbGRlckNsYXNzIiwicGFzdGVGcm9tV29yZFJlbW92ZVN0eWxlcyIsInBhc3RlRnJvbVdvcmRSZW1vdmVGb250U3R5bGVzIiwic2VsZWN0aW9uS2V5c3Ryb2tlcyIsIm1peCIsImVudiIsImllIiwiZWRnZSIsInJlcGxhY2UiLCJvbmNlIiwiX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXIiLCJlZGl0YWJsZSIsImFkZENsYXNzIiwiYmluZCIsIl9lZGl0b3IiLCJBbGxveUVkaXRvciIsImxvYWRMYW5ndWFnZVJlc291cmNlcyIsIl9yZW5kZXJVSSIsImRlc3RydWN0b3IiLCJfZGVzdHJveWVkIiwiX2VkaXRvclVJRWxlbWVudCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJuYXRpdmVFZGl0b3IiLCJyZW1vdmVDbGFzcyIsIl9jbGVhclNlbGVjdGlvbnMiLCJkZXN0cm95IiwiaXNNU1NlbGVjdGlvbiIsIndpbmRvdyIsImdldFNlbGVjdGlvbiIsImRvY3VtZW50IiwiJCIsInNlbGVjdGlvbiIsImVtcHR5IiwiZ2V0V2luZG93IiwicmVtb3ZlQWxsUmFuZ2VzIiwib24iLCJfZGVmYXVsdFJlYWRPbmx5Q2xpY2tGbiIsImV2ZW50IiwibW91c2VFdmVudCIsImRhdGEiLCJoYXNDdHJsS2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaG91bGRPcGVuIiwicmVhZE9ubHkiLCJwcmV2ZW50RGVmYXVsdCIsImxpc3RlbmVyRGF0YSIsImZpcmUiLCJja0VsZW1lbnQiLCJkb20iLCJlbGVtZW50UGF0aCIsImdldFRhcmdldCIsImxpbmsiLCJsYXN0RWxlbWVudCIsImhyZWYiLCJhdHRyaWJ1dGVzIiwidmFsdWUiLCJ0YXJnZXQiLCJfcmVkaXJlY3RMaW5rIiwiX2dldE5hdGl2ZUVkaXRvciIsIm9wZW4iLCJsb2NhdGlvbiIsImVkaXRvclVJRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJ1aU5vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJfbWFpblVJIiwicmVuZGVyIiwiX3RvRWxlbWVudCIsImlzU3RyaW5nIiwiZ2V0RWxlbWVudEJ5SWQiLCJfdmFsaWRhdGVBbGxvd2VkQ29udGVudCIsImlzT2JqZWN0IiwiaXNCb29sZWFuIiwiX3ZhbGlkYXRlVG9vbGJhcnMiLCJpc051bGwiLCJBVFRSUyIsInZhbGlkYXRvciIsIndyaXRlT25jZSIsImVuYWJsZUNvbnRlbnRFZGl0YWJsZSIsImV2ZW50c0RlbGF5IiwiaXNOdW1iZXIiLCJnZXR0ZXIiLCJpc0FycmF5Iiwia2V5cyIsIkNUUkwiLCJTSElGVCIsInNyY05vZGUiLCJzZXR0ZXIiLCJhZGQiLCJidXR0b25zIiwidGFiSW5kZXgiLCJzdHlsZXMiLCJzZWxlY3Rpb25zIiwiaW1wbGVtZW50T24iLCJCUklER0VfQlVUVE9OUyIsImltcGxlbWVudEV2ZW50VGFyZ2V0IiwiZ2V0QmFzZVBhdGgiLCJwYXRoIiwiQUxMT1lFRElUT1JfQkFTRVBBVEgiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpIiwibGVuZ3RoIiwibWF0Y2giLCJzcmMiLCJyZWdleEJhc2VQYXRoIiwiaW5kZXhPZiIsInNsaWNlIiwiY2FsbGJhY2siLCJpc0Z1bmN0aW9uIiwiU3RyaW5ncyIsInNldFRpbWVvdXQiLCJfbGFuZ1Jlc291cmNlUmVxdWVzdGVkIiwibGFuZ3VhZ2VzIiwidXNlckxhbmd1YWdlIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJwYXJ0cyIsInRvTG93ZXJDYXNlIiwibGFuZyIsImxvY2FsZSIsInNjcmlwdExvYWRlciIsImxvYWQiLCJnZXRVcmwiLCJsb2FkZWQiLCJyZXNvdXJjZSIsImJhc2VQYXRoIiwidGltZXN0YW1wIiwiY2hhckF0IiwidGVzdCIsImdldEJ1dHRvbnMiLCJyZWR1Y2UiLCJhY2MiLCJ2YWwiLCJjb25jYXQiLCJyZWdpc3RlckJyaWRnZUJ1dHRvbiIsImJ1dHRvbk5hbWUiLCJwbHVnaW5OYW1lIiwicHVzaCIsIkJ1dHRvbnMiLCJTZWxlY3Rpb25UZXN0IiwiVG9vbGJhcnMiLCJpc0FjdGl2ZSIsImdldFN0eWxlIiwicHJvcHMiLCJsb2NrIiwicmVtb3ZlU3R5bGUiLCJhcHBseVN0eWxlIiwidW5sb2NrIiwiV3JhcHBlZENvbXBvbmVudCIsImNvbW1hbmQiLCJnZXRDb21tYW5kIiwic3RhdGUiLCJUUklTVEFURV9PTiIsImV4ZWNDb21tYW5kIiwibW9kaWZpZXNTZWxlY3Rpb24iLCJzZWxlY3Rpb25DaGFuZ2UiLCJrZXlzdHJva2UiLCJjb21tYW5kTmFtZSIsIm5hbWUiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJleGVjIiwia2V5c3Ryb2tlRm4iLCJmbiIsImFkZENvbW1hbmQiLCJfZGVmYXVsdEtleXN0cm9rZUNvbW1hbmQiLCJrZXlzdHJva2VIYW5kbGVyIiwia2V5c3Ryb2tlcyIsInNldEtleXN0cm9rZSIsImJ1dHRvbkNmZyIsInJlc3VsdCIsInRvb2xzIiwibWVyZ2UiLCJzdGF0ZUNsYXNzZXMiLCJpc0Rpc2FibGVkIiwic3R5bGUiLCJzcGxpdCIsImN1cnJlbnRNZW1iZXIiLCJwcm9wZXJ0eSIsInNoaWZ0IiwiX3N0eWxlIiwiY2hlY2tBY3RpdmUiLCJhZGRpdGlvbmFsUHJvcHMiLCJidXR0b25Qcm9wcyIsInRvb2xiYXJCdXR0b25zIiwiZmlsdGVyRXhjbHVzaXZlIiwiZmlsdGVyIiwiYnV0dG9uIiwibWFwIiwia2V5IiwiY2ZnIiwibWVyZ2VFeGNsdXNpdmVQcm9wcyIsInRhYktleSIsInRyaWdnZXIiLCJtZXJnZURyb3Bkb3duUHJvcHMiLCJhcnJvd0JveENsYXNzZXMiLCJnZXRJbnRlcmFjdGlvblBvaW50IiwiZGlyZWN0aW9uIiwiU0VMRUNUSU9OX1RPUF9UT19CT1RUT00iLCJkcm9wZG93blRyaWdnZXIiLCJpdGVtRHJvcGRvd24iLCJuZXh0UHJvcHMiLCJzZXRTdGF0ZSIsIm9iaiIsIml0ZW1LZXkiLCJleHBhbmRlZCIsInRvZ2dsZURyb3Bkb3duIiwidG9nZ2xlRGlyZWN0aW9uIiwibW92ZUZvY3VzIiwiZmluZERPTU5vZGUiLCJmb2N1cyIsIml0ZW1FeGNsdXNpdmUiLCJpdGVtcyIsIml0ZW0iLCJjYW5jZWxFeGNsdXNpdmUiLCJyZW5kZXJFeGNsdXNpdmUiLCJyZXF1ZXN0RXhjbHVzaXZlIiwiRElSRUNUSU9OX05PTkUiLCJESVJFQ1RJT05fTkVYVCIsIkRJUkVDVElPTl9QUkVWIiwiQUNUSU9OX05PTkUiLCJBQ1RJT05fTU9WRV9GT0NVUyIsIkFDVElPTl9ESVNNSVNTX0ZPQ1VTIiwiX3JlZnJlc2giLCJfaXNWYWxpZFRhcmdldCIsIl9kZXNjZW5kYW50cyIsImFjdGl2ZURlc2NlbmRhbnRFbCIsIl9hY3RpdmVEZXNjZW5kYW50IiwiYWN0aXZlRWxlbWVudCIsImZvY3VzRmlyc3RDaGlsZCIsInN0b3BQcm9wYWdhdGlvbiIsImFjdGlvbiIsIl9nZXRGb2N1c0FjdGlvbiIsInR5cGUiLCJfbW92ZUZvY3VzIiwib25EaXNtaXNzIiwiX2dldEZvY3VzTW92ZURpcmVjdGlvbiIsImRpc21pc3NBY3Rpb24iLCJfZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uIiwiZGlzbWlzcyIsImZvY3VzTW92ZURpcmVjdGlvbiIsIl9pc1ZhbGlkS2V5Iiwia2V5Q29kZSIsImRpc21pc3NOZXh0IiwiZGlzbWlzc1ByZXYiLCJjaXJjdWxhciIsIm5leHQiLCJwcmV2Iiwic2hpZktleSIsImVsZW1lbnQiLCJ0YWdOYW1lIiwibnVtRGVzY2VuZGFudHMiLCJkZXNjZW5kYW50IiwibWF4IiwibWluIiwiZG9tTm9kZSIsImRlc2NlbmRhbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsInByaW9yaXR5RGVzY2VuZGFudHMiLCJBcnJheSIsInByb3RvdHlwZSIsImZvckVhY2giLCJkYXRhVGFiSW5kZXgiLCJnZXRBdHRyaWJ1dGUiLCJzb3J0IiwiYSIsImIiLCJ0b0ludCIsInNvbWUiLCJpbmRleCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiX2FuaW1hdGlvbkZyYW1lSWQiLCJhdHRycyIsInZpZXdQYW5lU2l6ZSIsImdldFZpZXdQYW5lU2l6ZSIsIngiLCJsZWZ0IiwieSIsInRvcCIsIndpZHRoIiwiZXZlbnRQYXlsb2FkIiwiZWRpdG9yRXZlbnQiLCJzZWxlY3Rpb25EYXRhIiwibmF0aXZlRXZlbnQiLCJwb3MiLCJwYWdlWCIsInJlZ2lvbiIsImVuZFJlY3QiLCJzdGFydFJlY3QiLCJTRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCIsIl9nZXRYUG9pbnQiLCJfZ2V0WVBvaW50IiwiZXZlbnRYIiwicmlnaHQiLCJsZWZ0RGlzdCIsImFicyIsInJpZ2h0RGlzdCIsImVsZW1lbnRUYXJnZXQiLCJvZmZzZXRUb3AiLCJvZmZzZXRIZWlnaHQiLCJib3R0b20iLCJndXR0ZXIiLCJvZmZzZXRXaWR0aCIsIlNFTEVDVElPTl9MRUZUX1RPX1JJR0hUIiwiU0VMRUNUSU9OX1JJR0hUX1RPX0xFRlQiLCJkb21FbGVtZW50IiwiaGFzQ2xhc3MiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJzZXRTdHlsZXMiLCJvcGFjaXR5IiwiX2FuaW1hdGUiLCJpc1Zpc2libGUiLCJpbnRlcmFjdGlvblBvaW50IiwiZmluYWxYIiwiZmluYWxZIiwiaW5pdGlhbFgiLCJpbml0aWFsWSIsInBhcnNlRmxvYXQiLCJjb25zdHJhaW5Ub1ZpZXdwb3J0IiwicmVzIiwiZ2V0Q29uc3RyYWluZWRQb3NpdGlvbiIsImhlaWdodCIsIm1vdmVUb1BvaW50IiwieHkiLCJnZXRXaWRnZXRYWVBvaW50IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZGVmYXVsdFByb3BzIiwiQnV0dG9uQm9sZCIsImNzc0NsYXNzIiwiZ2V0U3RhdGVDbGFzc2VzIiwiYm9sZCIsIkNvbXBvbmVudCIsIkJ1dHRvbkNhbWVyYUltYWdlIiwicmVmcyIsImJ1dHRvblRha2VQaG90byIsIl9zdHJlYW0iLCJzdG9wIiwiZ2V0VmlkZW9UcmFja3MiLCJ0cmFjayIsImdldFVzZXJNZWRpYSIsIndlYmtpdEdldFVzZXJNZWRpYSIsIm1vekdldFVzZXJNZWRpYSIsIm1zR2V0VXNlck1lZGlhIiwidmlkZW8iLCJhdWRpbyIsIl9oYW5kbGVTdHJlYW1TdWNjZXNzIiwiX2hhbmRsZVN0cmVhbUVycm9yIiwidGFrZVBob3RvIiwidmlkZW9FbCIsInZpZGVvQ29udGFpbmVyIiwiY2FudmFzRWwiLCJjYW52YXNDb250YWluZXIiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsIl92aWRlb0hlaWdodCIsInZpZGVvV2lkdGgiLCJkcmF3SW1hZ2UiLCJpbWdVUkwiLCJ0b0RhdGFVUkwiLCJlbCIsImNyZWF0ZUZyb21IdG1sIiwiaW5zZXJ0RWxlbWVudCIsImVycm9yIiwiYWxlcnQiLCJzdHJlYW0iLCJhZGRFdmVudExpc3RlbmVyIiwidmlkZW9IZWlnaHQiLCJpc05hTiIsIm1velNyY09iamVjdCIsIlVSTCIsIndlYmtpdFVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInBsYXkiLCJkaXNhYmxlZCIsIkJ1dHRvbkNhbWVyYSIsInByb3RvY29sIiwibGFiZWwiLCJjYW1lcmFEaXNhYmxlZCIsImNhbWVyYSIsIkJ1dHRvbkNvZGUiLCJjb2RlIiwiQnV0dG9uQ29tbWFuZExpc3RJdGVtIiwiZGVzY3JpcHRpb24iLCJfZ2V0Q2xhc3NOYW1lIiwiaWNvbiIsIkJ1dHRvbkNvbW1hbmRzTGlzdCIsImhhbmRsZUtleSIsImxpc3RJZCIsIl9yZW5kZXJBY3Rpb25zIiwiY29tbWFuZHMiLCJCdXR0b25Ecm9wZG93biIsImNoaWxkcmVuIiwiS0VZX0VOVEVSIiwiS0VZX0VTQyIsIkJ1dHRvbkVtYmVkRWRpdCIsImxpbmtJbnB1dCIsImNyZWF0ZVJlZiIsImdldEluaXRpYWxTdGF0ZSIsIm1hbnVhbFNlbGVjdGlvbiIsIl9mb2N1c0xpbmtJbnB1dCIsImVtYmVkIiwic2VsZWN0ZWRFbGVtZW50IiwiZ2V0U2VsZWN0ZWRFbGVtZW50IiwiZmluZE9uZSIsImluaXRpYWxMaW5rIiwibGlua0hyZWYiLCJjbGVhckxpbmtTdHlsZSIsImRlbGV0ZUVtYmVkIiwiX3JlbW92ZUVtYmVkIiwiX2hhbmRsZUxpbmtIcmVmQ2hhbmdlIiwiX2hhbmRsZUtleURvd24iLCJlZGl0TGluayIsImNsZWFySW5wdXQiLCJfY2xlYXJMaW5rIiwiY2xlYXIiLCJjb25maXJtIiwiX2lzVmFsaWRTdGF0ZSIsIl9lbWJlZExpbmsiLCJ1cmwiLCJjdXJyZW50IiwidmFsaWRTdGF0ZSIsImVtYmVkV3JhcHBlciIsImdldEFzY2VuZGFudCIsInJlbW92ZSIsIkJ1dHRvbkVtYmVkIiwiX3JlcXVlc3RFeGNsdXNpdmUiLCJCdXR0b25IMSIsImgxIiwiQnV0dG9uSDIiLCJoMiIsIkJ1dHRvbkhsaW5lIiwiaG9yaXpvbnRhbHJ1bGUiLCJCdXR0b25JbWFnZUFsaWduQ2VudGVyIiwiYWxpZ25DZW50ZXIiLCJCdXR0b25JbWFnZUFsaWduTGVmdCIsImFsaWduTGVmdCIsIkJ1dHRvbkltYWdlQWxpZ25SaWdodCIsImFsaWduUmlnaHQiLCJCdXR0b25JbWFnZSIsImZpbGVJbnB1dCIsImlucHV0U3lsZSIsImRpc3BsYXkiLCJpbWFnZSIsImhhbmRsZUNsaWNrIiwiX29uSW5wdXRDaGFuZ2UiLCJjbGljayIsImlucHV0RWwiLCJmaWxlcyIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJmaWxlIiwib25sb2FkIiwiaW1hZ2VGaWxlcyIsImltYWdlRGF0YSIsInJlYWRBc0RhdGFVUkwiLCJCdXR0b25JbmRlbnRCbG9jayIsImluZGVudCIsIkJ1dHRvbkl0YWxpYyIsIml0YWxpYyIsIkJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IiwidGVybSIsImNsZWFyVGltZW91dCIsIl90aW1lb3V0IiwiX3VwZGF0ZUl0ZW1zIiwiZGVsYXkiLCJhdXRvY29tcGxldGVTZWxlY3RlZCIsInNldEF1dG9jb21wbGV0ZVN0YXRlIiwic2VsZWN0ZWQiLCJfcmVuZGVyQXV0b2NvbXBsZXRlSXRlbXMiLCJuZXh0U3RhdGUiLCJoYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2siLCJ0aXRsZSIsImluc3RhbmNlIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIkJ1dHRvbkxpbmtFZGl0IiwiX2dldEluaXRpYWxTdGF0ZSIsInRhcmdldFNlbGVjdG9yIiwiYWxsb3dlZFRhcmdldHMiLCJoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlIiwiX2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2UiLCJzZWxlY3RlZFRhcmdldCIsImxpbmtUYXJnZXQiLCJsaW5rVGFyZ2V0RGVmYXVsdCIsImF1dG9jb21wbGV0ZURyb3Bkb3duIiwiZGF0YUZuIiwiYXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wcyIsIl9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2siLCJfc2V0QXV0b2NvbXBsZXRlU3RhdGUiLCJidXR0b25DbGVhckxpbmsiLCJwbGFjZWhvbGRlclByb3AiLCJwbGFjZWhvbGRlciIsInJlbW92ZUxpbmsiLCJfcmVtb3ZlTGluayIsInNob3dUYXJnZXRTZWxlY3RvciIsIl91cGRhdGVMaW5rIiwiZGVmYXVsdExpbmtUYXJnZXQiLCJMaW5rIiwiZ2V0RnJvbVNlbGVjdGlvbiIsImZvY3VzTGlua0VsIiwiYWR2YW5jZVNlbGVjdGlvbiIsImxpbmtVdGlscyIsImJvb2ttYXJrcyIsImNyZWF0ZUJvb2ttYXJrcyIsImFkdmFuY2UiLCJzZWxlY3RCb29rbWFya3MiLCJhcHBlbmRQcm90b2NvbCIsImxpbmtBdHRycyIsIm1vZGlmeVNlbGVjdGlvbiIsInVwZGF0ZSIsImNyZWF0ZSIsImF1dG9jb21wbGV0ZVVybCIsImN1c3RvbUluZGV4U3RhcnQiLCJCdXR0b25MaW5rVGFyZ2V0RWRpdCIsImFsbG93ZWRMaW5rVGFyZ2V0cyIsIkJ1dHRvbkxpbmsiLCJtZXJnZUJ1dHRvbkNmZ1Byb3BzIiwiQnV0dG9uT3JkZXJlZExpc3QiLCJudW1iZXJlZGxpc3QiLCJCdXR0b25PdXRkZW50QmxvY2siLCJvdXRkZW50IiwiQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0IiwiQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCIsIkJ1dHRvblBhcmFncmFwaENlbnRlciIsIkJ1dHRvblBhcmFncmFwaEp1c3RpZnkiLCJhbGlnbkp1c3RpZnkiLCJCdXR0b25RdW90ZSIsInF1b3RlIiwiQnV0dG9uUmVtb3ZlRm9ybWF0IiwicmVtb3ZlZm9ybWF0IiwiQnV0dG9uU3RyaWtlIiwic3RyaWtlIiwiQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIiLCJCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSIsIl9yZW1vdmVTdHlsZXMiLCJub3JtYWwiLCJyZW1vdmVCbG9ja3MiLCJibG9ja0l0ZW0iLCJibG9ja1N0eWxlIiwiQnV0dG9uU3R5bGVzTGlzdEl0ZW0iLCJzdHlsZUNmZyIsIm1hcmdpbiIsIl9wcmV2aWV3IiwiYnVpbGRQcmV2aWV3IiwiYWN0aXZlU3R5bGUiLCJfX2h0bWwiLCJfb25DbGljayIsIkJ1dHRvblN0eWxlc0xpc3QiLCJibG9ja1N0eWxlcyIsImlubGluZVN0eWxlcyIsIm9iamVjdFN0eWxlcyIsIlNUWUxFX0JMT0NLIiwiU1RZTEVfSU5MSU5FIiwiU1RZTEVfT0JKRUNUIiwiX2Jsb2NrU3R5bGVzIiwiX2lubGluZVN0eWxlcyIsIl9vYmplY3RTdHlsZXMiLCJyZW1vdmVTdHlsZXNJdGVtIiwic2hvd1JlbW92ZVN0eWxlc0l0ZW0iLCJfcmVuZGVyU3R5bGVzSXRlbXMiLCJCdXR0b25TdHlsZXMiLCJfZ2V0U3R5bGVzIiwiX2NoZWNrQWN0aXZlIiwiYnV0dG9uU3R5bGVzTGlzdCIsInN0eWxlQ29uZmlnIiwiZm9ybWF0dGVkIiwiY2l0ZSIsIkJ1dHRvblN1YnNjcmlwdCIsInN1YnNjcmlwdCIsIkJ1dHRvblN1cGVyc2NyaXB0Iiwic3VwZXJzY3JpcHQiLCJCdXR0b25UYWJsZUNlbGwiLCJidXR0b25Db21tYW5kc0xpc3QiLCJidXR0b25Db21tYW5kc0xpc3RJZCIsIl9nZXRDb21tYW5kcyIsImNlbGwiLCJjZWxsSW5zZXJ0QmVmb3JlIiwiY2VsbEluc2VydEFmdGVyIiwiY2VsbERlbGV0ZSIsImNlbGxNZXJnZSIsImNlbGxNZXJnZURvd24iLCJjZWxsTWVyZ2VSaWdodCIsImNlbGxTcGxpdEhvcml6b250YWwiLCJjZWxsU3BsaXRWZXJ0aWNhbCIsIkJ1dHRvblRhYmxlQ29sdW1uIiwiY29sdW1uIiwiY29sdW1uSW5zZXJ0QmVmb3JlIiwiY29sdW1uSW5zZXJ0QWZ0ZXIiLCJjb2x1bW5EZWxldGUiLCJCdXR0b25UYWJsZUVkaXQiLCJyb3dzUmVmIiwiY29sc1JlZiIsImNvbHMiLCJyb3dzIiwidGFibGVVdGlscyIsIlRhYmxlIiwidGFibGVBdHRyaWJ1dGVzIiwiaW5wdXROYW1lIiwiX2NyZWF0ZVRhYmxlIiwidGltZSIsIkRhdGUiLCJub3ciLCJyb3dzSWQiLCJjb2xzSWQiLCJfaGFuZGxlQ2hhbmdlIiwiY29sdW1ucyIsImJvcmRlciIsImNlbGxQYWRkaW5nIiwiY2VsbFNwYWNpbmciLCJCdXR0b25UYWJsZUhlYWRpbmciLCJhY3RpdmVIZWFkaW5nIiwiZ2V0SGVhZGluZyIsImFjdGl2ZUhlYWRpbmdJbnRybyIsImhlYWRlcnMiLCJhY3RpdmVIZWFkaW5nTGFiZWwiLCJoZWFkZXJzTm9uZSIsImhlYWRlcnNSb3ciLCJoZWFkZXJzQ29sdW1uIiwiaGVhZGVyc0JvdGgiLCJCdXR0b25UYWJsZVJlbW92ZSIsImRlbGV0ZVRhYmxlIiwiX3JlbW92ZVRhYmxlIiwiQnV0dG9uVGFibGVSb3ciLCJyb3ciLCJyb3dJbnNlcnRCZWZvcmUiLCJyb3dJbnNlcnRBZnRlciIsInJvd0RlbGV0ZSIsIkJ1dHRvblRhYmxlIiwidGFibGUiLCJCdXR0b25UYXJnZXRMaXN0IiwibGlzdFRhcmdldHMiLCJfcmVuZGVyTGlzdFRhcmdldHMiLCJsaW5rVGFyZ2V0U2VsZiIsImxpbmtUYXJnZXRCbGFuayIsImxpbmtUYXJnZXRQYXJlbnQiLCJsaW5rVGFyZ2V0VG9wIiwidGFyZ2V0cyIsIl9nZXRBbGxvd2VkVGFyZ2V0SXRlbXMiLCJCdXR0b25Ud2l0dGVyIiwiX2dldEhyZWYiLCJ0d2l0dGVyIiwic2VsZWN0ZWRUZXh0IiwiZ2V0U2VsZWN0ZWRUZXh0IiwidmlhIiwidHdpdHRlckhyZWYiLCJCdXR0b25Vbm9yZGVyZWRsaXN0IiwiYnVsbGV0ZWRsaXN0IiwiQnV0dG9uVW5kZXJsaW5lIiwidW5kZXJsaW5lIiwiVUkiLCJoaWRkZW4iLCJfb25FZGl0b3JJbnRlcmFjdGlvbiIsIl9vbkFjdGlvblBlcmZvcm1lZCIsIl9vbkVkaXRvcktleSIsIl9tb3VzZWRvd25MaXN0ZW5lciIsIl9zZXRVSUhpZGRlbiIsIl9rZXlEb3duTGlzdGVuZXIiLCJkZWJvdW5jZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsIm1lc3NhZ2UiLCJfZ2V0QXZhaWxhYmxlVG9vbGJhcnNNZXNzYWdlIiwiYXJpYVVwZGF0ZSIsIl9hcmlhVXBkYXRlVGVtcGxhdGVzIiwidGVtcGxhdGUiLCJfZ2V0QXJpYVVwZGF0ZXMiLCJhcmlhVXBkYXRlcyIsIm5vVG9vbGJhciIsImFyaWFVcGRhdGVOb1Rvb2xiYXIiLCJvbmVUb29sYmFyIiwiYXJpYVVwZGF0ZU9uZVRvb2xiYXIiLCJtYW55VG9vbGJhcnMiLCJhcmlhVXBkYXRlTWFueVRvb2xiYXJzIiwidG9vbGJhcnNOb2RlTGlzdCIsInRvb2xiYXJOYW1lcyIsInRvb2xiYXIiLCJfZ2V0QXJpYVVwZGF0ZVRlbXBsYXRlIiwib3V0cHV0Iiwiam9pbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2giLCJPYmplY3QiLCJfb25EaXNtaXNzVG9vbGJhckZvY3VzIiwiZ2V0U2VsZWN0aW9uRGF0YSIsImRvbUV2ZW50IiwiYWx0S2V5IiwidGFyZ2V0Tm9kZSIsImNvbnRhaW5zIiwiUE9TSVRJT05fTEVGVCIsIlBPU0lUSU9OX1JJR0hUIiwiVG9vbGJhckFkZCIsIl91cGRhdGVQb3NpdGlvbiIsImlzQ29udGVudEVkaXRhYmxlIiwiX2dldEJ1dHRvbnMiLCJfZ2V0VG9vbGJhckNsYXNzTmFtZSIsImdldFRvb2xiYXJCdXR0b25zIiwiZ2V0QXJyb3dCb3hDbGFzc2VzIiwidXBkYXRlUG9zaXRpb24iLCJzaG93IiwiY2xpZW50UmVjdCIsImdldENsaWVudFJlY3QiLCJvZmZzZXRMZWZ0IiwicG9zaXRpb24iLCJndXR0ZXJFeGNsdXNpdmUiLCJmbG9vciIsImNhbmNlbEFuaW1hdGlvbiIsIlRvb2xiYXJTdHlsZXMiLCJjdXJyZW50U2VsZWN0aW9uIiwiX2dldEN1cnJlbnRTZWxlY3Rpb24iLCJnZXRBcnJvd0JveENsYXNzZXNGbiIsIl9nZXRTZWxlY3Rpb25GdW5jdGlvbiIsImNzc0NsYXNzZXMiLCJzZWxlY3Rpb25UeXBlIiwic2VsZWN0aW9uRm4iLCJzZWxlY3Rpb25GdW5jdGlvbiIsInRlc3RGbiIsInNldFBvc2l0aW9uRm4iLCJzZXRQb3NpdGlvbiIsInBsdWdpbnMiLCJiZWZvcmVJbml0Iiwib3JpZ2luYWxVSUFkZEZuIiwidWkiLCJkZWZpbml0aW9uIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ0eXBlSGFuZGxlciIsIl8iLCJoYW5kbGVycyIsIl9fcHJvY2Vzc2luZ1BsdWdpbl9fIiwicGx1Z2luIiwidGltZW91dCIsImFyZ3MiLCJkZWJvdW5jZUhhbmRsZSIsImNhbGxGbiIsImNhbGxDb250ZXh0IiwibGVuIiwic3RhcnRJbmRleCIsImNhbGxBcmdzIiwic2VsZWN0aW9uUmVnaW9uIiwidWljb3JlIiwiUkVHRVhfQk9PS01BUktfU0NIRU1FIiwiUkVHRVhfRU1BSUxfU0NIRU1FIiwiUkVHRVhfVVJJX1NDSEVNRSIsInJhbmdlIiwiZ2V0UmFuZ2VzIiwibW92ZVRvRWxlbWVudEVkaXRFbmQiLCJuZXh0Tm9kZSIsImdldE5leHRFZGl0YWJsZU5vZGUiLCJlcXVhbHMiLCJnZXRDb21tb25BbmNlc3RvciIsIndoaXRlc3BhY2UiLCJnZXRUZXh0Iiwib2Zmc2V0Iiwic2V0U3RhcnQiLCJzZXRFbmQiLCJzZWxlY3RSYW5nZXMiLCJVUkkiLCJjb2xsYXBzZWQiLCJ0ZXh0IiwiaW5zZXJ0Tm9kZSIsInNlbGVjdE5vZGVDb250ZW50cyIsIl9nZXRDb21wbGV0ZVVSSSIsImFwcGx5VG9SYW5nZSIsInNlbGVjdCIsImlzIiwic2hyaW5rIiwiU0hSSU5LX1RFWFQiLCJhbHdheXNSZW1vdmVFbGVtZW50Iiwic2VsZWN0RWxlbWVudCIsImdldFN0YXJ0RWxlbWVudCIsInVyaSIsInNldEF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRycyIsInNldEF0dHJzIiwicmVtb3ZlQXR0cmlidXRlcyIsIndyYXBQbHVnaW5MaWZlY3ljbGUiLCJtZXRob2RzIiwibWV0aG9kTmFtZSIsIm92ZXJyaWRlIiwib3JpZ2luYWxQbHVnaW5NZXRob2QiLCJwYXlsb2FkIiwicGhhc2UiLCJmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyIsInJlcXVpcmVzIiwicmVxdWlyZSIsInBsdWdpbnNMb2FkIiwibmFtZXMiLCJzY29wZSIsIlNlbGVjdGlvblJlZ2lvbiIsImNyZWF0ZVNlbGVjdGlvbkZyb21Qb2ludCIsImNyZWF0ZVNlbGVjdGlvbkZyb21SYW5nZSIsInN0YXJ0WCIsInN0YXJ0WSIsImVuZFgiLCJlbmRZIiwiZW5kIiwiZW5kQ29udGFpbmVyIiwiZW5kT2Zmc2V0Iiwic3RhcnQiLCJzdGFydENvbnRhaW5lciIsInN0YXJ0T2Zmc2V0IiwiY2FyZXRQb3NpdGlvbkZyb21Qb2ludCIsIm9mZnNldE5vZGUiLCJjcmVhdGVSYW5nZSIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJjcmVhdGVUZXh0UmFuZ2UiLCJlbmRSYW5nZSIsImR1cGxpY2F0ZSIsInNldEVuZFBvaW50IiwiZ2V0Q2FyZXRSZWdpb24iLCJib29rbWFya05vZGVFbCIsInN0YXJ0Tm9kZSIsInNjcm9sbFBvcyIsImdldFNjcm9sbFBvc2l0aW9uIiwiZ2V0TmF0aXZlIiwiZ2V0U2VsZWN0aW9uUmVnaW9uIiwiZ2V0Q2xpZW50UmVjdHNSZWdpb24iLCJnZXRTZWxlY3Rpb25EaXJlY3Rpb24iLCJpc1NlbGVjdGlvbkVtcHR5IiwicmFuZ2VzIiwiZ2V0VHlwZSIsIlNFTEVDVElPTl9OT05FIiwibmF0aXZlU2VsZWN0aW9uIiwiZGVmYXVsdFJlY3QiLCJjbGllbnRSZWN0cyIsIkluZmluaXR5IiwicmFuZ2VDb3VudCIsImdldENsaWVudFJlY3RzIiwiZ2V0UmFuZ2VBdCIsImFuY2hvck5vZGUiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImZvY3VzTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiTm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyIsImluaXQiLCJhdHRyIiwiaGFzT3duUHJvcGVydHkiLCJJRV9OT05fRElSRUNUTFlfRURJVEFCTEVfRUxFTUVOVCIsIkhFQURJTkdfQk9USCIsIkhFQURJTkdfQ09MIiwiSEVBRElOR19OT05FIiwiSEVBRElOR19ST1ciLCJfY3JlYXRlRWxlbWVudCIsInRib2R5IiwiYXBwZW5kIiwiaiIsImFwcGVuZEJvZ3VzIiwic2V0SGVhZGluZyIsImhlYWRpbmciLCJmaXJzdENlbGwiLCJjZWxscyIsIm1vdmVUb1Bvc2l0aW9uIiwiUE9TSVRJT05fQUZURVJfU1RBUlQiLCJ3ZWJraXQiLCJOT0RFX0VMRU1FTlQiLCJpc0VkaXRhYmxlIiwiaXNSZWFkT25seSIsImhhc0F0dHJpYnV0ZSIsImdldFBhcmVudCIsInJvd0hlYWRpbmdTZXR0aW5ncyIsInRIZWFkIiwiY29sSGVhZGluZ1NldHRpbmdzIiwibm9kZU5hbWUiLCJoZWFkaW5nU2V0dGluZ3MiLCJwYXJlbnQiLCJnZXRDaGlsZENvdW50IiwiUE9TSVRJT05fQkVGT1JFX1NUQVJUIiwibmV3Q2VsbCIsInRhYmxlSGVhZCIsInRhYmxlQm9keSIsImdldEVsZW1lbnRzQnlUYWciLCJnZXRJdGVtIiwidGFibGVIZWFkaW5nIiwiaGFkQ29sSGVhZGluZyIsIm5lZWRDb2xIZWFkaW5nIiwibmVlZFJvd0hlYWRpbmciLCJ0YWJsZUZpcnN0Um93IiwidGFibGVGaXJzdFJvd0NoaWxkQ291bnQiLCJnZXRDaGlsZCIsInJlbmFtZU5vZGUiLCJjcmVhdGVUSGVhZCIsInByZXZpb3VzRmlyc3RSb3ciLCJnZXRGaXJzdCIsIm5ld0ZpcnN0Um93IiwibmV3Rmlyc3RSb3dDaGlsZENvdW50IiwicmVtb3ZlQXR0cmlidXRlIiwiaW5zZXJ0QmVmb3JlIiwiaGFzQ29sSGVhZGluZyIsImdldE5hbWUiLCJoZWFkaW5nQ29tbWFuZHMiLCJqc29ucCIsInVybFRlbXBsYXRlIiwidXJsUGFyYW1zIiwiZXJyb3JDYWxsYmFjayIsImNhbGxiYWNrS2V5IiwiZ2V0TmV4dE51bWJlciIsImpzb25wQ2FsbGJhY2tzIiwicmVzcG9uc2UiLCJjbGVhblVwIiwic2NyaXB0RWxlbWVudCIsImdldEJvZHkiLCJjYW5jZWwiLCJpZCIsInNpbXVsYXRlIiwiZXZlbnRJbnN0YW5jZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImFyaWFTdGF0ZSIsImFyaWFFbGVtZW50IiwiX2NyZWF0ZUFyaWFFbGVtZW50IiwidWlUYXNrc1RpbWVvdXQiLCJoYW5kbGVVSSIsImFsbG93RXNjIiwiaGFuZGxlQXJpYSIsImlubmVySFRNTCIsImhhbmRsZU1vdXNlTGVhdmUiLCJhZVVJTm9kZXMiLCJmb3VuZCIsInJlbGF0ZWRUYXJnZXQiLCJmb2N1c0hhbmRsZXIiLCJhdHRhY2hMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwic3RhdHVzRWxlbWVudCIsIkF0dHJpYnV0ZSIsIl9fY29uZmlnX18iLCJfX0FUVFJTX18iLCJjdXJyZW50QXR0ciIsIl9pc0luaXRpYWxpemVkIiwiX2luaXQiLCJjdXJWYWx1ZSIsIl9jYWxsU3RyaW5nT3JGdW5jdGlvbiIsInNldCIsInN0cmluZ09yRnVuY3Rpb24iLCJoYXNEZWZhdWx0VmFsdWUiLCJoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZyIsInZhbHVlRm4iLCJCYXNlIiwiX2NhbGxDaGFpbiIsIndhdCIsImFyciIsImN0b3IiLCJyZXZlcnNlIiwiTGFuZyIsImlzRmluaXRlIiwidmFsdWVUeXBlIiwicmVjZWl2ZXIiLCJzdXBwbGllciIsInBhcnNlSW50IiwiZXh0ZW5kIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwic3VwcGxpZXJQcm90byIsInJlY2VpdmVyUHJvdG8iLCJpc0lFIiwiX29uRHJhZ0VudGVyIiwiX29uRHJhZ092ZXIiLCJfb25EcmFnRHJvcCIsIl9vblBhc3RlIiwiX2hhbmRsZUZpbGVzIiwiX3Byb2Nlc3NGaWxlIiwiY2xpZW50WCIsImNsaWVudFkiLCJkYXRhVHJhbnNmZXIiLCJfcHJldmVudEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsInBhc3RlZERhdGEiLCJpbWFnZUZpbGUiLCJnZXRBc0ZpbGUiLCJiaW4iLCJ1c2VyQWdlbnQiLCJLRVlfQkFDSyIsIktFWV9DT01NQSIsIktFWV9TRU1JQ09MT04iLCJLRVlfU1BBQ0UiLCJERUxJTUlURVJTIiwiUkVHRVhfTEFTVF9XT1JEIiwiUkVHRVhfVVJMIiwiX29uS2V5VXAiLCJfZ2V0TGFzdFdvcmQiLCJwcmV2aW91c1RleHQiLCJfY3VycmVudEtleUNvZGUiLCJwcmV2aW91c05vZGUiLCJnZXRQcmV2aW91cyIsImxhc3RDaGlsZCIsImdldExhc3QiLCJfc3RhcnRDb250YWluZXIiLCJfb2Zmc2V0Iiwic3Vic3RyaW5nIiwibGFzdFdvcmQiLCJwb3AiLCJfaXNWYWxpZFVSTCIsIl9vbktleURvd24iLCJfY2tMaW5rIiwiX3JlcGxhY2VDb250ZW50QnlMaW5rIiwiY29udGVudCIsImNrTGluayIsImxpbmtOb2RlIiwiX3N1YnNjcmliZVRvS2V5RXZlbnQiLCJuZXh0RWRpdGFibGVOb2RlIiwiZ2V0TmV4dE5vZGUiLCJjYXJldE9mZnNldCIsImdldE5leHQiLCJuZXdSYW5nZSIsInNldEVuZEFmdGVyIiwiREVGQVVMVF9DT05GSUciLCJyZWdleCIsIl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8iLCJpbnNlcnRIdG1sIiwiYnVsbGV0IiwiX2dldExpc3RDb25maWciLCJjb25maWdSZWdleCIsImF1dG9saXN0IiwidGV4dENvbnRhaW5lciIsInJlZ2V4TGVuIiwiYXV0b2xpc3RDZmciLCJyZWdleEl0ZW0iLCJfY3JlYXRlTGlzdCIsImxpc3RDb25maWciLCJzZXRUZXh0IiwiSU1BR0VfSEFORExFUyIsImJvdGgiLCJzY2FsZSIsIlBPU0lUSU9OX0VMRU1FTlRfRk4iLCJibCIsImhhbmRsZSIsImJveCIsInBvc2l0aW9uRWxlbWVudCIsImJtIiwicm91bmQiLCJiciIsImxtIiwidGwiLCJ0bSIsInRyIiwicm0iLCJJTUFHRV9TTkFQX1RPX1NJWkUiLCJpc0ZpcmVmb3giLCJkb2N1bWVudEVsZW1lbnQiLCJpc1dlYktpdCIsImVuYWJsZVBsdWdpbiIsImFkZENzcyIsIm9uTG9hZCIsImV2dCIsInNuYXBUb1NpemUiLCJpbWFnZVNjYWxlUmVzaXplIiwicmVzaXplciIsIlJlc2l6ZXIiLCJtb3VzZURvd25MaXN0ZW5lciIsImUiLCJpc0hhbmRsZSIsImluaXREcmFnIiwiaGlkZSIsImh0bWwiLCJkYXRhVmFsdWUiLCJzZWxmIiwicmVzaXplRWxlbWVudCIsInJlc2l6ZVRpbWVvdXQiLCJjb250YWluZXIiLCJwcmV2aWV3IiwiaGFuZGxlcyIsImhhbmRsZU5hbWUiLCJjcmVhdGVIYW5kbGUiLCJuIiwiY2xhc3NMaXN0Iiwib3RoZXJJbWFnZXMiLCJ0b0FycmF5Iiwic3BsaWNlIiwiZ2V0Qm91bmRpbmdCb3giLCJzaG93SGFuZGxlcyIsImVsZW1lbnRzIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImhpZGVIYW5kbGVzIiwiZHJhZyIsIkRyYWdFdmVudCIsIm9uU3RhcnQiLCJzaG93UHJldmlldyIsImlzRHJhZ2dpbmciLCJvbkRyYWciLCJjYWxjdWxhdGVTaXplIiwidXBkYXRlUHJldmlldyIsInByZXZpZXdCb3giLCJ1cGRhdGVIYW5kbGVzIiwib25SZWxlYXNlIiwiaGlkZVByZXZpZXciLCJvbkNvbXBsZXRlIiwicmVzaXplQ29tcGxldGUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJkZWx0YSIsInJhdGlvIiwib3RoZXJzIiwib3RoZXIiLCJldmVudHMiLCJtb3VzZW1vdmUiLCJrZXlkb3duIiwibW91c2V1cCIsInN0YXJ0UG9zIiwiY3VycmVudFBvcyIsInNoaWZ0S2V5IiwiY3RybCIsImFsdCIsIndoaWNoIiwicmVsZWFzZSIsImN0eCIsIlN0cmluZyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiYWxpZ25tZW50c09iaiIsImNlbnRlciIsImN1cnNvciIsInJlZ2V4UGVyY2VudCIsImhpZHBpIiwiaWNvbnMiLCJ3aWRnZXREZWYiLCJ3aWRnZXRzIiwiaW5pdE9uIiwiYWxpZ25DbGFzc2VzIiwiaW1hZ2UyX2FsaWduQ2xhc3NlcyIsImNhcHRpb25lZENsYXNzIiwiaW1hZ2UyX2NhcHRpb25lZENsYXNzIiwiaGVscGVycyIsImltYWdlMiIsImhhc0NhcHRpb24iLCJjYXB0aW9uIiwicmVhZHkiLCJjaGVja0hhc05hdHVyYWxSYXRpbyIsIndyYXBwZXIiLCJhbGlnbiIsImFsaWduRWxlbWVudCIsInNldERhdGEiLCJpbWFnZTJfZGlzYWJsZVJlc2l6ZXIiLCJzZXR1cFJlc2l6ZXIiLCJnZXRTdHlsZWFibGVFbGVtZW50IiwiZ2V0V2lkZ2V0QWxsb3dlZENvbnRlbnQiLCJjb250ZW50VHJhbnNmb3JtYXRpb25zIiwiZmVhdHVyZXMiLCJjaGVja0ZlYXR1cmUiLCJjb250ZW50ZWRpdGFibGUiLCJvbGREYXRhIiwiYyIsImNsYXNzZXMiLCJkaW1lbnNpb24iLCJzZXREaW1lbnNpb25zIiwiZG93bmNhc3QiLCJkb3duY2FzdFdpZGdldEVsZW1lbnQiLCJkcmFnZ2FibGUiLCJlZGl0YWJsZXMiLCJzZWxlY3RvciIsImdldFdpZGdldEZlYXR1cmVzIiwiZ2V0Q2xhc3NlcyIsImNsYXNzUmVnZXgiLCJSZWdFeHAiLCJyZXBvc2l0b3J5IiwicGFyc2VFbGVtZW50Q2xhc3NlcyIsImdldExhYmVsIiwicGF0aE5hbWUiLCJyZXF1aXJlZENvbnRlbnQiLCJzdHlsZWFibGVFbGVtZW50cyIsInVwY2FzdCIsInVwY2FzdFdpZGdldEVsZW1lbnQiLCJuYXR1cmFsIiwiZ2V0TmF0dXJhbCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZGltZW5zaW9ucyIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaCIsImltZyIsIkltYWdlIiwiaGVpZ2giLCJpc0NlbnRlcldyYXBwZXIiLCJjZW50ZXJXcmFwcGVyQ2hlY2tlciIsImZpZ3VyZSIsInJlcGxhY2VXaXRoIiwiaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZSIsImQiLCJhdHRyc0hvbGRlciIsInJlc2l6ZVdyYXBwZXIiLCJwYXJzZUNzc1RleHQiLCJ3cmFwV2l0aCIsImh0bWxQYXJzZXIiLCJpc0VtcHR5Iiwid3JpdGVDc3NUZXh0IiwidmFsaWRDaGlsZHJlbiIsImRpdiIsInAiLCJjaGlsZCIsImVudGVyTW9kZSIsIkVOVEVSX1AiLCJ3aWRnZXQiLCJkb2MiLCJpbWFnZU9yTGluayIsIm9sZFJlc2l6ZVdyYXBwZXIiLCJmYWN0b3IiLCJzY3JlZW5YIiwic2NyZWVuWSIsInN0YXJ0V2lkdGgiLCJzdGFydEhlaWdodCIsImxpc3RlbmVycyIsImN1cnNvckNsYXNzIiwibmF0aXZlRXZ0IiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJ1cGRhdGVEYXRhIiwibW92ZURpZmZYIiwibW92ZURpZmZZIiwibW92ZVJhdGlvIiwiYXR0YWNoVG9Eb2N1bWVudHMiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsImNvbGxlY3Rpb24iLCJnbG9iYWxEb2MiLCJsIiwicnVsZXMiLCJmaWdjYXB0aW9uIiwiUkVHRVhfSFRUUCIsIlJFR0VYX0RFRkFVTFRfTElOSyIsIlBST1ZJREVSUyIsIkRFRkFVTFRfQUVfRU1CRURfVVJMX1RQTCIsIkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTCIsIkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCIsIkFFX0VNQkVEX1VSTF9UUEwiLCJlbWJlZFVybFRlbXBsYXRlIiwiQUVfRU1CRURfV0lER0VUX1RQTCIsImVtYmVkV2lkZ2V0VHBsIiwiQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCIsImVtYmVkTGlua0RlZmF1bHRUcGwiLCJkZWZhdWx0RW1iZWRXaWRnZXRVcGNhc3RGbiIsIm1hc2siLCJlbmNvZGVVUklDb21wb25lbnQiLCJjcmVhdGVBVGFnIiwic2V0SHRtbCIsIm1zZyIsImFUYWdIdG1sIiwiZW1iZWRXaWRnZXRVcGNhc3RGbiIsIndpZGdldEVsZW1lbnQiLCJzY3JvbGxQb3NpdGlvbiIsImFkZEVsZW1lbnRDYWxsYmFjayIsIkZJTFRFUl9TS0lQX1RSRUUiLCJJTUFHRV9BTElHTk1FTlQiLCJDRU5URVIiLCJMRUZUIiwiUklHSFQiLCJBTElHTl9WQUxVRVMiLCJDRU5URVJFRF9JTUFHRV9TVFlMRSIsImdldEltYWdlQWxpZ25tZW50IiwiaW1hZ2VBbGlnbm1lbnQiLCJjZW50ZXJlZEltYWdlIiwiZXZlcnkiLCJzdHlsZUNoZWNrIiwidmVuZG9yUHJlZml4ZXMiLCJ2ZW5kb3JQcmVmaXgiLCJyZW1vdmVJbWFnZUFsaWdubWVudCIsInNldEltYWdlQWxpZ25tZW50Iiwic2V0U3R5bGUiLCJhZnRlckluaXQiLCJyZWZyZXNoQ29tbWFuZHMiLCJUUklTVEFURV9PRkYiLCJyZWZyZXNoIiwiYWRkaW1hZ2VzIiwiYXV0b2xpbmsiLCJkcmFncmVzaXplIiwiZHJhZ3Jlc2l6ZWllIiwiaW1hZ2VhbGlnbm1lbnQiLCJwYXN0ZWltYWdlcyIsInNlbGVjdGlvbmtleXN0cm9rZXMiLCJ0YWJsZXJlc2l6ZSIsInRhYmxldG9vbHMiLCJickZpbGxlciIsIm5lZWRzQnJGaWxsZXIiLCJlbnRlck1vZGVFbXB0eVZhbHVlIiwiX2NoZWNrRW1wdHlEYXRhIiwiX3JlbW92ZVBsYWNlaG9sZGVyQ2xhc3MiLCJlZGl0YWJsZU5vZGUiLCJpbm5lckh0bWwiLCJ0cmltIiwiZWRpdG9yTm9kZSIsInNlbGVjdGlvbktleXN0cm9rZSIsInB4VW5pdCIsImNzc0xlbmd0aCIsImdldFdpZHRoIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldEJvcmRlcldpZHRoIiwic2lkZSIsImNvbXB1dGVkIiwiYm9yZGVyTWFwIiwidGhpbiIsIm1lZGl1bSIsInRoaWNrIiwiZ2V0TWFzdGVyUGlsbGFyUm93IiwiJHJvd3MiLCJtYXhDZWxscyIsImNlbGxzQ291bnQiLCIkZWxlY3RlZCIsIiR0ciIsImJ1aWxkVGFibGVDb2x1bW5QaWxsYXJzIiwicGlsbGFycyIsInBpbGxhckluZGV4IiwicnRsIiwidEJvZGllcyIsInRib2R5UG9zaXRpb24iLCJnZXREb2N1bWVudFBvc2l0aW9uIiwidGQiLCJuZXh0VGQiLCJjb2xTcGFuIiwicGlsbGFyTGVmdCIsInBpbGxhclJpZ2h0IiwicGlsbGFyV2lkdGgiLCJnZXRQaWxsYXJBdFBvc2l0aW9uIiwicG9zaXRpb25YIiwicGlsbGFyIiwiY29sdW1uUmVzaXplciIsImlzUmVzaXppbmciLCJjdXJyZW50U2hpZnQiLCJsZWZ0U2lkZUNlbGxzIiwicmlnaHRTaWRlQ2VsbHMiLCJsZWZ0U2hpZnRCb3VuZGFyeSIsInJpZ2h0U2hpZnRCb3VuZGFyeSIsIm9uTW91c2VEb3duIiwicmVzaXplU3RhcnQiLCJjb2x1bW5JbmRleCIsImJ1aWxkVGFibGVNYXAiLCJsZWZ0Q29sdW1uQ2VsbHMiLCJyaWdodENvbHVtbkNlbGxzIiwibGVmdE1pblNpemUiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJyaWdodE1pblNpemUiLCJsZWZ0Q2VsbCIsInJpZ2h0Q2VsbCIsInNldE9wYWNpdHkiLCJyZXNpemVFbmQiLCJyZXNpemVDb2x1bW4iLCJyZW1vdmVDdXN0b21EYXRhIiwibGVmdE9sZFdpZHRoIiwicmlnaHRPbGRXaWR0aCIsInRhYmxlV2lkdGgiLCJzaXplU2hpZnQiLCJtb3ZlIiwiZ2V0UGFnZU9mZnNldCIsImdldERvY3VtZW50RWxlbWVudCIsImF0dGFjaFRvIiwidGFyZ2V0UGlsbGFyIiwicG9zWCIsInJlc2l6ZXJOZXdQb3NpdGlvbiIsImNsZWFyUGlsbGFyc0NhY2hlIiwiZGVzdCIsInRvRWxlbWVudCIsImlzSW5saW5lIiwiZ2V0Q3VzdG9tRGF0YSIsInNldEN1c3RvbURhdGEiLCJjZWxsTm9kZVJlZ2V4IiwiZ2V0U2VsZWN0ZWRDZWxscyIsInJldHZhbCIsImRhdGFiYXNlIiwibW92ZU91dE9mQ2VsbEd1YXJkIiwic2V0TWFya2VyIiwibmVhcmVzdENlbGwiLCJ3YWxrZXIiLCJndWFyZCIsImR0ZCIsImNsZWFyQWxsTWFya2VycyIsImdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMiLCJjZWxsc1RvRGVsZXRlIiwibGFzdCIsImZvY3VzZWRDZWxsIiwiaW5zZXJ0Um93IiwiZ2V0RG9jdW1lbnQiLCJzdGFydFJvdyIsInN0YXJ0Um93SW5kZXgiLCJyb3dJbmRleCIsImxhc3RDZWxsIiwiZW5kUm93SW5kZXgiLCJyb3dTcGFuIiwiZW5kUm93IiwiY2xvbmVSb3ciLCJuZXh0Um93IiwibmV3Um93IiwiY2xvbmUiLCJpbnNlcnRBZnRlciIsImRlbGV0ZVJvd3MiLCJzZWxlY3Rpb25PclJvdyIsInJvd3NUb0RlbGV0ZSIsIm1hcFJvdyIsImNlbGxSb3dJbmRleCIsIm5leHRNYXBSb3ciLCJjdXJzb3JQb3NpdGlvbiIsImdldENlbGxDb2xJbmRleCIsImlzU3RhcnQiLCJyb3dDZWxscyIsImNvbEluZGV4IiwibWFwQ2VsbCIsImdldENvbHVtbnNJbmRpY2VzIiwiaW5zZXJ0Q29sdW1uIiwic3RhcnRDb2wiLCJsYXN0Q29sIiwiY2xvbmVDb2wiLCJuZXh0Q29sIiwibmV4dENlbGwiLCJkZWxldGVDb2x1bW5zIiwic2VsZWN0aW9uT3JDZWxsIiwic3RhcnRDb2xJbmRleCIsImVuZENvbEluZGV4IiwiZmlyc3RSb3dDZWxscyIsImluc2VydENlbGwiLCJzdGFydEVsZW1lbnQiLCJkZWxldGVDZWxscyIsImNlbGxUb0ZvY3VzIiwicGxhY2VDdXJzb3JJbkNlbGwiLCJ0cmltQ2VsbCIsImJvZ3VzIiwiZ2V0Qm9ndXMiLCJwbGFjZUF0RW5kIiwiZG9jSW5uZXIiLCJkb2NPdXRlciIsInZlcnNpb24iLCJjb2xsYXBzZSIsImNlbGxJblJvdyIsInRhYmxlTWFwIiwib1JvdyIsImNlbGxJbkNvbCIsIm9Db2wiLCJyIiwibWVyZ2VDZWxscyIsIm1lcmdlRGlyZWN0aW9uIiwiaXNEZXRlY3QiLCJjb21tb25BbmNlc3RvciIsIm1hcEhlaWdodCIsIm1hcFdpZHRoIiwic3RhcnRDb2x1bW4iLCJ0YXJnZXRDZWxsIiwicm93c3BhbiIsImNvbHNwYW4iLCJlciIsImxhc3RSb3dJbmRleCIsInRvdGFsUm93U3BhbiIsInRvdGFsQ29sU3BhbiIsImZyYWciLCJkb2N1bWVudEZyYWdtZW50IiwiY2VsbEZpcnN0Q2hpbGQiLCJnZXRDaGlsZHJlbiIsImNvdW50IiwiaXNCbG9ja0JvdW5kYXJ5Iiwid2hpdGVzcGFjZXMiLCJtb3ZlQ2hpbGRyZW4iLCJ0cnMiLCJub2RlTGlzdCIsInRhaWxUciIsInZlcnRpY2FsU3BsaXRDZWxsIiwibmV3Um93U3BhbiIsIm5ld0NlbGxSb3dTcGFuIiwibmV3Um93SW5kZXgiLCJjZWlsIiwibmV3Q2VsbFRyIiwibmV3Q2VsbFJvdyIsImNhbmRpZGF0ZUNlbGwiLCJjZWxsc0luU2FtZVJvdyIsImhvcml6b250YWxTcGxpdENlbGwiLCJuZXdDb2xTcGFuIiwibmV3Q2VsbENvbFNwYW4iLCJjZWxsc0luU2FtZUNvbCIsImNyZWF0ZURlZiIsImRlZiIsImNvbnRleHRTZW5zaXRpdmUiLCJ0aCIsIlRSSVNUQVRFX0RJU0FCTEVEIiwiYWRkQ21kIiwiY21kIiwiYWRkRmVhdHVyZSIsImFSb3dzIiwiYU1hcCIsIm9DZWxsIiwiaUNvbFNwYW4iLCJpUm93U3BhbiIsInJzIiwiY3MiLCJ0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyIsIlNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyIsIkRFRkFVTFRfR1VUVEVSIiwiY2VudGVyVG9vbGJhciIsInRvb2xiYXJOb2RlIiwiaGFsZk5vZGVXaWR0aCIsIndpZGdldFhZIiwiaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvbiIsInRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb24iLCJTZWxlY3Rpb25TZXRQb3NpdGlvbiIsIl9pc1JhbmdlQXRFbGVtZW50RW5kIiwiZW1iZWRTZWxlY3Rpb25UZXN0IiwibGlua1NlbGVjdGlvblRlc3QiLCJpbWFnZVNlbGVjdGlvblRlc3QiLCJ0ZXh0U2VsZWN0aW9uVGVzdCIsInNlbGVjdGlvbkVtcHR5IiwidGFibGVTZWxlY3Rpb25UZXN0IiwiU2VsZWN0aW9ucyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBOztBQUNBOztBQUVBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7OztBQU9BLFNBQVNBLElBQVQsQ0FBY0MsTUFBZCxFQUFzQjtBQUNsQkQsU0FBS0UsVUFBTCxDQUFnQkMsV0FBaEIsQ0FBNEJDLElBQTVCLENBQWlDLElBQWpDLEVBQXVDSCxNQUF2QztBQUNIOztBQUVELG1CQUFPRCxJQUFQLGtCQUFtQjtBQUNmOzs7Ozs7Ozs7O0FBVUFLLGlCQUFhLHFCQUFTSixNQUFULEVBQWlCO0FBQzFCLFlBQUlLLE9BQU8sS0FBS0MsR0FBTCxDQUFTLFNBQVQsQ0FBWDs7QUFFQSxZQUFJLEtBQUtBLEdBQUwsQ0FBUyx1QkFBVCxDQUFKLEVBQXVDO0FBQ25DRCxpQkFBS0UsWUFBTCxDQUFrQixpQkFBbEIsRUFBcUMsTUFBckM7QUFDSDs7QUFFRCxZQUFJQyxTQUFTQyxTQUFTQyxNQUFULENBQWdCTCxJQUFoQixDQUFiOztBQUVBRyxlQUFPUixNQUFQLENBQWNXLGNBQWQsR0FBK0IsS0FBS0wsR0FBTCxDQUFTLGdCQUFULENBQS9COztBQUVBRSxlQUFPUixNQUFQLENBQWNZLFFBQWQsR0FBeUIsS0FBS04sR0FBTCxDQUFTLFVBQVQsQ0FBekI7O0FBRUFFLGVBQU9SLE1BQVAsQ0FBY2EsYUFBZCxHQUE4QixLQUFLUCxHQUFMLENBQVMsZUFBVCxDQUE5QjtBQUNBRSxlQUFPUixNQUFQLENBQWNjLFlBQWQsR0FBNkIsS0FBS1IsR0FBTCxDQUFTLGNBQVQsQ0FBN0I7QUFDQUUsZUFBT1IsTUFBUCxDQUFjZSxnQkFBZCxHQUFpQyxLQUFLVCxHQUFMLENBQVMsa0JBQVQsQ0FBakM7O0FBRUFFLGVBQU9SLE1BQVAsQ0FBY2dCLHlCQUFkLEdBQTBDLEtBQTFDO0FBQ0FSLGVBQU9SLE1BQVAsQ0FBY2lCLDZCQUFkLEdBQThDLEtBQTlDOztBQUVBVCxlQUFPUixNQUFQLENBQWNrQixtQkFBZCxHQUFvQyxLQUFLWixHQUFMLENBQVMscUJBQVQsQ0FBcEM7O0FBRUEsdUJBQUthLEdBQUwsQ0FBU1gsT0FBT1IsTUFBaEIsRUFBd0JBLE1BQXhCOztBQUVBLFlBQUlTLFNBQVNXLEdBQVQsQ0FBYUMsRUFBYixJQUFtQixDQUFDWixTQUFTVyxHQUFULENBQWFFLElBQXJDLEVBQTJDO0FBQ3ZDZCxtQkFBT1IsTUFBUCxDQUFjYyxZQUFkLEdBQTZCTixPQUFPUixNQUFQLENBQWNjLFlBQWQsQ0FBMkJTLE9BQTNCLENBQW1DLGVBQW5DLEVBQW9ELGtCQUFwRCxDQUE3QjtBQUNBZixtQkFBT1IsTUFBUCxDQUFjYSxhQUFkLEdBQThCTCxPQUFPUixNQUFQLENBQWNhLGFBQWQsQ0FBNEJVLE9BQTVCLENBQW9DLGVBQXBDLEVBQXFELGtCQUFyRCxDQUE5QjtBQUNIOztBQUVEZixlQUFPZ0IsSUFBUCxDQUFZLFlBQVosRUFBMEIsWUFBVzs7QUFFakMsaUJBQUtDLDZCQUFMLENBQW1DakIsTUFBbkM7O0FBRUEsZ0JBQUlrQixXQUFXbEIsT0FBT2tCLFFBQVAsRUFBZjs7QUFFQUEscUJBQVNDLFFBQVQsQ0FBa0IsYUFBbEI7QUFFSCxTQVJ5QixDQVF4QkMsSUFSd0IsQ0FRbkIsSUFSbUIsQ0FBMUI7O0FBVUEsYUFBS0MsT0FBTCxHQUFlckIsTUFBZjs7QUFFQXNCLG9CQUFZQyxxQkFBWixDQUFrQyxLQUFLQyxTQUFMLENBQWVKLElBQWYsQ0FBb0IsSUFBcEIsQ0FBbEM7QUFDSCxLQXJEYzs7QUF1RGY7Ozs7Ozs7OztBQVNBSyxnQkFBWSxzQkFBVztBQUNuQixhQUFLQyxVQUFMLEdBQWtCLElBQWxCOztBQUVBLFlBQUksS0FBS0MsZ0JBQVQsRUFBMkI7QUFDdkIsK0JBQVNDLHNCQUFULENBQWdDLEtBQUtELGdCQUFyQztBQUNBLGlCQUFLQSxnQkFBTCxDQUFzQkUsVUFBdEIsQ0FBaUNDLFdBQWpDLENBQTZDLEtBQUtILGdCQUFsRDtBQUNIOztBQUVELFlBQUlJLGVBQWUsS0FBS2pDLEdBQUwsQ0FBUyxjQUFULENBQW5COztBQUVBLFlBQUlpQyxZQUFKLEVBQWtCO0FBQ2QsZ0JBQUliLFdBQVdhLGFBQWFiLFFBQWIsRUFBZjs7QUFFQSxnQkFBSUEsUUFBSixFQUFjO0FBQ1ZBLHlCQUFTYyxXQUFULENBQXFCLGFBQXJCOztBQUVBLG9CQUFJLEtBQUtsQyxHQUFMLENBQVMsdUJBQVQsQ0FBSixFQUF1QztBQUNuQyx5QkFBS0EsR0FBTCxDQUFTLFNBQVQsRUFBb0JDLFlBQXBCLENBQWlDLGlCQUFqQyxFQUFvRCxPQUFwRDtBQUNIO0FBQ0o7O0FBRUQsaUJBQUtrQyxnQkFBTDs7QUFFQUYseUJBQWFHLE9BQWI7QUFDSDtBQUNKLEtBekZjOztBQTRGZjs7Ozs7Ozs7QUFRQUQsc0JBQWtCLDRCQUFXO0FBQ3pCLFlBQUlGLGVBQWUsS0FBS2pDLEdBQUwsQ0FBUyxjQUFULENBQW5CO0FBQ0EsWUFBSXFDLGdCQUFnQixPQUFPQyxPQUFPQyxZQUFkLElBQThCLFVBQWxEOztBQUVBLFlBQUlGLGFBQUosRUFBbUI7QUFDZkoseUJBQWFPLFFBQWIsQ0FBc0JDLENBQXRCLENBQXdCQyxTQUF4QixDQUFrQ0MsS0FBbEM7QUFDSCxTQUZELE1BRU87QUFDSFYseUJBQWFPLFFBQWIsQ0FBc0JJLFNBQXRCLEdBQWtDSCxDQUFsQyxDQUFvQ0YsWUFBcEMsR0FBbURNLGVBQW5EO0FBQ0g7QUFDSixLQTdHYzs7QUErR2Y7Ozs7Ozs7OztBQVNBMUIsbUNBQStCLHVDQUFTakIsTUFBVCxFQUFpQjtBQUM1Q0EsZUFBT2tCLFFBQVAsR0FBa0IwQixFQUFsQixDQUFxQixPQUFyQixFQUE4QixLQUFLQyx1QkFBbkMsRUFBNEQsSUFBNUQsRUFBa0U7QUFDOUQ3QyxvQkFBUUE7QUFEc0QsU0FBbEU7QUFHSCxLQTVIYzs7QUE4SGY7Ozs7Ozs7Ozs7O0FBV0E2Qyw2QkFBeUIsaUNBQVNDLEtBQVQsRUFBZ0I7QUFDckMsWUFBSUMsYUFBYUQsTUFBTUUsSUFBTixDQUFXVCxDQUE1QjtBQUNBLFlBQUlVLGFBQWFGLFdBQVdHLE9BQVgsSUFBc0JILFdBQVdJLE9BQWxEO0FBQ0EsWUFBSUMsYUFBYSxLQUFLL0IsT0FBTCxDQUFhN0IsTUFBYixDQUFvQjZELFFBQXBCLElBQWdDSixVQUFqRDs7QUFFQUYsbUJBQVdPLGNBQVg7O0FBRUEsWUFBSSxDQUFDRixVQUFMLEVBQWlCO0FBQ2I7QUFDSDs7QUFFRCxZQUFJTixNQUFNUyxZQUFOLENBQW1CdkQsTUFBbkIsQ0FBMEJrQixRQUExQixHQUFxQ2xCLE1BQXJDLENBQTRDd0QsSUFBNUMsQ0FBaUQsZUFBakQsRUFBa0VWLE1BQU1FLElBQXhFLE1BQWtGLEtBQXRGLEVBQTZGO0FBQ3pGLGdCQUFJUyxZQUFZLElBQUl4RCxTQUFTeUQsR0FBVCxDQUFhQyxXQUFqQixDQUE2QmIsTUFBTUUsSUFBTixDQUFXWSxTQUFYLEVBQTdCLEVBQXFELElBQXJELENBQWhCO0FBQ0EsZ0JBQUlDLE9BQU9KLFVBQVVLLFdBQXJCOztBQUVBLGdCQUFJRCxJQUFKLEVBQVU7QUFDTixvQkFBSUUsT0FBT0YsS0FBS3RCLENBQUwsQ0FBT3lCLFVBQVAsQ0FBa0JELElBQWxCLEdBQXlCRixLQUFLdEIsQ0FBTCxDQUFPeUIsVUFBUCxDQUFrQkQsSUFBbEIsQ0FBdUJFLEtBQWhELEdBQXdELElBQW5FO0FBQ0Esb0JBQUlDLFNBQVNqQixhQUFhLFFBQWIsR0FBd0JZLEtBQUt0QixDQUFMLENBQU95QixVQUFQLENBQWtCRSxNQUFsQixHQUEyQkwsS0FBS3RCLENBQUwsQ0FBT3lCLFVBQVAsQ0FBa0JFLE1BQWxCLENBQXlCRCxLQUFwRCxHQUE0RCxJQUFqRztBQUNBLHFCQUFLRSxhQUFMLENBQW1CSixJQUFuQixFQUF5QkcsTUFBekI7QUFDSDtBQUNKO0FBQ0osS0E5SmM7O0FBZ0tmOzs7Ozs7Ozs7QUFTQUUsc0JBQWtCLDRCQUFXO0FBQ3pCLGVBQU8sS0FBSy9DLE9BQVo7QUFDSCxLQTNLYzs7QUE2S2Y7Ozs7Ozs7Ozs7QUFVQThDLG1CQUFlLHVCQUFTSixJQUFULEVBQWVHLE1BQWYsRUFBdUI7QUFDbEMsWUFBSUEsVUFBVUgsSUFBZCxFQUFvQjtBQUNoQjNCLG1CQUFPaUMsSUFBUCxDQUFZTixJQUFaLEVBQWtCRyxNQUFsQjtBQUNILFNBRkQsTUFHSyxJQUFJSCxJQUFKLEVBQVU7QUFDWDNCLG1CQUFPa0MsUUFBUCxDQUFnQlAsSUFBaEIsR0FBdUJBLElBQXZCO0FBQ0g7QUFDSixLQTlMYzs7QUFnTWY7Ozs7Ozs7O0FBUUF2QyxlQUFXLHFCQUFXO0FBQ2xCLFlBQUksQ0FBQyxLQUFLRSxVQUFWLEVBQXNCO0FBQ2xCLGdCQUFJNkMsa0JBQWtCakMsU0FBU2tDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBdEI7QUFDQUQsNEJBQWdCRSxTQUFoQixHQUE0QixPQUE1Qjs7QUFFQSxnQkFBSUMsU0FBUyxLQUFLNUUsR0FBTCxDQUFTLFFBQVQsS0FBc0J3QyxTQUFTcUMsSUFBNUM7O0FBRUFELG1CQUFPRSxXQUFQLENBQW1CTCxlQUFuQjs7QUFFQSxpQkFBS00sT0FBTCxHQUFlLG1CQUFTQyxNQUFULENBQWdCO0FBQzNCLHdCQUFRLElBRG1CO0FBRTNCLDZCQUFhLEtBQUtoRixHQUFMLENBQVMsYUFBVCxDQUZjO0FBRzNCLDBCQUFVLEtBQUtBLEdBQUwsQ0FBUyxVQUFULENBSGlCLEdBQWhCLEVBR3lCeUUsZUFIekIsQ0FBZjs7QUFLQSxpQkFBSzVDLGdCQUFMLEdBQXdCNEMsZUFBeEI7O0FBRUEsaUJBQUt6RSxHQUFMLENBQVMsY0FBVCxFQUF5QjBELElBQXpCLENBQThCLFNBQTlCO0FBQ0g7QUFDSixLQTFOYzs7QUE0TmY7Ozs7Ozs7Ozs7Ozs7QUFhQXVCLGdCQUFZLG9CQUFTZCxLQUFULEVBQWdCO0FBQ3hCLFlBQUksZUFBS2UsUUFBTCxDQUFjZixLQUFkLENBQUosRUFBMEI7QUFDdEJBLG9CQUFRM0IsU0FBUzJDLGNBQVQsQ0FBd0JoQixLQUF4QixDQUFSO0FBQ0g7O0FBRUQsZUFBT0EsS0FBUDtBQUNILEtBL09jOztBQWlQZjs7Ozs7Ozs7Ozs7O0FBWUFpQiw2QkFBeUIsaUNBQVNqQixLQUFULEVBQWdCO0FBQ3JDLGVBQU8sZUFBS2UsUUFBTCxDQUFjZixLQUFkLEtBQXdCLGVBQUtrQixRQUFMLENBQWNsQixLQUFkLENBQXhCLElBQWdELGVBQUttQixTQUFMLENBQWVuQixLQUFmLENBQXZEO0FBQ0gsS0EvUGM7O0FBaVFmOzs7Ozs7Ozs7O0FBVUFvQix1QkFBbUIsMkJBQVNwQixLQUFULEVBQWdCO0FBQy9CLGVBQU8sZUFBS2tCLFFBQUwsQ0FBY2xCLEtBQWQsS0FBd0IsZUFBS3FCLE1BQUwsQ0FBWXJCLEtBQVosQ0FBL0I7QUFDSDtBQTdRYyxDQUFuQixFQThRRztBQUNDc0IsV0FBTztBQUNIOzs7Ozs7Ozs7Ozs7QUFZQXBGLHdCQUFnQjtBQUNacUYsdUJBQVcseUJBREM7QUFFWnZCLG1CQUFPLElBRks7QUFHWndCLHVCQUFXO0FBSEMsU0FiYjs7QUFtQkg7Ozs7Ozs7Ozs7O0FBV0FDLCtCQUF1QjtBQUNuQkYsdUJBQVcsZUFBS0osU0FERztBQUVuQm5CLG1CQUFPLElBRlk7QUFHbkJ3Qix1QkFBVztBQUhRLFNBOUJwQjs7QUFvQ0g7Ozs7Ozs7O0FBUUFFLHFCQUFhO0FBQ1RILHVCQUFXLGVBQUtJLFFBRFA7QUFFVDNCLG1CQUFPO0FBRkUsU0E1Q1Y7O0FBaURIOzs7Ozs7Ozs7OztBQVdBM0Qsc0JBQWM7QUFDVmtGLHVCQUFXLGVBQUtSLFFBRE47QUFFVmYsbUJBQU8sdUdBQ0gsOEVBREcsR0FFSCxhQUpNO0FBS047QUFDSndCLHVCQUFXO0FBTkQsU0E1RFg7O0FBcUVIOzs7Ozs7Ozs7QUFTQTFELHNCQUFjO0FBQ1Y4RCxvQkFBUSxrQkFERTtBQUVWeEMsc0JBQVU7QUFGQSxTQTlFWDs7QUFtRkg7Ozs7Ozs7Ozs7OztBQVlBOUMsMEJBQWtCO0FBQ2RpRix1QkFBVyxlQUFLUixRQURGO0FBRWRmLG1CQUFPLGdCQUZPO0FBR2R3Qix1QkFBVztBQUhHLFNBL0ZmOztBQXFHSDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBcEYsdUJBQWU7QUFDWG1GLHVCQUFXLGVBQUtSLFFBREw7QUFFWGYsbUJBQU8sd0RBRkk7QUFHWHdCLHVCQUFXO0FBSEEsU0F2SFo7O0FBNkhIOzs7Ozs7Ozs7OztBQVdBL0UsNkJBQXFCO0FBQ2pCOEUsdUJBQVcsZUFBS00sT0FEQztBQUVqQjdCLG1CQUFPLENBQUM7QUFDSjhCLHNCQUFNOUYsU0FBUytGLElBQVQsR0FBZ0IsRUFEbEIsQ0FDcUI7QUFEckIsa0JBRUp4RCxXQUFXO0FBRlAsYUFBRCxFQUdKO0FBQ0N1RCxzQkFBTTlGLFNBQVMrRixJQUFULEdBQWdCL0YsU0FBU2dHLEtBQXpCLEdBQWlDLEVBRHhDLENBQzJDO0FBRDNDLGtCQUVDekQsV0FBVztBQUZaLGFBSEk7QUFGVSxTQXhJbEI7O0FBbUpIOzs7Ozs7Ozs7QUFTQTBELGlCQUFTO0FBQ0xDLG9CQUFRLFlBREg7QUFFTFYsdUJBQVc7QUFGTixTQTVKTjs7QUFpS0g7Ozs7Ozs7QUFPQXJGLGtCQUFVO0FBQ05vRix1QkFBVyxtQkFETDtBQUVOdkIsbUJBQU87QUFDSG1DLHFCQUFLO0FBQ0RDLDZCQUFTLENBQUMsT0FBRCxFQUFVLE9BQVYsRUFBbUIsUUFBbkIsRUFBNkIsT0FBN0IsRUFBc0MsT0FBdEMsQ0FEUjtBQUVEQyw4QkFBVTtBQUZULGlCQURGO0FBS0hDLHdCQUFRO0FBQ0pDLG9EQURJO0FBRUpGLDhCQUFVO0FBRk47QUFMTDtBQUZELFNBeEtQOztBQXNMSDs7Ozs7Ozs7O0FBU0E1QixnQkFBUTtBQUNKeUIsb0JBQVEsWUFESjtBQUVKVix1QkFBVztBQUZQO0FBL0xMO0FBRFIsQ0E5UUg7O0FBcWRBeEYsU0FBUzZDLEtBQVQsQ0FBZTJELFdBQWYsQ0FBMkJsSCxJQUEzQjs7a0JBRWVBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoZmY7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBRUE7QUFDQSxJQUFJbUgsaUJBQWlCLEVBQXJCOztBQUVBOzs7Ozs7Ozs7O0FBVUEsSUFBTXhGLFdBQVcsU0FBWEEsUUFBVyxDQUFTckIsSUFBVCxFQUFlTCxNQUFmLEVBQXVCO0FBQ3BDQSxhQUFTQSxVQUFVLEVBQW5CO0FBQ0FBLFdBQU8wRyxPQUFQLEdBQWlCckcsSUFBakI7O0FBRUF5QixnQkFBWXFGLG9CQUFaOztBQUVBLFdBQU8sbUJBQVNuSCxNQUFULENBQVA7QUFDSCxDQVBEOztBQVNBOzs7Ozs7Ozs7OztBQVdBLElBQU1vSCxjQUFjLFNBQWRBLFdBQWMsR0FBVztBQUMzQjtBQUNBLFFBQUlDLE9BQU96RSxPQUFPMEUsb0JBQVAsSUFBK0IsRUFBMUM7O0FBRUEsUUFBSSxDQUFDRCxJQUFMLEVBQVc7QUFDUCxZQUFJRSxVQUFVekUsU0FBUzBFLG9CQUFULENBQThCLFFBQTlCLENBQWQ7O0FBRUEsYUFBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlGLFFBQVFHLE1BQTVCLEVBQW9DRCxHQUFwQyxFQUF5QztBQUNyQyxnQkFBSUUsUUFBUUosUUFBU0UsQ0FBVCxFQUFhRyxHQUFiLENBQWlCRCxLQUFqQixDQUF1QjdGLFlBQVkrRixhQUFuQyxDQUFaOztBQUdBLGdCQUFJRixLQUFKLEVBQVc7QUFDUE4sdUJBQU9NLE1BQU0sQ0FBTixDQUFQO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBLFFBQUlOLEtBQUtTLE9BQUwsQ0FBYSxJQUFiLE1BQXVCLENBQUMsQ0FBeEIsSUFBNkJULEtBQUtVLEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBZCxNQUFxQixJQUF0RCxFQUE2RDtBQUN6RDtBQUNBLFlBQUlWLEtBQUtTLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLENBQTFCLEVBQTZCO0FBQ3pCVCxtQkFBT3ZDLFNBQVNQLElBQVQsQ0FBY29ELEtBQWQsQ0FBb0IsaUJBQXBCLEVBQXVDLENBQXZDLElBQTRDTixJQUFuRDtBQUNIO0FBQ0Q7QUFIQSxhQUlLO0FBQ0RBLHVCQUFPdkMsU0FBU1AsSUFBVCxDQUFjb0QsS0FBZCxDQUFvQixlQUFwQixFQUFxQyxDQUFyQyxJQUEwQ04sSUFBakQ7QUFDSDtBQUNKOztBQUVELFFBQUksQ0FBQ0EsSUFBTCxFQUFVO0FBQ04sY0FBTSxnS0FBTjtBQUNIOztBQUVELFdBQU9BLElBQVA7QUFDSCxDQXBDRDs7QUFzQ0E7Ozs7Ozs7OztBQVNBLElBQU10Rix3QkFBd0IsU0FBeEJBLHFCQUF3QixDQUFTaUcsUUFBVCxFQUFtQjtBQUM3Q2xHLGdCQUFZcUYsb0JBQVo7O0FBRUEsUUFBSSxlQUFLYyxVQUFMLENBQWdCRCxRQUFoQixDQUFKLEVBQStCO0FBQzNCLFlBQUlsRyxZQUFZb0csT0FBaEIsRUFBeUI7QUFDckJDLHVCQUFXSCxRQUFYLEVBQXFCLENBQXJCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hsRyx3QkFBWU4sSUFBWixDQUFpQix5QkFBakIsRUFBNEMsWUFBVztBQUNuRDJHLDJCQUFXSCxRQUFYLEVBQXFCLENBQXJCO0FBQ0gsYUFGRDtBQUdIO0FBQ0o7O0FBRUQsUUFBSSxDQUFDbEcsWUFBWXNHLHNCQUFqQixFQUF5QztBQUNyQ3RHLG9CQUFZc0csc0JBQVosR0FBcUMsSUFBckM7O0FBRUEsWUFBSUMsWUFBWSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUEyQyxJQUEzQyxFQUFpRCxJQUFqRCxFQUF1RCxJQUF2RCxFQUE2RCxJQUE3RCxFQUFtRSxPQUFuRSxFQUE0RSxPQUE1RSxFQUFxRixPQUFyRixFQUE4RixJQUE5RixFQUFvRyxJQUFwRyxFQUEwRyxJQUExRyxFQUFnSCxJQUFoSCxFQUFzSCxJQUF0SCxFQUE0SCxJQUE1SCxFQUFrSSxJQUFsSSxFQUF3SSxJQUF4SSxFQUE4SSxPQUE5SSxFQUF1SixJQUF2SixFQUE2SixJQUE3SixFQUFtSyxJQUFuSyxFQUF5SyxJQUF6SyxFQUErSyxJQUEvSyxFQUFxTCxJQUFyTCxFQUEyTCxJQUEzTCxFQUFpTSxJQUFqTSxFQUF1TSxJQUF2TSxFQUE2TSxJQUE3TSxFQUFtTixJQUFuTixFQUF5TixJQUF6TixFQUErTixJQUEvTixFQUFxTyxJQUFyTyxFQUEyTyxJQUEzTyxFQUFpUCxJQUFqUCxFQUF1UCxJQUF2UCxFQUE2UCxJQUE3UCxFQUFtUSxJQUFuUSxFQUF5USxJQUF6USxFQUErUSxJQUEvUSxFQUFxUixJQUFyUixFQUEyUixJQUEzUixFQUFpUyxJQUFqUyxFQUF1UyxPQUF2UyxFQUFnVCxJQUFoVCxFQUFzVCxJQUF0VCxFQUE0VCxJQUE1VCxFQUFrVSxJQUFsVSxFQUF3VSxJQUF4VSxFQUE4VSxJQUE5VSxFQUFvVixJQUFwVixFQUEwVixTQUExVixFQUFxVyxJQUFyVyxFQUEyVyxJQUEzVyxFQUFpWCxJQUFqWCxFQUF1WCxJQUF2WCxFQUE2WCxJQUE3WCxFQUFtWSxJQUFuWSxFQUF5WSxJQUF6WSxFQUErWSxJQUEvWSxFQUFxWixPQUFyWixFQUE4WixJQUE5WixDQUFoQjs7QUFFQSxZQUFJQyxlQUFlQyxVQUFVQyxRQUFWLElBQXNCRCxVQUFVRCxZQUFoQyxJQUFnRCxJQUFuRTs7QUFFQSxZQUFJRyxRQUFRSCxhQUFhSSxXQUFiLEdBQTJCZixLQUEzQixDQUFpQyx3QkFBakMsQ0FBWjtBQUNBLFlBQUlnQixPQUFPRixNQUFNLENBQU4sQ0FBWDtBQUNBLFlBQUlHLFNBQVNILE1BQU0sQ0FBTixDQUFiOztBQUVBLFlBQUlKLFVBQVVQLE9BQVYsQ0FBa0JhLE9BQU8sR0FBUCxHQUFhQyxNQUEvQixLQUEwQyxDQUE5QyxFQUFpRDtBQUM3Q0QsbUJBQU9BLE9BQU8sR0FBUCxHQUFhQyxNQUFwQjtBQUNILFNBRkQsTUFFTyxJQUFJUCxVQUFVUCxPQUFWLENBQWtCYSxJQUFsQixNQUE0QixDQUFDLENBQWpDLEVBQW9DO0FBQ3ZDQSxtQkFBTyxJQUFQO0FBQ0g7O0FBRURsSSxpQkFBU29JLFlBQVQsQ0FBc0JDLElBQXRCLENBQTJCaEgsWUFBWWlILE1BQVosQ0FBbUIsdUJBQXVCSixJQUF2QixHQUE4QixLQUFqRCxDQUEzQixFQUFvRixVQUFTSyxNQUFULEVBQWlCO0FBQ2pHLGdCQUFJQSxNQUFKLEVBQVk7QUFDUmxILDRCQUFZa0MsSUFBWixDQUFpQix5QkFBakI7QUFDSDtBQUNKLFNBSkQsRUFJRyxJQUpIO0FBS0g7QUFDSixDQXBDRDs7QUFzQ0E7Ozs7Ozs7Ozs7OztBQVlBLElBQU0rRSxTQUFTLFNBQVRBLE1BQVMsQ0FBU0UsUUFBVCxFQUFtQjtBQUM5QixRQUFJQyxXQUFXcEgsWUFBWXNGLFdBQVosRUFBZjs7QUFFQTtBQUNBLFFBQUk2QixTQUFTbkIsT0FBVCxDQUFpQixJQUFqQixNQUEyQixDQUFDLENBQTVCLElBQWlDbUIsU0FBU25CLE9BQVQsQ0FBaUIsR0FBakIsTUFBMEIsQ0FBL0QsRUFBa0U7QUFDOURtQixtQkFBV0MsV0FBV0QsUUFBdEI7QUFDSDs7QUFFRDtBQUNBLFFBQUl4SSxTQUFTMEksU0FBVCxJQUFzQkYsU0FBU0csTUFBVCxDQUFpQkgsU0FBU3ZCLE1BQVQsR0FBa0IsQ0FBbkMsTUFBMkMsR0FBakUsSUFBd0UsQ0FBRSxRQUFELENBQVcyQixJQUFYLENBQWdCSixRQUFoQixDQUE3RSxFQUF3RztBQUNwR0Esb0JBQVksQ0FBQ0EsU0FBU25CLE9BQVQsQ0FBaUIsR0FBakIsS0FBeUIsQ0FBekIsR0FBNkIsR0FBN0IsR0FBbUMsR0FBcEMsSUFBMkMsSUFBM0MsR0FBa0RySCxTQUFTMEksU0FBdkU7QUFDSDs7QUFFRCxXQUFPRixRQUFQO0FBQ0gsQ0FkRDs7QUFnQkE7Ozs7Ozs7QUFPQSxJQUFNOUIsdUJBQXVCLFNBQXZCQSxvQkFBdUIsR0FBVztBQUNwQyxRQUFJLENBQUNyRixZQUFZa0MsSUFBYixJQUFxQixDQUFDbEMsWUFBWXNCLEVBQXRDLEVBQTBDO0FBQ3RDM0MsaUJBQVM2QyxLQUFULENBQWUyRCxXQUFmLENBQTJCbkYsV0FBM0I7QUFDSDtBQUNKLENBSkQ7O0FBTUE7Ozs7Ozs7O0FBUUEsSUFBTStGLGdCQUFnQixtRUFBdEI7O0FBRUE7Ozs7Ozs7QUFPQTs7Ozs7Ozs7OztBQVVBLElBQU15QixhQUFhLFNBQWJBLFVBQWEsQ0FBU3pDLE9BQVQsRUFBa0I7QUFDakMsV0FBTyxZQUFXO0FBQ2QsZUFBT0EsUUFBUTBDLE1BQVIsQ0FBZSxVQUFTQyxHQUFULEVBQWNDLEdBQWQsRUFBbUI7QUFDckNBLGtCQUFNdkMsZUFBZXVDLEdBQWYsS0FBdUIsQ0FBQ0EsR0FBRCxDQUE3QjtBQUNBLG1CQUFPRCxJQUFJRSxNQUFKLENBQVdELEdBQVgsQ0FBUDtBQUNILFNBSE0sRUFHSixFQUhJLENBQVA7QUFJSCxLQUxEO0FBTUgsQ0FQRDs7QUFTQTs7Ozs7Ozs7O0FBU0EsSUFBTUUsdUJBQXVCLFNBQXZCQSxvQkFBdUIsQ0FBU0MsVUFBVCxFQUFxQkMsVUFBckIsRUFBaUM7QUFDMUQsUUFBSSxDQUFDM0MsZUFBZTJDLFVBQWYsQ0FBTCxFQUFpQztBQUM3QjNDLHVCQUFlMkMsVUFBZixJQUE2QixFQUE3QjtBQUNIOztBQUVEM0MsbUJBQWUyQyxVQUFmLEVBQTJCQyxJQUEzQixDQUFnQ0YsVUFBaEM7QUFDSCxDQU5EOztRQVNJRyxPO1FBQ0FySSxRLEdBQUFBLFE7UUFDQTBGLFcsR0FBQUEsVztRQUNBa0MsVSxHQUFBQSxVO1FBQ0FQLE0sR0FBQUEsTTtRQUNBNUIsb0IsR0FBQUEsb0I7UUFDQXBGLHFCLEdBQUFBLHFCO1FBQ0E0SCxvQixHQUFBQSxvQjtRQUNBSyxhO1FBQ0FDLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdE9KOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7a0JBV2U7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUNYOzs7Ozs7O0FBRFcseUNBUUU7QUFDVCxvQkFBSSxlQUFLaEMsVUFBTCxDQUFnQixLQUFLaUMsUUFBckIsS0FBa0MsZUFBS2pDLFVBQUwsQ0FBZ0IsS0FBS2tDLFFBQXJCLENBQXRDLEVBQXNFO0FBQ2xFLHdCQUFJM0osU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjs7QUFFQUUsMkJBQU9xQyxZQUFQLEdBQXNCd0gsSUFBdEI7O0FBRUEsd0JBQUksS0FBS0gsUUFBTCxFQUFKLEVBQXFCO0FBQ2pCMUosK0JBQU84SixXQUFQLENBQW1CLEtBQUtILFFBQUwsRUFBbkI7QUFDSCxxQkFGRCxNQUVPO0FBQ0gzSiwrQkFBTytKLFVBQVAsQ0FBa0IsS0FBS0osUUFBTCxFQUFsQjtBQUNIOztBQUVEM0osMkJBQU9xQyxZQUFQLEdBQXNCMkgsTUFBdEI7O0FBRUFoSywyQkFBT3dELElBQVAsQ0FBWSxpQkFBWixFQUErQixJQUEvQjtBQUNIO0FBQ0o7QUF4QlU7O0FBQUE7QUFBQSxNQUFrQ3lHLGdCQUFsQztBQUFBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYmY7Ozs7OztrQkFNZTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQ1g7Ozs7Ozs7O0FBRFcsaUNBU0E7QUFDUCxZQUFJakssU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjs7QUFFQSxZQUFJb0ssVUFBVWxLLE9BQU9tSyxVQUFQLENBQWtCLEtBQUtQLEtBQUwsQ0FBV00sT0FBN0IsQ0FBZDs7QUFFQSxlQUFPQSxVQUFVQSxRQUFRRSxLQUFSLEtBQWtCbkssU0FBU29LLFdBQXJDLEdBQW1ELEtBQTFEO0FBQ0g7QUFmVTs7QUFBQTtBQUFBLElBQWtDSixnQkFBbEM7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05mOzs7OztrQkFLZTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQ1g7Ozs7Ozs7O0FBRFcsd0NBU0NqSCxJQVRELEVBU087QUFDZCxvQkFBSWhELFNBQVMsS0FBSzRKLEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQWI7O0FBRUFFLHVCQUFPc0ssV0FBUCxDQUFtQixLQUFLVixLQUFMLENBQVdNLE9BQTlCLEVBQXVDbEgsSUFBdkM7O0FBRUEsb0JBQUksS0FBSzRHLEtBQUwsQ0FBV1csaUJBQWYsRUFBa0M7QUFDOUJ2SywyQkFBT3dLLGVBQVAsQ0FBdUIsSUFBdkI7QUFDSDs7QUFFRHhLLHVCQUFPd0QsSUFBUCxDQUFZLGlCQUFaLEVBQStCLElBQS9CO0FBQ0g7QUFuQlU7O0FBQUE7QUFBQSxNQUFrQ3lHLGdCQUFsQztBQUFBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMZjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7OztrQkFNZTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQ1g7Ozs7Ozs7QUFEVyxpREFRVTtBQUNqQixvQkFBSSxlQUFLeEMsVUFBTCx5R0FBSixFQUErQztBQUMzQztBQUNIOztBQUVELG9CQUFJMUYsZUFBZSxLQUFLNkgsS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBbkI7QUFDQSxvQkFBSTJLLFlBQVksS0FBS2IsS0FBTCxDQUFXYSxTQUEzQjs7QUFFQSxvQkFBSUMsY0FBY0QsVUFBVUUsSUFBVixJQUFrQixDQUFFQyxLQUFLQyxNQUFMLEtBQWdCLEdBQWpCLEtBQTBCLENBQTNCLEVBQThCQyxRQUE5QixFQUFwQzs7QUFFQSxvQkFBSVosVUFBVW5JLGFBQWFvSSxVQUFiLENBQXdCTyxXQUF4QixDQUFkOztBQUVBLG9CQUFJLENBQUNSLE9BQUwsRUFBYztBQUNWQSw4QkFBVSxJQUFJakssU0FBU2lLLE9BQWIsQ0FBcUJuSSxZQUFyQixFQUFtQztBQUN6Q2dKLDhCQUFNLFVBQVMvSyxNQUFULEVBQWlCO0FBQ2YsZ0NBQUlnTCxjQUFjUCxVQUFVUSxFQUE1Qjs7QUFFQSxnQ0FBSSxlQUFLakcsUUFBTCxDQUFjZ0csV0FBZCxDQUFKLEVBQWdDO0FBQzVCLHFDQUFLQSxXQUFMLEVBQWtCckwsSUFBbEIsQ0FBdUIsSUFBdkIsRUFBNkJLLE1BQTdCO0FBQ0gsNkJBRkQsTUFFTyxJQUFJLGVBQUt5SCxVQUFMLENBQWdCdUQsV0FBaEIsQ0FBSixFQUFrQztBQUNyQ0EsNENBQVlyTCxJQUFaLENBQWlCLElBQWpCLEVBQXVCSyxNQUF2QjtBQUNIO0FBQ0oseUJBUkMsQ0FRQW9CLElBUkEsQ0FRSyxJQVJMO0FBRG1DLHFCQUFuQyxDQUFWOztBQWFBVyxpQ0FBYW1KLFVBQWIsQ0FBd0JSLFdBQXhCLEVBQXFDUixPQUFyQztBQUNIOztBQUVELHFCQUFLaUIsd0JBQUwsR0FBZ0NwSixhQUFhcUosZ0JBQWIsQ0FBOEJDLFVBQTlCLENBQXlDWixVQUFVMUUsSUFBbkQsQ0FBaEM7O0FBRUFoRSw2QkFBYXVKLFlBQWIsQ0FBMEJiLFVBQVUxRSxJQUFwQyxFQUEwQzJFLFdBQTFDO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBMUNXO0FBQUE7QUFBQSxtREFpRFk7QUFDbkIsb0JBQUksZUFBS2pELFVBQUwsMkdBQUosRUFBaUQ7QUFDN0M7QUFDSDs7QUFFRCxxQkFBS21DLEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLEVBQXNDd0wsWUFBdEMsQ0FBbUQsS0FBSzFCLEtBQUwsQ0FBV2EsU0FBWCxDQUFxQjFFLElBQXhFLEVBQThFLEtBQUtvRix3QkFBbkY7QUFDSDtBQXZEVTs7QUFBQTtBQUFBLE1BQWtDbEIsZ0JBQWxDO0FBQUEsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSZjs7Ozs7O2tCQU1lO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFDWDs7Ozs7Ozs7Ozs7QUFEVywwQ0FZU0wsS0FaVCxFQVlnQjtBQUN2QkEsZ0JBQVFBLFNBQVMsS0FBS0EsS0FBdEI7O0FBRUEsWUFBSTdILGVBQWUsS0FBSzZILEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQW5CO0FBQ0EsWUFBSXlMLFlBQVl4SixhQUFhdkMsTUFBYixDQUFvQitMLFNBQXBCLElBQWlDLEVBQWpEO0FBQ0EsWUFBSUMsU0FBU3ZMLFNBQVN3TCxLQUFULENBQWVDLEtBQWYsQ0FBcUI5QixLQUFyQixFQUE0QjJCLFVBQVUsVUFBVixDQUE1QixDQUFiOztBQUVBLGVBQU9DLE1BQVA7QUFDSDtBQXBCVTs7QUFBQTtBQUFBLElBQWtDdkIsZ0JBQWxDO0FBQUEsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOZjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7a0JBVWU7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUNYOzs7Ozs7Ozs7QUFEVyw4Q0FVTztBQUNkLG9CQUFJMEIsZUFBZSxFQUFuQjs7QUFFQTtBQUNBLG9CQUFJLGVBQUtsRSxVQUFMLENBQWdCLEtBQUtpQyxRQUFyQixLQUFrQyxLQUFLQSxRQUFMLEVBQXRDLEVBQXVEO0FBQ25EaUMsb0NBQWdCLG1CQUFoQjtBQUNIOztBQUVEO0FBQ0Esb0JBQUksZUFBS2xFLFVBQUwsQ0FBZ0IsS0FBS21FLFVBQXJCLEtBQW9DLEtBQUtBLFVBQUwsRUFBeEMsRUFBMkQ7QUFDdkRELG9DQUFnQixxQkFBaEI7QUFDSDs7QUFFRCx1QkFBT0EsWUFBUDtBQUNIO0FBeEJVOztBQUFBO0FBQUEsTUFBa0MxQixnQkFBbEM7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWmY7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7a0JBTWU7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUNYOzs7Ozs7O0FBRFcsaURBUVU7QUFDakIsb0JBQUksZUFBS3hDLFVBQUwseUdBQUosRUFBK0M7QUFDM0M7QUFDSDs7QUFFRCxvQkFBSW9FLFFBQVEsS0FBS2pDLEtBQUwsQ0FBV2lDLEtBQXZCOztBQUVBLG9CQUFJLGVBQUs3RyxRQUFMLENBQWM2RyxLQUFkLENBQUosRUFBMEI7QUFDdEIsd0JBQUk1RCxRQUFRNEQsTUFBTUMsS0FBTixDQUFZLEdBQVosQ0FBWjtBQUNBLHdCQUFJQyxnQkFBZ0IsS0FBS25DLEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLEVBQXNDTixNQUExRDtBQUNBLHdCQUFJd00sV0FBVy9ELE1BQU1nRSxLQUFOLEVBQWY7O0FBRUEsMkJBQU9ELFlBQVksZUFBSzdHLFFBQUwsQ0FBYzRHLGFBQWQsQ0FBWixJQUE0QyxlQUFLNUcsUUFBTCxDQUFjNEcsY0FBY0MsUUFBZCxDQUFkLENBQW5ELEVBQTJGO0FBQ3ZGRCx3Q0FBZ0JBLGNBQWNDLFFBQWQsQ0FBaEI7QUFDQUEsbUNBQVcvRCxNQUFNZ0UsS0FBTixFQUFYO0FBQ0g7O0FBRUQsd0JBQUksZUFBSzlHLFFBQUwsQ0FBYzRHLGFBQWQsQ0FBSixFQUFrQztBQUM5QkYsZ0NBQVFFLGFBQVI7QUFDSDtBQUNKOztBQUVELHFCQUFLRyxNQUFMLEdBQWMsSUFBSWpNLFNBQVM0TCxLQUFiLENBQW1CQSxLQUFuQixDQUFkO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBakNXO0FBQUE7QUFBQSxtREF3Q1k7QUFDbkIsb0JBQUksZUFBS3BFLFVBQUwsMkdBQUosRUFBaUQ7QUFDN0M7QUFDSDs7QUFFRCxxQkFBS3lFLE1BQUwsR0FBYyxJQUFkO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQWhEVztBQUFBO0FBQUEsdUNBd0RBO0FBQ1AsdUJBQU8sS0FBS0EsTUFBWjtBQUNIOztBQUVEOzs7Ozs7Ozs7QUE1RFc7QUFBQTtBQUFBLHVDQW9FQTtBQUNQLG9CQUFJVixNQUFKOztBQUVBLG9CQUFJeEwsU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjs7QUFFQSxvQkFBSTZELGNBQWMzRCxPQUFPMkQsV0FBUCxFQUFsQjs7QUFFQTZILHlCQUFTLEtBQUs3QixRQUFMLEdBQWdCd0MsV0FBaEIsQ0FBNEJ4SSxXQUE1QixFQUF5QzNELE1BQXpDLENBQVQ7O0FBRUEsdUJBQU93TCxNQUFQO0FBQ0g7QUE5RVU7O0FBQUE7QUFBQSxNQUFrQ3ZCLGdCQUFsQztBQUFBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUmY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7OztrQkFNZTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQ1g7Ozs7Ozs7Ozs7O0FBRFcsOENBWU81RCxPQVpQLEVBWWdCK0YsZUFaaEIsRUFZaUM7QUFDeEMsb0JBQUlDLGNBQWMsRUFBbEI7O0FBRUEsb0JBQUl0SyxlQUFlLEtBQUs2SCxLQUFMLENBQVc1SixNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixDQUFuQjtBQUNBLG9CQUFJeUwsWUFBWXhKLGFBQWF2QyxNQUFiLENBQW9CK0wsU0FBcEIsSUFBaUMsRUFBakQ7O0FBRUEsb0JBQUksZUFBSzlELFVBQUwsQ0FBZ0JwQixPQUFoQixDQUFKLEVBQThCO0FBQzFCQSw4QkFBVUEsUUFBUTFHLElBQVIsQ0FBYSxJQUFiLEtBQXNCLEVBQWhDO0FBQ0g7O0FBRUQsb0JBQUkyTSxpQkFBaUIsS0FBS0MsZUFBTCxDQUNibEcsUUFBUW1HLE1BQVIsQ0FBZSxVQUFTQyxNQUFULEVBQWlCO0FBQzVCLDJCQUFPQSxXQUFXbkwsWUFBWWlJLE9BQVosQ0FBb0JrRCxNQUFwQixLQUErQm5MLFlBQVlpSSxPQUFaLENBQW9Ca0QsT0FBTzlCLElBQTNCLENBQTFDLENBQVA7QUFDSCxpQkFGRCxFQUdDK0IsR0FIRCxDQUdLLFVBQVNELE1BQVQsRUFBaUI7QUFDbEIsd0JBQUksZUFBS3pILFFBQUwsQ0FBY3lILE1BQWQsQ0FBSixFQUEyQjtBQUN2Qkosb0NBQVlJLE1BQVosSUFBc0JsQixVQUFVa0IsTUFBVixDQUF0QjtBQUNBQSxpQ0FBU25MLFlBQVlpSSxPQUFaLENBQW9Ca0QsTUFBcEIsQ0FBVDtBQUNILHFCQUhELE1BR08sSUFBSSxlQUFLekgsUUFBTCxDQUFjeUgsT0FBTzlCLElBQXJCLENBQUosRUFBZ0M7QUFDbkMwQixvQ0FBWS9LLFlBQVlpSSxPQUFaLENBQW9Ca0QsT0FBTzlCLElBQTNCLEVBQWlDZ0MsR0FBN0MsSUFBb0QxTSxTQUFTd0wsS0FBVCxDQUFlQyxLQUFmLENBQXFCSCxVQUFVa0IsTUFBVixDQUFyQixFQUF3Q0EsT0FBT0csR0FBL0MsQ0FBcEQ7QUFDQUgsaUNBQVNuTCxZQUFZaUksT0FBWixDQUFvQmtELE9BQU85QixJQUEzQixDQUFUO0FBQ0g7O0FBRUQsMkJBQU84QixNQUFQO0FBQ0gsaUJBYkQsQ0FEYSxFQWdCaEJDLEdBaEJnQixDQWdCWixVQUFTRCxNQUFULEVBQWlCO0FBQ2xCLHdCQUFJN0MsUUFBUSxLQUFLaUQsbUJBQUwsQ0FBeUI7QUFDakM3TSxnQ0FBUSxLQUFLNEosS0FBTCxDQUFXNUosTUFEYztBQUVqQzJNLDZCQUFLRixPQUFPRSxHQUZxQjtBQUdqQ0csZ0NBQVFMLE9BQU9FLEdBSGtCO0FBSWpDckcsa0NBQVcsS0FBS3NELEtBQUwsQ0FBV21ELE9BQVgsSUFBc0IsS0FBS25ELEtBQUwsQ0FBV21ELE9BQVgsQ0FBbUJuRCxLQUFuQixDQUF5QmtELE1BQXpCLEtBQW9DTCxPQUFPRSxHQUFsRSxHQUF5RSxDQUF6RSxHQUE2RSxDQUFDLENBSnZEO0FBS2pDSSxpQ0FBUyxLQUFLbkQsS0FBTCxDQUFXbUQ7QUFMYSxxQkFBekIsRUFNVE4sT0FBT0UsR0FORSxDQUFaOztBQVFBL0MsNEJBQVEsS0FBS29ELGtCQUFMLENBQXdCcEQsS0FBeEIsRUFBK0I2QyxPQUFPRSxHQUF0QyxDQUFSOztBQUVBLHdCQUFJUCxlQUFKLEVBQXFCO0FBQ2pCeEMsZ0NBQVEzSixTQUFTd0wsS0FBVCxDQUFlQyxLQUFmLENBQXFCOUIsS0FBckIsRUFBNEJ3QyxlQUE1QixDQUFSO0FBQ0g7O0FBRUR4Qyw0QkFBUTNKLFNBQVN3TCxLQUFULENBQWVDLEtBQWYsQ0FBcUI5QixLQUFyQixFQUE0QnlDLFlBQVlJLE9BQU9FLEdBQW5CLENBQTVCLENBQVI7O0FBRUEsMkJBQU8sZ0JBQU1uSSxhQUFOLENBQW9CaUksTUFBcEIsRUFBNEI3QyxLQUE1QixDQUFQO0FBQ0gsaUJBbENnQixFQWtDZCxJQWxDYyxDQUFyQjs7QUFvQ0EsdUJBQU8wQyxjQUFQO0FBQ0g7QUEzRFU7O0FBQUE7QUFBQSxNQUFrQ3JDLGdCQUFsQztBQUFBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVGY7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7a0JBTWU7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUNYOzs7Ozs7Ozs7QUFEVyxpREFVVTtBQUNqQixvQkFBSWdELGtCQUFrQixjQUF0Qjs7QUFFQSxvQkFBSSxlQUFLeEYsVUFBTCxDQUFnQixLQUFLeUYsbUJBQXJCLEtBQTZDLEtBQUtBLG1CQUFMLEVBQWpELEVBQTZFO0FBQ3pFLHdCQUFJLEtBQUtBLG1CQUFMLEdBQTJCQyxTQUEzQixLQUF5Q2xOLFNBQVNtTix1QkFBdEQsRUFBK0U7QUFDM0VILDJDQUFtQixtQkFBbkI7QUFDSCxxQkFGRCxNQUVPO0FBQ0hBLDJDQUFtQixzQkFBbkI7QUFDSDtBQUNKOztBQUVELHVCQUFPQSxlQUFQO0FBQ0g7QUF0QlU7O0FBQUE7QUFBQSxNQUFrQ2hELGdCQUFsQztBQUFBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1JmOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7OztrQkFLZTtBQUFBO0FBQUE7O0FBQ1gsd0JBQVlMLEtBQVosRUFBbUI7QUFBQTs7QUFBQSx3SEFDVEEsS0FEUzs7QUFHZixrQkFBS1EsS0FBTCxnQkFDTyxNQUFLQSxLQURaO0FBRUlpRCxpQ0FBaUIsSUFGckI7QUFHSUMsOEJBQWM7QUFIbEI7QUFIZTtBQVFsQjs7QUFFRDs7Ozs7Ozs7OztBQVhXO0FBQUE7QUFBQSxzREFtQmVDLFNBbkJmLEVBbUIwQjtBQUNqQyxvQkFBSSxlQUFLOUYsVUFBTCxnSEFBSixFQUFzRDtBQUNsRDtBQUNIOztBQUVELHFCQUFLK0YsUUFBTCxDQUFjO0FBQ1ZILHFDQUFpQixJQURQO0FBRVZDLGtDQUFjO0FBRkosaUJBQWQ7QUFJSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUE5Qlc7QUFBQTtBQUFBLCtDQTJDUUcsR0EzQ1IsRUEyQ2FDLE9BM0NiLEVBMkNzQjtBQUM3Qix1QkFBT3pOLFNBQVN3TCxLQUFULENBQWVDLEtBQWYsQ0FBcUIrQixHQUFyQixFQUEwQjtBQUM3QkUsOEJBQVUsS0FBS3ZELEtBQUwsQ0FBV2tELFlBQVgsS0FBNEJJLE9BQTVCLEdBQXNDLElBQXRDLEdBQTZDLEtBRDFCO0FBRTdCcEgsOEJBQVUsS0FBSzhELEtBQUwsQ0FBV2lELGVBQVgsS0FBK0JLLE9BQS9CLEdBQXlDLENBQXpDLEdBQTZDLENBQUMsQ0FGM0I7QUFHN0JFLG9DQUFnQixLQUFLQSxjQUFMLENBQW9CeE0sSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0JzTSxPQUEvQjtBQUhhLGlCQUExQixDQUFQO0FBS0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFuRFc7QUFBQTtBQUFBLDJDQTRESUosWUE1REosRUE0RGtCTyxlQTVEbEIsRUE0RG1DO0FBQzFDLHFCQUFLTCxRQUFMLENBQWM7QUFDVkgscUNBQWlCQyxZQURQO0FBRVZBLGtDQUFjQSxpQkFBaUIsS0FBS2xELEtBQUwsQ0FBV2tELFlBQTVCLEdBQTJDQSxZQUEzQyxHQUEwRDtBQUY5RCxpQkFBZCxFQUdHLFlBQVc7QUFDVix3QkFBSSxDQUFDLEtBQUtsRCxLQUFMLENBQVdrRCxZQUFoQixFQUE4QjtBQUMxQiw0QkFBSSxLQUFLUSxTQUFULEVBQW9CO0FBQ2hCLGlDQUFLQSxTQUFMLENBQWVELGVBQWY7QUFDSCx5QkFGRCxNQUVPO0FBQ0gsK0NBQVNFLFdBQVQsQ0FBcUIsSUFBckIsRUFBMkJDLEtBQTNCO0FBQ0g7QUFDSjtBQUNKLGlCQVhEO0FBWUg7QUF6RVU7O0FBQUE7QUFBQSxNQUFrQy9ELGdCQUFsQztBQUFBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSZjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7O2tCQVFlO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFDWDs7Ozs7Ozs7QUFEVyw0Q0FTS2dFLGFBVEwsRUFTb0I7QUFDM0Isb0JBQUksS0FBSzdELEtBQUwsQ0FBVzZELGFBQVgsS0FBNkJBLGFBQWpDLEVBQWdEO0FBQzVDLHlCQUFLVCxRQUFMLENBQWM7QUFDVlMsdUNBQWU7QUFETCxxQkFBZDtBQUdIO0FBQ0o7O0FBRUQ7Ozs7Ozs7Ozs7O0FBakJXO0FBQUE7QUFBQSxzREEyQmVWLFNBM0JmLEVBMkIwQjtBQUNqQyxvQkFBSSxlQUFLOUYsVUFBTCxnSEFBSixFQUFzRDtBQUNsRDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHFCQUFLK0YsUUFBTCxDQUFjO0FBQ1ZTLG1DQUFlO0FBREwsaUJBQWQ7QUFHSDs7QUFFRDs7Ozs7Ozs7OztBQXhDVztBQUFBO0FBQUEsNENBaURLQyxLQWpETCxFQWlEWTtBQUNuQix1QkFBT0EsTUFBTTFCLE1BQU4sQ0FBYSxVQUFTMkIsSUFBVCxFQUFlO0FBQy9CLHdCQUFJLEtBQUsvRCxLQUFMLENBQVc2RCxhQUFmLEVBQThCO0FBQzFCLDRCQUFJLEtBQUs3RCxLQUFMLENBQVc2RCxhQUFYLEtBQTZCRSxLQUFLeEIsR0FBdEMsRUFBMkM7QUFDdkMsbUNBQU93QixJQUFQO0FBQ0g7QUFDSixxQkFKRCxNQUlPO0FBQ0gsK0JBQU9BLElBQVA7QUFDSDtBQUNKLGlCQVJtQixDQVFsQi9NLElBUmtCLENBUWIsSUFSYSxDQUFiLENBQVA7QUFTSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBN0RXO0FBQUE7QUFBQSxnREEyRVNxTSxHQTNFVCxFQTJFY0MsT0EzRWQsRUEyRXVCO0FBQzlCLHVCQUFPek4sU0FBU3dMLEtBQVQsQ0FBZUMsS0FBZixDQUFxQitCLEdBQXJCLEVBQTBCO0FBQzdCVyxxQ0FBaUIsS0FBS0EsZUFBTCxDQUFxQmhOLElBQXJCLENBQTBCLElBQTFCLEVBQWdDc00sT0FBaEMsQ0FEWTtBQUU3QlcscUNBQWtCLEtBQUtqRSxLQUFMLENBQVc2RCxhQUFYLEtBQTZCUCxPQUZsQjtBQUc3Qlksc0NBQWtCLEtBQUtBLGdCQUFMLENBQXNCbE4sSUFBdEIsQ0FBMkIsSUFBM0IsRUFBaUNzTSxPQUFqQztBQUhXLGlCQUExQixDQUFQO0FBS0g7O0FBRUQ7Ozs7Ozs7OztBQW5GVztBQUFBO0FBQUEsNkNBMkZNTyxhQTNGTixFQTJGcUI7QUFDNUIscUJBQUtULFFBQUwsQ0FBYztBQUNWUyxtQ0FBZUE7QUFETCxpQkFBZDtBQUdIO0FBL0ZVOztBQUFBO0FBQUEsTUFBa0NoRSxnQkFBbEM7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVmY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBSXNFLGlCQUFpQixDQUFyQjtBQUNBLElBQUlDLGlCQUFpQixDQUFyQjtBQUNBLElBQUlDLGlCQUFpQixDQUFDLENBQXRCOztBQUVBLElBQUlDLGNBQWMsQ0FBbEI7QUFDQSxJQUFJQyxvQkFBb0IsQ0FBeEI7QUFDQSxJQUFJQyx1QkFBdUIsQ0FBM0I7O0FBRUE7Ozs7Ozs7a0JBTWU7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUNYOzs7Ozs7O0FBRFcsZ0RBUVM7QUFDaEIsb0JBQUksZUFBS25ILFVBQUwsd0dBQUosRUFBOEM7QUFDMUM7QUFDSDs7QUFFRCxxQkFBS29ILFFBQUw7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBaEJXO0FBQUE7QUFBQSxpREF3QlU7QUFDakIsb0JBQUksZUFBS3BILFVBQUwseUdBQUosRUFBK0M7QUFDM0M7QUFDSDs7QUFFRCxxQkFBS29ILFFBQUw7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7QUFoQ1c7QUFBQTtBQUFBLGtDQTBDTC9MLEtBMUNLLEVBMENFO0FBQ1Qsb0JBQUksQ0FBQ0EsS0FBRCxJQUFVLEtBQUtnTSxjQUFMLENBQW9CaE0sTUFBTW9CLE1BQTFCLENBQWQsRUFBaUQ7QUFDN0Msd0JBQUksS0FBSzZLLFlBQUwsSUFBcUIsS0FBS0EsWUFBTCxDQUFrQjdILE1BQTNDLEVBQW1EO0FBQy9DLDRCQUFJOEgscUJBQXFCLEtBQUtELFlBQUwsQ0FBa0IsS0FBS0UsaUJBQXZCLENBQXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBSTNNLFNBQVM0TSxhQUFULEtBQTJCRixrQkFBM0IsSUFBaUQsQ0FBQyxLQUFLcEYsS0FBTCxDQUFXdUYsZUFBakUsRUFBa0Y7QUFDOUUsZ0NBQUksS0FBS0osWUFBTCxDQUFrQnpILE9BQWxCLENBQTBCaEYsU0FBUzRNLGFBQW5DLE1BQXNELENBQUMsQ0FBM0QsRUFBOEQ7QUFDMURGLG1EQUFtQmhCLEtBQW5CO0FBQ0g7QUFDSjs7QUFFRCw0QkFBSWxMLEtBQUosRUFBVztBQUNQQSxrQ0FBTXNNLGVBQU47QUFDQXRNLGtDQUFNUSxjQUFOO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQWhFVztBQUFBO0FBQUEsc0NBd0VEUixLQXhFQyxFQXdFTTtBQUNiLG9CQUFJLEtBQUtnTSxjQUFMLENBQW9CaE0sTUFBTW9CLE1BQTFCLEtBQXFDLEtBQUs2SyxZQUE5QyxFQUE0RDtBQUN4RCx3QkFBSU0sU0FBUyxLQUFLQyxlQUFMLENBQXFCeE0sS0FBckIsQ0FBYjs7QUFFQSx3QkFBSXVNLE9BQU9FLElBQVgsRUFBaUI7QUFDYnpNLDhCQUFNc00sZUFBTjtBQUNBdE0sOEJBQU1RLGNBQU47O0FBRUEsNEJBQUkrTCxPQUFPRSxJQUFQLEtBQWdCWixpQkFBcEIsRUFBdUM7QUFDbkMsaUNBQUthLFVBQUwsQ0FBZ0JILE9BQU9sQyxTQUF2QjtBQUNIOztBQUVELDRCQUFJa0MsT0FBT0UsSUFBUCxLQUFnQlgsb0JBQXBCLEVBQTBDO0FBQ3RDLGlDQUFLaEYsS0FBTCxDQUFXNkYsU0FBWCxDQUFxQkosT0FBT2xDLFNBQTVCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQTNGVztBQUFBO0FBQUEsc0NBbUdEQSxTQW5HQyxFQW1HVTtBQUNqQkEsNEJBQVksZUFBS3ZILFFBQUwsQ0FBY3VILFNBQWQsSUFBMkJBLFNBQTNCLEdBQXVDLENBQW5EOztBQUVBLHFCQUFLcUMsVUFBTCxDQUFnQnJDLFNBQWhCO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OztBQXpHVztBQUFBO0FBQUEsNENBb0hLckssS0FwSEwsRUFvSFk7QUFDbkIsb0JBQUl1TSxTQUFTO0FBQ1RFLDBCQUFNYjtBQURHLGlCQUFiOztBQUlBLG9CQUFJLEtBQUs5RSxLQUFMLENBQVc3RCxJQUFmLEVBQXFCO0FBQ2pCLHdCQUFJb0gsWUFBWSxLQUFLdUMsc0JBQUwsQ0FBNEI1TSxLQUE1QixDQUFoQjs7QUFFQSx3QkFBSXFLLFNBQUosRUFBZTtBQUNYa0MsK0JBQU9sQyxTQUFQLEdBQW1CQSxTQUFuQjtBQUNBa0MsK0JBQU9FLElBQVAsR0FBY1osaUJBQWQ7QUFDSDs7QUFFRCx3QkFBSWdCLGdCQUFnQixLQUFLQyxzQkFBTCxDQUE0QjlNLEtBQTVCLEVBQW1DcUssU0FBbkMsQ0FBcEI7O0FBRUEsd0JBQUl3QyxjQUFjRSxPQUFsQixFQUEyQjtBQUN2QlIsK0JBQU9sQyxTQUFQLEdBQW1Cd0MsY0FBY3hDLFNBQWpDO0FBQ0FrQywrQkFBT0UsSUFBUCxHQUFjWCxvQkFBZDtBQUNIO0FBQ0o7O0FBRUQsdUJBQU9TLE1BQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE1SVc7QUFBQTtBQUFBLG1EQTRKWXZNLEtBNUpaLEVBNEptQmdOLGtCQTVKbkIsRUE0SnVDO0FBQzlDLG9CQUFJSCxnQkFBZ0I7QUFDaEJ4QywrQkFBVzJDLGtCQURLO0FBRWhCRCw2QkFBUztBQUZPLGlCQUFwQjs7QUFLQSxvQkFBSSxLQUFLakcsS0FBTCxDQUFXNkYsU0FBZixFQUEwQjtBQUN0Qix3QkFBSSxLQUFLTSxXQUFMLENBQWlCak4sTUFBTWtOLE9BQXZCLEVBQWdDLEtBQUtwRyxLQUFMLENBQVc3RCxJQUFYLENBQWdCOEosT0FBaEQsQ0FBSixFQUE4RDtBQUMxREYsc0NBQWNFLE9BQWQsR0FBd0IsSUFBeEI7QUFDSDtBQUNELHdCQUFJLEtBQUtFLFdBQUwsQ0FBaUJqTixNQUFNa04sT0FBdkIsRUFBZ0MsS0FBS3BHLEtBQUwsQ0FBVzdELElBQVgsQ0FBZ0JrSyxXQUFoRCxDQUFKLEVBQWtFO0FBQzlETixzQ0FBY0UsT0FBZCxHQUF3QixJQUF4QjtBQUNBRixzQ0FBY3hDLFNBQWQsR0FBMEJxQixjQUExQjtBQUNIO0FBQ0Qsd0JBQUksS0FBS3VCLFdBQUwsQ0FBaUJqTixNQUFNa04sT0FBdkIsRUFBZ0MsS0FBS3BHLEtBQUwsQ0FBVzdELElBQVgsQ0FBZ0JtSyxXQUFoRCxDQUFKLEVBQWtFO0FBQzlEUCxzQ0FBY0UsT0FBZCxHQUF3QixJQUF4QjtBQUNBRixzQ0FBY3hDLFNBQWQsR0FBMEJzQixjQUExQjtBQUNIOztBQUVELHdCQUFJLENBQUNrQixjQUFjRSxPQUFmLElBQTBCLENBQUMsS0FBS2pHLEtBQUwsQ0FBV3VHLFFBQXRDLElBQWtETCxrQkFBdEQsRUFBMEU7QUFDdEVILHNDQUFjRSxPQUFkLEdBQ0lDLHVCQUF1QnJCLGNBQXZCLElBQXlDLEtBQUtRLGlCQUFMLEtBQTJCLENBQXBFLElBQ0FhLHVCQUF1QnRCLGNBQXZCLElBQXlDLEtBQUtTLGlCQUFMLEtBQTJCLEtBQUtGLFlBQUwsQ0FBa0I3SCxNQUFsQixHQUEyQixDQUZuRztBQUlIO0FBQ0o7O0FBRUQsdUJBQU95SSxhQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OztBQTFMVztBQUFBO0FBQUEsbURBcU1ZN00sS0FyTVosRUFxTW1CO0FBQzFCLG9CQUFJcUssWUFBWW9CLGNBQWhCOztBQUVBLG9CQUFJLEtBQUt3QixXQUFMLENBQWlCak4sTUFBTWtOLE9BQXZCLEVBQWdDLEtBQUtwRyxLQUFMLENBQVc3RCxJQUFYLENBQWdCcUssSUFBaEQsQ0FBSixFQUEyRDtBQUN2RGpELGdDQUFZcUIsY0FBWjtBQUNIO0FBQ0Qsb0JBQUksS0FBS3VCLFdBQUwsQ0FBaUJqTixNQUFNa04sT0FBdkIsRUFBZ0MsS0FBS3BHLEtBQUwsQ0FBVzdELElBQVgsQ0FBZ0JzSyxJQUFoRCxDQUFKLEVBQTJEO0FBQ3ZEbEQsZ0NBQVlzQixjQUFaO0FBQ0g7O0FBRUQsb0JBQUkzTCxNQUFNd04sT0FBVixFQUFtQjtBQUNmbkQsaUNBQWEsQ0FBQyxDQUFkO0FBQ0g7O0FBRUQsdUJBQU9BLFNBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBdE5XO0FBQUE7QUFBQSx3Q0FpT0M2QyxPQWpPRCxFQWlPVWpLLElBak9WLEVBaU9nQjtBQUN2Qix1QkFBTyxlQUFLRCxPQUFMLENBQWFDLElBQWIsSUFBc0JBLEtBQUt1QixPQUFMLENBQWEwSSxPQUFiLE1BQTBCLENBQUMsQ0FBakQsR0FBdURBLFlBQVlqSyxJQUExRTtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7QUFyT1c7QUFBQTtBQUFBLDJDQWdQSXdLLE9BaFBKLEVBZ1BhO0FBQ3BCLG9CQUFJQyxVQUFVRCxRQUFRQyxPQUFSLENBQWdCdEksV0FBaEIsRUFBZDs7QUFFQSx1QkFBUXNJLFlBQVksT0FBWixJQUF1QkEsWUFBWSxRQUFuQyxJQUErQ0EsWUFBWSxVQUFuRTtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBdFBXO0FBQUE7QUFBQSx1Q0ErUEFyRCxTQS9QQSxFQStQVztBQUNsQixvQkFBSXNELGlCQUFpQixLQUFLMUIsWUFBTCxDQUFrQjdILE1BQXZDOztBQUVBLG9CQUFJd0osYUFBYSxLQUFLM0IsWUFBTCxDQUFrQixLQUFLRSxpQkFBdkIsQ0FBakI7O0FBRUF5QiwyQkFBVzNRLFlBQVgsQ0FBd0IsVUFBeEIsRUFBb0MsQ0FBQyxDQUFyQzs7QUFFQSxxQkFBS2tQLGlCQUFMLElBQTBCOUIsU0FBMUI7O0FBRUEsb0JBQUksS0FBS3ZELEtBQUwsQ0FBV3VHLFFBQWYsRUFBeUI7QUFDckI7QUFDQTtBQUNBLHlCQUFLbEIsaUJBQUwsR0FBeUIsQ0FBRSxLQUFLQSxpQkFBTCxHQUF5QndCLGNBQTFCLEdBQTRDQSxjQUE3QyxJQUErREEsY0FBeEY7QUFDSCxpQkFKRCxNQUlPO0FBQ0gseUJBQUt4QixpQkFBTCxHQUF5QnJFLEtBQUsrRixHQUFMLENBQVMvRixLQUFLZ0csR0FBTCxDQUFTLEtBQUszQixpQkFBZCxFQUFpQ3dCLGlCQUFpQixDQUFsRCxDQUFULEVBQStELENBQS9ELENBQXpCO0FBQ0g7O0FBRURDLDZCQUFhLEtBQUszQixZQUFMLENBQWtCLEtBQUtFLGlCQUF2QixDQUFiOztBQUVBeUIsMkJBQVczUSxZQUFYLENBQXdCLFVBQXhCLEVBQW9DLENBQXBDO0FBQ0EyUSwyQkFBVzFDLEtBQVg7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBdFJXO0FBQUE7QUFBQSx1Q0E4UkE7QUFDUCxvQkFBSTZDLFVBQVUsbUJBQVM5QyxXQUFULENBQXFCLElBQXJCLENBQWQ7O0FBRUEsb0JBQUk4QyxPQUFKLEVBQWE7QUFDVCx3QkFBSUMsY0FBY0QsUUFBUUUsZ0JBQVIsQ0FBeUIsS0FBS25ILEtBQUwsQ0FBV2tILFdBQXBDLENBQWxCOztBQUVBLHdCQUFJRSxzQkFBc0IsRUFBMUI7O0FBRUEseUJBQUtqQyxZQUFMLEdBQW9CLEVBQXBCOztBQUVBa0MsMEJBQU1DLFNBQU4sQ0FBZ0IzSixLQUFoQixDQUFzQjVILElBQXRCLENBQTJCbVIsV0FBM0IsRUFBd0NLLE9BQXhDLENBQWdELFVBQVNoRCxJQUFULEVBQWU7QUFDM0QsNEJBQUlpRCxlQUFlakQsS0FBS2tELFlBQUwsQ0FBa0IsZUFBbEIsQ0FBbkI7O0FBRUEsNEJBQUlELFlBQUosRUFBa0I7QUFDZEosZ0RBQW9CMUgsSUFBcEIsQ0FBeUI2RSxJQUF6QjtBQUNILHlCQUZELE1BRU87QUFDSCxpQ0FBS1ksWUFBTCxDQUFrQnpGLElBQWxCLENBQXVCNkUsSUFBdkI7QUFDSDtBQUNKLHFCQVIrQyxDQVE5Qy9NLElBUjhDLENBUXpDLElBUnlDLENBQWhEOztBQVVBNFAsMENBQXNCQSxvQkFBb0JNLElBQXBCLENBQXlCLFVBQVNDLENBQVQsRUFBWUMsQ0FBWixFQUFlO0FBQzFELCtCQUFRLGVBQUtDLEtBQUwsQ0FBV0YsRUFBRUYsWUFBRixDQUFlLGVBQWYsQ0FBWCxJQUE4QyxlQUFLSSxLQUFMLENBQVdELEVBQUVILFlBQUYsQ0FBZSxlQUFmLENBQVgsQ0FBdEQ7QUFDSCxxQkFGcUIsQ0FBdEI7O0FBSUEseUJBQUt0QyxZQUFMLEdBQW9CaUMsb0JBQW9COUgsTUFBcEIsQ0FBMkIsS0FBSzZGLFlBQWhDLENBQXBCOztBQUVBLHlCQUFLRSxpQkFBTCxHQUF5QixDQUF6Qjs7QUFFQSx5QkFBS0YsWUFBTCxDQUFrQjJDLElBQWxCLENBQXVCLFVBQVN2RCxJQUFULEVBQWV3RCxLQUFmLEVBQXNCO0FBQ3pDLDRCQUFJeEQsS0FBS2tELFlBQUwsQ0FBa0IsVUFBbEIsTUFBa0MsR0FBdEMsRUFBMkM7QUFDdkMsaUNBQUtwQyxpQkFBTCxHQUF5QjBDLEtBQXpCO0FBQ0EsaUNBQUszRCxLQUFMOztBQUVBLG1DQUFPLElBQVA7QUFDSDtBQUNKLHFCQVBzQixDQU9yQjVNLElBUHFCLENBT2hCLElBUGdCLENBQXZCO0FBUUg7QUFDSjtBQW5VVTs7QUFBQTtBQUFBLE1BQWtDNkksZ0JBQWxDO0FBQUEsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCZjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7OztrQkFNZTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7OztBQWlCWDs7Ozs7OztBQWpCVyw4Q0F3Qk87QUFDZCxvQkFBSTdILE9BQU93UCxvQkFBWCxFQUFpQztBQUM3QnhQLDJCQUFPd1Asb0JBQVAsQ0FBNEIsS0FBS0MsaUJBQWpDO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBN0JBOzs7Ozs7OztBQURXO0FBQUE7QUFBQSxtREErQ1lDLEtBL0NaLEVBK0NtQkMsWUEvQ25CLEVBK0NpQztBQUN4Q0EsK0JBQWVBLGdCQUFnQixJQUFJOVIsU0FBU3lELEdBQVQsQ0FBYXRCLE1BQWpCLENBQXdCQSxNQUF4QixFQUFnQzRQLGVBQWhDLEVBQS9COztBQUVBLG9CQUFJQyxJQUFJSCxNQUFNSSxJQUFkO0FBQ0Esb0JBQUlDLElBQUlMLE1BQU1NLEdBQWQ7O0FBRUEsb0JBQUlOLE1BQU1JLElBQU4sR0FBYUosTUFBTU8sS0FBbkIsR0FBMkJOLGFBQWFNLEtBQTVDLEVBQW1EO0FBQy9DSix5QkFBTUgsTUFBTUksSUFBTixHQUFhSixNQUFNTyxLQUFuQixHQUEyQk4sYUFBYU0sS0FBOUM7QUFDSDs7QUFFRCxvQkFBSUYsSUFBSSxDQUFSLEVBQVc7QUFDUEEsd0JBQUksQ0FBSjtBQUNIOztBQUVELHVCQUFPO0FBQ0hGLHVCQUFHQSxDQURBO0FBRUhFLHVCQUFHQTtBQUZBLGlCQUFQO0FBSUg7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFuRVc7QUFBQTtBQUFBLGtEQXFGVztBQUNsQixvQkFBSUcsZUFBZSxLQUFLMUksS0FBTCxDQUFXMkksV0FBWCxHQUF5QixLQUFLM0ksS0FBTCxDQUFXMkksV0FBWCxDQUF1QnZQLElBQWhELEdBQXVELElBQTFFOztBQUVBLG9CQUFJLENBQUNzUCxZQUFMLEVBQW1CO0FBQ2Y7QUFDSDs7QUFFRCxvQkFBSUUsZ0JBQWdCRixhQUFhRSxhQUFqQzs7QUFFQSxvQkFBSUMsY0FBY0gsYUFBYUcsV0FBL0I7O0FBRUEsb0JBQUlDLE1BQU07QUFDTlQsdUJBQUdLLGFBQWFHLFdBQWIsQ0FBeUJFLEtBRHRCO0FBRU5SLHVCQUFHSyxjQUFjSSxNQUFkLENBQXFCUjtBQUZsQixpQkFBVjs7QUFLQSxvQkFBSWpGLFlBQVlxRixjQUFjSSxNQUFkLENBQXFCekYsU0FBckM7O0FBRUEsb0JBQUkwRixVQUFVTCxjQUFjSSxNQUFkLENBQXFCQyxPQUFuQzs7QUFFQSxvQkFBSUMsWUFBWU4sY0FBY0ksTUFBZCxDQUFxQkUsU0FBckM7O0FBRUEsb0JBQUlELFdBQVdDLFNBQVgsSUFBd0JBLFVBQVVWLEdBQVYsS0FBa0JTLFFBQVFULEdBQXRELEVBQTJEO0FBQ3ZEakYsZ0NBQVlsTixTQUFTOFMsdUJBQXJCO0FBQ0g7O0FBRUQsb0JBQUlkLENBQUo7QUFDQSxvQkFBSUUsQ0FBSjs7QUFFQTtBQUNBOztBQUVBLG9CQUFJTyxJQUFJVCxDQUFKLElBQVNTLElBQUlQLENBQWpCLEVBQW9CO0FBQ2hCRix3QkFBSSxLQUFLZSxVQUFMLENBQWdCUixhQUFoQixFQUErQkUsSUFBSVQsQ0FBbkMsQ0FBSjs7QUFFQSx3QkFBSTlFLGNBQWNsTixTQUFTOFMsdUJBQTNCLEVBQW9EO0FBQ2hEWiw0QkFBSXZILEtBQUtnRyxHQUFMLENBQVM4QixJQUFJUCxDQUFiLEVBQWdCSyxjQUFjSSxNQUFkLENBQXFCUixHQUFyQyxDQUFKO0FBQ0gscUJBRkQsTUFFTztBQUNIRCw0QkFBSXZILEtBQUsrRixHQUFMLENBQVMrQixJQUFJUCxDQUFiLEVBQWdCLEtBQUtjLFVBQUwsQ0FBZ0JULGFBQWhCLEVBQStCQyxXQUEvQixDQUFoQixDQUFKO0FBQ0g7QUFDSixpQkFSRCxNQVFPO0FBQ0hSLHdCQUFJTyxjQUFjSSxNQUFkLENBQXFCVixJQUFyQixHQUE0Qk0sY0FBY0ksTUFBZCxDQUFxQlAsS0FBckIsR0FBNkIsQ0FBN0Q7O0FBRUEsd0JBQUlsRixjQUFjbE4sU0FBU21OLHVCQUEzQixFQUFvRDs7QUFFaEQrRSw0QkFBSSxLQUFLYyxVQUFMLENBQWdCVCxhQUFoQixFQUErQkMsV0FBL0IsQ0FBSjtBQUVILHFCQUpELE1BSU87QUFDSE4sNEJBQUlLLGNBQWNJLE1BQWQsQ0FBcUJSLEdBQXpCO0FBQ0g7QUFDSjs7QUFFRCx1QkFBTztBQUNIakYsK0JBQVdBLFNBRFI7QUFFSDhFLHVCQUFHQSxDQUZBO0FBR0hFLHVCQUFHQTtBQUhBLGlCQUFQO0FBS0g7O0FBRUQ7Ozs7Ozs7Ozs7OztBQWhKVztBQUFBO0FBQUEsdUNBMkpBSyxhQTNKQSxFQTJKZVUsTUEzSmYsRUEySnVCO0FBQzlCLG9CQUFJTixTQUFTSixjQUFjSSxNQUEzQjs7QUFFQSxvQkFBSVYsT0FBT1UsT0FBT0UsU0FBUCxHQUFtQkYsT0FBT0UsU0FBUCxDQUFpQlosSUFBcEMsR0FBMkNVLE9BQU9WLElBQTdEO0FBQ0Esb0JBQUlpQixRQUFRUCxPQUFPQyxPQUFQLEdBQWlCRCxPQUFPQyxPQUFQLENBQWVNLEtBQWhDLEdBQXdDUCxPQUFPTyxLQUEzRDs7QUFFQSxvQkFBSWxCLENBQUo7O0FBRUEsb0JBQUlDLE9BQU9nQixNQUFQLElBQWlCQyxRQUFRRCxNQUE3QixFQUFxQztBQUNqQ2pCLHdCQUFJaUIsTUFBSjtBQUNILGlCQUZELE1BRU87QUFDSCx3QkFBSUUsV0FBV3hJLEtBQUt5SSxHQUFMLENBQVNuQixPQUFPZ0IsTUFBaEIsQ0FBZjtBQUNBLHdCQUFJSSxZQUFZMUksS0FBS3lJLEdBQUwsQ0FBU0YsUUFBUUQsTUFBakIsQ0FBaEI7O0FBRUEsd0JBQUlFLFdBQVdFLFNBQWYsRUFBMEI7QUFBRTtBQUN4QnJCLDRCQUFJQyxJQUFKO0FBQ0gscUJBRkQsTUFFTztBQUNIRCw0QkFBSWtCLEtBQUo7QUFDSDtBQUNKOztBQUVELHVCQUFPbEIsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7QUFuTFc7QUFBQTtBQUFBLHVDQThMQU8sYUE5TEEsRUE4TGVDLFdBOUxmLEVBOEw0QjtBQUNuQyxvQkFBSU4sSUFBSSxDQUFSOztBQUVBLG9CQUFJSyxpQkFBaUJDLFdBQXJCLEVBQWtDO0FBQzlCLHdCQUFJYyxnQkFBZ0IsSUFBSXRULFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5QmtDLFlBQVl2TyxNQUFyQyxDQUFwQjs7QUFFQSx3QkFBSXFQLGNBQWNoUixDQUFkLElBQW1CZ1IsY0FBYzVKLFFBQWQsQ0FBdUIsVUFBdkIsTUFBdUMsTUFBOUQsRUFBc0U7QUFDbEV3SSw0QkFBSU0sWUFBWXZPLE1BQVosQ0FBbUJzUCxTQUFuQixHQUErQmYsWUFBWXZPLE1BQVosQ0FBbUJ1UCxZQUF0RDtBQUNILHFCQUZELE1BRU87QUFDSHRCLDRCQUFJSyxjQUFjSSxNQUFkLENBQXFCYyxNQUF6QjtBQUNIO0FBQ0o7O0FBRUQsdUJBQU92QixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztBQTlNVztBQUFBO0FBQUEsNkNBNE5NRCxJQTVOTixFQTROWUUsR0E1TlosRUE0TmlCakYsU0E1TmpCLEVBNE40QjtBQUNuQyxvQkFBSTBELFVBQVUsbUJBQVM5QyxXQUFULENBQXFCLElBQXJCLENBQWQ7O0FBRUEsb0JBQUk0RixTQUFTLEtBQUsvSixLQUFMLENBQVcrSixNQUF4Qjs7QUFFQSxvQkFBSXhHLGNBQWNsTixTQUFTbU4sdUJBQXZCLElBQWtERCxjQUFjbE4sU0FBUzhTLHVCQUE3RSxFQUFzRztBQUNsR2IsMkJBQU9BLE9BQU95QixPQUFPekIsSUFBZCxHQUFzQnJCLFFBQVErQyxXQUFSLEdBQXNCLENBQW5EOztBQUVBeEIsMEJBQU9qRixjQUFjbE4sU0FBU21OLHVCQUF4QixHQUFvRGdGLE1BQU11QixPQUFPdkIsR0FBakUsR0FDREEsTUFBTXZCLFFBQVE0QyxZQUFkLEdBQTZCRSxPQUFPdkIsR0FEekM7QUFHSCxpQkFORCxNQU1PLElBQUlqRixjQUFjbE4sU0FBUzRULHVCQUF2QixJQUNQMUcsY0FBY2xOLFNBQVM2VCx1QkFEcEIsRUFDNkM7O0FBRWhENUIsMkJBQVEvRSxjQUFjbE4sU0FBUzRULHVCQUF4QixHQUNGM0IsT0FBT3lCLE9BQU96QixJQUFkLEdBQXFCckIsUUFBUTRDLFlBQVIsR0FBdUIsQ0FEMUMsR0FFRnZCLE9BQU8sSUFBSXJCLFFBQVE0QyxZQUFaLEdBQTJCLENBQWxDLEdBQXNDRSxPQUFPekIsSUFGbEQ7O0FBSUFFLDBCQUFNQSxNQUFNdUIsT0FBT3ZCLEdBQWIsR0FBb0J2QixRQUFRNEMsWUFBUixHQUF1QixDQUFqRDtBQUNIOztBQUVELG9CQUFJdkIsT0FBTyxDQUFYLEVBQWM7QUFDVkEsMkJBQU8sQ0FBUDtBQUNIOztBQUVELG9CQUFJRSxNQUFNLENBQVYsRUFBYTtBQUNUQSwwQkFBTSxDQUFOO0FBQ0g7O0FBRUQsdUJBQU8sQ0FBQ0YsSUFBRCxFQUFPRSxHQUFQLENBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBNVBXO0FBQUE7QUFBQSx3Q0FvUUM7QUFDUixvQkFBSXZCLFVBQVUsbUJBQVM5QyxXQUFULENBQXFCLElBQXJCLENBQWQ7O0FBRUEsb0JBQUk4QyxPQUFKLEVBQWE7QUFDVCx3QkFBSWtELGFBQWEsSUFBSTlULFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5Qk0sT0FBekIsQ0FBakI7O0FBRUEsMkJBQU9rRCxXQUFXQyxRQUFYLENBQW9CLHNCQUFwQixDQUFQO0FBQ0g7O0FBRUQsdUJBQU8sS0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBaFJXO0FBQUE7QUFBQSx3Q0F5UkNDLFVBelJELEVBeVJhQyxRQXpSYixFQXlSdUI7QUFDOUIsb0JBQUlILGFBQWEsSUFBSTlULFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5QixtQkFBU3hDLFdBQVQsQ0FBcUIsSUFBckIsQ0FBekIsQ0FBakI7O0FBRUFnRywyQkFBV0ksU0FBWCxDQUFxQjtBQUNqQmpDLDBCQUFNK0IsV0FBVyxDQUFYLElBQWdCLElBREw7QUFFakI3Qix5QkFBSzZCLFdBQVcsQ0FBWCxJQUFnQixJQUZKO0FBR2pCRyw2QkFBUztBQUhRLGlCQUFyQjs7QUFNQUwsMkJBQVcvUixXQUFYLENBQXVCLHdCQUF2Qjs7QUFFQSxxQkFBS3FTLFFBQUwsQ0FBYyxZQUFXO0FBQ3JCTiwrQkFBVzVTLFFBQVgsQ0FBb0IsdUJBQXBCO0FBQ0E0UywrQkFBVzVTLFFBQVgsQ0FBb0Isc0JBQXBCO0FBQ0E0UywrQkFBV0ksU0FBWCxDQUFxQjtBQUNqQmpDLDhCQUFNZ0MsU0FBUyxDQUFULElBQWMsSUFESDtBQUVqQjlCLDZCQUFLOEIsU0FBUyxDQUFULElBQWMsSUFGRjtBQUdqQkUsaUNBQVM7QUFIUSxxQkFBckI7QUFLSCxpQkFSRDtBQVNIOztBQUVEOzs7Ozs7OztBQS9TVztBQUFBO0FBQUEsbUNBc1RKO0FBQ0gsb0JBQUl2RCxVQUFVLG1CQUFTOUMsV0FBVCxDQUFxQixJQUFyQixDQUFkOztBQUVBLG9CQUFJLENBQUMsS0FBS3VHLFNBQUwsRUFBRCxJQUFxQnpELE9BQXpCLEVBQWtDO0FBQzlCLHdCQUFJMEQsbUJBQW1CLEtBQUtySCxtQkFBTCxFQUF2Qjs7QUFFQSx3QkFBSXFILGdCQUFKLEVBQXNCO0FBQ2xCLDRCQUFJUixhQUFhLElBQUk5VCxTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBeUJNLE9BQXpCLENBQWpCOztBQUVBLDRCQUFJMkQsTUFBSixFQUNJQyxNQURKLEVBRUlDLFFBRkosRUFHSUMsUUFISjs7QUFLQUgsaUNBQVNFLFdBQVdFLFdBQVdiLFdBQVdwSyxRQUFYLENBQW9CLE1BQXBCLENBQVgsQ0FBcEI7QUFDQThLLGlDQUFTRSxXQUFXQyxXQUFXYixXQUFXcEssUUFBWCxDQUFvQixLQUFwQixDQUFYLENBQXBCOztBQUVBLDRCQUFJLEtBQUtDLEtBQUwsQ0FBV2lMLG1CQUFmLEVBQW9DO0FBQ2hDLGdDQUFJQyxNQUFNLEtBQUtDLHNCQUFMLENBQTRCO0FBQ2xDQyx3Q0FBUUosV0FBVy9ELFFBQVE0QyxZQUFuQixDQUQwQjtBQUVsQ3ZCLHNDQUFNc0MsTUFGNEI7QUFHbENwQyxxQ0FBS3FDLE1BSDZCO0FBSWxDcEMsdUNBQU91QyxXQUFXL0QsUUFBUStDLFdBQW5CO0FBSjJCLDZCQUE1QixDQUFWOztBQU9BWSxxQ0FBU00sSUFBSTdDLENBQWI7QUFDQXdDLHFDQUFTSyxJQUFJM0MsQ0FBYjtBQUNIOztBQUVELDRCQUFJb0MsaUJBQWlCcEgsU0FBakIsS0FBK0JsTixTQUFTbU4sdUJBQTVDLEVBQXFFO0FBQ2pFdUgsdUNBQVcsS0FBSy9LLEtBQUwsQ0FBVzRJLGFBQVgsQ0FBeUJJLE1BQXpCLENBQWdDYyxNQUEzQztBQUNILHlCQUZELE1BRU87QUFDSGlCLHVDQUFXLEtBQUsvSyxLQUFMLENBQVc0SSxhQUFYLENBQXlCSSxNQUF6QixDQUFnQ1IsR0FBM0M7QUFDSDs7QUFFRCw2QkFBSzZDLFdBQUwsQ0FBaUIsQ0FBQ1AsUUFBRCxFQUFXQyxRQUFYLENBQWpCLEVBQXVDLENBQUNILE1BQUQsRUFBU0MsTUFBVCxDQUF2QztBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7Ozs7QUE5Vlc7QUFBQTtBQUFBLDZDQXFXTTtBQUNiLG9CQUFJRixtQkFBbUIsS0FBS3JILG1CQUFMLEVBQXZCOztBQUVBLG9CQUFJMkQsVUFBVSxtQkFBUzlDLFdBQVQsQ0FBcUIsSUFBckIsQ0FBZDs7QUFFQSxvQkFBSXdHLG9CQUFvQjFELE9BQXhCLEVBQWlDO0FBQzdCLHdCQUFJcUUsS0FBSyxLQUFLQyxnQkFBTCxDQUFzQlosaUJBQWlCdEMsQ0FBdkMsRUFBMENzQyxpQkFBaUJwQyxDQUEzRCxFQUE4RG9DLGlCQUFpQnBILFNBQS9FLENBQVQ7O0FBRUEsd0JBQUlsTixTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBeUJNLE9BQXpCLEVBQWtDc0QsU0FBbEMsQ0FBNEM7QUFDeENqQyw4QkFBTWdELEdBQUcsQ0FBSCxJQUFRLElBRDBCO0FBRXhDOUMsNkJBQUs4QyxHQUFHLENBQUgsSUFBUTtBQUYyQixxQkFBNUM7QUFJSDtBQUNKOztBQUVEOzs7Ozs7Ozs7O0FBcFhXO0FBQUE7QUFBQSxxQ0E2WEYxTixRQTdYRSxFQTZYUTtBQUNmLG9CQUFJcEYsT0FBT2dULHFCQUFYLEVBQWtDO0FBQzlCLHlCQUFLdkQsaUJBQUwsR0FBeUJ6UCxPQUFPZ1QscUJBQVAsQ0FBNkI1TixRQUE3QixDQUF6QjtBQUNILGlCQUZELE1BRU87QUFDSEE7QUFDSDtBQUNKO0FBbllVOztBQUFBO0FBQUEsTUFBa0N5QyxnQkFBbEMsVUFRSm9MLFlBUkksZ0JBU0pwTCxpQkFBaUJvTCxZQVRiO0FBVVAxQixnQkFBUTtBQUNKekIsa0JBQU0sQ0FERjtBQUVKRSxpQkFBSztBQUZELFNBVkQ7QUFjUHlDLDZCQUFxQixJQWRkO0FBQUEsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7O0lBU01TLFU7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJQyxXQUFXLGVBQWUsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQVEsY0FBWWxVLFlBQVlvRyxPQUFaLENBQW9CK04sSUFBeEMsRUFBOEMsZ0JBQWNGLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBN0YsRUFBZ0csV0FBV2lPLFFBQTNHLEVBQXFILGFBQVUsYUFBL0gsRUFBNkksU0FBUyxLQUFLakwsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQXRKLEVBQW1MLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQXhNLEVBQWtOLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQitOLElBQTdPO0FBQ0ksd0RBQU0sV0FBVSxjQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCb0IsZ0JBQU1DLFM7O0FBb0IvQjs7Ozs7Ozs7OztBQVFBSixXQUFXM0ksR0FBWCxHQUFpQixNQUFqQjs7QUFFQTs7Ozs7Ozs7QUFRQTJJLFdBQVdELFlBQVgsR0FBMEI7QUFDdEJuTCxhQUFTLE1BRGE7QUFFdEJPLGVBQVc7QUFDUFEsWUFBSSxhQURHO0FBRVBsRixjQUFNOUYsU0FBUytGLElBQVQsR0FBZ0IsRUFGZixDQUVrQjtBQUZsQixLQUZXO0FBTXRCNkYsV0FBTztBQU5lLENBQTFCOztrQkFTZSw2QkFDWCwrQkFDQSxrQ0FDQSwyQkFDSXlKLFVBREosQ0FEQSxDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5RGY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0lBS01LLGlCOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7OzRDQVNvQjtBQUNoQiwrQkFBUzVILFdBQVQsQ0FBcUIsS0FBSzZILElBQUwsQ0FBVUMsZUFBL0IsRUFBZ0Q3SCxLQUFoRDtBQUNIOztBQUVEOzs7Ozs7Ozs7OytDQU91QjtBQUNuQixnQkFBSSxLQUFLOEgsT0FBVCxFQUFrQjtBQUNkLG9CQUFJLEtBQUtBLE9BQUwsQ0FBYUMsSUFBakIsRUFBdUI7QUFDbkIseUJBQUtELE9BQUwsQ0FBYUMsSUFBYjtBQUNILGlCQUZELE1BRU8sSUFBSSxLQUFLRCxPQUFMLENBQWFFLGNBQWpCLEVBQWlDO0FBQ3BDLHlCQUFLRixPQUFMLENBQWFFLGNBQWIsR0FBOEI3RSxPQUE5QixDQUFzQyxVQUFTOEUsS0FBVCxFQUFnQjtBQUNsREEsOEJBQU1GLElBQU47QUFDSCxxQkFGRDtBQUdIO0FBQ0QscUJBQUtELE9BQUwsR0FBZSxJQUFmO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSUksZUFBZW5PLFVBQVVtTyxZQUFWLElBQ2ZuTyxVQUFVb08sa0JBREssSUFFZnBPLFVBQVVxTyxlQUZLLElBR2ZyTyxVQUFVc08sY0FIZDs7QUFLQUgseUJBQWF2VyxJQUFiLENBQWtCb0ksU0FBbEIsRUFBNkI7QUFDekJ1Tyx1QkFBTyxJQURrQjtBQUV6QkMsdUJBQU87QUFGa0IsYUFBN0IsRUFHRyxLQUFLQyxvQkFBTCxDQUEwQnBWLElBQTFCLENBQStCLElBQS9CLENBSEgsRUFHeUMsS0FBS3FWLGtCQUFMLENBQXdCclYsSUFBeEIsQ0FBNkIsSUFBN0IsQ0FIekM7O0FBS0EsbUJBQ0k7QUFBQTtBQUFBLGtCQUFLLFdBQVUsV0FBZjtBQUNJO0FBQUE7QUFBQSxzQkFBTyxLQUFJLGdCQUFYO0FBQUE7QUFBQSxpQkFESjtBQUVJO0FBQUE7QUFBQSxzQkFBUSxXQUFVLGlCQUFsQixFQUFvQyxTQUFTLEtBQUtzVixTQUFMLENBQWV0VixJQUFmLENBQW9CLElBQXBCLENBQTdDLEVBQXdFLEtBQUksaUJBQTVFO0FBQUE7QUFBQSxpQkFGSjtBQUdJLDBEQUFRLFdBQVUsa0JBQWxCLEVBQXFDLEtBQUksaUJBQXpDO0FBSEosYUFESjtBQU9IOztBQUVEOzs7Ozs7Ozs7OztvQ0FRWTtBQUNSLGdCQUFJdVYsVUFBVSxtQkFBUzVJLFdBQVQsQ0FBcUIsS0FBSzZILElBQUwsQ0FBVWdCLGNBQS9CLENBQWQ7QUFDQSxnQkFBSUMsV0FBVyxtQkFBUzlJLFdBQVQsQ0FBcUIsS0FBSzZILElBQUwsQ0FBVWtCLGVBQS9CLENBQWY7O0FBRUEsZ0JBQUlDLFVBQVVGLFNBQVNHLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBZDs7QUFFQSxnQkFBSWhDLFNBQVMsS0FBS2lDLFlBQWxCO0FBQ0EsZ0JBQUk1RSxRQUFRLEtBQUt6SSxLQUFMLENBQVdzTixVQUF2Qjs7QUFFQSxnQkFBSTdFLFNBQVMyQyxNQUFiLEVBQXFCO0FBQ2pCNkIseUJBQVN4RSxLQUFULEdBQWlCQSxLQUFqQjtBQUNBd0UseUJBQVM3QixNQUFULEdBQWtCQSxNQUFsQjs7QUFFQStCLHdCQUFRSSxTQUFSLENBQWtCUixPQUFsQixFQUEyQixDQUEzQixFQUE4QixDQUE5QixFQUFpQ3RFLEtBQWpDLEVBQXdDMkMsTUFBeEM7O0FBRUEsb0JBQUlvQyxTQUFTUCxTQUFTUSxTQUFULENBQW1CLFdBQW5CLENBQWI7O0FBRUEsb0JBQUlDLEtBQUtyWCxTQUFTeUQsR0FBVCxDQUFhNk0sT0FBYixDQUFxQmdILGNBQXJCLENBQW9DLGVBQWVILE1BQWYsR0FBd0IsSUFBNUQsQ0FBVDs7QUFFQSxvQkFBSXBYLFNBQVMsS0FBSzRKLEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQWI7O0FBRUFFLHVCQUFPd1gsYUFBUCxDQUFxQkYsRUFBckI7O0FBRUEscUJBQUsxTixLQUFMLENBQVd3RSxlQUFYOztBQUVBcE8sdUJBQU93RCxJQUFQLENBQVksaUJBQVosRUFBK0IsSUFBL0I7O0FBRUF4RCx1QkFBT3dELElBQVAsQ0FBWSxnQkFBWixFQUE4QjhULEVBQTlCO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7OzJDQVNtQkcsSyxFQUFPO0FBQ3RCclYsbUJBQU9zVixLQUFQLENBQWEsd0JBQXdCRCxLQUFyQztBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7OzZDQVVxQkUsTSxFQUFRO0FBQ3pCLGdCQUFJaEIsVUFBVSxtQkFBUzVJLFdBQVQsQ0FBcUIsS0FBSzZILElBQUwsQ0FBVWdCLGNBQS9CLENBQWQ7QUFDQSxnQkFBSUMsV0FBVyxtQkFBUzlJLFdBQVQsQ0FBcUIsS0FBSzZILElBQUwsQ0FBVWtCLGVBQS9CLENBQWY7O0FBRUFILG9CQUFRaUIsZ0JBQVIsQ0FBeUIsU0FBekIsRUFBb0MsVUFBUzlVLEtBQVQsRUFBZ0I7QUFDaEQsb0JBQUlrUyxTQUFTMkIsUUFBUWtCLFdBQVIsSUFBdUJsQixRQUFRTyxVQUFSLEdBQW1CLEtBQUt0TixLQUFMLENBQVdzTixVQUFyRCxDQUFiOztBQUVBLG9CQUFJWSxNQUFNOUMsTUFBTixDQUFKLEVBQW1CO0FBQ2ZBLDZCQUFTLEtBQUtwTCxLQUFMLENBQVdzTixVQUFYLElBQXlCLElBQUUsQ0FBM0IsQ0FBVDtBQUNIOztBQUVEUCx3QkFBUTVXLFlBQVIsQ0FBcUIsT0FBckIsRUFBOEIsS0FBSzZKLEtBQUwsQ0FBV3NOLFVBQXpDO0FBQ0FQLHdCQUFRNVcsWUFBUixDQUFxQixRQUFyQixFQUErQmlWLE1BQS9CO0FBQ0E2Qix5QkFBUzlXLFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0IsS0FBSzZKLEtBQUwsQ0FBV3NOLFVBQTFDO0FBQ0FMLHlCQUFTOVcsWUFBVCxDQUFzQixRQUF0QixFQUFnQ2lWLE1BQWhDOztBQUVBLHFCQUFLaUMsWUFBTCxHQUFvQmpDLE1BQXBCO0FBQ0gsYUFibUMsQ0FhbEM1VCxJQWJrQyxDQWE3QixJQWI2QixDQUFwQyxFQWFjLEtBYmQ7O0FBZUEsaUJBQUswVSxPQUFMLEdBQWU2QixNQUFmOztBQUVBLGdCQUFJNVAsVUFBVXFPLGVBQWQsRUFBK0I7QUFDM0JPLHdCQUFRb0IsWUFBUixHQUF1QkosTUFBdkI7QUFDSCxhQUZELE1BRU87QUFDSGhCLHdCQUFRdlAsR0FBUixHQUFjLENBQUNoRixPQUFPNFYsR0FBUCxJQUFjNVYsT0FBTzZWLFNBQXRCLEVBQWlDQyxlQUFqQyxDQUFpRFAsTUFBakQsQ0FBZDtBQUNIOztBQUVEaEIsb0JBQVF3QixJQUFSOztBQUVBLCtCQUFTcEssV0FBVCxDQUFxQixLQUFLNkgsSUFBTCxDQUFVQyxlQUEvQixFQUFnRHVDLFFBQWhELEdBQTJELEtBQTNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O0VBNUo0QixnQkFBTTFDLFM7O0FBcUt0Qzs7Ozs7Ozs7OztBQVFBQyxrQkFBa0JoSixHQUFsQixHQUF3QixhQUF4Qjs7QUFFQTs7Ozs7OztBQU9BZ0osa0JBQWtCTixZQUFsQixHQUFpQztBQUM3QjZCLGdCQUFZO0FBRGlCLENBQWpDOztrQkFJZXZCLGlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xNZjs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7SUFRTTBDLFk7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJLEtBQUt6TyxLQUFMLENBQVd5RSxlQUFmLEVBQWdDO0FBQzVCLHVCQUNJLDJEQUF1QixLQUFLekUsS0FBNUIsQ0FESjtBQUdILGFBSkQsTUFJTztBQUNILG9CQUFJd08sV0FBVyxFQUFFclEsVUFBVW1PLFlBQVYsSUFDWm5PLFVBQVVvTyxrQkFBVixJQUFnQzdSLFNBQVNnVSxRQUFULEtBQXNCLE9BRDFDLElBRWJ2USxVQUFVcU8sZUFGRyxJQUdick8sVUFBVXNPLGNBSEMsQ0FBZjs7QUFLQSxvQkFBSWtDLFFBQVFILFdBQVc5VyxZQUFZb0csT0FBWixDQUFvQjhRLGNBQS9CLEdBQWdEbFgsWUFBWW9HLE9BQVosQ0FBb0IrUSxNQUFoRjs7QUFFQSx1QkFDSTtBQUFBO0FBQUEsc0JBQVEsY0FBWUYsS0FBcEIsRUFBMkIsV0FBVSxXQUFyQyxFQUFpRCxhQUFVLHFCQUEzRCxFQUFpRixVQUFVSCxRQUEzRixFQUFxRyxTQUFTLEtBQUt4TyxLQUFMLENBQVcwRSxnQkFBWCxDQUE0QmxOLElBQTVCLENBQWlDaVgsYUFBYTFMLEdBQTlDLENBQTlHLEVBQWtLLFVBQVUsS0FBSy9DLEtBQUwsQ0FBV3RELFFBQXZMLEVBQWlNLE9BQU9pUyxLQUF4TTtBQUNJLDREQUFNLFdBQVUsZ0JBQWhCO0FBREosaUJBREo7QUFLSDtBQUNKOzs7O0VBNUJzQixnQkFBTTdDLFM7O0FBK0JqQzs7Ozs7Ozs7OztBQVFBMkMsYUFBYTFMLEdBQWIsR0FBbUIsUUFBbkI7O2tCQUVlMEwsWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNSyxVOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSW5ELFdBQVcsZUFBZSxLQUFLQyxlQUFMLEVBQTlCOztBQUVBLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZbFUsWUFBWW9HLE9BQVosQ0FBb0JpUixJQUF4QyxFQUE4QyxnQkFBY3BELFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBN0YsRUFBZ0csV0FBV2lPLFFBQTNHLEVBQXFILGFBQVUsYUFBL0gsRUFBNkksU0FBUyxLQUFLeEwsVUFBTCxDQUFnQjNJLElBQWhCLENBQXFCLElBQXJCLENBQXRKLEVBQWtMLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQXZNLEVBQWlOLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQmlSLElBQTVPO0FBQ0ksd0RBQU0sV0FBVSxjQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCb0IsZ0JBQU1qRCxTOztBQW9CL0I7Ozs7Ozs7Ozs7QUFRQWdELFdBQVcvTCxHQUFYLEdBQWlCLE1BQWpCOztBQUVBOzs7Ozs7OztBQVFBK0wsV0FBV3JELFlBQVgsR0FBMEI7QUFDdEJ4SixXQUFPO0FBQ0gwRSxpQkFBUztBQUROO0FBRGUsQ0FBMUI7O2tCQU1lLGlDQUNYLGtDQUNBLDJCQUNJbUksVUFESixDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RGY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7SUFPTUUscUI7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZLEtBQUtoUCxLQUFMLENBQVdpUCxXQUEvQixFQUE0QyxXQUFXLEtBQUtDLGFBQUwsRUFBdkQsRUFBNkUsU0FBUyxLQUFLeE8sV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQXRGLEVBQW1ILFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQXhJO0FBQW1KLHFCQUFLc0QsS0FBTCxDQUFXaVA7QUFBOUosYUFESjtBQUdIOztBQUVEOzs7Ozs7Ozs7Ozs7d0NBU2dCO0FBQ1osZ0JBQUlwVSxZQUFZLG9CQUFoQjs7QUFFQSxnQkFBSSxLQUFLbUYsS0FBTCxDQUFXbVAsSUFBZixFQUFxQjtBQUNqQnRVLDZCQUFhLGNBQWMsS0FBS21GLEtBQUwsQ0FBV21QLElBQXRDO0FBQ0g7O0FBRUQsbUJBQU90VSxTQUFQO0FBQ0g7Ozs7RUFoQytCLGdCQUFNaVIsUzs7QUFtQzFDOzs7Ozs7Ozs7O0FBUUFrRCxzQkFBc0JqTSxHQUF0QixHQUE0Qix1QkFBNUI7O2tCQUVlLDZCQUNYaU0scUJBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7O0lBT01JLGtCOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7OzRDQVNvQjtBQUNoQiwrQkFBU2pMLFdBQVQsQ0FBcUIsSUFBckIsRUFBMkJDLEtBQTNCO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFTO0FBQ0wsbUJBQ0k7QUFBQTtBQUFBLGtCQUFLLFdBQVUsZ0RBQWYsRUFBZ0UsU0FBUyxLQUFLQSxLQUFMLENBQVc1TSxJQUFYLENBQWdCLElBQWhCLENBQXpFLEVBQWdHLFdBQVcsS0FBSzZYLFNBQUwsQ0FBZTdYLElBQWYsQ0FBb0IsSUFBcEIsQ0FBM0csRUFBc0ksVUFBUyxHQUEvSTtBQUNJO0FBQUE7QUFBQSxzQkFBSSxXQUFVLFlBQWQsRUFBMkIsSUFBSSxLQUFLd0ksS0FBTCxDQUFXc1AsTUFBMUMsRUFBa0QsTUFBSyxTQUF2RDtBQUNLLHlCQUFLQyxjQUFMLENBQW9CLEtBQUt2UCxLQUFMLENBQVd3UCxRQUEvQjtBQURMO0FBREosYUFESjtBQU9IOztBQUVEOzs7Ozs7Ozs7Ozs7dUNBU2VBLFEsRUFBVTtBQUNyQixnQkFBSXBaLFNBQVMsS0FBSzRKLEtBQUwsQ0FBVzVKLE1BQXhCO0FBQ0EsZ0JBQUlrTyxLQUFKOztBQUVBLGdCQUFJa0wsWUFBWUEsU0FBU2xTLE1BQXpCLEVBQWlDO0FBQzdCZ0gsd0JBQVFrTCxTQUFTMU0sR0FBVCxDQUFhLFVBQVN5QixJQUFULEVBQWU7QUFDaEMsMkJBQ0k7QUFBQTtBQUFBLDBCQUFJLEtBQUtBLEtBQUtqRSxPQUFkLEVBQXVCLE1BQUssUUFBNUI7QUFDSSx5RkFBdUIsU0FBU2lFLEtBQUtqRSxPQUFyQyxFQUE4QyxhQUFhLE9BQU9pRSxLQUFLb0ssS0FBWixLQUFzQixRQUF0QixHQUFpQ3BLLEtBQUtvSyxLQUF0QyxHQUE4Q3BLLEtBQUtvSyxLQUFMLEVBQXpHLEVBQXVILFFBQVF2WSxNQUEvSDtBQURKLHFCQURKO0FBS0gsaUJBTk8sQ0FBUjtBQU9IOztBQUVELG1CQUFPa08sS0FBUDtBQUNIOzs7O0VBeEQ0QixnQkFBTXdILFM7O0FBMkR2Qzs7Ozs7Ozs7OztBQVFBc0QsbUJBQW1Cck0sR0FBbkIsR0FBeUIsb0JBQXpCOztBQUVBOzs7Ozs7OztBQVFBcU0sbUJBQW1CM0QsWUFBbkIsR0FBa0M7QUFDOUJsRixjQUFVLEtBRG9CO0FBRTlCVyxpQkFBYSxxQkFGaUI7QUFHOUIvSyxVQUFNO0FBQ0Y4SixpQkFBUyxDQUFDLEVBQUQsQ0FEUDtBQUVGSSxxQkFBYSxDQUFDLEVBQUQsQ0FGWDtBQUdGQyxxQkFBYSxDQUFDLEVBQUQsQ0FIWDtBQUlGRSxjQUFNLENBQUMsRUFBRCxDQUpKO0FBS0ZDLGNBQU0sQ0FBQyxFQUFEO0FBTEo7QUFId0IsQ0FBbEM7O2tCQVllLGtDQUNYMkksa0JBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyR2Y7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7OztJQU1NSyxjOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxtQkFDSTtBQUFBO0FBQUEsa0JBQUssV0FBVSxnREFBZixFQUFnRSxTQUFTLEtBQUtyTCxLQUFMLENBQVc1TSxJQUFYLENBQWdCLElBQWhCLENBQXpFLEVBQWdHLFdBQVcsS0FBSzZYLFNBQUwsQ0FBZTdYLElBQWYsQ0FBb0IsSUFBcEIsQ0FBM0csRUFBc0ksVUFBUyxHQUEvSTtBQUNJO0FBQUE7QUFBQSxzQkFBSSxXQUFVLFlBQWQsRUFBMkIsTUFBSyxTQUFoQztBQUNLLHlCQUFLd0ksS0FBTCxDQUFXMFA7QUFEaEI7QUFESixhQURKO0FBT0g7Ozs7RUFqQndCLGdCQUFNNUQsUzs7QUFvQm5DOzs7Ozs7Ozs7O0FBUUEyRCxlQUFlMU0sR0FBZixHQUFxQixVQUFyQjs7QUFFQTs7Ozs7OztBQU9BME0sZUFBZWhFLFlBQWYsR0FBOEI7QUFDMUJsRixjQUFVLEtBRGdCO0FBRTFCVyxpQkFBYSxxQkFGYTtBQUcxQi9LLFVBQU07QUFDRjhKLGlCQUFTLENBQUMsRUFBRCxDQURQO0FBRUZJLHFCQUFhLENBQUMsRUFBRCxDQUZYO0FBR0ZDLHFCQUFhLENBQUMsRUFBRCxDQUhYO0FBSUZFLGNBQU0sQ0FBQyxFQUFELENBSko7QUFLRkMsY0FBTSxDQUFDLEVBQUQ7QUFMSjtBQUhvQixDQUE5Qjs7a0JBWWUsa0NBQ1hnSixjQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURmOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLElBQUlFLFlBQVksRUFBaEI7QUFDQSxJQUFJQyxVQUFVLEVBQWQ7O0FBRUE7Ozs7Ozs7SUFNTUMsZTs7O0FBQ0YsNkJBQVk3UCxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsc0lBQ1RBLEtBRFM7O0FBR2YsY0FBSzhQLFNBQUwsR0FBaUIsZ0JBQU1DLFNBQU4sRUFBakI7QUFDQSxjQUFLdlAsS0FBTCxHQUFhLE1BQUt3UCxlQUFMLEVBQWI7QUFKZTtBQUtsQjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7NENBVW9CO0FBQ2hCLGdCQUFJLEtBQUtoUSxLQUFMLENBQVd5RSxlQUFYLElBQThCLEtBQUt6RSxLQUFMLENBQVdpUSxlQUE3QyxFQUE4RDtBQUMxRDtBQUNBO0FBQ0Esb0JBQUl6WCxPQUFPZ1QscUJBQVgsRUFBa0M7QUFDOUJoVCwyQkFBT2dULHFCQUFQLENBQTZCLEtBQUswRSxlQUFMLENBQXFCMVksSUFBckIsQ0FBMEIsSUFBMUIsQ0FBN0I7QUFDSCxpQkFGRCxNQUVPO0FBQ0h1RywrQkFBVyxLQUFLbVMsZUFBTCxDQUFxQjFZLElBQXJCLENBQTBCLElBQTFCLENBQVgsRUFBNEMsQ0FBNUM7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7Ozs7Ozs7O29EQVE0QjtBQUN4QixpQkFBS29NLFFBQUwsQ0FBYyxLQUFLb00sZUFBTCxFQUFkO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OzBDQVFrQjtBQUNkLGdCQUFJNVosU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjtBQUNBLGdCQUFJaWEsS0FBSjs7QUFFQSxnQkFBSXZYLFlBQVl4QyxPQUFPcUMsWUFBUCxFQUFoQjs7QUFFQSxnQkFBSUcsU0FBSixFQUFlO0FBQ1gsb0JBQUl3WCxrQkFBa0J4WCxVQUFVeVgsa0JBQVYsRUFBdEI7O0FBRUEsb0JBQUlELGVBQUosRUFBcUI7QUFDakJELDRCQUFRQyxnQkFBZ0JFLE9BQWhCLENBQXdCLDBCQUF4QixDQUFSO0FBQ0g7QUFDSjs7QUFFRCxnQkFBSW5XLE9BQU9nVyxRQUFRQSxNQUFNMUksWUFBTixDQUFtQixtQkFBbkIsQ0FBUixHQUFrRCxFQUE3RDs7QUFFQSxtQkFBTztBQUNIZCx5QkFBU3dKLEtBRE47QUFFSEksNkJBQWE7QUFDVHBXLDBCQUFNQTtBQURHLGlCQUZWO0FBS0hxVywwQkFBVXJXO0FBTFAsYUFBUDtBQU9IOztBQUVEOzs7Ozs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJc1csaUJBQWlCO0FBQ2pCakcseUJBQVMsS0FBS2hLLEtBQUwsQ0FBV2dRLFFBQVgsR0FBc0IsQ0FBdEIsR0FBMEI7QUFEbEIsYUFBckI7O0FBSUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFLLFdBQVUsd0JBQWY7QUFDSTtBQUFBO0FBQUEsc0JBQVEsY0FBWTlZLFlBQVlvRyxPQUFaLENBQW9CNFMsV0FBeEMsRUFBcUQsV0FBVSxXQUEvRCxFQUEyRSxhQUFVLHFCQUFyRixFQUEyRyxVQUFVLENBQUMsS0FBS2xRLEtBQUwsQ0FBV21HLE9BQWpJLEVBQTBJLFNBQVMsS0FBS2dLLFlBQUwsQ0FBa0JuWixJQUFsQixDQUF1QixJQUF2QixDQUFuSixFQUFpTCxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUF0TSxFQUFnTixPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0I0UyxXQUEzTztBQUNJLDREQUFNLFdBQVUsYUFBaEI7QUFESixpQkFESjtBQUlJO0FBQUE7QUFBQSxzQkFBSyxXQUFVLHdCQUFmO0FBQ0ksNkRBQU8sV0FBVSxVQUFqQixFQUE0QixVQUFVLEtBQUtFLHFCQUFMLENBQTJCcFosSUFBM0IsQ0FBZ0MsSUFBaEMsQ0FBdEMsRUFBNkUsV0FBVyxLQUFLcVosY0FBTCxDQUFvQnJaLElBQXBCLENBQXlCLElBQXpCLENBQXhGLEVBQXdILGFBQWFFLFlBQVlvRyxPQUFaLENBQW9CZ1QsUUFBekosRUFBbUssS0FBSyxLQUFLaEIsU0FBN0ssRUFBd0wsTUFBSyxNQUE3TCxFQUFvTSxPQUFPLEtBQUt0UCxLQUFMLENBQVdnUSxRQUF0TixHQURKO0FBRUksOERBQVEsY0FBWTlZLFlBQVlvRyxPQUFaLENBQW9CaVQsVUFBeEMsRUFBb0QsV0FBVSwwQkFBOUQsRUFBeUYsU0FBUyxLQUFLQyxVQUFMLENBQWdCeFosSUFBaEIsQ0FBcUIsSUFBckIsQ0FBbEcsRUFBOEgsT0FBT2laLGNBQXJJLEVBQXFKLE9BQU8vWSxZQUFZb0csT0FBWixDQUFvQm1ULEtBQWhMO0FBRkosaUJBSko7QUFRSTtBQUFBO0FBQUEsc0JBQVEsY0FBWXZaLFlBQVlvRyxPQUFaLENBQW9Cb1QsT0FBeEMsRUFBaUQsV0FBVSxXQUEzRCxFQUF1RSxVQUFVLENBQUMsS0FBS0MsYUFBTCxFQUFsRixFQUF3RyxTQUFTLEtBQUtDLFVBQUwsQ0FBZ0I1WixJQUFoQixDQUFxQixJQUFyQixDQUFqSCxFQUE2SSxPQUFPRSxZQUFZb0csT0FBWixDQUFvQm9ULE9BQXhLO0FBQ0ksNERBQU0sV0FBVSxZQUFoQjtBQURKO0FBUkosYUFESjtBQWNIOztBQUVEOzs7Ozs7Ozs7Ozs7O3FDQVVhO0FBQ1QsaUJBQUt0TixRQUFMLENBQWM7QUFDVjRNLDBCQUFVO0FBREEsYUFBZDtBQUdIOztBQUVEOzs7Ozs7Ozs7OztxQ0FRYTtBQUNULGdCQUFJclksZUFBZSxLQUFLNkgsS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBbkI7O0FBRUFpQyx5QkFBYXVJLFdBQWIsQ0FBeUIsVUFBekIsRUFBcUM7QUFDakMyUSxxQkFBSyxLQUFLN1EsS0FBTCxDQUFXZ1E7QUFEaUIsYUFBckM7O0FBSUE7QUFDQTtBQUNBLGlCQUFLeFEsS0FBTCxDQUFXd0UsZUFBWDtBQUNIOztBQUVEOzs7Ozs7Ozs7OzswQ0FRa0I7QUFDZCxpQkFBS3NMLFNBQUwsQ0FBZXdCLE9BQWYsQ0FBdUJsTixLQUF2QjtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Ozt1Q0FXZWxMLEssRUFBTztBQUNsQixnQkFBSUEsTUFBTWtOLE9BQU4sS0FBa0J1SixTQUFsQixJQUErQnpXLE1BQU1rTixPQUFOLEtBQWtCd0osT0FBckQsRUFBOEQ7QUFDMUQxVyxzQkFBTVEsY0FBTjtBQUNIOztBQUVELGdCQUFJUixNQUFNa04sT0FBTixLQUFrQnVKLFNBQXRCLEVBQWlDO0FBQzdCLHFCQUFLeUIsVUFBTDtBQUNILGFBRkQsTUFFTyxJQUFJbFksTUFBTWtOLE9BQU4sS0FBa0J3SixPQUF0QixFQUErQjtBQUNsQyxvQkFBSXhaLFNBQVMsS0FBSzRKLEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQWI7O0FBRUE7QUFDQTtBQUNBLHFCQUFLOEosS0FBTCxDQUFXd0UsZUFBWDs7QUFFQXBPLHVCQUFPd0QsSUFBUCxDQUFZLGlCQUFaLEVBQStCLElBQS9CO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7OzhDQVNzQlYsSyxFQUFPO0FBQ3pCLGlCQUFLMEssUUFBTCxDQUFjO0FBQ1Y0TSwwQkFBVXRYLE1BQU1vQixNQUFOLENBQWFEO0FBRGIsYUFBZDtBQUdIOztBQUVEOzs7Ozs7Ozs7Ozs7O3dDQVVnQjtBQUNaLGdCQUFJa1gsYUFDQSxLQUFLL1EsS0FBTCxDQUFXZ1EsUUFBWCxJQUNJLEtBQUtoUSxLQUFMLENBQVdnUSxRQUFYLEtBQXdCLEtBQUtoUSxLQUFMLENBQVcrUCxXQUFYLENBQXVCcFcsSUFGdkQ7O0FBS0EsbUJBQU9vWCxVQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O3VDQVFlO0FBQ1gsZ0JBQUluYixTQUFTLEtBQUs0SixLQUFMLENBQVc1SixNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixDQUFiOztBQUVBLGdCQUFJc2IsZUFBZSxLQUFLaFIsS0FBTCxDQUFXbUcsT0FBWCxDQUFtQjhLLFlBQW5CLENBQWdDLFVBQVM5SyxPQUFULEVBQWtCO0FBQ2pFLHVCQUFPQSxRQUFReUQsUUFBUixDQUFpQixvQkFBakIsQ0FBUDtBQUNILGFBRmtCLENBQW5COztBQUlBb0gseUJBQWFFLE1BQWI7O0FBRUF0YixtQkFBT3dELElBQVAsQ0FBWSxpQkFBWixFQUErQixJQUEvQjtBQUNIOzs7O0VBek95QixnQkFBTWtTLFM7O0FBNE9wQzs7Ozs7Ozs7OztBQVFBK0QsZ0JBQWdCOU0sR0FBaEIsR0FBc0IsV0FBdEI7O2tCQUVlOE0sZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsUWY7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7OztJQVVNOEIsVzs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUksS0FBSzNSLEtBQUwsQ0FBV3lFLGVBQWYsRUFBZ0M7QUFDNUIsdUJBQ0kseURBQXFCLEtBQUt6RSxLQUExQixDQURKO0FBR0gsYUFKRCxNQUlPO0FBQ0gsdUJBQ0k7QUFBQTtBQUFBLHNCQUFRLGNBQVl0SSxZQUFZb0csT0FBWixDQUFvQjdELElBQXhDLEVBQThDLFdBQVUsV0FBeEQsRUFBb0UsYUFBVSxjQUE5RSxFQUE2RixTQUFTLEtBQUsyWCxpQkFBTCxDQUF1QnBhLElBQXZCLENBQTRCLElBQTVCLENBQXRHLEVBQXlJLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTlKLEVBQXdLLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQjdELElBQW5NO0FBQ0ksNERBQU0sV0FBVSxhQUFoQjtBQURKLGlCQURKO0FBS0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7NENBUW9CO0FBQ2hCLGlCQUFLK0YsS0FBTCxDQUFXMEUsZ0JBQVgsQ0FBNEJpTixZQUFZNU8sR0FBeEM7QUFDSDs7OztFQWpDcUIsZ0JBQU0rSSxTOztBQW9DaEM7Ozs7Ozs7Ozs7QUFRQTZGLFlBQWE1TyxHQUFiLEdBQW1CLE9BQW5COztBQUVBOzs7Ozs7OztBQVFBNE8sWUFBWWxHLFlBQVosR0FBMkI7QUFDdkI1SyxlQUFXO0FBQ1BRLFlBQUksbUJBREc7QUFFUGxGLGNBQU05RixTQUFTK0YsSUFBVCxHQUFnQi9GLFNBQVNnRyxLQUF6QixHQUFpQyxFQUZoQyxDQUVtQztBQUZuQztBQURZLENBQTNCOztrQkFPZSwrQkFDWHNWLFdBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzRWY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNRSxROzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSWxHLFdBQVcsZUFBZSxLQUFLQyxlQUFMLEVBQTlCOztBQUVBLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZbFUsWUFBWW9HLE9BQVosQ0FBb0JnVSxFQUF4QyxFQUE0QyxnQkFBY25HLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBM0YsRUFBOEYsV0FBV2lPLFFBQXpHLEVBQW1ILGFBQVUsV0FBN0gsRUFBeUksU0FBUyxLQUFLeEwsVUFBTCxDQUFnQjNJLElBQWhCLENBQXFCLElBQXJCLENBQWxKLEVBQThLLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQW5NLEVBQTZNLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQmdVLEVBQXhPO0FBQ0ksd0RBQU0sV0FBVSxZQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCa0IsZ0JBQU1oRyxTOztBQW9CN0I7Ozs7Ozs7Ozs7QUFRQStGLFNBQVM5TyxHQUFULEdBQWUsSUFBZjs7QUFFQTs7Ozs7Ozs7QUFRQThPLFNBQVNwRyxZQUFULEdBQXdCO0FBQ3BCeEosV0FBTztBQUNIMEUsaUJBQVM7QUFETjtBQURhLENBQXhCOztrQkFNZSxpQ0FDWCxrQ0FDQSwyQkFDSWtMLFFBREosQ0FEQSxDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekRmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7SUFRTUUsUTs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUlwRyxXQUFXLGVBQWUsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQVEsY0FBWWxVLFlBQVlvRyxPQUFaLENBQW9Ca1UsRUFBeEMsRUFBNEMsZ0JBQWNyRyxTQUFTak8sT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBQTNGLEVBQThGLFdBQVdpTyxRQUF6RyxFQUFtSCxhQUFVLFdBQTdILEVBQXlJLFNBQVMsS0FBS3hMLFVBQUwsQ0FBZ0IzSSxJQUFoQixDQUFxQixJQUFyQixDQUFsSixFQUE4SyxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUFuTSxFQUE2TSxPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0JrVSxFQUF4TztBQUNJLHdEQUFNLFdBQVUsWUFBaEI7QUFESixhQURKO0FBS0g7Ozs7RUFqQmtCLGdCQUFNbEcsUzs7QUFvQjdCOzs7Ozs7Ozs7O0FBUUFpRyxTQUFTaFAsR0FBVCxHQUFlLElBQWY7O0FBRUE7Ozs7Ozs7O0FBUUFnUCxTQUFTdEcsWUFBVCxHQUF3QjtBQUNwQnhKLFdBQU87QUFDSDBFLGlCQUFTO0FBRE47QUFEYSxDQUF4Qjs7a0JBTWUsaUNBQ1gsa0NBQ0EsMkJBQ0lvTCxRQURKLENBREEsQ0FEVyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pEZjs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7O0lBT01FLFc7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZdmEsWUFBWW9HLE9BQVosQ0FBb0JvVSxjQUF4QyxFQUF3RCxXQUFVLFdBQWxFLEVBQThFLGFBQVUsY0FBeEYsRUFBdUcsU0FBUyxLQUFLeFIsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQWhILEVBQTZJLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQWxLLEVBQTRLLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQm9VLGNBQXZNO0FBQ0ksd0RBQU0sV0FBVSxtQkFBaEI7QUFESixhQURKO0FBS0g7Ozs7RUFmcUIsZ0JBQU1wRyxTOztBQWtCaEM7Ozs7Ozs7Ozs7QUFRQW1HLFlBQVlsUCxHQUFaLEdBQWtCLE9BQWxCOztBQUVBOzs7Ozs7OztBQVFBa1AsWUFBWXhHLFlBQVosR0FBMkI7QUFDdkJuTCxhQUFTLGdCQURjO0FBRXZCMkIsV0FBTztBQUNIMEUsaUJBQVM7QUFETjtBQUZnQixDQUEzQjs7a0JBT2UsNkJBQ1gsMkJBQ0lzTCxXQURKLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNRSxzQjs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUl4RyxXQUFXLGVBQWUsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQVEsY0FBWWxVLFlBQVlvRyxPQUFaLENBQW9Cc1UsV0FBeEMsRUFBcUQsZ0JBQWN6RyxTQUFTak8sT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBQXBHLEVBQXVHLFdBQVdpTyxRQUFsSCxFQUE0SCxhQUFVLDJCQUF0SSxFQUFrSyxTQUFTLEtBQUtqTCxXQUFMLENBQWlCbEosSUFBakIsQ0FBc0IsSUFBdEIsQ0FBM0ssRUFBd00sVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBN04sRUFBdU8sT0FBT2hGLFlBQVlvRyxPQUFaLENBQW9Cc1UsV0FBbFE7QUFDSSx3REFBTSxXQUFVLHNCQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCZ0MsZ0JBQU10RyxTOztBQW9CM0M7Ozs7Ozs7Ozs7QUFRQXFHLHVCQUF1QnBQLEdBQXZCLEdBQTZCLGFBQTdCOztBQUVBOzs7Ozs7OztBQVFBb1AsdUJBQXVCMUcsWUFBdkIsR0FBc0M7QUFDbENuTCxhQUFTO0FBRHlCLENBQXRDOztrQkFJZSw2QkFDWCxtQ0FDQSxrQ0FDSTZSLHNCQURKLENBREEsQ0FEVyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZEZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7O0lBUU1FLG9COzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSTFHLFdBQVcsZUFBZSxLQUFLQyxlQUFMLEVBQTlCOztBQUVBLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZbFUsWUFBWW9HLE9BQVosQ0FBb0J3VSxTQUF4QyxFQUFtRCxnQkFBYzNHLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBbEcsRUFBcUcsV0FBV2lPLFFBQWhILEVBQTBILGFBQVUseUJBQXBJLEVBQThKLFNBQVMsS0FBS2pMLFdBQUwsQ0FBaUJsSixJQUFqQixDQUFzQixJQUF0QixDQUF2SyxFQUFvTSxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUF6TixFQUFtTyxPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0J3VSxTQUE5UDtBQUNJLHdEQUFNLFdBQVUsb0JBQWhCO0FBREosYUFESjtBQUtIOzs7O0VBakI4QixnQkFBTXhHLFM7O0FBb0J6Qzs7Ozs7Ozs7OztBQVFBdUcscUJBQXFCdFAsR0FBckIsR0FBMkIsV0FBM0I7O0FBRUE7Ozs7Ozs7O0FBUUFzUCxxQkFBcUI1RyxZQUFyQixHQUFvQztBQUNoQ25MLGFBQVM7QUFEdUIsQ0FBcEM7O2tCQUllLDZCQUNYLG1DQUNBLGtDQUNJK1Isb0JBREosQ0FEQSxDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkRmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7SUFRTUUscUI7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJNUcsV0FBVyxlQUFlLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFRLGNBQVlsVSxZQUFZb0csT0FBWixDQUFvQjBVLFVBQXhDLEVBQW9ELGdCQUFjN0csU0FBU2pPLE9BQVQsQ0FBaUIsU0FBakIsTUFBZ0MsQ0FBQyxDQUFuRyxFQUFzRyxXQUFXaU8sUUFBakgsRUFBMkgsYUFBVSwwQkFBckksRUFBZ0ssU0FBUyxLQUFLakwsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQXpLLEVBQXNNLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTNOLEVBQXFPLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQjBVLFVBQWhRO0FBQ0ksd0RBQU0sV0FBVSxxQkFBaEI7QUFESixhQURKO0FBS0g7Ozs7RUFqQitCLGdCQUFNMUcsUzs7QUFvQjFDOzs7Ozs7Ozs7O0FBUUF5RyxzQkFBc0J4UCxHQUF0QixHQUE0QixZQUE1Qjs7QUFFQTs7Ozs7Ozs7QUFRQXdQLHNCQUFzQjlHLFlBQXRCLEdBQXFDO0FBQ2pDbkwsYUFBUztBQUR3QixDQUFyQzs7a0JBSWUsNkJBQ1gsbUNBQ0Esa0NBQ0lpUyxxQkFESixDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RGY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0lBS01FLFc7OztBQUNGLHlCQUFZelMsS0FBWixFQUFtQjtBQUFBOztBQUFBLDhIQUNUQSxLQURTOztBQUVmLGNBQUswUyxTQUFMLEdBQWlCLGdCQUFNM0MsU0FBTixFQUFqQjtBQUZlO0FBR2xCOztBQUVEOzs7Ozs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSTRDLFlBQVksRUFBQ0MsU0FBUyxNQUFWLEVBQWhCOztBQUVBLG1CQUNJO0FBQUE7QUFBQTtBQUNJO0FBQUE7QUFBQSxzQkFBUSxjQUFZbGIsWUFBWW9HLE9BQVosQ0FBb0IrVSxLQUF4QyxFQUErQyxXQUFVLFdBQXpELEVBQXFFLGFBQVUsY0FBL0UsRUFBOEYsU0FBUyxLQUFLQyxXQUFMLENBQWlCdGIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBdkcsRUFBb0ksVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBekosRUFBbUssT0FBT2hGLFlBQVlvRyxPQUFaLENBQW9CK1UsS0FBOUw7QUFDSSw0REFBTSxXQUFVLGVBQWhCO0FBREosaUJBREo7QUFLSSx5REFBTyxRQUFPLFNBQWQsRUFBd0IsVUFBVSxLQUFLRSxjQUFMLENBQW9CdmIsSUFBcEIsQ0FBeUIsSUFBekIsQ0FBbEMsRUFBa0UsS0FBSyxLQUFLa2IsU0FBNUUsRUFBdUYsT0FBT0MsU0FBOUYsRUFBeUcsTUFBSyxNQUE5RztBQUxKLGFBREo7QUFTSDs7QUFFRDs7Ozs7Ozs7Ozs7c0NBUWM7QUFDVixpQkFBS0QsU0FBTCxDQUFlcEIsT0FBZixDQUF1QjBCLEtBQXZCO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUNBZ0JpQjtBQUNiLGdCQUFJQyxVQUFVLEtBQUtQLFNBQUwsQ0FBZXBCLE9BQTdCOztBQUVBO0FBQ0E7QUFDQSxnQkFBSSxDQUFDMkIsUUFBUUMsS0FBUixDQUFjNVYsTUFBbkIsRUFBMkI7QUFDdkI7QUFDSDs7QUFFRCxnQkFBSTZWLFNBQVMsSUFBSUMsVUFBSixFQUFiO0FBQ0EsZ0JBQUlDLE9BQU9KLFFBQVFDLEtBQVIsQ0FBYyxDQUFkLENBQVg7O0FBRUFDLG1CQUFPRyxNQUFQLEdBQWdCLFVBQVNwYSxLQUFULEVBQWdCO0FBQzVCLG9CQUFJOUMsU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjs7QUFFQSxvQkFBSTBMLFNBQVN4TCxPQUFPd0QsSUFBUCxDQUFZLGdCQUFaLEVBQThCO0FBQ3ZDMlosZ0NBQVlGO0FBRDJCLGlCQUE5QixDQUFiOztBQUlBLG9CQUFJLENBQUMsQ0FBQ3pSLE1BQU4sRUFBYztBQUNWLHdCQUFJOEwsS0FBS3JYLFNBQVN5RCxHQUFULENBQWE2TSxPQUFiLENBQXFCZ0gsY0FBckIsQ0FBb0MsZUFBZXpVLE1BQU1vQixNQUFOLENBQWFzSCxNQUE1QixHQUFxQyxJQUF6RSxDQUFUOztBQUVBeEwsMkJBQU93WCxhQUFQLENBQXFCRixFQUFyQjs7QUFFQXRYLDJCQUFPd0QsSUFBUCxDQUFZLGlCQUFaLEVBQStCLElBQS9COztBQUVBLHdCQUFJNFosWUFBWTtBQUNaOUYsNEJBQUlBLEVBRFE7QUFFWjJGLDhCQUFNQTtBQUZNLHFCQUFoQjs7QUFNQWpkLDJCQUFPd0QsSUFBUCxDQUFZLFVBQVosRUFBd0I0WixTQUF4QjtBQUNIO0FBQ0osYUF0QmUsQ0FzQmRoYyxJQXRCYyxDQXNCVCxJQXRCUyxDQUFoQjs7QUF3QkEyYixtQkFBT00sYUFBUCxDQUFxQkosSUFBckI7O0FBRUFKLG9CQUFRNVksS0FBUixHQUFnQixFQUFoQjtBQUNIOzs7O0VBL0ZxQixnQkFBTXlSLFM7O0FBa0doQzs7Ozs7Ozs7OztBQVFBMkcsWUFBWTFQLEdBQVosR0FBa0IsT0FBbEI7O2tCQUVlMFAsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNaUIsaUI7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJL0gsV0FBVyxlQUFlLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFRLGNBQVlsVSxZQUFZb0csT0FBWixDQUFvQjZWLE1BQXhDLEVBQWdELGdCQUFjaEksU0FBU2pPLE9BQVQsQ0FBaUIsU0FBakIsTUFBZ0MsQ0FBQyxDQUEvRixFQUFrRyxXQUFXaU8sUUFBN0csRUFBdUgsYUFBVSxxQkFBakksRUFBdUosU0FBUyxLQUFLakwsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQWhLLEVBQTZMLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQWxOLEVBQTROLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQjZWLE1BQXZQO0FBQ0ksd0RBQU0sV0FBVSxzQkFBaEI7QUFESixhQURKO0FBS0g7Ozs7RUFqQjJCLGdCQUFNN0gsUzs7QUFvQnRDOzs7Ozs7Ozs7O0FBUUE0SCxrQkFBa0IzUSxHQUFsQixHQUF3QixhQUF4Qjs7QUFFQTs7Ozs7Ozs7QUFRQTJRLGtCQUFrQmpJLFlBQWxCLEdBQWlDO0FBQzdCbkwsYUFBUztBQURvQixDQUFqQzs7a0JBSWUsNkJBQ1gsbUNBQ0Esa0NBQ0lvVCxpQkFESixDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7OztJQVNNRSxZOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSWpJLFdBQVcsZUFBZSxLQUFLQyxlQUFMLEVBQTlCOztBQUVBLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZbFUsWUFBWW9HLE9BQVosQ0FBb0IrVixNQUF4QyxFQUFnRCxnQkFBY2xJLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBL0YsRUFBa0csV0FBV2lPLFFBQTdHLEVBQXVILGFBQVUsZUFBakksRUFBaUosU0FBUyxLQUFLakwsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQTFKLEVBQXVMLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTVNLEVBQXNOLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQitWLE1BQWpQO0FBQ0ksd0RBQU0sV0FBVSxnQkFBaEI7QUFESixhQURKO0FBS0g7Ozs7RUFqQnNCLGdCQUFNL0gsUzs7QUFvQmpDOzs7Ozs7Ozs7O0FBUUE4SCxhQUFhN1EsR0FBYixHQUFtQixRQUFuQjs7QUFFQTs7Ozs7Ozs7QUFRQTZRLGFBQWFuSSxZQUFiLEdBQTRCO0FBQ3hCbkwsYUFBUyxRQURlO0FBRXhCTyxlQUFXO0FBQ1BRLFlBQUksYUFERztBQUVQbEYsY0FBTTlGLFNBQVMrRixJQUFULEdBQWdCLEVBRmYsQ0FFa0I7QUFGbEIsS0FGYTtBQU14QjZGLFdBQU87QUFOaUIsQ0FBNUI7O2tCQVNlLDZCQUNYLCtCQUNBLGtDQUNBLDJCQUNJMlIsWUFESixDQURBLENBREEsQ0FEVyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlEZjs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7O0lBT01FLDBCOzs7QUFDRix3Q0FBWTlULEtBQVosRUFBbUI7QUFBQTs7QUFBQSw0SkFDVEEsS0FEUzs7QUFHZixjQUFLUSxLQUFMLEdBQWE7QUFDVDhELG1CQUFPO0FBREUsU0FBYjtBQUhlO0FBTWxCOztBQUVEOzs7Ozs7Ozs7Ozs7a0RBUTBCWCxTLEVBQVc7QUFDakMsZ0JBQUksQ0FBQ0EsVUFBVW9RLElBQVgsSUFBbUJwUSxVQUFVb1EsSUFBVixLQUFtQixLQUFLL1QsS0FBTCxDQUFXK1QsSUFBckQsRUFBMkQ7QUFDdkRDLDZCQUFhLEtBQUtDLFFBQWxCOztBQUVBLG9CQUFJdFEsVUFBVW9RLElBQWQsRUFBb0I7QUFDaEIseUJBQUtFLFFBQUwsR0FBZ0JsVyxXQUFXLEtBQUttVyxZQUFoQixFQUE4QixLQUFLbFUsS0FBTCxDQUFXbVUsS0FBekMsQ0FBaEI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gseUJBQUt2USxRQUFMLENBQWM7QUFDVlUsK0JBQU87QUFERyxxQkFBZDtBQUdIO0FBQ0o7O0FBRUQsZ0JBQUlYLFVBQVV5USxvQkFBZCxFQUFvQztBQUNoQ3JXLDJCQUFXLEtBQUtxRyxLQUFoQixFQUF1QixDQUF2QjtBQUNBLHFCQUFLcEUsS0FBTCxDQUFXcVUsb0JBQVgsQ0FBZ0M7QUFDNUJDLDhCQUFVO0FBRGtCLGlCQUFoQztBQUdIO0FBQ0o7O0FBRUQ7Ozs7Ozs7Ozs7K0NBT3VCO0FBQ25CTix5QkFBYSxLQUFLQyxRQUFsQjtBQUNIOztBQUVEOzs7Ozs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJLENBQUMsS0FBS2pVLEtBQUwsQ0FBVytELFFBQVosSUFBd0IsQ0FBQyxLQUFLdkQsS0FBTCxDQUFXOEQsS0FBWCxDQUFpQmhILE1BQTlDLEVBQXNEO0FBQ2xELHVCQUFPLElBQVA7QUFDSDs7QUFFRCxtQkFDSTtBQUFBO0FBQUE7QUFDSyxxQkFBS2lYLHdCQUFMLENBQThCLEtBQUsvVCxLQUFMLENBQVc4RCxLQUF6QztBQURMLGFBREo7QUFLSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs4Q0FVc0JYLFMsRUFBVzZRLFMsRUFBVztBQUN4QyxtQkFBTzdRLFVBQVVJLFFBQVYsS0FBdUIsS0FBSy9ELEtBQUwsQ0FBVytELFFBQWxDLElBQThDSixVQUFVb1EsSUFBVixLQUFtQixLQUFLL1QsS0FBTCxDQUFXK1QsSUFBNUUsSUFBb0ZTLFVBQVVsUSxLQUFWLEtBQW9CLEtBQUs5RCxLQUFMLENBQVc4RCxLQUExSDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7O2lEQVV5QkEsSyxFQUFPO0FBQzVCQSxvQkFBUUEsU0FBUyxFQUFqQjs7QUFFQSxnQkFBSW1RLDhCQUE4QixLQUFLelUsS0FBTCxDQUFXeVUsMkJBQTdDOztBQUVBLG1CQUFPblEsTUFBTXhCLEdBQU4sQ0FBVSxVQUFTeUIsSUFBVCxFQUFlO0FBQzVCLG9CQUFJMUosWUFBWSxLQUFLbUYsS0FBTCxDQUFXK1QsSUFBWCxLQUFvQnhQLEtBQUs4TSxHQUF6QixHQUErQiwyQkFBL0IsR0FBNkQsb0JBQTdFOztBQUVBLHVCQUNJO0FBQUE7QUFBQSxzQkFBSSxLQUFLOU0sS0FBSzhNLEdBQWQsRUFBbUIsTUFBSyxRQUF4QjtBQUNJO0FBQUE7QUFBQSwwQkFBUSxXQUFXeFcsU0FBbkIsRUFBOEIsU0FBUzRaLDJCQUF2QyxFQUFvRSxjQUFZbFEsS0FBSzhNLEdBQXJGO0FBQTJGOU0sNkJBQUttUTtBQUFoRztBQURKLGlCQURKO0FBS0gsYUFSZ0IsQ0FRZmxkLElBUmUsQ0FRVixJQVJVLENBQVYsQ0FBUDtBQVNIOztBQUVEOzs7Ozs7Ozs7Ozt1Q0FRZTtBQUNYLGdCQUFJbWQsV0FBVyxJQUFmOztBQUVBLGdCQUFJLENBQUMsS0FBSzNVLEtBQUwsQ0FBVytULElBQWhCLEVBQXNCO0FBQ2xCO0FBQ0g7O0FBRUQsZ0JBQUlhLFVBQVVDLFFBQVFDLE9BQVIsQ0FBZ0IsS0FBSzlVLEtBQUwsQ0FBVzVHLElBQVgsQ0FBZ0IsS0FBSzRHLEtBQUwsQ0FBVytULElBQTNCLENBQWhCLENBQWQ7O0FBRUFhLG9CQUFRRyxJQUFSLENBQWEsVUFBU3pRLEtBQVQsRUFBZ0I7QUFDekIsb0JBQUlBLE1BQU1oSCxNQUFWLEVBQWtCO0FBQ2QscUJBQUNxWCxTQUFTM1UsS0FBVCxDQUFlK0QsUUFBaEIsSUFBNEI0USxTQUFTM1UsS0FBVCxDQUFlZ0UsY0FBZixFQUE1QjtBQUNIOztBQUVEMlEseUJBQVMvUSxRQUFULENBQWtCO0FBQ2RVLDJCQUFPQTtBQURPLGlCQUFsQjtBQUdILGFBUkQ7QUFTSDs7OztFQXZJb0MsZ0JBQU13SCxTOztBQTBJL0M7Ozs7Ozs7Ozs7QUFRQWdJLDJCQUEyQi9RLEdBQTNCLEdBQWlDLDRCQUFqQzs7QUFFQTs7Ozs7Ozs7QUFRQStRLDJCQUEyQnJJLFlBQTNCLEdBQTBDO0FBQ3RDbEYsY0FBVSxLQUQ0QjtBQUV0Q25OLFVBQU0sRUFGZ0M7QUFHdEMrYSxXQUFPLEdBSCtCO0FBSXRDak4saUJBQWEscUJBSnlCO0FBS3RDL0ssVUFBTTtBQUNGOEosaUJBQVMsQ0FBQyxFQUFELENBRFA7QUFFRkkscUJBQWEsQ0FBQyxFQUFELENBRlg7QUFHRkMscUJBQWEsQ0FBQyxFQUFELENBSFg7QUFJRkUsY0FBTSxDQUFDLEVBQUQsQ0FKSjtBQUtGQyxjQUFNLENBQUMsRUFBRDtBQUxKO0FBTGdDLENBQTFDOztrQkFjZSxrQ0FDWHFOLDBCQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyTGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7OztJQVNNa0IsYzs7O0FBQ0YsNEJBQVloVixLQUFaLEVBQW1CO0FBQUE7O0FBQUEsb0lBQ1RBLEtBRFM7O0FBR2YsY0FBSzhQLFNBQUwsR0FBaUIsZ0JBQU1DLFNBQU4sRUFBakI7QUFDQSxjQUFLdlAsS0FBTCxHQUFhLE1BQUt5VSxnQkFBTCxFQUFiO0FBSmU7QUFLbEI7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OzRDQVVvQjtBQUNoQixnQkFBSSxLQUFLalYsS0FBTCxDQUFXeUUsZUFBWCxJQUE4QixLQUFLekUsS0FBTCxDQUFXaVEsZUFBN0MsRUFBOEQ7QUFDMUQ7QUFDQTtBQUNBLHFCQUFLQyxlQUFMO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7b0RBUTRCO0FBQ3hCLGlCQUFLdE0sUUFBTCxDQUFjLEtBQUtxUixnQkFBTCxFQUFkO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUlDLGlCQUFpQjtBQUNqQkMsZ0NBQWdCLEtBQUtuVixLQUFMLENBQVdtVixjQURWO0FBRWpCL2Usd0JBQVEsS0FBSzRKLEtBQUwsQ0FBVzVKLE1BRkY7QUFHakJnZix3Q0FBd0IsS0FBS0MsdUJBQUwsQ0FBNkI3ZCxJQUE3QixDQUFrQyxJQUFsQyxDQUhQO0FBSWpCOGQsZ0NBQWdCLEtBQUs5VSxLQUFMLENBQVcrVSxVQUFYLElBQXlCN2QsWUFBWW9HLE9BQVosQ0FBb0IwWDtBQUo1QyxhQUFyQjs7QUFPQU4sNkJBQWlCLEtBQUs5UixrQkFBTCxDQUF3QjhSLGNBQXhCLEVBQXdDLCtCQUFxQm5TLEdBQTdELENBQWpCOztBQUVBLGdCQUFJMFMsb0JBQUo7O0FBRUEsZ0JBQUksS0FBS3pWLEtBQUwsQ0FBVzVHLElBQWYsRUFBcUI7QUFDakIsb0JBQUlzYyxTQUFTLEtBQUsxVixLQUFMLENBQVc1RyxJQUF4Qjs7QUFFQSxvQkFBSSxDQUFDLGVBQUt5RSxVQUFMLENBQWdCNlgsTUFBaEIsQ0FBTCxFQUE4QjtBQUMxQix3QkFBSXBSLFFBQVEsS0FBS3RFLEtBQUwsQ0FBVzVHLElBQXZCOztBQUVBc2MsNkJBQVM7QUFBQSwrQkFBTXBSLEtBQU47QUFBQSxxQkFBVDtBQUNIOztBQUVELG9CQUFJcVIsNEJBQTRCO0FBQzVCdkIsMENBQXNCLEtBQUs1VCxLQUFMLENBQVc0VCxvQkFETDtBQUU1QmhiLDBCQUFNc2MsTUFGc0I7QUFHNUJ0Ziw0QkFBUSxLQUFLNEosS0FBTCxDQUFXNUosTUFIUztBQUk1QnFlLGlEQUE2QixLQUFLbUIsNEJBSk47QUFLNUIvUCwrQkFBVyxLQUFLN0YsS0FBTCxDQUFXZ0UsY0FMTTtBQU01QnFRLDBDQUFzQixLQUFLd0IscUJBTkM7QUFPNUI5QiwwQkFBTSxLQUFLdlQsS0FBTCxDQUFXZ1E7QUFQVyxpQkFBaEM7O0FBVUFtRiw0Q0FBNEIsS0FBS3ZTLGtCQUFMLENBQXdCdVMseUJBQXhCLEVBQW1ELHFDQUEyQjVTLEdBQTlFLENBQTVCOztBQUVBMFMsdUNBQXVCLG9FQUFnQ0UseUJBQWhDLENBQXZCO0FBQ0g7O0FBRUQsZ0JBQUlHLGVBQUo7O0FBRUEsZ0JBQUksS0FBS3RWLEtBQUwsQ0FBV2dRLFFBQWYsRUFBeUI7QUFDckJzRixrQ0FBa0IsMENBQVEsY0FBWXBlLFlBQVlvRyxPQUFaLENBQW9CaVQsVUFBeEMsRUFBb0QsV0FBVSwwQkFBOUQsRUFBeUYsU0FBUyxLQUFLQyxVQUFMLENBQWdCeFosSUFBaEIsQ0FBcUIsSUFBckIsQ0FBbEcsRUFBOEgsT0FBT0UsWUFBWW9HLE9BQVosQ0FBb0JtVCxLQUF6SixHQUFsQjtBQUNIOztBQUVELGdCQUFJOEUsa0JBQWtCLEVBQXRCOztBQUVBLGdCQUFJLENBQUMxZixTQUFTVyxHQUFULENBQWFDLEVBQWQsSUFBb0JTLFlBQVlvRyxPQUFwQyxFQUE2QztBQUN6Q2lZLGdDQUFnQkMsV0FBaEIsR0FBOEJ0ZSxZQUFZb0csT0FBWixDQUFvQmdULFFBQWxEO0FBQ0g7O0FBRUQsbUJBQ0k7QUFBQTtBQUFBLGtCQUFLLFdBQVUsd0JBQWY7QUFDSTtBQUFBO0FBQUEsc0JBQVEsY0FBWXBaLFlBQVlvRyxPQUFaLENBQW9CbVksVUFBeEMsRUFBb0QsV0FBVSxXQUE5RCxFQUEwRSxVQUFVLENBQUMsS0FBS3pWLEtBQUwsQ0FBV21HLE9BQWhHLEVBQXlHLFNBQVMsS0FBS3VQLFdBQUwsQ0FBaUIxZSxJQUFqQixDQUFzQixJQUF0QixDQUFsSCxFQUErSSxPQUFPRSxZQUFZb0csT0FBWixDQUFvQjRULE1BQTFLO0FBQ0ksNERBQU0sV0FBVSxnQkFBaEI7QUFESixpQkFESjtBQUlJO0FBQUE7QUFBQSxzQkFBSyxXQUFVLHdCQUFmO0FBQ0sseUJBQUsxUixLQUFMLENBQVdtVyxrQkFBWCxJQUFpQyw4REFBMEJqQixjQUExQixDQUR0QztBQUVJO0FBQUE7QUFBQSwwQkFBSyxXQUFVLG9CQUFmO0FBQ0ksMEVBQU8sV0FBVSxVQUFqQixFQUE0QixVQUFVLEtBQUt0RSxxQkFBTCxDQUEyQnBaLElBQTNCLENBQWdDLElBQWhDLENBQXRDLEVBQTZFLFdBQVcsS0FBS3FaLGNBQUwsQ0FBb0JyWixJQUFwQixDQUF5QixJQUF6QixDQUF4RixJQUE2SHVlLGVBQTdILElBQStJLEtBQUssS0FBS2pHLFNBQXpKLEVBQW9LLE1BQUssTUFBekssRUFBZ0wsT0FBTyxLQUFLdFAsS0FBTCxDQUFXZ1EsUUFBbE0sSUFESjtBQUVLaUY7QUFGTCxxQkFGSjtBQU1LSztBQU5MLGlCQUpKO0FBWUk7QUFBQTtBQUFBLHNCQUFRLGNBQVlwZSxZQUFZb0csT0FBWixDQUFvQm9ULE9BQXhDLEVBQWlELFdBQVUsV0FBM0QsRUFBdUUsVUFBVSxDQUFDLEtBQUtDLGFBQUwsRUFBbEYsRUFBd0csU0FBUyxLQUFLaUYsV0FBTCxDQUFpQjVlLElBQWpCLENBQXNCLElBQXRCLENBQWpILEVBQThJLE9BQU9FLFlBQVlvRyxPQUFaLENBQW9Cb1QsT0FBeks7QUFDSSw0REFBTSxXQUFVLFlBQWhCO0FBREo7QUFaSixhQURKO0FBa0JIOztBQUVEOzs7Ozs7Ozs7Ozs7MkNBU21CO0FBQUEseUJBQ3FCLEtBQUtsUixLQUQxQjtBQUFBLGdCQUNSNUosTUFEUSxVQUNSQSxNQURRO0FBQUEsZ0JBQ0FpZ0IsaUJBREEsVUFDQUEsaUJBREE7OztBQUdmLGdCQUFNcGMsT0FBTyxJQUFJNUQsU0FBU2lnQixJQUFiLENBQWtCbGdCLE9BQU9GLEdBQVAsQ0FBVyxjQUFYLENBQWxCLEVBQThDcWdCLGdCQUE5QyxFQUFiO0FBQ0EsZ0JBQU1wYyxPQUFPRixPQUFPQSxLQUFLd04sWUFBTCxDQUFrQixNQUFsQixDQUFQLEdBQW1DLEVBQWhEO0FBQ0EsZ0JBQU1uTixTQUFTTCxPQUFPQSxLQUFLd04sWUFBTCxDQUFrQixRQUFsQixDQUFQLEdBQXFDNE8saUJBQXBEOztBQUVBLG1CQUFPO0FBQ0hqQyxzQ0FBc0IsS0FEbkI7QUFFSHpOLHlCQUFTMU0sSUFGTjtBQUdIc1csNkJBQWE7QUFDVHBXLDBCQUFNQSxJQURHO0FBRVRHLDRCQUFRQTtBQUZDLGlCQUhWO0FBT0hrVywwQkFBVXJXLElBUFA7QUFRSG9iLDRCQUFZamI7QUFSVCxhQUFQO0FBVUg7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7cUNBVWE7QUFDVCxpQkFBS3NKLFFBQUwsQ0FBYztBQUNWNE0sMEJBQVU7QUFEQSxhQUFkOztBQUlBLGlCQUFLTixlQUFMO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OzBDQVFrQjtBQUNkLGdCQUFJeUUsV0FBVyxJQUFmOztBQUVBLGdCQUFJNkIsY0FBYyxTQUFkQSxXQUFjLEdBQVc7QUFDekI3Qix5QkFBUzdFLFNBQVQsQ0FBbUJ3QixPQUFuQixDQUEyQmxOLEtBQTNCO0FBQ0gsYUFGRDs7QUFJQSxnQkFBSTVMLE9BQU9nVCxxQkFBWCxFQUFrQztBQUM5QmhULHVCQUFPZ1QscUJBQVAsQ0FBNkJnTCxXQUE3QjtBQUNILGFBRkQsTUFFTztBQUNIelksMkJBQVd5WSxXQUFYLEVBQXdCLENBQXhCO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7dUNBV2V0ZCxLLEVBQU87QUFDbEIsZ0JBQUlBLE1BQU1rTixPQUFOLEtBQWtCLEVBQWxCLElBQXdCbE4sTUFBTWtOLE9BQU4sS0FBa0IsRUFBOUMsRUFBa0Q7QUFDOUNsTixzQkFBTVEsY0FBTjtBQUNIOztBQUVELGdCQUFJUixNQUFNa04sT0FBTixLQUFrQixFQUF0QixFQUEwQjtBQUN0QixxQkFBS2dRLFdBQUw7QUFDSCxhQUZELE1BRU8sSUFBSWxkLE1BQU1rTixPQUFOLEtBQWtCLEVBQXRCLEVBQTBCO0FBQzdCLHFCQUFLeEMsUUFBTCxDQUFjO0FBQ1Z3USwwQ0FBc0I7QUFEWixpQkFBZDtBQUdILGFBSk0sTUFJQSxJQUFJbGIsTUFBTWtOLE9BQU4sS0FBa0IsRUFBdEIsRUFBMEI7QUFDN0Isb0JBQUloUSxTQUFTLEtBQUs0SixLQUFMLENBQVc1SixNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixDQUFiOztBQUVBLG9CQUFJRyxTQUFTaWdCLElBQWIsQ0FBa0JsZ0IsTUFBbEIsRUFBMEJxZ0IsZ0JBQTFCOztBQUVBLHFCQUFLelcsS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsRUFBc0MwRCxJQUF0QyxDQUEyQyxpQkFBM0MsRUFBOEQsSUFBOUQ7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7Ozs7OENBU3NCVixLLEVBQU87QUFDekIsaUJBQUswSyxRQUFMLENBQWM7QUFDVjRNLDBCQUFVdFgsTUFBTW9CLE1BQU4sQ0FBYUQ7QUFEYixhQUFkOztBQUlBLGlCQUFLNlYsZUFBTDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Z0RBU3dCaFgsSyxFQUFPO0FBQzNCLGlCQUFLMEssUUFBTCxDQUFjO0FBQ1ZGLDhCQUFjLElBREo7QUFFVjZSLDRCQUFZcmMsTUFBTW9CLE1BQU4sQ0FBYW1OLFlBQWIsQ0FBMEIsWUFBMUI7QUFGRixhQUFkOztBQUtBLGlCQUFLeUksZUFBTDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7cURBUzZCaFgsSyxFQUFPO0FBQ2hDLGlCQUFLMEssUUFBTCxDQUFjO0FBQ1ZGLDhCQUFjLElBREo7QUFFVjhNLDBCQUFVdFgsTUFBTW9CLE1BQU4sQ0FBYW1OLFlBQWIsQ0FBMEIsWUFBMUI7QUFGQSxhQUFkOztBQUtBLGlCQUFLeUksZUFBTDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Ozt3Q0FXZ0I7QUFDWixnQkFBSXFCLGFBQ0EsS0FBSy9RLEtBQUwsQ0FBV2dRLFFBQVgsS0FDSSxLQUFLaFEsS0FBTCxDQUFXZ1EsUUFBWCxLQUF3QixLQUFLaFEsS0FBTCxDQUFXK1AsV0FBWCxDQUF1QnBXLElBQS9DLElBQ0EsS0FBS3FHLEtBQUwsQ0FBVytVLFVBQVgsS0FBMEIsS0FBSy9VLEtBQUwsQ0FBVytQLFdBQVgsQ0FBdUJqVyxNQUZyRCxDQURKOztBQU1BLG1CQUFPaVgsVUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7OztzQ0FRYztBQUNWLGdCQUFJbmIsU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjtBQUNBLGdCQUFJd2dCLFlBQVksSUFBSXJnQixTQUFTaWdCLElBQWIsQ0FBa0JsZ0IsTUFBbEIsQ0FBaEI7QUFDQSxnQkFBSXdDLFlBQVl4QyxPQUFPcUMsWUFBUCxFQUFoQjtBQUNBLGdCQUFJa2UsWUFBWS9kLFVBQVVnZSxlQUFWLEVBQWhCOztBQUVBRixzQkFBVWhGLE1BQVYsQ0FBaUIsS0FBS2xSLEtBQUwsQ0FBV21HLE9BQTVCLEVBQXFDLEVBQUVrUSxTQUFTLElBQVgsRUFBckM7O0FBRUFqZSxzQkFBVWtlLGVBQVYsQ0FBMEJILFNBQTFCOztBQUVBO0FBQ0E7QUFDQSxpQkFBSzNXLEtBQUwsQ0FBV3dFLGVBQVg7O0FBRUFwTyxtQkFBT3dELElBQVAsQ0FBWSxpQkFBWixFQUErQixJQUEvQjtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs4Q0FRc0I0RyxLLEVBQU87QUFDekIsaUJBQUtvRCxRQUFMLENBQWM7QUFDVndRLHNDQUFzQjVULE1BQU04VDtBQURsQixhQUFkO0FBR0g7O0FBRUQ7Ozs7Ozs7Ozs7OztzQ0FTYztBQUNWLGdCQUFJbGUsU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjtBQUNBLGdCQUFJd2dCLFlBQVksSUFBSXJnQixTQUFTaWdCLElBQWIsQ0FBa0JsZ0IsTUFBbEIsRUFBMEIsRUFBQzJnQixnQkFBZ0IsS0FBSy9XLEtBQUwsQ0FBVytXLGNBQTVCLEVBQTFCLENBQWhCO0FBQ0EsZ0JBQUlDLFlBQVk7QUFDWjFjLHdCQUFRLEtBQUtrRyxLQUFMLENBQVcrVTtBQURQLGFBQWhCO0FBR0EsZ0JBQUkwQixrQkFBa0IsRUFBRUosU0FBUyxJQUFYLEVBQXRCOztBQUVBLGdCQUFJLEtBQUtyVyxLQUFMLENBQVdnUSxRQUFmLEVBQXlCO0FBQ3JCLG9CQUFJLEtBQUtoUSxLQUFMLENBQVdtRyxPQUFmLEVBQXdCO0FBQ3BCcVEsOEJBQVU3YyxJQUFWLEdBQWlCLEtBQUtxRyxLQUFMLENBQVdnUSxRQUE1Qjs7QUFFQWtHLDhCQUFVUSxNQUFWLENBQWlCRixTQUFqQixFQUE0QixLQUFLeFcsS0FBTCxDQUFXbUcsT0FBdkMsRUFBZ0RzUSxlQUFoRDtBQUNILGlCQUpELE1BSU87QUFDSFAsOEJBQVVTLE1BQVYsQ0FBaUIsS0FBSzNXLEtBQUwsQ0FBV2dRLFFBQTVCLEVBQXNDd0csU0FBdEMsRUFBaURDLGVBQWpEO0FBQ0g7O0FBRUQ3Z0IsdUJBQU93RCxJQUFQLENBQVksaUJBQVosRUFBK0IsSUFBL0I7QUFDSDs7QUFFRDtBQUNBO0FBQ0EsaUJBQUtvRyxLQUFMLENBQVd3RSxlQUFYO0FBQ0g7Ozs7RUF0V3dCLGdCQUFNc0gsUzs7QUF5V25DOzs7Ozs7Ozs7O0FBUUFrSixlQUFlalMsR0FBZixHQUFxQixVQUFyQjs7QUFFQTs7Ozs7Ozs7QUFRQWlTLGVBQWV2SixZQUFmLEdBQThCO0FBQzFCc0wsb0JBQWdCLElBRFU7QUFFMUJLLHFCQUFpQixFQUZTO0FBRzFCN1EsY0FBVSxJQUhnQjtBQUkxQjhRLHNCQUFrQixJQUpRO0FBSzFCaEIsdUJBQW1CLEVBTE87QUFNMUJuUCxpQkFBYSxxQkFOYTtBQU8xQi9LLFVBQU07QUFDRjhKLGlCQUFTLENBQUMsRUFBRCxDQURQO0FBRUZJLHFCQUFhLENBQUMsRUFBRCxDQUZYO0FBR0ZDLHFCQUFhLENBQUMsRUFBRCxDQUhYO0FBSUZFLGNBQU0sQ0FBQyxFQUFELENBSko7QUFLRkMsY0FBTSxDQUFDLEVBQUQ7QUFMSixLQVBvQjtBQWMxQjBQLHdCQUFvQjtBQWRNLENBQTlCOztrQkFpQmUsMkJBQ1gsOEJBQ0Esa0NBQ0luQixjQURKLENBREEsQ0FEVyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlaZjs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7O0lBTU1zQyxvQjs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUlsQyx5QkFBeUIsS0FBS3BWLEtBQUwsQ0FBV29WLHNCQUF4QztBQUNBLGdCQUFJbUMscUJBQXFCLEtBQUt2WCxLQUFMLENBQVdtVixjQUFwQzs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQUssV0FBVSxrR0FBZixFQUFrSCxVQUFTLEdBQTNIO0FBQ0k7QUFBQTtBQUFBLHNCQUFRLGlCQUFlLEtBQUtuVixLQUFMLENBQVcrRCxRQUFsQyxFQUE0QyxjQUFZLEtBQUsvRCxLQUFMLENBQVdzVixjQUFuRSxFQUFtRixXQUFVLG9CQUE3RixFQUFrSCxTQUFTLEtBQUt0VixLQUFMLENBQVdnRSxjQUFYLENBQTBCeE0sSUFBMUIsQ0FBK0IsSUFBL0IsQ0FBM0gsRUFBaUssTUFBSyxVQUF0SyxFQUFpTCxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUF0TSxFQUFnTixPQUFPLEtBQUtzRCxLQUFMLENBQVdzVixjQUFsTztBQUNJO0FBQUE7QUFBQSwwQkFBSyxXQUFVLGNBQWY7QUFDSTtBQUFBO0FBQUEsOEJBQU0sV0FBVSxxQ0FBaEI7QUFBdUQsaUNBQUt0VixLQUFMLENBQVdzVjtBQUFsRSx5QkFESjtBQUVJLGdFQUFNLFdBQVUsZUFBaEI7QUFGSjtBQURKLGlCQURKO0FBT0sscUJBQUt0VixLQUFMLENBQVcrRCxRQUFYLElBQ0csNERBQWtCLFFBQVEsS0FBSy9ELEtBQUwsQ0FBVzVKLE1BQXJDLEVBQTZDLFdBQVcsS0FBSzRKLEtBQUwsQ0FBV2dFLGNBQW5FLEVBQW1GLG9CQUFvQnVULGtCQUF2RyxFQUEySCx3QkFBd0JuQyxzQkFBbkosRUFBMkssZ0JBQWdCLEtBQUtwVixLQUFMLENBQVdzVixjQUF0TTtBQVJSLGFBREo7QUFhSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs4Q0FVc0IzUixTLEVBQVc7QUFDN0IsbUJBQU9BLFVBQVVJLFFBQVYsS0FBdUIsS0FBSy9ELEtBQUwsQ0FBVytELFFBQWxDLElBQThDSixVQUFVMlIsY0FBVixLQUE2QixLQUFLdFYsS0FBTCxDQUFXc1YsY0FBN0Y7QUFDSDs7OztFQXhDOEIsZ0JBQU14SixTOztBQTJDekM7Ozs7Ozs7Ozs7QUFRQXdMLHFCQUFxQnZVLEdBQXJCLEdBQTJCLGdCQUEzQjs7a0JBRWV1VSxvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7OztJQVlNRSxVOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7bUNBUVc7QUFDUCxtQkFBUSxJQUFJbmhCLFNBQVNpZ0IsSUFBYixDQUFrQixLQUFLdFcsS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBbEIsRUFBeURxZ0IsZ0JBQXpELE9BQWdGLElBQXhGO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUk1SyxXQUFXLGVBQWUsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxnQkFBSSxLQUFLNUwsS0FBTCxDQUFXeUUsZUFBZixFQUFnQztBQUM1QixvQkFBSXpFLFFBQVEsS0FBS3lYLG1CQUFMLEVBQVo7O0FBRUEsdUJBQ0ksd0RBQW9CelgsS0FBcEIsQ0FESjtBQUdILGFBTkQsTUFNTztBQUNILHVCQUNJO0FBQUE7QUFBQSxzQkFBUSxjQUFZdEksWUFBWW9HLE9BQVosQ0FBb0I3RCxJQUF4QyxFQUE4QyxXQUFXMFIsUUFBekQsRUFBbUUsYUFBVSxhQUE3RSxFQUEyRixTQUFTLEtBQUtpRyxpQkFBTCxDQUF1QnBhLElBQXZCLENBQTRCLElBQTVCLENBQXBHLEVBQXVJLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTVKLEVBQXNLLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQjdELElBQWpNO0FBQ0ksNERBQU0sV0FBVSxjQUFoQjtBQURKLGlCQURKO0FBS0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7NENBUW9CO0FBQ2hCLGlCQUFLK0YsS0FBTCxDQUFXMEUsZ0JBQVgsQ0FBNEI4UyxXQUFXelUsR0FBdkM7QUFDSDs7OztFQWpEb0IsZ0JBQU0rSSxTOztBQW9EL0I7Ozs7Ozs7Ozs7QUFRQTBMLFdBQVd6VSxHQUFYLEdBQWlCLE1BQWpCOztBQUVBOzs7Ozs7OztBQVFBeVUsV0FBVy9MLFlBQVgsR0FBMEI7QUFDdEI1SyxlQUFXO0FBQ1BRLFlBQUksbUJBREc7QUFFUGxGLGNBQU05RixTQUFTK0YsSUFBVCxHQUFnQixFQUZmLENBRWtCO0FBRmxCO0FBRFcsQ0FBMUI7O2tCQU9lLDJCQUNYLCtCQUNBLGtDQUNJb2IsVUFESixDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRmY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNRSxpQjs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUkvTCxXQUFXLGVBQWUsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQVEsY0FBWWxVLFlBQVlvRyxPQUFaLENBQW9CNlosWUFBeEMsRUFBc0QsZ0JBQWNoTSxTQUFTak8sT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBQXJHLEVBQXdHLFdBQVdpTyxRQUFuSCxFQUE2SCxhQUFVLFdBQXZJLEVBQW1KLFNBQVMsS0FBS2pMLFdBQUwsQ0FBaUJsSixJQUFqQixDQUFzQixJQUF0QixDQUE1SixFQUF5TCxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUE5TSxFQUF3TixPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0I2WixZQUFuUDtBQUNJLHdEQUFNLFdBQVUsdUJBQWhCO0FBREosYUFESjtBQUtIOzs7O0VBakIyQixnQkFBTTdMLFM7O0FBb0J0Qzs7Ozs7Ozs7OztBQVFBNEwsa0JBQWtCM1UsR0FBbEIsR0FBd0IsSUFBeEI7O0FBRUE7Ozs7Ozs7O0FBUUEyVSxrQkFBa0JqTSxZQUFsQixHQUFpQztBQUM3Qm5MLGFBQVMsY0FEb0I7QUFFN0IyQixXQUFPO0FBQ0gwRSxpQkFBUztBQUROO0FBRnNCLENBQWpDOztrQkFPZSw2QkFDWCxrQ0FDQSwyQkFDSStRLGlCQURKLENBREEsQ0FEVyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFEZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7O0lBUU1FLGtCOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSWpNLFdBQVcsZUFBZSxLQUFLQyxlQUFMLEVBQTlCOztBQUVBLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZbFUsWUFBWW9HLE9BQVosQ0FBb0IrWixPQUF4QyxFQUFpRCxnQkFBY2xNLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBaEcsRUFBbUcsV0FBV2lPLFFBQTlHLEVBQXdILGFBQVUsc0JBQWxJLEVBQXlKLFNBQVMsS0FBS2pMLFdBQUwsQ0FBaUJsSixJQUFqQixDQUFzQixJQUF0QixDQUFsSyxFQUErTCxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUFwTixFQUE4TixPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0IrWixPQUF6UDtBQUNJLHdEQUFNLFdBQVUsdUJBQWhCO0FBREosYUFESjtBQUtIOzs7O0VBakI0QixnQkFBTS9MLFM7O0FBb0J2Qzs7Ozs7Ozs7OztBQVFBOEwsbUJBQW1CN1UsR0FBbkIsR0FBeUIsY0FBekI7O0FBRUE7Ozs7Ozs7O0FBUUE2VSxtQkFBbUJuTSxZQUFuQixHQUFrQztBQUM5Qm5MLGFBQVM7QUFEcUIsQ0FBbEM7O2tCQUllLDZCQUNYLG1DQUNBLGtDQUNJc1gsa0JBREosQ0FEQSxDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkRmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFDQTs7Ozs7Ozs7SUFRTUUsd0I7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJbk0sV0FBVyxlQUFlLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFRLGNBQVlsVSxZQUFZb0csT0FBWixDQUFvQndVLFNBQXhDLEVBQW1ELGdCQUFjM0csU0FBU2pPLE9BQVQsQ0FBaUIsU0FBakIsTUFBZ0MsQ0FBQyxDQUFsRyxFQUFxRyxXQUFXaU8sUUFBaEgsRUFBMEgsYUFBVSw2QkFBcEksRUFBa0ssU0FBUyxLQUFLakwsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQTNLLEVBQXdNLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTdOLEVBQXVPLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQndVLFNBQWxRO0FBQ0ksd0RBQU0sV0FBVSxvQkFBaEI7QUFESixhQURKO0FBS0g7Ozs7RUFqQmtDLGdCQUFNeEcsUzs7QUFvQjdDOzs7Ozs7Ozs7O0FBUUFnTSx5QkFBeUIvVSxHQUF6QixHQUErQixlQUEvQjs7QUFFQTs7Ozs7Ozs7QUFRQStVLHlCQUF5QnJNLFlBQXpCLEdBQXdDO0FBQ3BDbkwsYUFBUztBQUQyQixDQUF4Qzs7a0JBSWUsNkJBQ1gsbUNBQ0Esa0NBQ0l3WCx3QkFESixDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUNBOzs7Ozs7OztJQVFNQyx5Qjs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUlwTSxXQUFXLGVBQWUsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQVEsY0FBWWxVLFlBQVlvRyxPQUFaLENBQW9CMFUsVUFBeEMsRUFBb0QsZ0JBQWM3RyxTQUFTak8sT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBQW5HLEVBQXNHLFdBQVdpTyxRQUFqSCxFQUEySCxhQUFVLDhCQUFySSxFQUFvSyxTQUFTLEtBQUtqTCxXQUFMLENBQWlCbEosSUFBakIsQ0FBc0IsSUFBdEIsQ0FBN0ssRUFBME0sVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBL04sRUFBeU8sT0FBT2hGLFlBQVlvRyxPQUFaLENBQW9CMFUsVUFBcFE7QUFDSSx3REFBTSxXQUFVLHFCQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCbUMsZ0JBQU0xRyxTOztBQW9COUM7Ozs7Ozs7Ozs7QUFRQWlNLDBCQUEwQmhWLEdBQTFCLEdBQWdDLGdCQUFoQzs7QUFFQTs7Ozs7Ozs7QUFRQWdWLDBCQUEwQnRNLFlBQTFCLEdBQXlDO0FBQ3JDbkwsYUFBUztBQUQ0QixDQUF6Qzs7a0JBSWUsNkJBQ1gsbUNBQ0Esa0NBQ0l5WCx5QkFESixDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNQyxxQjs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUlyTSxXQUFXLGVBQWUsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQVEsY0FBWWxVLFlBQVlvRyxPQUFaLENBQW9Cc1UsV0FBeEMsRUFBcUQsZ0JBQWN6RyxTQUFTak8sT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBQXBHLEVBQXVHLFdBQVdpTyxRQUFsSCxFQUE0SCxhQUFVLHlCQUF0SSxFQUFnSyxTQUFTLEtBQUtqTCxXQUFMLENBQWlCbEosSUFBakIsQ0FBc0IsSUFBdEIsQ0FBekssRUFBc00sVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBM04sRUFBcU8sT0FBT2hGLFlBQVlvRyxPQUFaLENBQW9Cc1UsV0FBaFE7QUFDSSx3REFBTSxXQUFVLHNCQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCK0IsZ0JBQU10RyxTOztBQW9CMUM7Ozs7Ozs7Ozs7QUFRQWtNLHNCQUFzQmpWLEdBQXRCLEdBQTRCLGlCQUE1Qjs7QUFFQTs7Ozs7Ozs7QUFRQWlWLHNCQUFzQnZNLFlBQXRCLEdBQXFDO0FBQ2pDbkwsYUFBUztBQUR3QixDQUFyQzs7a0JBSWUsNkJBQ1gsbUNBQ0Esa0NBQ0kwWCxxQkFESixDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNQyxzQjs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUl0TSxXQUFXLGVBQWUsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQVEsY0FBWWxVLFlBQVlvRyxPQUFaLENBQW9Cb2EsWUFBeEMsRUFBc0QsZ0JBQWN2TSxTQUFTak8sT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBQXJHLEVBQXdHLFdBQVdpTyxRQUFuSCxFQUE2SCxhQUFVLDBCQUF2SSxFQUFrSyxTQUFTLEtBQUtqTCxXQUFMLENBQWlCbEosSUFBakIsQ0FBc0IsSUFBdEIsQ0FBM0ssRUFBd00sVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBN04sRUFBdU8sT0FBT2hGLFlBQVlvRyxPQUFaLENBQW9Cb2EsWUFBbFE7QUFDSSx3REFBTSxXQUFVLHlCQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCZ0MsZ0JBQU1wTSxTOztBQW9CM0M7Ozs7Ozs7Ozs7QUFRQW1NLHVCQUF1QmxWLEdBQXZCLEdBQTZCLGtCQUE3Qjs7QUFFQTs7Ozs7Ozs7QUFRQWtWLHVCQUF1QnhNLFlBQXZCLEdBQXNDO0FBQ2xDbkwsYUFBUztBQUR5QixDQUF0Qzs7a0JBSWUsNkJBQ1gsbUNBQ0Esa0NBQ0kyWCxzQkFESixDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNRSxXOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSXhNLFdBQVcsZUFBZSxLQUFLQyxlQUFMLEVBQTlCOztBQUVBLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZbFUsWUFBWW9HLE9BQVosQ0FBb0JzYSxLQUF4QyxFQUErQyxnQkFBY3pNLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBOUYsRUFBaUcsV0FBV2lPLFFBQTVHLEVBQXNILGFBQVUsY0FBaEksRUFBK0ksU0FBUyxLQUFLakwsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQXhKLEVBQXFMLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTFNLEVBQW9OLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQnNhLEtBQS9PO0FBQ0ksd0RBQU0sV0FBVSxlQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCcUIsZ0JBQU10TSxTOztBQW9CaEM7Ozs7Ozs7Ozs7QUFRQXFNLFlBQVlwVixHQUFaLEdBQWtCLE9BQWxCOztBQUVBOzs7Ozs7OztBQVFBb1YsWUFBWTFNLFlBQVosR0FBMkI7QUFDdkJuTCxhQUFTLFlBRGM7QUFFdkIyQixXQUFPO0FBQ0gwRSxpQkFBUztBQUROO0FBRmdCLENBQTNCOztrQkFPZSw2QkFDWCxrQ0FDQSwyQkFDSXdSLFdBREosQ0FEQSxDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURmOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7SUFNTUUsa0I7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZM2dCLFlBQVlvRyxPQUFaLENBQW9Cd2EsWUFBeEMsRUFBc0QsV0FBVSxXQUFoRSxFQUE0RSxhQUFVLHFCQUF0RixFQUE0RyxTQUFTLEtBQUs1WCxXQUFMLENBQWlCbEosSUFBakIsQ0FBc0IsSUFBdEIsQ0FBckgsRUFBa0osVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBdkssRUFBaUwsT0FBT2hGLFlBQVlvRyxPQUFaLENBQW9Cd2EsWUFBNU07QUFDSSx3REFBTSxXQUFVLHNCQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWY0QixnQkFBTXhNLFM7O0FBa0J2Qzs7Ozs7Ozs7OztBQVFBdU0sbUJBQW1CdFYsR0FBbkIsR0FBeUIsY0FBekI7O0FBRUE7Ozs7Ozs7O0FBUUFzVixtQkFBbUI1TSxZQUFuQixHQUFrQztBQUM5Qm5MLGFBQVM7QUFEcUIsQ0FBbEM7O2tCQUllLDZCQUNYK1gsa0JBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNRSxZOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7OztpQ0FPUztBQUNMLGdCQUFJNU0sV0FBVyxlQUFlLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFRLGNBQVlsVSxZQUFZb0csT0FBWixDQUFvQjBhLE1BQXhDLEVBQWdELGdCQUFjN00sU0FBU2pPLE9BQVQsQ0FBaUIsU0FBakIsTUFBZ0MsQ0FBQyxDQUEvRixFQUFrRyxXQUFXaU8sUUFBN0csRUFBdUgsYUFBVSxlQUFqSSxFQUFpSixTQUFTLEtBQUtqTCxXQUFMLENBQWlCbEosSUFBakIsQ0FBc0IsSUFBdEIsQ0FBMUosRUFBdUwsVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBNU0sRUFBc04sT0FBT2hGLFlBQVlvRyxPQUFaLENBQW9CMGEsTUFBalA7QUFDSSx3REFBTSxXQUFVLGdCQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWhCc0IsZ0JBQU0xTSxTOztBQW1CakM7Ozs7Ozs7Ozs7QUFRQXlNLGFBQWF4VixHQUFiLEdBQW1CLFFBQW5COztBQUVBOzs7Ozs7OztBQVFBd1YsYUFBYTlNLFlBQWIsR0FBNEI7QUFDeEJuTCxhQUFTLFFBRGU7QUFFeEIyQixXQUFPO0FBRmlCLENBQTVCOztrQkFLZSw2QkFDWCxrQ0FDQSwyQkFDSXNXLFlBREosQ0FEQSxDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkRmOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLTUUsdUI7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJLEtBQUt6WSxLQUFMLENBQVdyRCxNQUFYLElBQXFCLEtBQUtxRCxLQUFMLENBQVdyRCxNQUFYLENBQWtCVyxNQUEzQyxFQUFtRDtBQUMvQyx1QkFDSTtBQUFBO0FBQUEsc0JBQU0sV0FBVSxnQkFBaEI7QUFBa0MseUJBQUswQyxLQUFMLENBQVdlO0FBQTdDLGlCQURKO0FBR0gsYUFKRCxNQUlPO0FBQ0gsdUJBQU8sSUFBUDtBQUNIO0FBQ0o7Ozs7RUFqQmlDLGdCQUFNK0ssUzs7a0JBb0I3QjJNLHVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCZjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7OztJQU1NQywwQjs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsbUJBQ0k7QUFBQTtBQUFBLGtCQUFJLE1BQUssUUFBVDtBQUNJO0FBQUE7QUFBQSxzQkFBUSxXQUFVLG9CQUFsQixFQUF1QyxTQUFTLEtBQUtDLGFBQUwsQ0FBbUJuaEIsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBaEQsRUFBK0UsVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBcEc7QUFBK0doRixnQ0FBWW9HLE9BQVosQ0FBb0I4YTtBQUFuSTtBQURKLGFBREo7QUFLSDs7QUFFRDs7Ozs7Ozs7Ozs7d0NBUWdCO0FBQ1osZ0JBQUl4aUIsU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjs7QUFFQUUsbUJBQU9zSyxXQUFQLENBQW1CLGNBQW5COztBQUVBLGlCQUFLVixLQUFMLENBQVc2WSxZQUFYLENBQXdCdFIsT0FBeEIsQ0FBZ0MsVUFBU3VSLFNBQVQsRUFBb0I7QUFDaEQsb0JBQUlDLGFBQWEsSUFBSTFpQixTQUFTNEwsS0FBYixDQUFtQixFQUFDMEUsU0FBU21TLFNBQVYsRUFBbkIsQ0FBakI7O0FBRUExaUIsdUJBQU84SixXQUFQLENBQW1CNlksVUFBbkI7QUFDSCxhQUpEOztBQU1BM2lCLG1CQUFPd0QsSUFBUCxDQUFZLGlCQUFaLEVBQStCLElBQS9CO0FBQ0g7Ozs7RUFyQ29DLGdCQUFNa1MsUzs7QUF3Qy9DOzs7Ozs7Ozs7O0FBUUE0TSwyQkFBMkIzVixHQUEzQixHQUFpQyw0QkFBakM7O0FBRUE7Ozs7Ozs7O0FBUUEyViwyQkFBMkJqTixZQUEzQixHQUEwQztBQUN0Q29OLGtCQUFjLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLEtBQXJDO0FBRHdCLENBQTFDOztrQkFJZUgsMEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEVmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7O0lBUU1NLG9COzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs2Q0FPcUI7QUFDakI7QUFDQTtBQUNBLGdCQUFJQyxXQUFXO0FBQ1h0Uyx5QkFBUyxNQURFO0FBRVhoSyx3QkFBUTtBQUNKdWMsNEJBQVE7QUFESjtBQUZHLGFBQWY7O0FBT0FELHVCQUFXNWlCLFNBQVN3TCxLQUFULENBQWVDLEtBQWYsQ0FBcUJtWCxRQUFyQixFQUErQixLQUFLalosS0FBTCxDQUFXaUMsS0FBMUMsQ0FBWDs7QUFFQSxpQkFBS2tYLFFBQUwsR0FBZ0IsSUFBSTlpQixTQUFTNEwsS0FBYixDQUFtQmdYLFFBQW5CLEVBQTZCRyxZQUE3QixDQUEwQyxLQUFLcFosS0FBTCxDQUFXZSxJQUFyRCxDQUFoQjtBQUNIOztBQUVEOzs7Ozs7Ozs7OztpQ0FRUztBQUNMO0FBQ0E7QUFDQSxnQkFBSWxHLFlBQVksS0FBS21GLEtBQUwsQ0FBV2UsSUFBWCxLQUFvQixLQUFLZixLQUFMLENBQVdxWixXQUEvQixHQUE2QywyQkFBN0MsR0FBMkUsb0JBQTNGOztBQUVBLG1CQUNJLDBDQUFRLFdBQVd4ZSxTQUFuQixFQUE4Qix5QkFBeUIsRUFBQ3llLFFBQVEsS0FBS0gsUUFBZCxFQUF2RCxFQUFnRixTQUFTLEtBQUtJLFFBQUwsQ0FBYy9oQixJQUFkLENBQW1CLElBQW5CLENBQXpGLEVBQW1ILFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQXhJLEdBREo7QUFHSDs7QUFFRDs7Ozs7Ozs7Ozs7bUNBUVc7QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBS3NELEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLEVBQXNDd0ssV0FBdEMsQ0FBa0QsY0FBbEQ7O0FBRUEsaUJBQUtQLFVBQUw7QUFDSDs7OztFQXhEOEIsZ0JBQU0yTCxTOztBQTJEekM7Ozs7Ozs7Ozs7QUFRQWtOLHFCQUFxQmpXLEdBQXJCLEdBQTJCLHNCQUEzQjs7a0JBRWUsaUNBQ1gsMkJBQ0lpVyxvQkFESixDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakZmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7OztJQU9NUSxnQjs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7Ozs0Q0FTb0I7QUFDaEIsK0JBQVNyVixXQUFULENBQXFCLElBQXJCLEVBQTJCQyxLQUEzQjtBQUNIOztBQUVEOzs7Ozs7Ozs7OzZDQU9xQjtBQUNqQixnQkFBSXFWLGNBQWMsRUFBbEI7QUFDQSxnQkFBSUMsZUFBZSxFQUFuQjtBQUNBLGdCQUFJQyxlQUFlLEVBQW5COztBQUVBLGlCQUFLM1osS0FBTCxDQUFXckQsTUFBWCxDQUFrQjRLLE9BQWxCLENBQTBCLFVBQVNoRCxJQUFULEVBQWU7QUFDckMsb0JBQUl0QyxRQUFRLElBQUk1TCxTQUFTNEwsS0FBYixDQUFtQnNDLEtBQUt0QyxLQUF4QixDQUFaOztBQUVBLG9CQUFJQSxNQUFNMEQsSUFBTixLQUFldFAsU0FBU3VqQixXQUE1QixFQUF5QztBQUNyQ0gsZ0NBQVkvWixJQUFaLENBQWlCNkUsSUFBakI7QUFDSCxpQkFGRCxNQUVPLElBQUl0QyxNQUFNMEQsSUFBTixLQUFldFAsU0FBU3dqQixZQUE1QixFQUEwQztBQUM3Q0gsaUNBQWFoYSxJQUFiLENBQWtCNkUsSUFBbEI7QUFDSCxpQkFGTSxNQUVBLElBQUl0QyxNQUFNMEQsSUFBTixLQUFldFAsU0FBU3lqQixZQUE1QixFQUEwQztBQUM3Q0gsaUNBQWFqYSxJQUFiLENBQWtCNkUsSUFBbEI7QUFDSDtBQUNKLGFBVkQ7O0FBWUEsaUJBQUt3VixZQUFMLEdBQW9CTixXQUFwQjtBQUNBLGlCQUFLTyxhQUFMLEdBQXFCTixZQUFyQjtBQUNBLGlCQUFLTyxhQUFMLEdBQXFCTixZQUFyQjtBQUNIOztBQUVEOzs7Ozs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJTyxnQkFBSjs7QUFFQSxnQkFBSSxLQUFLbGEsS0FBTCxDQUFXbWEsb0JBQWYsRUFBcUM7QUFDakNELG1DQUFtQixzRUFBNEIsUUFBUSxLQUFLbGEsS0FBTCxDQUFXNUosTUFBL0MsRUFBdUQsV0FBVyxLQUFLNEosS0FBTCxDQUFXZ0UsY0FBN0UsR0FBbkI7QUFDSDs7QUFFRCxtQkFDSTtBQUFBO0FBQW9CLHFCQUFLaEUsS0FBekI7QUFDS2thLGdDQURMO0FBR0ksa0ZBQXlCLE1BQU14aUIsWUFBWW9HLE9BQVosQ0FBb0IyYixXQUFuRCxFQUFnRSxRQUFRLEtBQUtNLFlBQTdFLEdBSEo7QUFJSyxxQkFBS0ssa0JBQUwsQ0FBd0IsS0FBS0wsWUFBN0IsQ0FKTDtBQU1JLGtGQUF5QixNQUFNcmlCLFlBQVlvRyxPQUFaLENBQW9CNGIsWUFBbkQsRUFBaUUsUUFBUSxLQUFLTSxhQUE5RSxHQU5KO0FBT0sscUJBQUtJLGtCQUFMLENBQXdCLEtBQUtKLGFBQTdCLENBUEw7QUFTSSxrRkFBeUIsTUFBTXRpQixZQUFZb0csT0FBWixDQUFvQjZiLFlBQW5ELEVBQWlFLFFBQVEsS0FBS00sYUFBOUUsR0FUSjtBQVVLLHFCQUFLRyxrQkFBTCxDQUF3QixLQUFLSCxhQUE3QjtBQVZMLGFBREo7QUFjSDs7QUFFRDs7Ozs7Ozs7Ozs7OzsyQ0FVbUJ0ZCxNLEVBQVE7QUFDdkIsZ0JBQUl2RyxTQUFTLEtBQUs0SixLQUFMLENBQVc1SixNQUF4QjtBQUNBLGdCQUFJa08sS0FBSjs7QUFFQSxnQkFBSTNILFVBQVVBLE9BQU9XLE1BQXJCLEVBQTZCO0FBQ3pCZ0gsd0JBQVEzSCxPQUFPbUcsR0FBUCxDQUFXLFVBQVN5QixJQUFULEVBQWU7QUFDOUIsMkJBQ0k7QUFBQTtBQUFBLDBCQUFJLEtBQUtBLEtBQUt4RCxJQUFkLEVBQW9CLE1BQUssUUFBekI7QUFDSSx3RkFBc0IsYUFBYSxLQUFLZixLQUFMLENBQVdxWixXQUE5QyxFQUEyRCxRQUFRampCLE1BQW5FLEVBQTJFLE1BQU1tTyxLQUFLeEQsSUFBdEYsRUFBNEYsT0FBT3dELEtBQUt0QyxLQUF4RztBQURKLHFCQURKO0FBS0gsaUJBTmtCLENBTWpCekssSUFOaUIsQ0FNWixJQU5ZLENBQVgsQ0FBUjtBQU9IOztBQUVELG1CQUFPOE0sS0FBUDtBQUNIOzs7O0VBbkcwQixnQkFBTXdILFM7O0FBc0dyQzs7Ozs7Ozs7OztBQVFBME4saUJBQWlCelcsR0FBakIsR0FBdUIsa0JBQXZCOztBQUVBOzs7Ozs7OztBQVFBeVcsaUJBQWlCL04sWUFBakIsR0FBZ0M7QUFDNUJsRixjQUFVLEtBRGtCO0FBRTVCVyxpQkFBYSxxQkFGZTtBQUc1Qi9LLFVBQU07QUFDRjhKLGlCQUFTLENBQUMsRUFBRCxDQURQO0FBRUZJLHFCQUFhLENBQUMsRUFBRCxDQUZYO0FBR0ZDLHFCQUFhLENBQUMsRUFBRCxDQUhYO0FBSUZFLGNBQU0sQ0FBQyxFQUFELENBSko7QUFLRkMsY0FBTSxDQUFDLEVBQUQ7QUFMSixLQUhzQjtBQVU1QjBULDBCQUFzQjtBQVZNLENBQWhDOztrQkFhZSxrQ0FDWFgsZ0JBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSmY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7SUFPTWEsWTs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUloQixjQUFjM2hCLFlBQVlvRyxPQUFaLENBQW9COGEsTUFBdEM7O0FBRUEsZ0JBQUlqYyxTQUFTLEtBQUsyZCxVQUFMLEVBQWI7O0FBRUEzZCxtQkFBTzRLLE9BQVAsQ0FBZSxVQUFTaEQsSUFBVCxFQUFlO0FBQzFCLG9CQUFJLEtBQUtnVyxZQUFMLENBQWtCaFcsS0FBS3RDLEtBQXZCLENBQUosRUFBbUM7QUFDL0JvWCxrQ0FBYzlVLEtBQUt4RCxJQUFuQjtBQUNIO0FBQ0osYUFKYyxDQUlidkosSUFKYSxDQUlSLElBSlEsQ0FBZjs7QUFNQSxnQkFBSWdqQixnQkFBSjs7QUFFQSxnQkFBSSxLQUFLeGEsS0FBTCxDQUFXK0QsUUFBZixFQUF5QjtBQUNyQnlXLG1DQUFtQiw0REFBa0IsYUFBYW5CLFdBQS9CLEVBQTRDLFFBQVEsS0FBS3JaLEtBQUwsQ0FBVzVKLE1BQS9ELEVBQXVFLFdBQVcsS0FBSzRKLEtBQUwsQ0FBV2dFLGNBQTdGLEVBQTZHLHNCQUFzQixLQUFLaEUsS0FBTCxDQUFXbWEsb0JBQTlJLEVBQW9LLFFBQVF4ZCxNQUE1SyxHQUFuQjtBQUNIOztBQUVELG1CQUNJO0FBQUE7QUFBQSxrQkFBSyxXQUFVLHVDQUFmO0FBQ0k7QUFBQTtBQUFBLHNCQUFRLGlCQUFlLEtBQUtxRCxLQUFMLENBQVcrRCxRQUFsQyxFQUE0QyxjQUFZck0sWUFBWW9HLE9BQVosQ0FBb0JuQixNQUFwQixHQUE2QixHQUE3QixHQUFtQzBjLFdBQTNGLEVBQXdHLFdBQVUsb0JBQWxILEVBQXVJLFNBQVMsS0FBS3JaLEtBQUwsQ0FBV2dFLGNBQVgsQ0FBMEJ4TSxJQUExQixDQUErQixJQUEvQixDQUFoSixFQUFzTCxNQUFLLFVBQTNMLEVBQXNNLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTNOLEVBQXFPLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQm5CLE1BQXBCLEdBQTZCLEdBQTdCLEdBQW1DMGMsV0FBL1E7QUFDSTtBQUFBO0FBQUEsMEJBQUssV0FBVSxjQUFmO0FBQ0k7QUFBQTtBQUFBLDhCQUFNLFdBQVUscUNBQWhCO0FBQXVEQTtBQUF2RCx5QkFESjtBQUVJLGdFQUFNLFdBQVUsZUFBaEI7QUFGSjtBQURKLGlCQURKO0FBT0ttQjtBQVBMLGFBREo7QUFXSDs7QUFFRDs7Ozs7Ozs7Ozs7OztxQ0FVYUMsVyxFQUFhO0FBQ3RCLGdCQUFJdGlCLGVBQWUsS0FBSzZILEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQW5COztBQUVBO0FBQ0E7QUFDQXVrQiwwQkFBY3BrQixTQUFTd0wsS0FBVCxDQUFlQyxLQUFmLENBQXFCLEVBQUM2RSxTQUFTLE1BQVYsRUFBckIsRUFBd0M4VCxXQUF4QyxDQUFkOztBQUVBLGdCQUFJeFksUUFBUSxJQUFJNUwsU0FBUzRMLEtBQWIsQ0FBbUJ3WSxXQUFuQixDQUFaOztBQUVBLG1CQUFPeFksTUFBTU0sV0FBTixDQUFrQnBLLGFBQWE0QixXQUFiLEVBQWxCLEVBQThDNUIsWUFBOUMsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7cUNBWWE7QUFDVCxtQkFBTyxLQUFLNkgsS0FBTCxDQUFXckQsTUFBWCxJQUFxQixDQUN4QjtBQUNJb0Usc0JBQU1ySixZQUFZb0csT0FBWixDQUFvQmdVLEVBRDlCO0FBRUk3UCx1QkFBTztBQUNIMEUsNkJBQVM7QUFETjtBQUZYLGFBRHdCLEVBT3hCO0FBQ0k1RixzQkFBTXJKLFlBQVlvRyxPQUFaLENBQW9Ca1UsRUFEOUI7QUFFSS9QLHVCQUFPO0FBQ0gwRSw2QkFBUztBQUROO0FBRlgsYUFQd0IsRUFheEI7QUFDSTVGLHNCQUFNckosWUFBWW9HLE9BQVosQ0FBb0I0YyxTQUQ5QjtBQUVJelksdUJBQU87QUFDSDBFLDZCQUFTO0FBRE47QUFGWCxhQWJ3QixFQW1CeEI7QUFDSTVGLHNCQUFNckosWUFBWW9HLE9BQVosQ0FBb0I2YyxJQUQ5QjtBQUVJMVksdUJBQU87QUFDSDBFLDZCQUFTO0FBRE47QUFGWCxhQW5Cd0IsRUF5QnhCO0FBQ0k1RixzQkFBTXJKLFlBQVlvRyxPQUFaLENBQW9CaVIsSUFEOUI7QUFFSTlNLHVCQUFPO0FBQ0gwRSw2QkFBUztBQUROO0FBRlgsYUF6QndCLENBQTVCO0FBZ0NIOzs7O0VBMUdzQixnQkFBTW1GLFM7O0FBNkdqQzs7Ozs7Ozs7OztBQVFBdU8sYUFBYXRYLEdBQWIsR0FBbUIsUUFBbkI7O2tCQUVlc1gsWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqSWY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQVFNTyxlOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSWpQLFdBQVcsZUFBZSxLQUFLQyxlQUFMLEVBQTlCOztBQUVBLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZbFUsWUFBWW9HLE9BQVosQ0FBb0IrYyxTQUF4QyxFQUFtRCxnQkFBY2xQLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBbEcsRUFBcUcsV0FBV2lPLFFBQWhILEVBQTBILGFBQVUsa0JBQXBJLEVBQXVKLFNBQVMsS0FBS2pMLFdBQUwsQ0FBaUJsSixJQUFqQixDQUFzQixJQUF0QixDQUFoSyxFQUE2TCxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUFsTixFQUE0TixPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0IrYyxTQUF2UDtBQUNJLHdEQUFNLFdBQVUsbUJBQWhCO0FBREosYUFESjtBQUtIOzs7O0VBakJ5QixnQkFBTS9PLFM7O0FBb0JwQzs7Ozs7Ozs7OztBQVFBOE8sZ0JBQWdCN1gsR0FBaEIsR0FBc0IsV0FBdEI7O0FBRUE7Ozs7Ozs7O0FBUUE2WCxnQkFBZ0JuUCxZQUFoQixHQUErQjtBQUMzQm5MLGFBQVMsV0FEa0I7QUFFM0IyQixXQUFPO0FBRm9CLENBQS9COztrQkFLZSw2QkFDWCxrQ0FDQSwyQkFDSTJZLGVBREosQ0FEQSxDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeERmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7SUFRTUUsaUI7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJblAsV0FBVyxlQUFlLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFRLGNBQVlsVSxZQUFZb0csT0FBWixDQUFvQmlkLFdBQXhDLEVBQXFELGdCQUFjcFAsU0FBU2pPLE9BQVQsQ0FBaUIsU0FBakIsTUFBZ0MsQ0FBQyxDQUFwRyxFQUF1RyxXQUFXaU8sUUFBbEgsRUFBNEgsYUFBVSxvQkFBdEksRUFBMkosU0FBUyxLQUFLakwsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQXBLLEVBQWlNLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQXROLEVBQWdPLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQmlkLFdBQTNQO0FBQ0ksd0RBQU0sV0FBVSxxQkFBaEI7QUFESixhQURKO0FBS0g7Ozs7RUFqQjJCLGdCQUFNalAsUzs7QUFvQnRDOzs7Ozs7Ozs7O0FBUUFnUCxrQkFBa0IvWCxHQUFsQixHQUF3QixhQUF4Qjs7QUFFQTs7Ozs7Ozs7QUFRQStYLGtCQUFrQnJQLFlBQWxCLEdBQWlDO0FBQzdCbkwsYUFBUyxhQURvQjtBQUU3QjJCLFdBQU87QUFGc0IsQ0FBakM7O2tCQUtlLDZCQUNYLGtDQUNBLDJCQUNJNlksaUJBREosQ0FEQSxDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeERmOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7OztJQUtNRSxlOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSUMsa0JBQUo7QUFDQSxnQkFBSUMsb0JBQUo7O0FBRUEsZ0JBQUksS0FBS2xiLEtBQUwsQ0FBVytELFFBQWYsRUFBeUI7QUFDckJtWCx1Q0FBdUJGLGdCQUFnQmpZLEdBQWhCLEdBQXNCLE1BQTdDO0FBQ0FrWSxxQ0FBcUIsOERBQW9CLFVBQVUsS0FBS0UsWUFBTCxFQUE5QixFQUFtRCxRQUFRLEtBQUtuYixLQUFMLENBQVc1SixNQUF0RSxFQUE4RSxRQUFROGtCLG9CQUF0RixFQUE0RyxXQUFXLEtBQUtsYixLQUFMLENBQVdnRSxjQUFsSSxHQUFyQjtBQUNIOztBQUVELG1CQUNJO0FBQUE7QUFBQSxrQkFBSyxXQUFVLDhCQUFmO0FBQ0k7QUFBQTtBQUFBLHNCQUFRLGlCQUFlLEtBQUtoRSxLQUFMLENBQVcrRCxRQUFsQyxFQUE0QyxjQUFZck0sWUFBWW9HLE9BQVosQ0FBb0JzZCxJQUE1RSxFQUFrRixhQUFXRixvQkFBN0YsRUFBbUgsV0FBVSxXQUE3SCxFQUF5SSxTQUFTLEtBQUtsYixLQUFMLENBQVdnRSxjQUFYLENBQTBCeE0sSUFBMUIsQ0FBK0IsSUFBL0IsQ0FBbEosRUFBd0wsVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBN00sRUFBdU4sT0FBT2hGLFlBQVlvRyxPQUFaLENBQW9Cc2QsSUFBbFA7QUFDSSw0REFBTSxXQUFVLGNBQWhCO0FBREosaUJBREo7QUFJS0g7QUFKTCxhQURKO0FBUUg7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7dUNBVWU7QUFDWCxtQkFBTyxLQUFLamIsS0FBTCxDQUFXd1AsUUFBWCxJQUF1QixDQUMxQjtBQUNJbFAseUJBQVMsa0JBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0J1ZDtBQUYvQixhQUQwQixFQUsxQjtBQUNJL2EseUJBQVMsaUJBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0J3ZDtBQUYvQixhQUwwQixFQVMxQjtBQUNJaGIseUJBQVMsWUFEYjtBQUVJcU8sdUJBQU9qWCxZQUFZb0csT0FBWixDQUFvQnlkO0FBRi9CLGFBVDBCLEVBYTFCO0FBQ0lqYix5QkFBUyxXQURiO0FBRUlxTyx1QkFBT2pYLFlBQVlvRyxPQUFaLENBQW9CMGQ7QUFGL0IsYUFiMEIsRUFpQjFCO0FBQ0lsYix5QkFBUyxlQURiO0FBRUlxTyx1QkFBT2pYLFlBQVlvRyxPQUFaLENBQW9CMmQ7QUFGL0IsYUFqQjBCLEVBcUIxQjtBQUNJbmIseUJBQVMsZ0JBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0I0ZDtBQUYvQixhQXJCMEIsRUF5QjFCO0FBQ0lwYix5QkFBUyxxQkFEYjtBQUVJcU8sdUJBQU9qWCxZQUFZb0csT0FBWixDQUFvQjZkO0FBRi9CLGFBekIwQixFQTZCMUI7QUFDSXJiLHlCQUFTLG1CQURiO0FBRUlxTyx1QkFBT2pYLFlBQVlvRyxPQUFaLENBQW9COGQ7QUFGL0IsYUE3QjBCLENBQTlCO0FBa0NIOzs7O0VBekV5QixnQkFBTTlQLFM7O0FBNEVwQzs7Ozs7Ozs7OztBQVFBa1AsZ0JBQWdCalksR0FBaEIsR0FBc0IsV0FBdEI7O2tCQUVlaVksZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5RmY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0lBS01hLGlCOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSVosa0JBQUosRUFDSUMsb0JBREo7O0FBR0EsZ0JBQUksS0FBS2xiLEtBQUwsQ0FBVytELFFBQWYsRUFBeUI7QUFDckJtWCx1Q0FBdUJXLGtCQUFrQjlZLEdBQWxCLEdBQXdCLE1BQS9DO0FBQ0FrWSxxQ0FBcUIsOERBQW9CLFVBQVUsS0FBS0UsWUFBTCxFQUE5QixFQUFtRCxRQUFRLEtBQUtuYixLQUFMLENBQVc1SixNQUF0RSxFQUE4RSxRQUFROGtCLG9CQUF0RixFQUE0RyxXQUFXLEtBQUtsYixLQUFMLENBQVdnRSxjQUFsSSxHQUFyQjtBQUNIOztBQUVELG1CQUNJO0FBQUE7QUFBQSxrQkFBSyxXQUFVLDhCQUFmO0FBQ0k7QUFBQTtBQUFBLHNCQUFRLGlCQUFlLEtBQUtoRSxLQUFMLENBQVcrRCxRQUFsQyxFQUE0QyxjQUFZck0sWUFBWW9HLE9BQVosQ0FBb0JnZSxNQUE1RSxFQUFvRixhQUFXWixvQkFBL0YsRUFBcUgsV0FBVSxXQUEvSCxFQUEySSxTQUFTLEtBQUtsYixLQUFMLENBQVdnRSxjQUFYLENBQTBCeE0sSUFBMUIsQ0FBK0IsSUFBL0IsQ0FBcEosRUFBMEwsTUFBSyxTQUEvTCxFQUF5TSxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUE5TixFQUF3TyxPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0JnZSxNQUFuUTtBQUNJLDREQUFNLFdBQVUsZ0JBQWhCO0FBREosaUJBREo7QUFJS2I7QUFKTCxhQURKO0FBUUg7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7dUNBVWU7QUFDWCxtQkFBTyxLQUFLamIsS0FBTCxDQUFXd1AsUUFBWCxJQUF1QixDQUMxQjtBQUNJbFAseUJBQVMsb0JBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0JpZTtBQUYvQixhQUQwQixFQUsxQjtBQUNJemIseUJBQVMsbUJBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0JrZTtBQUYvQixhQUwwQixFQVMxQjtBQUNJMWIseUJBQVMsY0FEYjtBQUVJcU8sdUJBQU9qWCxZQUFZb0csT0FBWixDQUFvQm1lO0FBRi9CLGFBVDBCLENBQTlCO0FBY0g7Ozs7RUFyRDJCLGdCQUFNblEsUzs7QUF3RHRDOzs7Ozs7Ozs7O0FBUUErUCxrQkFBa0I5WSxHQUFsQixHQUF3QixhQUF4Qjs7a0JBRWU4WSxpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRWY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBSWxNLFlBQVksRUFBaEI7QUFDQSxJQUFJQyxVQUFVLEVBQWQ7O0FBRUE7Ozs7Ozs7SUFNTXNNLGU7OztBQUNGOzs7Ozs7O0FBT0EsNkJBQVlsYyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsc0lBQ1RBLEtBRFM7O0FBR2YsY0FBS21jLE9BQUwsR0FBZSxnQkFBTXBNLFNBQU4sRUFBZjtBQUNBLGNBQUtxTSxPQUFMLEdBQWUsZ0JBQU1yTSxTQUFOLEVBQWY7QUFDQSxjQUFLdlAsS0FBTCxHQUFhO0FBQ1Q2YixrQkFBTSxDQURHO0FBRVRDLGtCQUFNO0FBRkcsU0FBYjtBQUxlO0FBU2xCOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs0Q0FVb0I7QUFDaEIsaUJBQUtILE9BQUwsQ0FBYTdLLE9BQWIsQ0FBcUJsTixLQUFyQjtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozt1Q0FRZTtBQUNYLGdCQUFJaE8sU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjtBQUNBLGdCQUFJcW1CLGFBQWEsSUFBSWxtQixTQUFTbW1CLEtBQWIsQ0FBbUJwbUIsTUFBbkIsQ0FBakI7O0FBRUFtbUIsdUJBQVdwRixNQUFYLENBQWtCO0FBQ2RqUCx1QkFBTyxLQUFLbEksS0FBTCxDQUFXeWMsZUFESjtBQUVkSixzQkFBTSxLQUFLN2IsS0FBTCxDQUFXNmIsSUFGSDtBQUdkQyxzQkFBTSxLQUFLOWIsS0FBTCxDQUFXOGI7QUFISCxhQUFsQjs7QUFNQSxpQkFBS3RjLEtBQUwsQ0FBV3dFLGVBQVg7O0FBRUFwTyxtQkFBT3dELElBQVAsQ0FBWSxpQkFBWixFQUErQixJQUEvQjtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7O3NDQVVjOGlCLFMsRUFBV3hqQixLLEVBQU87QUFDNUIsZ0JBQUlzSCxRQUFRLEVBQVo7QUFDQUEsa0JBQU1rYyxTQUFOLElBQW1CeGpCLE1BQU1vQixNQUFOLENBQWFELEtBQWhDOztBQUVBLGlCQUFLdUosUUFBTCxDQUFjcEQsS0FBZDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Ozt1Q0FXZXRILEssRUFBTztBQUNsQixnQkFBSUEsTUFBTWtOLE9BQU4sS0FBa0J1SixTQUFsQixJQUErQnpXLE1BQU1rTixPQUFOLEtBQWtCd0osT0FBckQsRUFBOEQ7QUFDMUQxVyxzQkFBTVEsY0FBTjtBQUNIOztBQUVELGdCQUFJUixNQUFNa04sT0FBTixLQUFrQnVKLFNBQXRCLEVBQWlDO0FBQzdCLHFCQUFLZ04sWUFBTDtBQUNILGFBRkQsTUFFTyxJQUFJempCLE1BQU1rTixPQUFOLEtBQWtCd0osT0FBdEIsRUFBK0I7QUFDbEMscUJBQUs1UCxLQUFMLENBQVd3RSxlQUFYO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSW9ZLE9BQU9DLEtBQUtDLEdBQUwsRUFBWDtBQUNBLGdCQUFJQyxTQUFTSCxPQUFPLE1BQXBCO0FBQ0EsZ0JBQUlJLFNBQVNKLE9BQU8sTUFBcEI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFLLFdBQVUseUJBQWY7QUFDSTtBQUFBO0FBQUEsc0JBQU8sU0FBU0csTUFBaEI7QUFBeUJybEIsZ0NBQVlvRyxPQUFaLENBQW9Cd2U7QUFBN0MsaUJBREo7QUFFSTtBQUFBO0FBQUEsc0JBQUssV0FBVSwwQkFBZjtBQUNJLDZEQUFPLFdBQVUsVUFBakIsRUFBNEIsSUFBSVMsTUFBaEMsRUFBd0MsVUFBVSxLQUFLRSxhQUFMLENBQW1CemxCLElBQW5CLENBQXdCLElBQXhCLEVBQThCLE1BQTlCLENBQWxELEVBQXlGLEtBQUksR0FBN0YsRUFBaUcsV0FBVyxLQUFLcVosY0FBTCxDQUFvQnJaLElBQXBCLENBQXlCLElBQXpCLENBQTVHLEVBQTRJLGFBQVksTUFBeEosRUFBK0osS0FBSyxLQUFLMmtCLE9BQXpLLEVBQWtMLE1BQUssUUFBdkwsRUFBZ00sT0FBTyxLQUFLM2IsS0FBTCxDQUFXOGIsSUFBbE47QUFESixpQkFGSjtBQU1JO0FBQUE7QUFBQSxzQkFBTyxTQUFTVSxNQUFoQjtBQUF5QnRsQixnQ0FBWW9HLE9BQVosQ0FBb0JvZjtBQUE3QyxpQkFOSjtBQU9JO0FBQUE7QUFBQSxzQkFBSyxXQUFVLDBCQUFmO0FBQ0ksNkRBQU8sV0FBVSxVQUFqQixFQUE0QixJQUFJRixNQUFoQyxFQUF3QyxVQUFVLEtBQUtDLGFBQUwsQ0FBbUJ6bEIsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEIsTUFBOUIsQ0FBbEQsRUFBeUYsS0FBSSxHQUE3RixFQUFpRyxXQUFXLEtBQUtxWixjQUFMLENBQW9CclosSUFBcEIsQ0FBeUIsSUFBekIsQ0FBNUcsRUFBNEksYUFBWSxRQUF4SixFQUFpSyxLQUFLLEtBQUs0a0IsT0FBM0ssRUFBb0wsTUFBSyxRQUF6TCxFQUFrTSxPQUFPLEtBQUs1YixLQUFMLENBQVc2YixJQUFwTjtBQURKLGlCQVBKO0FBV0k7QUFBQTtBQUFBLHNCQUFRLGNBQVcsU0FBbkIsRUFBNkIsV0FBVSxXQUF2QyxFQUFtRCxTQUFTLEtBQUtNLFlBQUwsQ0FBa0JubEIsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBNUQ7QUFDSSw0REFBTSxXQUFVLFlBQWhCO0FBREo7QUFYSixhQURKO0FBaUJIOzs7O0VBOUh5QixnQkFBTXNVLFM7O0FBaUlwQzs7Ozs7Ozs7OztBQVFBb1EsZ0JBQWdCblosR0FBaEIsR0FBc0IsV0FBdEI7O0FBRUE7Ozs7Ozs7QUFPQW1aLGdCQUFnQnpRLFlBQWhCLEdBQStCO0FBQzNCZ1IscUJBQWlCO0FBQ2JVLGdCQUFRLENBREs7QUFFYkMscUJBQWEsQ0FGQTtBQUdiQyxxQkFBYSxDQUhBO0FBSWJwYixlQUFPO0FBSk07QUFEVSxDQUEvQjs7a0JBU2VpYSxlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZLZjs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLTW9CLGtCOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSXJDLGtCQUFKO0FBQ0EsZ0JBQUlDLG9CQUFKOztBQUVBLGdCQUFJLEtBQUtsYixLQUFMLENBQVcrRCxRQUFmLEVBQXlCO0FBQ3JCbVgsdUNBQXVCb0MsbUJBQW1CdmEsR0FBbkIsR0FBeUIsTUFBaEQ7QUFDQWtZLHFDQUFxQiw4REFBb0IsVUFBVSxLQUFLRSxZQUFMLEVBQTlCLEVBQW1ELFFBQVEsS0FBS25iLEtBQUwsQ0FBVzVKLE1BQXRFLEVBQThFLFFBQVE4a0Isb0JBQXRGLEVBQTRHLFdBQVcsS0FBS2xiLEtBQUwsQ0FBV2dFLGNBQWxJLEdBQXJCO0FBQ0g7O0FBRUQsZ0JBQUl1WixnQkFBZ0IsSUFBSWxuQixTQUFTbW1CLEtBQWIsQ0FBbUIsS0FBS3hjLEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQW5CLEVBQTBEc25CLFVBQTFELEVBQXBCO0FBQ0EsZ0JBQUlDLHFCQUFxQi9sQixZQUFZb0csT0FBWixDQUFvQjRmLE9BQXBCLEdBQThCLEdBQXZEO0FBQ0EsZ0JBQUlDLHFCQUFxQmptQixZQUFZb0csT0FBWixDQUFvQixZQUFZeWYsYUFBaEMsQ0FBekI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFLLFdBQVUsMENBQWY7QUFDSTtBQUFBO0FBQUEsc0JBQVEsaUJBQWUsS0FBS3ZkLEtBQUwsQ0FBVytELFFBQWxDLEVBQTRDLGNBQVcsRUFBdkQsRUFBMEQsV0FBVSxvQkFBcEUsRUFBeUYsU0FBUyxLQUFLL0QsS0FBTCxDQUFXZ0UsY0FBWCxDQUEwQnhNLElBQTFCLENBQStCLElBQS9CLENBQWxHLEVBQXdJLE1BQUssVUFBN0ksRUFBd0osVUFBVSxLQUFLd0ksS0FBTCxDQUFXdEQsUUFBN0ssRUFBdUwsT0FBTSxFQUE3TDtBQUNJO0FBQUE7QUFBQSwwQkFBSyxXQUFVLGNBQWY7QUFDSTtBQUFBO0FBQUEsOEJBQU0sV0FBVSxxQ0FBaEI7QUFBdUQrZ0IsOENBQXZEO0FBQUE7QUFBMkU7QUFBQTtBQUFBO0FBQVNFO0FBQVQ7QUFBM0UseUJBREo7QUFFSSxnRUFBTSxXQUFVLGVBQWhCO0FBRko7QUFESixpQkFESjtBQU9LMUM7QUFQTCxhQURKO0FBV0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7dUNBVWU7QUFDWCxtQkFBTyxLQUFLamIsS0FBTCxDQUFXd1AsUUFBWCxJQUF1QixDQUMxQjtBQUNJbFAseUJBQVMsa0JBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0I4ZjtBQUYvQixhQUQwQixFQUsxQjtBQUNJdGQseUJBQVMsaUJBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0IrZjtBQUYvQixhQUwwQixFQVMxQjtBQUNJdmQseUJBQVMsb0JBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0JnZ0I7QUFGL0IsYUFUMEIsRUFhMUI7QUFDSXhkLHlCQUFTLGtCQURiO0FBRUlxTyx1QkFBT2pYLFlBQVlvRyxPQUFaLENBQW9CaWdCO0FBRi9CLGFBYjBCLENBQTlCO0FBa0JIOzs7O0VBaEU0QixnQkFBTWpTLFM7O0FBbUV2Qzs7Ozs7Ozs7OztBQVFBd1IsbUJBQW1CdmEsR0FBbkIsR0FBeUIsY0FBekI7O2tCQUVldWEsa0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckZmOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLTVUsaUI7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZdG1CLFlBQVlvRyxPQUFaLENBQW9CbWdCLFdBQXhDLEVBQXFELFdBQVUsV0FBL0QsRUFBMkUsYUFBVSxxQkFBckYsRUFBMkcsU0FBUyxLQUFLQyxZQUFMLENBQWtCMW1CLElBQWxCLENBQXVCLElBQXZCLENBQXBILEVBQWtKLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQXZLLEVBQWlMLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQm1nQixXQUE1TTtBQUNJLHdEQUFNLFdBQVUsYUFBaEI7QUFESixhQURKO0FBS0g7O0FBRUQ7Ozs7Ozs7Ozs7O3VDQVFlO0FBQ1gsZ0JBQUk3bkIsU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjtBQUNBLGdCQUFJcW1CLGFBQWEsSUFBSWxtQixTQUFTbW1CLEtBQWIsQ0FBbUJwbUIsTUFBbkIsQ0FBakI7O0FBRUFtbUIsdUJBQVc3SyxNQUFYOztBQUVBdGIsbUJBQU93RCxJQUFQLENBQVksaUJBQVosRUFBK0IsSUFBL0I7QUFDSDs7OztFQWhDMkIsZ0JBQU1rUyxTOztBQW1DdEM7Ozs7Ozs7Ozs7QUFRQWtTLGtCQUFrQmpiLEdBQWxCLEdBQXdCLGFBQXhCOztrQkFFZWliLGlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BEZjs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLTUcsYzs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7O2lDQVFTO0FBQ0wsZ0JBQUlsRCxrQkFBSjtBQUNBLGdCQUFJQyxvQkFBSjs7QUFFQSxnQkFBSSxLQUFLbGIsS0FBTCxDQUFXK0QsUUFBZixFQUF5QjtBQUNyQm1YLHVDQUF1QmlELGVBQWVwYixHQUFmLEdBQXFCLE1BQTVDO0FBQ0FrWSxxQ0FBcUIsOERBQW9CLFVBQVUsS0FBS0UsWUFBTCxFQUE5QixFQUFtRCxRQUFRLEtBQUtuYixLQUFMLENBQVc1SixNQUF0RSxFQUE4RSxRQUFROGtCLG9CQUF0RixFQUE0RyxXQUFXLEtBQUtsYixLQUFMLENBQVdnRSxjQUFsSSxHQUFyQjtBQUNIOztBQUVELG1CQUNJO0FBQUE7QUFBQSxrQkFBSyxXQUFVLDhCQUFmO0FBQ0k7QUFBQTtBQUFBLHNCQUFRLGlCQUFlLEtBQUtoRSxLQUFMLENBQVcrRCxRQUFsQyxFQUE0QyxjQUFZck0sWUFBWW9HLE9BQVosQ0FBb0JzZ0IsR0FBNUUsRUFBaUYsYUFBV2xELG9CQUE1RixFQUFrSCxXQUFVLFdBQTVILEVBQXdJLFNBQVMsS0FBS2xiLEtBQUwsQ0FBV2dFLGNBQVgsQ0FBMEJ4TSxJQUExQixDQUErQixJQUEvQixDQUFqSixFQUF1TCxNQUFLLFVBQTVMLEVBQXVNLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTVOLEVBQXNPLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQnNnQixHQUFqUTtBQUNJLDREQUFNLFdBQVUsYUFBaEI7QUFESixpQkFESjtBQUlLbkQ7QUFKTCxhQURKO0FBUUg7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7dUNBVWU7QUFDWCxtQkFBTyxLQUFLamIsS0FBTCxDQUFXd1AsUUFBWCxJQUF1QixDQUMxQjtBQUNJbFAseUJBQVMsaUJBRGI7QUFFSXFPLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0J1Z0I7QUFGL0IsYUFEMEIsRUFLMUI7QUFDSS9kLHlCQUFTLGdCQURiO0FBRUlxTyx1QkFBT2pYLFlBQVlvRyxPQUFaLENBQW9Cd2dCO0FBRi9CLGFBTDBCLEVBUzFCO0FBQ0loZSx5QkFBUyxXQURiO0FBRUlxTyx1QkFBT2pYLFlBQVlvRyxPQUFaLENBQW9CeWdCO0FBRi9CLGFBVDBCLENBQTlCO0FBY0g7Ozs7RUFyRHdCLGdCQUFNelMsUzs7QUF3RG5DOzs7Ozs7Ozs7O0FBUUFxUyxlQUFlcGIsR0FBZixHQUFxQixVQUFyQjs7a0JBRWVvYixjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFFZjs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7O0lBU01LLFc7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJLEtBQUt4ZSxLQUFMLENBQVd5RSxlQUFmLEVBQWdDO0FBQzVCLHVCQUNJLHlEQUFxQixLQUFLekUsS0FBMUIsQ0FESjtBQUdILGFBSkQsTUFJTztBQUNILHVCQUNJO0FBQUE7QUFBQSxzQkFBUSxjQUFZdEksWUFBWW9HLE9BQVosQ0FBb0IyZ0IsS0FBeEMsRUFBK0MsV0FBVSxXQUF6RCxFQUFxRSxhQUFVLGNBQS9FLEVBQThGLFNBQVMsS0FBS3plLEtBQUwsQ0FBVzBFLGdCQUFsSCxFQUFvSSxVQUFVLEtBQUsxRSxLQUFMLENBQVd0RCxRQUF6SixFQUFtSyxPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0IyZ0IsS0FBOUw7QUFDSSw0REFBTSxXQUFVLGVBQWhCO0FBREosaUJBREo7QUFLSDtBQUNKOzs7O0VBckJxQixnQkFBTTNTLFM7O0FBd0JoQzs7Ozs7Ozs7OztBQVFBMFMsWUFBWXpiLEdBQVosR0FBa0IsT0FBbEI7O2tCQUVleWIsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5Q2Y7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7O0lBT01FLGdCOzs7Ozs7Ozs7Ozs7QUFDRjs7Ozs7Ozs0Q0FPb0I7QUFDaEIsK0JBQVN2YSxXQUFULENBQXFCLElBQXJCLEVBQTJCQyxLQUEzQjtBQUNIOztBQUVEOzs7Ozs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJdWEsY0FBYyxLQUFLQyxrQkFBTCxFQUFsQjs7QUFFQSxtQkFDSTtBQUFBO0FBQW9CLHFCQUFLNWUsS0FBekI7QUFDSzJlO0FBREwsYUFESjtBQUtIOztBQUVEOzs7Ozs7Ozs7Ozs7aURBU3lCO0FBQ3JCLG1CQUFPLEtBQUszZSxLQUFMLENBQVd1WCxrQkFBWCxJQUFpQyxDQUFDO0FBQ3JDNUksdUJBQU9qWCxZQUFZb0csT0FBWixDQUFvQjBYLGlCQURVO0FBRXJDbmIsdUJBQU87QUFGOEIsYUFBRCxFQUdyQztBQUNDc1UsdUJBQU9qWCxZQUFZb0csT0FBWixDQUFvQitnQixjQUQ1QjtBQUVDeGtCLHVCQUFPO0FBRlIsYUFIcUMsRUFNckM7QUFDQ3NVLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0JnaEIsZUFENUI7QUFFQ3prQix1QkFBTztBQUZSLGFBTnFDLEVBU3JDO0FBQ0NzVSx1QkFBT2pYLFlBQVlvRyxPQUFaLENBQW9CaWhCLGdCQUQ1QjtBQUVDMWtCLHVCQUFPO0FBRlIsYUFUcUMsRUFZckM7QUFDQ3NVLHVCQUFPalgsWUFBWW9HLE9BQVosQ0FBb0JraEIsYUFENUI7QUFFQzNrQix1QkFBTztBQUZSLGFBWnFDLENBQXhDO0FBZ0JIOztBQUVEOzs7Ozs7Ozs7Ozs7NkNBU3FCO0FBQ2pCLGdCQUFJNGtCLFVBQVUsS0FBS0Msc0JBQUwsRUFBZDs7QUFFQSxnQkFBSTlKLHlCQUF5QixLQUFLcFYsS0FBTCxDQUFXb1Ysc0JBQXhDOztBQUVBNkosc0JBQVVBLFFBQVFuYyxHQUFSLENBQVksVUFBU3hJLE1BQVQsRUFBaUI7QUFDbkMsb0JBQUlPLFlBQVksS0FBS21GLEtBQUwsQ0FBV3NWLGNBQVgsS0FBOEJoYixPQUFPRCxLQUFyQyxHQUE2QywyQkFBN0MsR0FBMkUsb0JBQTNGOztBQUVBLHVCQUNJO0FBQUE7QUFBQSxzQkFBSSxLQUFLQyxPQUFPRCxLQUFoQixFQUF1QixNQUFLLFFBQTVCO0FBQ0k7QUFBQTtBQUFBLDBCQUFRLFdBQVdRLFNBQW5CLEVBQThCLGNBQVlQLE9BQU9ELEtBQWpELEVBQXdELFNBQVMrYSxzQkFBakU7QUFBMEY5YSwrQkFBT3FVO0FBQWpHO0FBREosaUJBREo7QUFLSCxhQVJxQixDQVFwQm5YLElBUm9CLENBUWYsSUFSZSxDQUFaLENBQVY7O0FBVUEsbUJBQU95bkIsT0FBUDtBQUNIOzs7O0VBbkYwQixnQkFBTW5ULFM7O0FBc0ZyQzs7Ozs7Ozs7OztBQVFBNFMsaUJBQWlCM2IsR0FBakIsR0FBdUIsWUFBdkI7O0FBRUE7Ozs7Ozs7QUFPQTJiLGlCQUFpQmpULFlBQWpCLEdBQWdDO0FBQzVCbEYsY0FBVSxJQURrQjtBQUU1QlcsaUJBQWEscUJBRmU7QUFHNUIvSyxVQUFNO0FBQ0Y4SixpQkFBUyxDQUFDLEVBQUQsQ0FEUDtBQUVGSSxxQkFBYSxDQUFDLEVBQUQsQ0FGWDtBQUdGQyxxQkFBYSxDQUFDLEVBQUQsQ0FIWDtBQUlGRSxjQUFNLENBQUMsRUFBRCxDQUpKO0FBS0ZDLGNBQU0sQ0FBQyxFQUFEO0FBTEo7QUFIc0IsQ0FBaEM7O2tCQVllLGtDQUNYaVksZ0JBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSGY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7SUFPTVMsYTs7Ozs7Ozs7Ozs7O0FBQ0Y7Ozs7Ozs7c0NBT2M7QUFDVixnQkFBSS9vQixTQUFTLEtBQUs0SixLQUFMLENBQVc1SixNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixDQUFiOztBQUVBLGdCQUFJd2dCLFlBQVksSUFBSXJnQixTQUFTaWdCLElBQWIsQ0FBa0JsZ0IsTUFBbEIsQ0FBaEI7O0FBRUEsZ0JBQUksS0FBSzBKLFFBQUwsRUFBSixFQUFxQjtBQUNqQjRXLDBCQUFVaEYsTUFBVixDQUFpQmdGLFVBQVVILGdCQUFWLEVBQWpCO0FBQ0gsYUFGRCxNQUVPO0FBQ0hHLDBCQUFVUyxNQUFWLENBQ0ksS0FBS2lJLFFBQUwsRUFESixFQUVJO0FBQ0ksNkJBQVMsaUJBRGI7QUFFSSw4QkFBVTtBQUZkLGlCQUZKO0FBT0g7O0FBRURocEIsbUJBQU93RCxJQUFQLENBQVksaUJBQVosRUFBK0IsSUFBL0I7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7bUNBUVc7QUFDUCxnQkFBSUssT0FBTyxJQUFJNUQsU0FBU2lnQixJQUFiLENBQWtCLEtBQUt0VyxLQUFMLENBQVc1SixNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixDQUFsQixFQUF5RHFnQixnQkFBekQsRUFBWDs7QUFFQSxtQkFBUXRjLFFBQVNBLEtBQUt3TixZQUFMLENBQWtCLE1BQWxCLEVBQTBCL0osT0FBMUIsQ0FBa0MsMEJBQWxDLE1BQWtFLENBQUMsQ0FBcEY7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7aUNBUVM7QUFDTCxnQkFBSWlPLFdBQVcsZUFBZSxLQUFLQyxlQUFMLEVBQTlCOztBQUVBLG1CQUNJO0FBQUE7QUFBQSxrQkFBUSxjQUFZbFUsWUFBWW9HLE9BQVosQ0FBb0J1aEIsT0FBeEMsRUFBaUQsV0FBVzFULFFBQTVELEVBQXNFLGFBQVUsZ0JBQWhGLEVBQWlHLFNBQVMsS0FBS21ILFdBQUwsQ0FBaUJ0YixJQUFqQixDQUFzQixJQUF0QixDQUExRyxFQUF1SSxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUE1SixFQUFzSyxPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0J1aEIsT0FBak07QUFDSSx3REFBTSxXQUFVLGlCQUFoQjtBQURKLGFBREo7QUFLSDs7QUFFRDs7Ozs7Ozs7Ozs7OzttQ0FVVztBQUNQLGdCQUFJbG5CLGVBQWUsS0FBSzZILEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQW5CO0FBQ0EsZ0JBQUlvcEIsZUFBZW5uQixhQUFhTSxZQUFiLEdBQTRCOG1CLGVBQTVCLEVBQW5CO0FBQ0EsZ0JBQUlsTyxNQUFNLEtBQUtyUixLQUFMLENBQVdxUixHQUFyQjtBQUNBLGdCQUFJbU8sTUFBTSxLQUFLeGYsS0FBTCxDQUFXd2YsR0FBckI7QUFDQSxnQkFBSUMsY0FBYywyQ0FBMkNILFlBQTdEOztBQUVBLGdCQUFJak8sR0FBSixFQUFTO0FBQ0xvTywrQkFBZSxVQUFVcE8sR0FBekI7QUFDSDs7QUFFRCxnQkFBSW1PLEdBQUosRUFBUztBQUNMQywrQkFBZSxVQUFVRCxHQUF6QjtBQUNIOztBQUVELG1CQUFPQyxXQUFQO0FBQ0g7Ozs7RUF0RnVCLGdCQUFNM1QsUzs7QUF5RmxDOzs7Ozs7Ozs7O0FBUUFxVCxjQUFjcGMsR0FBZCxHQUFvQixTQUFwQjs7a0JBRWUsa0NBQ1hvYyxhQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0dmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7SUFRTU8sbUI7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJL1QsV0FBVyxlQUFlLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFRLGNBQVlsVSxZQUFZb0csT0FBWixDQUFvQjZoQixZQUF4QyxFQUFzRCxnQkFBY2hVLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBckcsRUFBd0csV0FBV2lPLFFBQW5ILEVBQTZILGFBQVUsV0FBdkksRUFBbUosU0FBUyxLQUFLakwsV0FBTCxDQUFpQmxKLElBQWpCLENBQXNCLElBQXRCLENBQTVKLEVBQXlMLFVBQVUsS0FBS3dJLEtBQUwsQ0FBV3RELFFBQTlNLEVBQXdOLE9BQU9oRixZQUFZb0csT0FBWixDQUFvQjZoQixZQUFuUDtBQUNJLHdEQUFNLFdBQVUsdUJBQWhCO0FBREosYUFESjtBQUtIOzs7O0VBakI2QixnQkFBTTdULFM7O0FBb0J4Qzs7Ozs7Ozs7OztBQVFBNFQsb0JBQW9CM2MsR0FBcEIsR0FBMEIsSUFBMUI7O0FBRUE7Ozs7Ozs7O0FBUUEyYyxvQkFBb0JqVSxZQUFwQixHQUFtQztBQUMvQm5MLGFBQVMsY0FEc0I7QUFFL0IyQixXQUFPO0FBQ0gwRSxpQkFBUztBQUROO0FBRndCLENBQW5DOztrQkFPZSw2QkFDWCxrQ0FDQSwyQkFDSStZLG1CQURKLENBREEsQ0FEVyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFEZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7O0lBU01FLGU7Ozs7Ozs7Ozs7OztBQUNGOzs7Ozs7OztpQ0FRUztBQUNMLGdCQUFJalUsV0FBVyxlQUFlLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsbUJBQ0k7QUFBQTtBQUFBLGtCQUFRLGNBQVlsVSxZQUFZb0csT0FBWixDQUFvQitoQixTQUF4QyxFQUFtRCxnQkFBY2xVLFNBQVNqTyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FBbEcsRUFBcUcsV0FBV2lPLFFBQWhILEVBQTBILGFBQVUsa0JBQXBJLEVBQXVKLFNBQVMsS0FBS2pMLFdBQUwsQ0FBaUJsSixJQUFqQixDQUFzQixJQUF0QixDQUFoSyxFQUE2TCxVQUFVLEtBQUt3SSxLQUFMLENBQVd0RCxRQUFsTixFQUE0TixPQUFPaEYsWUFBWW9HLE9BQVosQ0FBb0IraEIsU0FBdlA7QUFDSSx3REFBTSxXQUFVLG1CQUFoQjtBQURKLGFBREo7QUFLSDs7OztFQWpCeUIsZ0JBQU0vVCxTOztBQW9CcEM7Ozs7Ozs7Ozs7QUFRQThULGdCQUFnQjdjLEdBQWhCLEdBQXNCLFdBQXRCOztBQUVBOzs7Ozs7OztBQVFBNmMsZ0JBQWdCblUsWUFBaEIsR0FBK0I7QUFDM0JuTCxhQUFTLFdBRGtCO0FBRTNCTyxlQUFXO0FBQ1BRLFlBQUksYUFERztBQUVQbEYsY0FBTTlGLFNBQVMrRixJQUFULEdBQWdCLEVBRmYsQ0FFa0I7QUFGbEIsS0FGZ0I7QUFNM0I2RixXQUFPO0FBTm9CLENBQS9COztrQkFTZSw2QkFDWCwrQkFDQSxrQ0FDQSwyQkFDSTJkLGVBREosQ0FEQSxDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5RGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O3NGQUdLLHFCQUFXN2MsRyxnRUFDWCw0QkFBa0JBLEcsdUVBQ2xCLHVCQUFhQSxHLGtFQUNiLHFCQUFXQSxHLGdFQUNYLGdDQUFzQkEsRywyRUFDdEIsNkJBQW1CQSxHLHdFQUNuQix5QkFBZUEsRyxvRUFDZiwwQkFBZ0JBLEcscUVBQ2hCLHNCQUFZQSxHLGlFQUNaLGtCQUFTQSxHLDZEQUNULGtCQUFTQSxHLDZEQUNULHNCQUFZQSxHLGlFQUNaLGlDQUF1QkEsRyw0RUFDdkIsK0JBQXFCQSxHLDBFQUNyQixnQ0FBc0JBLEcsMkVBQ3RCLHNCQUFZQSxHLGlFQUNaLDRCQUFrQkEsRyx1RUFDbEIsdUJBQWFBLEcsa0VBQ2IscUNBQTJCQSxHLGdGQUMzQix5QkFBZUEsRyxvRUFDZiwrQkFBcUJBLEcsMEVBQ3JCLHFCQUFXQSxHLGdFQUNYLG1CQUFTQSxHLDhEQUNULDZCQUFtQkEsRyx3RUFDbkIsbUNBQXlCQSxHLDhFQUN6QixvQ0FBMEJBLEcsK0VBQzFCLGdDQUFzQkEsRywyRUFDdEIsaUNBQXVCQSxHLDRFQUN2QixzQkFBWUEsRyxpRUFDWiw2QkFBbUJBLEcsd0VBQ25CLHVCQUFhQSxHLGtFQUNiLGlDQUF1QkEsRyw0RUFDdkIscUNBQTJCQSxHLGdGQUMzQiwrQkFBcUJBLEcsMEVBQ3JCLDJCQUFpQkEsRyxzRUFDakIsdUJBQWFBLEcsa0VBQ2IsMEJBQWdCQSxHLHFFQUNoQiw0QkFBa0JBLEcsdUVBQ2xCLDBCQUFnQkEsRyxxRUFDaEIsNEJBQWtCQSxHLHVFQUNsQiwwQkFBZ0JBLEcscUVBQ2hCLDZCQUFtQkEsRyx3RUFDbkIsNEJBQWtCQSxHLHVFQUNsQix5QkFBZUEsRyxvRUFDZixzQkFBWUEsRyxpRUFDWiwyQkFBaUJBLEcsc0VBQ2pCLHdCQUFjQSxHLG1FQUNkLG1CQUFTQSxHLDhEQUNULDBCQUFnQkEsRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuR3JCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7OztJQU9NK2MsRTs7O0FBQ0YsZ0JBQVk5ZixLQUFaLEVBQW1CO0FBQUE7O0FBQUEsNEdBQ1RBLEtBRFM7O0FBR2YsY0FBS1EsS0FBTCxHQUFhO0FBQ1R1ZixvQkFBUTtBQURDLFNBQWI7QUFIZTtBQU1sQjs7QUFFRDs7Ozs7Ozs7Ozs7NENBT29CO0FBQ2hCLGdCQUFJM3BCLFNBQVMsS0FBSzRKLEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQWI7O0FBRUFFLG1CQUFPNEMsRUFBUCxDQUFVLG1CQUFWLEVBQStCLEtBQUtnbkIsb0JBQXBDLEVBQTBELElBQTFEO0FBQ0E1cEIsbUJBQU80QyxFQUFQLENBQVUsaUJBQVYsRUFBNkIsS0FBS2luQixrQkFBbEMsRUFBc0QsSUFBdEQ7QUFDQTdwQixtQkFBTzRDLEVBQVAsQ0FBVSxLQUFWLEVBQWlCLEtBQUtrbkIsWUFBdEIsRUFBb0MsSUFBcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQUtDLGtCQUFMLEdBQTBCLFVBQVVqbkIsS0FBVixFQUFpQjtBQUN2QyxxQkFBS2tuQixZQUFMLENBQWtCbG5CLE1BQU1vQixNQUF4QjtBQUNILGFBRnlCLENBRXhCOUMsSUFGd0IsQ0FFbkIsSUFGbUIsQ0FBMUI7O0FBSUEsaUJBQUs2b0IsZ0JBQUwsR0FBd0JocUIsU0FBU3dMLEtBQVQsQ0FBZXllLFFBQWYsQ0FBd0IsVUFBU3BuQixLQUFULEVBQWdCO0FBQzVELHFCQUFLa25CLFlBQUwsQ0FBa0IxbkIsU0FBUzRNLGFBQTNCO0FBQ0gsYUFGdUIsRUFFckIsS0FBS3RGLEtBQUwsQ0FBV2pFLFdBRlUsRUFFRyxJQUZILENBQXhCOztBQUlBckQscUJBQVNzVixnQkFBVCxDQUEwQixXQUExQixFQUF1QyxLQUFLbVMsa0JBQTVDO0FBQ0F6bkIscUJBQVNzVixnQkFBVCxDQUEwQixTQUExQixFQUFxQyxLQUFLcVMsZ0JBQTFDO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OzsyQ0FTb0JFLFMsRUFBV0MsUyxFQUFXO0FBQ3RDLGdCQUFJdlosVUFBVSxtQkFBUzlDLFdBQVQsQ0FBcUIsSUFBckIsQ0FBZDs7QUFFQSxnQkFBSS9OLFNBQVMsS0FBSzRKLEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQWI7O0FBRUEsZ0JBQUkrUSxPQUFKLEVBQWE7QUFDVDdRLHVCQUFPd0QsSUFBUCxDQUFZLFlBQVosRUFBMEI7QUFDdEI2bUIsNkJBQVMsS0FBS0MsNEJBQUwsQ0FBa0N6WixPQUFsQztBQURhLGlCQUExQjtBQUdIOztBQUVEN1EsbUJBQU93RCxJQUFQLENBQVksY0FBWixFQUE0QjtBQUN4QjJtQiwyQkFBV0EsU0FEYTtBQUV4QkMsMkJBQVdBLFNBRmE7QUFHeEJ4Z0IsdUJBQU8sS0FBS0EsS0FIWTtBQUl4QlEsdUJBQU8sS0FBS0E7QUFKWSxhQUE1QjtBQU1IOzs7K0NBRXNCbWdCLFUsRUFBWTtBQUMvQixnQkFBSSxDQUFDLEtBQUtDLG9CQUFWLEVBQWdDO0FBQzVCLHFCQUFLQSxvQkFBTCxHQUE0QixFQUE1QjtBQUNIOztBQUVELGdCQUFJLENBQUMsS0FBS0Esb0JBQUwsQ0FBMEJELFVBQTFCLENBQUwsRUFBNEM7QUFDeEMscUJBQUtDLG9CQUFMLENBQTBCRCxVQUExQixJQUF3QyxJQUFJdHFCLFNBQVN3cUIsUUFBYixDQUFzQixLQUFLQyxlQUFMLEdBQXVCSCxVQUF2QixDQUF0QixDQUF4QztBQUNIOztBQUVELG1CQUFPLEtBQUtDLG9CQUFMLENBQTBCRCxVQUExQixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQWNrQjtBQUNkLG1CQUFPLEtBQUszZ0IsS0FBTCxDQUFXK2dCLFdBQVgsSUFBMEI7QUFDN0JDLDJCQUFXdHBCLFlBQVlvRyxPQUFaLENBQW9CbWpCLG1CQURGO0FBRTdCQyw0QkFBWXhwQixZQUFZb0csT0FBWixDQUFvQnFqQixvQkFGSDtBQUc3QkMsOEJBQWMxcEIsWUFBWW9HLE9BQVosQ0FBb0J1akI7QUFITCxhQUFqQztBQUtIOztBQUVEOzs7Ozs7Ozs7Ozs7O3FEQVU2QnBhLE8sRUFBUztBQUNsQyxnQkFBSXFhLG1CQUFtQnJhLFFBQVFFLGdCQUFSLENBQXlCLGtCQUF6QixDQUF2Qjs7QUFFQSxnQkFBSSxDQUFDbWEsaUJBQWlCaGtCLE1BQXRCLEVBQThCO0FBQzFCLHVCQUFPLEtBQUt3akIsZUFBTCxHQUF1QkUsU0FBOUI7QUFDSCxhQUZELE1BRU87QUFDSCxvQkFBSU8sZUFBZWxhLE1BQU1DLFNBQU4sQ0FBZ0IzSixLQUFoQixDQUFzQjVILElBQXRCLENBQTJCdXJCLGdCQUEzQixFQUE2Q3hlLEdBQTdDLENBQWlELFVBQVMwZSxPQUFULEVBQWtCO0FBQ2xGLDJCQUFPQSxRQUFRL1osWUFBUixDQUFxQixZQUFyQixDQUFQO0FBQ0gsaUJBRmtCLENBQW5COztBQUlBLG9CQUFJa1osYUFBYVksYUFBYWprQixNQUFiLEtBQXdCLENBQXhCLEdBQTRCLFlBQTVCLEdBQTJDLGNBQTVEOztBQUVBLHVCQUFPLEtBQUtta0Isc0JBQUwsQ0FBNEJkLFVBQTVCLEVBQXdDZSxNQUF4QyxDQUErQztBQUNsRGxyQiw4QkFBVStxQixhQUFhSSxJQUFiLENBQWtCLEdBQWxCLEVBQXVCeHFCLE9BQXZCLENBQStCLFdBQS9CLEVBQTRDLFVBQVUsSUFBdEQ7QUFEd0MsaUJBQS9DLENBQVA7QUFHSDtBQUNKOztBQUVEOzs7Ozs7Ozs7OytDQU91QjtBQUNuQixnQkFBSSxLQUFLZ3BCLGtCQUFULEVBQTZCO0FBQ3pCem5CLHlCQUFTa3BCLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDLEtBQUt6QixrQkFBL0M7QUFDSDs7QUFFRCxnQkFBSSxLQUFLRSxnQkFBVCxFQUEyQjtBQUN2QixxQkFBS0EsZ0JBQUwsQ0FBc0J3QixNQUF0QjtBQUNBbnBCLHlCQUFTa3BCLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDLEtBQUt2QixnQkFBN0M7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7Ozs7aUNBU1M7QUFDTCxnQkFBSSxLQUFLN2YsS0FBTCxDQUFXdWYsTUFBZixFQUF1QjtBQUNuQix1QkFBTyxJQUFQO0FBQ0g7O0FBRUQsZ0JBQUl2cEIsV0FBV3NyQixPQUFPM2xCLElBQVAsQ0FBWSxLQUFLNkQsS0FBTCxDQUFXeEosUUFBdkIsRUFBaUNzTSxHQUFqQyxDQUFxQyxVQUFTMGUsT0FBVCxFQUFrQjtBQUNsRSx1QkFBTzlwQixZQUFZbUksUUFBWixDQUFxQjJoQixPQUFyQixLQUFpQ2hwQixPQUFPZ3BCLE9BQVAsQ0FBeEM7QUFDSCxhQUZjLENBQWY7O0FBSUFockIsdUJBQVcsS0FBS21NLGVBQUwsQ0FBcUJuTSxRQUFyQixFQUErQnNNLEdBQS9CLENBQW1DLFVBQVMwZSxPQUFULEVBQWtCO0FBQzVELG9CQUFJeGhCLFFBQVEsS0FBS2lELG1CQUFMLENBQXlCO0FBQ2pDck4sNEJBQVEsS0FBS29LLEtBQUwsQ0FBV3hKLFFBQVgsQ0FBb0JnckIsUUFBUXplLEdBQTVCLENBRHlCO0FBRWpDM00sNEJBQVEsS0FBSzRKLEtBQUwsQ0FBVzVKLE1BRmM7QUFHakN1UyxpQ0FBYSxLQUFLbkksS0FBTCxDQUFXbUksV0FIUztBQUlqQzVGLHlCQUFLeWUsUUFBUXplLEdBSm9CO0FBS2pDOEMsK0JBQVcsS0FBS2tjLHNCQUxpQjtBQU1qQ25aLG1DQUFlLEtBQUtwSSxLQUFMLENBQVdvSTtBQU5PLGlCQUF6QixFQU9UNFksUUFBUXplLEdBUEMsQ0FBWjs7QUFTQSx1QkFBTyxnQkFBTW5JLGFBQU4sQ0FBb0I0bUIsT0FBcEIsRUFBNkJ4aEIsS0FBN0IsQ0FBUDtBQUNILGFBWDZDLENBVzVDeEksSUFYNEMsQ0FXdkMsSUFYdUMsQ0FBbkMsQ0FBWDs7QUFhQSxtQkFDSTtBQUFBO0FBQUEsa0JBQUssV0FBVSxhQUFmLEVBQTZCLFdBQVcsS0FBSzZYLFNBQUwsQ0FBZTdYLElBQWYsQ0FBb0IsSUFBcEIsQ0FBeEM7QUFDS2hCO0FBREwsYUFESjtBQUtIOztBQUVEOzs7Ozs7Ozs7Ozs7MkNBU21CMEMsSyxFQUFPO0FBQ3RCLGdCQUFJOUMsU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjs7QUFFQUUsbUJBQU9nTyxLQUFQOztBQUVBLGlCQUFLUixRQUFMLENBQWM7QUFDVlMsK0JBQWUsSUFETDtBQUVWdUUsK0JBQWV4UyxPQUFPNHJCLGdCQUFQO0FBRkwsYUFBZDtBQUlIOztBQUVEOzs7Ozs7Ozs7OztpREFReUI7QUFDckIsZ0JBQUk1ckIsU0FBUyxLQUFLNEosS0FBTCxDQUFXNUosTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBYjs7QUFFQUUsbUJBQU9nTyxLQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7NkNBVXFCbEwsSyxFQUFPO0FBQ3hCLGlCQUFLMEssUUFBTCxDQUFjO0FBQ1YrRSw2QkFBYXpQLEtBREg7QUFFVjZtQix3QkFBUSxLQUZFO0FBR1YxYiwrQkFBZSxJQUhMO0FBSVZ1RSwrQkFBZTFQLE1BQU1FLElBQU4sQ0FBV3dQO0FBSmhCLGFBQWQ7QUFNSDs7QUFFRDs7Ozs7Ozs7Ozs7cUNBUWExUCxLLEVBQU87QUFDaEIsZ0JBQUkyUCxjQUFjM1AsTUFBTUUsSUFBTixDQUFXNm9CLFFBQVgsQ0FBb0J0cEIsQ0FBdEM7O0FBRUEsZ0JBQUlrUSxZQUFZcVosTUFBWixJQUFzQnJaLFlBQVl6QyxPQUFaLEtBQXdCLEdBQWxELEVBQXVEO0FBQ25ELHFCQUFLaEMsS0FBTDtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7cUNBVWE5SixNLEVBQVE7QUFDakIsZ0JBQUkyTSxVQUFVLG1CQUFTOUMsV0FBVCxDQUFxQixJQUFyQixDQUFkOztBQUVBLGdCQUFJOEMsT0FBSixFQUFhO0FBQ1Qsb0JBQUkzUCxXQUFXLEtBQUswSSxLQUFMLENBQVc1SixNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixFQUFzQ29CLFFBQXRDLEVBQWY7QUFDQSxvQkFBSTZxQixhQUFhLElBQUk5ckIsU0FBU3lELEdBQVQsQ0FBYTdELElBQWpCLENBQXNCcUUsTUFBdEIsQ0FBakI7O0FBRUEsb0JBQUksQ0FBQ2hELFFBQUwsRUFBZTtBQUNYLHlCQUFLc00sUUFBTCxDQUFjO0FBQ1ZtYyxnQ0FBUTtBQURFLHFCQUFkO0FBR0gsaUJBSkQsTUFJTztBQUNILHdCQUFJN1UsTUFBTzVULFNBQVNxQixDQUFULEtBQWUyQixNQUFoQixJQUEyQmhELFNBQVM4cUIsUUFBVCxDQUFrQkQsVUFBbEIsQ0FBM0IsSUFDTCxJQUFJOXJCLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5Qk0sT0FBekIsQ0FBRCxDQUFvQ21iLFFBQXBDLENBQTZDRCxVQUE3QyxDQURKOztBQUdBLHdCQUFJLENBQUNqWCxHQUFMLEVBQVU7QUFDTiw2QkFBS3RILFFBQUwsQ0FBYztBQUNWbWMsb0NBQVE7QUFERSx5QkFBZDtBQUdIO0FBQ0o7QUFDSjtBQUNKOzs7O0VBbFNZLGdCQUFNalUsUzs7QUFxU3ZCOzs7Ozs7Ozs7O0FBUUFnVSxHQUFHclUsWUFBSCxHQUFrQjtBQUNkbEYsY0FBVSxJQURJO0FBRWRXLGlCQUFhLHNCQUZDO0FBR2RuTCxpQkFBYSxDQUhDO0FBSWRJLFVBQU07QUFDRnFLLGNBQU07QUFESjtBQUpRLENBQWxCOztBQVNBOzs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7O2tCQVdlLCtCQUNYLGtDQUNJc1osRUFESixDQURXLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcFZmOzs7O0FBQ0E7Ozs7Ozs7O3NGQUdLLHFCQUFXL2MsRyxnRUFDWCx3QkFBY0EsRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMbkI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBSXNmLGdCQUFnQixDQUFwQjtBQUNBLElBQUlDLGlCQUFpQixDQUFyQjs7QUFFQTs7Ozs7Ozs7Ozs7O0lBV01DLFU7OztBQUNGLHdCQUFZdmlCLEtBQVosRUFBbUI7QUFBQTs7QUFBQSw0SEFDVEEsS0FEUzs7QUFHZixjQUFLUSxLQUFMLEdBQWEsRUFBYjtBQUhlO0FBSWxCOztBQUVEOzs7Ozs7Ozs7Ozs7NENBUW9CO0FBQ2hCLGlCQUFLZ2lCLGVBQUw7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7OzsyQ0FVbUJqQyxTLEVBQVdDLFMsRUFBVztBQUNyQyxpQkFBS2dDLGVBQUw7O0FBRUE7QUFDQTtBQUNBLGdCQUFJLEtBQUt4aUIsS0FBTCxDQUFXeUUsZUFBZixFQUFnQztBQUM1QixxQkFBS0wsS0FBTDtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7Ozs7OztpQ0FTUztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQUksQ0FBQyxLQUFLNUQsS0FBTCxDQUFXNkQsYUFBWixJQUNJLEtBQUtyRSxLQUFMLENBQVcySSxXQURmLElBRUksS0FBSzNJLEtBQUwsQ0FBVzJJLFdBQVgsQ0FBdUJ2UCxJQUF2QixDQUE0QnlQLFdBQTVCLENBQXdDdk8sTUFGNUMsSUFHSSxDQUFDLEtBQUswRixLQUFMLENBQVcySSxXQUFYLENBQXVCdlAsSUFBdkIsQ0FBNEJ5UCxXQUE1QixDQUF3Q3ZPLE1BQXhDLENBQStDbW9CLGlCQUh4RCxFQUcyRTtBQUN2RSx1QkFBTyxJQUFQO0FBQ0g7O0FBRUQsZ0JBQUlobUIsVUFBVSxLQUFLaW1CLFdBQUwsRUFBZDtBQUNBLGdCQUFJN25CLFlBQVksS0FBSzhuQixvQkFBTCxFQUFoQjs7QUFFQSxtQkFDSTtBQUFBO0FBQUEsa0JBQUssY0FBWWpyQixZQUFZb0csT0FBWixDQUFvQnRCLEdBQXJDLEVBQTBDLFdBQVczQixTQUFyRCxFQUFnRSxpQkFBZSxLQUFLbUYsS0FBTCxDQUFXcEssTUFBWCxDQUFrQjhHLFFBQWxCLElBQThCLENBQTdHLEVBQWdILFNBQVMsS0FBSzBILEtBQUwsQ0FBVzVNLElBQVgsQ0FBZ0IsSUFBaEIsQ0FBekgsRUFBZ0osV0FBVyxLQUFLNlgsU0FBTCxDQUFlN1gsSUFBZixDQUFvQixJQUFwQixDQUEzSixFQUFzTCxNQUFLLFNBQTNMLEVBQXFNLFVBQVMsSUFBOU07QUFDSTtBQUFBO0FBQUEsc0JBQUssV0FBVSxjQUFmO0FBQ0tpRjtBQURMO0FBREosYUFESjtBQU9IOztBQUVEOzs7Ozs7Ozs7Ozs7c0NBU2M7QUFDVixnQkFBSUEsT0FBSjs7QUFFQSxnQkFBSSxLQUFLdUQsS0FBTCxDQUFXeUUsZUFBZixFQUFnQztBQUM1QmhJLDBCQUFVLEtBQUttbUIsaUJBQUwsQ0FBdUIsS0FBSzVpQixLQUFMLENBQVdwSyxNQUFYLENBQWtCNkcsT0FBekMsQ0FBVjtBQUNILGFBRkQsTUFFTztBQUNILG9CQUFJLEtBQUt1RCxLQUFMLENBQVc0SSxhQUFYLElBQTRCLEtBQUs1SSxLQUFMLENBQVc0SSxhQUFYLENBQXlCSSxNQUF6RCxFQUFpRTtBQUM3RHZNLDhCQUNJO0FBQUE7QUFBQSwwQkFBUSxjQUFZL0UsWUFBWW9HLE9BQVosQ0FBb0J0QixHQUF4QyxFQUE2QyxXQUFVLHlCQUF2RCxFQUFpRixTQUFTLEtBQUt3RCxLQUFMLENBQVcwRSxnQkFBWCxDQUE0QmxOLElBQTVCLENBQWlDLElBQWpDLEVBQXVDK3FCLFdBQVd4ZixHQUFsRCxDQUExRixFQUFrSixPQUFPckwsWUFBWW9HLE9BQVosQ0FBb0J0QixHQUE3SztBQUNJLGdFQUFNLFdBQVUsYUFBaEI7QUFESixxQkFESjtBQUtIO0FBQ0o7O0FBRUQsbUJBQU9DLE9BQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7OytDQVN1QjtBQUNuQixnQkFBSWtQLFdBQVcsZ0JBQWY7O0FBRUEsZ0JBQUksS0FBSzNMLEtBQUwsQ0FBV3lFLGVBQWYsRUFBZ0M7QUFDNUJrSCwyQkFBVyxnQkFBZ0IsS0FBS2tYLGtCQUFMLEVBQTNCO0FBQ0g7O0FBRUQsbUJBQU9sWCxRQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OzBDQVFrQjtBQUNkLGdCQUFJM0MsTUFBSjs7QUFFQTtBQUNBLGdCQUFJLENBQUMsbUJBQVM3RSxXQUFULENBQXFCLElBQXJCLENBQUwsRUFBaUM7QUFDN0I7QUFDSDs7QUFFRCxnQkFBSSxLQUFLbkUsS0FBTCxDQUFXeUUsZUFBZixFQUFnQztBQUM1QixxQkFBS3FlLGNBQUw7QUFDQSxxQkFBS0MsSUFBTDtBQUNILGFBSEQsTUFHTztBQUNILG9CQUFJLEtBQUsvaUIsS0FBTCxDQUFXNEksYUFBZixFQUE4QjtBQUMxQkksNkJBQVMsS0FBS2hKLEtBQUwsQ0FBVzRJLGFBQVgsQ0FBeUJJLE1BQWxDO0FBQ0g7O0FBRUQsb0JBQUlBLE1BQUosRUFBWTtBQUNSLHdCQUFJL0IsVUFBVSxtQkFBUzlDLFdBQVQsQ0FBcUIsSUFBckIsQ0FBZDs7QUFFQSx3QkFBSWdHLGFBQWEsSUFBSTlULFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5Qk0sT0FBekIsQ0FBakI7O0FBRUEsd0JBQUlpQyxZQUFZRixPQUFPRSxTQUFQLElBQW9CRixNQUFwQzs7QUFFQSx3QkFBSTdRLGVBQWUsS0FBSzZILEtBQUwsQ0FBVzVKLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQW5COztBQUVBLHdCQUFJOHNCLGFBQWE3cUIsYUFBYWIsUUFBYixHQUF3QjJyQixhQUF4QixFQUFqQjs7QUFFQSx3QkFBSUMsVUFBSjs7QUFFQSx3QkFBSUMsV0FBVyxLQUFLbmpCLEtBQUwsQ0FBV3BLLE1BQVgsQ0FBa0J1dEIsUUFBbEIsSUFBOEIsS0FBS25qQixLQUFMLENBQVdtakIsUUFBeEQ7O0FBRUEsd0JBQUlBLGFBQWFkLGFBQWpCLEVBQWdDO0FBQzVCYSxxQ0FBYUYsV0FBVzFhLElBQVgsR0FBa0JyQixRQUFRK0MsV0FBMUIsR0FBd0MsS0FBS2hLLEtBQUwsQ0FBV29qQixlQUFYLENBQTJCOWEsSUFBbkUsR0FBMEUsSUFBdkY7QUFDSCxxQkFGRCxNQUVPO0FBQ0g0YSxxQ0FBYUYsV0FBV3paLEtBQVgsR0FBbUIsS0FBS3ZKLEtBQUwsQ0FBV29qQixlQUFYLENBQTJCOWEsSUFBOUMsR0FBcUQsSUFBbEU7QUFDSDs7QUFFRHJCLDRCQUFRaEYsS0FBUixDQUFjcUcsSUFBZCxHQUFxQjRhLFVBQXJCOztBQUVBamMsNEJBQVFoRixLQUFSLENBQWN1RyxHQUFkLEdBQW9CeEgsS0FBS3FpQixLQUFMLENBQVcsQ0FBQ3JhLE9BQU9jLE1BQVAsR0FBZ0JkLE9BQU9SLEdBQXhCLElBQStCLENBQTFDLElBQStDLElBQW5FOztBQUVBLHdCQUFJclEsYUFBYXdPLE9BQWIsQ0FBcUI1RyxRQUFyQixDQUE4QixVQUE5QixNQUE4QyxNQUFsRCxFQUEwRDtBQUN0RGtILGdDQUFRaEYsS0FBUixDQUFjdUcsR0FBZCxHQUFvQnhILEtBQUtxaUIsS0FBTCxDQUFXcmEsT0FBT1IsR0FBUCxHQUFhdkIsUUFBUTRDLFlBQVIsR0FBcUIsQ0FBbEMsR0FBc0NYLFVBQVVrQyxNQUFWLEdBQWlCLENBQWxFLElBQXVFLElBQTNGO0FBQ0gscUJBRkQsTUFFTztBQUNIbkUsZ0NBQVFoRixLQUFSLENBQWN1RyxHQUFkLEdBQW9CeEgsS0FBS3FpQixLQUFMLENBQVlsckIsYUFBYXdPLE9BQWIsQ0FBcUJoTyxDQUFyQixDQUF1QmlSLFNBQXZCLEdBQW9DVixVQUFVa0MsTUFBVixHQUFtQixDQUF2RCxHQUE2RG5FLFFBQVE0QyxZQUFSLEdBQXVCLENBQWhHLElBQXVHLElBQTNIO0FBQ0g7O0FBRUQ1Qyw0QkFBUWhGLEtBQVIsQ0FBY3VJLE9BQWQsR0FBd0IsQ0FBeEI7O0FBRUFMLCtCQUFXL1IsV0FBWCxDQUF1QixjQUF2Qjs7QUFFQSx5QkFBS2tyQixlQUFMO0FBQ0g7QUFDSjtBQUNKOzs7O0VBdkxvQixnQkFBTXhYLFM7O0FBMEwvQjs7Ozs7Ozs7OztBQVFBeVcsV0FBV3hmLEdBQVgsR0FBaUIsS0FBakI7O0FBRUE7Ozs7Ozs7O0FBUUF3ZixXQUFXamEsSUFBWCxHQUFrQitaLGFBQWxCOztBQUVBOzs7Ozs7OztBQVFBRSxXQUFXaFosS0FBWCxHQUFtQitZLGNBQW5COztBQUVBOzs7Ozs7OztBQVFBQyxXQUFXOVcsWUFBWCxHQUEwQjtBQUN0QmxGLGNBQVUsSUFEWTtBQUV0QlcsaUJBQWEsWUFGUztBQUd0QmtjLHFCQUFpQjtBQUNiOWEsY0FBTSxFQURPO0FBRWJFLGFBQUs7QUFGUSxLQUhLO0FBT3RCck0sVUFBTTtBQUNGOEosaUJBQVMsQ0FBQyxFQUFELENBRFA7QUFFRk8sY0FBTSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBRko7QUFHRkMsY0FBTSxDQUFDLEVBQUQsRUFBSyxFQUFMO0FBSEosS0FQZ0I7QUFZdEIwYyxjQUFVZDtBQVpZLENBQTFCOztrQkFlZSw4QkFDWCw4QkFDQSwrQkFDQSxrQ0FDQSw4QkFDQSw4QkFDSUUsVUFESixDQURBLENBREEsQ0FEQSxDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0UWY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7SUFXTWdCLGE7OztBQUNGLDJCQUFZdmpCLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxrSUFDVEEsS0FEUzs7QUFHZixjQUFLUSxLQUFMLEdBQWEsRUFBYjtBQUhlO0FBSWxCOztBQUVEOzs7Ozs7Ozs7Ozs7NENBUW9CO0FBQ2hCLGlCQUFLZ2lCLGVBQUw7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7OzsyQ0FVbUJqQyxTLEVBQVdDLFMsRUFBVztBQUNyQyxpQkFBS2dDLGVBQUw7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7O2lDQVNTO0FBQ0wsZ0JBQUlnQixtQkFBbUIsS0FBS0Msb0JBQUwsRUFBdkI7O0FBRUEsZ0JBQUlELGdCQUFKLEVBQXNCO0FBQ2xCLG9CQUFJRSx1QkFBdUIsS0FBS0MscUJBQUwsQ0FBMkJILGlCQUFpQlgsa0JBQTVDLENBQTNCO0FBQ0Esb0JBQUl4ZixlQUFKOztBQUVBLG9CQUFJcWdCLG9CQUFKLEVBQTBCO0FBQ3RCcmdCLHNDQUFrQnFnQixzQkFBbEI7QUFDSCxpQkFGRCxNQUVPO0FBQ0hyZ0Isc0NBQWtCLEtBQUt3ZixrQkFBTCxFQUFsQjtBQUNIOztBQUVELG9CQUFJZSxhQUFhLHVCQUF1QnZnQixlQUF4Qzs7QUFFQSxvQkFBSTVHLFVBQVUsS0FBS21tQixpQkFBTCxDQUNWWSxpQkFBaUIvbUIsT0FEUCxFQUVWO0FBQ0l3VCxxQ0FBaUIsS0FBS2pRLEtBQUwsQ0FBVzJJLFdBQVgsR0FBeUIsS0FBSzNJLEtBQUwsQ0FBVzJJLFdBQVgsQ0FBdUJ2UCxJQUF2QixDQUE0QjZXLGVBQXJELEdBQXVFLElBRDVGO0FBRUk0VCxtQ0FBZUwsaUJBQWlCemlCO0FBRnBDLGlCQUZVLENBQWQ7O0FBUUEsdUJBQ0k7QUFBQTtBQUFBLHNCQUFLLGNBQVlySixZQUFZb0csT0FBWixDQUFvQm5CLE1BQXJDLEVBQTZDLFdBQVdpbkIsVUFBeEQsRUFBb0UsaUJBQWUsS0FBSzVqQixLQUFMLENBQVdwSyxNQUFYLENBQWtCOEcsUUFBbEIsSUFBOEIsQ0FBakgsRUFBb0gsU0FBUyxLQUFLMEgsS0FBTCxDQUFXNU0sSUFBWCxDQUFnQixJQUFoQixDQUE3SCxFQUFvSixXQUFXLEtBQUs2WCxTQUFMLENBQWU3WCxJQUFmLENBQW9CLElBQXBCLENBQS9KLEVBQTBMLE1BQUssU0FBL0wsRUFBeU0sVUFBUyxJQUFsTjtBQUNJO0FBQUE7QUFBQSwwQkFBSyxXQUFVLGNBQWY7QUFDS2lGO0FBREw7QUFESixpQkFESjtBQU9IOztBQUVELG1CQUFPLElBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs4Q0FVc0JxbkIsVyxFQUFhO0FBQy9CLGdCQUFJQyxpQkFBSjs7QUFFQSxnQkFBSSxlQUFLbG1CLFVBQUwsQ0FBZ0JpbUIsV0FBaEIsQ0FBSixFQUFrQztBQUM5QkMsb0NBQW9CRCxXQUFwQjtBQUVILGFBSEQsTUFHTyxJQUFJLGVBQUsxb0IsUUFBTCxDQUFjMG9CLFdBQWQsQ0FBSixFQUFnQztBQUNuQyxvQkFBSXpsQixRQUFReWxCLFlBQVk1aEIsS0FBWixDQUFrQixHQUFsQixDQUFaO0FBQ0Esb0JBQUlDLGdCQUFnQjNKLE1BQXBCO0FBQ0Esb0JBQUk0SixXQUFXL0QsTUFBTWdFLEtBQU4sRUFBZjs7QUFFQSx1QkFBT0QsWUFBWSxlQUFLN0csUUFBTCxDQUFjNEcsYUFBZCxDQUFaLElBQTRDLGVBQUs1RyxRQUFMLENBQWM0RyxjQUFjQyxRQUFkLENBQWQsQ0FBbkQsRUFBMkY7QUFDdkZELG9DQUFnQkEsY0FBY0MsUUFBZCxDQUFoQjtBQUNBQSwrQkFBVy9ELE1BQU1nRSxLQUFOLEVBQVg7QUFDSDs7QUFFRCxvQkFBSSxlQUFLeEUsVUFBTCxDQUFnQnNFLGFBQWhCLENBQUosRUFBb0M7QUFDaEM0aEIsd0NBQW9CNWhCLGFBQXBCO0FBQ0g7QUFDSjs7QUFFRCxtQkFBTzRoQixpQkFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7K0NBU3VCO0FBQ25CLGdCQUFJcmIsZUFBZSxLQUFLMUksS0FBTCxDQUFXMkksV0FBWCxHQUF5QixLQUFLM0ksS0FBTCxDQUFXMkksV0FBWCxDQUF1QnZQLElBQWhELEdBQXVELElBQTFFO0FBQ0EsZ0JBQUlSLFNBQUo7O0FBRUEsZ0JBQUk4UCxZQUFKLEVBQWtCO0FBQ2QscUJBQUsxSSxLQUFMLENBQVdwSyxNQUFYLENBQWtCZ0gsVUFBbEIsQ0FBNkJrTCxJQUE3QixDQUFrQyxVQUFTdkQsSUFBVCxFQUFlO0FBQzdDLHdCQUFJeWYsU0FBUyxLQUFLTCxxQkFBTCxDQUEyQnBmLEtBQUt0RixJQUFoQyxDQUFiO0FBQ0Esd0JBQUkyQyxNQUFKOztBQUVBLHdCQUFJb2lCLE1BQUosRUFBWTtBQUNScGlCLGlDQUFTOEcsYUFBYXVILGVBQWIsS0FBaUMxTCxLQUFLeEQsSUFBdEMsSUFBOENpakIsT0FBTztBQUMxRDVxQixrQ0FBTXNQLFlBRG9EO0FBRTFEdFMsb0NBQVEsS0FBSzRKLEtBQUwsQ0FBVzVKO0FBRnVDLHlCQUFQLENBQXZEO0FBSUg7O0FBRUQsd0JBQUl3TCxNQUFKLEVBQVk7QUFDUmhKLG9DQUFZMkwsSUFBWjtBQUNIOztBQUVELDJCQUFPM0MsTUFBUDtBQUNILGlCQWhCRCxFQWdCRyxJQWhCSDtBQWlCSDs7QUFFRCxtQkFBT2hKLFNBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7MENBUWtCO0FBQ2Q7QUFDQSxnQkFBSSxDQUFDLG1CQUFTdUwsV0FBVCxDQUFxQixJQUFyQixDQUFMLEVBQWlDO0FBQzdCO0FBQ0g7O0FBRUQsZ0JBQUlxZixtQkFBbUIsS0FBS0Msb0JBQUwsRUFBdkI7QUFDQSxnQkFBSTdoQixNQUFKOztBQUVBO0FBQ0E7QUFDQSxnQkFBSTRoQixnQkFBSixFQUFzQjtBQUNsQixvQkFBSVMsZ0JBQWdCLEtBQUtOLHFCQUFMLENBQTJCSCxpQkFBaUJVLFdBQTVDLENBQXBCOztBQUVBLG9CQUFJRCxhQUFKLEVBQW1CO0FBQ2ZyaUIsNkJBQVNxaUIsY0FBY2x1QixJQUFkLENBQW1CLElBQW5CLEVBQXlCO0FBQzlCSyxnQ0FBUSxLQUFLNEosS0FBTCxDQUFXNUosTUFEVztBQUU5QnVTLHFDQUFhLEtBQUszSSxLQUFMLENBQVcySSxXQUZNO0FBRzlCQyx1Q0FBZSxLQUFLNUksS0FBTCxDQUFXNEk7QUFISSxxQkFBekIsQ0FBVDtBQUtIO0FBQ0o7O0FBRUQsZ0JBQUksQ0FBQ2hILE1BQUwsRUFBYTtBQUNULHFCQUFLa2hCLGNBQUw7QUFDQSxxQkFBS0MsSUFBTDtBQUNIO0FBQ0o7Ozs7RUF0THVCLGdCQUFNalgsUzs7QUF5TGxDOzs7Ozs7Ozs7O0FBUUF5WCxjQUFjOVgsWUFBZCxHQUE2QjtBQUN6QmxGLGNBQVUsSUFEZTtBQUV6QlcsaUJBQWEsNERBRlk7QUFHekIvSyxVQUFNO0FBQ0Y4SixpQkFBUyxDQUFDLEVBQUQsQ0FEUDtBQUVGTyxjQUFNLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FGSjtBQUdGQyxjQUFNLENBQUMsRUFBRCxFQUFLLEVBQUw7QUFISjtBQUhtQixDQUE3Qjs7QUFVQTs7Ozs7Ozs7QUFRQThjLGNBQWN4Z0IsR0FBZCxHQUFvQixRQUFwQjs7a0JBRWUsOEJBQ1gsOEJBQ0EsK0JBQ0Esa0NBQ0EsOEJBQ0EsOEJBQ0l3Z0IsYUFESixDQURBLENBREEsQ0FEQSxDQURBLENBRFcsQzs7Ozs7Ozs7Ozs7Ozs7QUMxT2QsYUFBVztBQUNSOztBQUVBOztBQUNBLFFBQUlsdEIsU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLGFBQXJCLENBQUosRUFBeUM7QUFDckM7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQUcsYUFBUzh0QixPQUFULENBQWlCM25CLEdBQWpCLENBQXFCLGFBQXJCLEVBQW9DO0FBQ2hDOzs7Ozs7QUFNQTRuQixvQkFBWSxvQkFBU2h1QixNQUFULEVBQWlCO0FBQ3pCLGdCQUFJaXVCLGtCQUFrQmp1QixPQUFPa3VCLEVBQVAsQ0FBVTluQixHQUFoQzs7QUFFQXBHLG1CQUFPa3VCLEVBQVAsQ0FBVTluQixHQUFWLEdBQWdCLFVBQVN1RSxJQUFULEVBQWU0RSxJQUFmLEVBQXFCNGUsVUFBckIsRUFBaUM7QUFDN0NGLGdDQUFnQkcsS0FBaEIsQ0FBc0IsSUFBdEIsRUFBNEJDLFNBQTVCOztBQUVBLG9CQUFJQyxjQUFjLEtBQUtDLENBQUwsQ0FBT0MsUUFBUCxDQUFnQmpmLElBQWhCLENBQWxCOztBQUVBLG9CQUFJK2UsZUFBZUEsWUFBWWxvQixHQUEvQixFQUFvQztBQUNoQ2tvQixnQ0FBWWxvQixHQUFaLENBQWdCdUUsSUFBaEIsRUFBc0J3akIsVUFBdEIsRUFBa0NudUIsTUFBbEM7QUFDQXNCLGdDQUFZNkgsb0JBQVosQ0FBaUN3QixJQUFqQyxFQUF1QzNLLE9BQU95dUIsb0JBQVAsQ0FBNEJDLE1BQTVCLENBQW1DL2pCLElBQTFFO0FBQ0g7QUFDSixhQVREO0FBVUg7QUFwQitCLEtBQXBDO0FBc0JILENBdENBLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7QUNBQyxhQUFXO0FBQ1I7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTFLLGFBQVN3TCxLQUFULENBQWV5ZSxRQUFmLEdBQTBCanFCLFNBQVN3TCxLQUFULENBQWV5ZSxRQUFmLElBQTJCLFVBQVMxaUIsUUFBVCxFQUFtQm1uQixPQUFuQixFQUE0QjVYLE9BQTVCLEVBQXFDNlgsSUFBckMsRUFBMkM7QUFDNUYsWUFBSUMsY0FBSjs7QUFFQSxZQUFJQyxTQUFTLFNBQVRBLE1BQVMsR0FBVztBQUNwQixnQkFBSUMsY0FBY2hZLFdBQVcsSUFBN0I7O0FBRUE2Ryx5QkFBYWlSLGNBQWI7O0FBRUEsZ0JBQUlyakIsU0FBUyxFQUFiOztBQUVBLGlCQUFLLElBQUl3akIsTUFBTVgsVUFBVW5uQixNQUFwQixFQUE0QituQixhQUFhLENBQTlDLEVBQWlEQSxhQUFhRCxHQUE5RCxFQUFtRSxFQUFFQyxVQUFyRSxFQUFpRjtBQUM3RXpqQix1QkFBT2xDLElBQVAsQ0FBWStrQixVQUFVWSxVQUFWLENBQVo7QUFDSDs7QUFFRCxnQkFBSUMsV0FBVzFqQixPQUFPdEMsTUFBUCxDQUFjMGxCLFFBQVEsRUFBdEIsQ0FBZjs7QUFFQUMsNkJBQWlCbG5CLFdBQVcsWUFBVztBQUNuQ0gseUJBQVM0bUIsS0FBVCxDQUFlVyxXQUFmLEVBQTRCRyxRQUE1QjtBQUNILGFBRmdCLEVBRWRQLE9BRmMsQ0FBakI7QUFHSCxTQWhCRDs7QUFrQkFHLGVBQU9yRCxNQUFQLEdBQWdCLFlBQVc7QUFDdkI3Tix5QkFBYWlSLGNBQWI7QUFDSCxTQUZEOztBQUlBLGVBQU9DLE1BQVA7QUFDSCxLQTFCRDtBQTJCSCxDQTdDQSxHQUFELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O1FBR0k1RSxRO1FBQ0FybUIsSTtRQUNBa3FCLE87UUFDQW9CLGU7UUFDQTlHLEs7UUFDQTVjLEs7UUFDQTJqQixNOzs7Ozs7Ozs7Ozs7Ozs7O0FDZkgsYUFBVztBQUNSOztBQUVBLFFBQUlDLHdCQUF3QixPQUE1QjtBQUNBLFFBQUlDLHFCQUFxQiwrQkFBekI7QUFDQSxRQUFJQyxtQkFBbUIsZ0NBQXZCOztBQUVBOzs7Ozs7O0FBT0EsYUFBU3JQLElBQVQsQ0FBY2xnQixNQUFkLEVBQXNCUixNQUF0QixFQUE4QjtBQUMxQixhQUFLNkIsT0FBTCxHQUFlckIsTUFBZjtBQUNBLGFBQUsyZ0IsY0FBTCxHQUFzQm5oQixVQUFVQSxPQUFPbWhCLGNBQVAsS0FBMEIsS0FBcEMsR0FBNEMsS0FBNUMsR0FBb0QsSUFBMUU7QUFDSDs7QUFFRFQsU0FBS2hQLFNBQUwsR0FBaUI7QUFDYnhSLHFCQUFhd2dCLElBREE7O0FBR2I7Ozs7Ozs7OztBQVNBRywwQkFBa0IsMEJBQVN4YyxJQUFULEVBQWU7QUFDN0JBLG1CQUFPQSxRQUFRLEtBQUtzYyxnQkFBTCxFQUFmOztBQUVBLGdCQUFJcVAsUUFBUSxLQUFLbnVCLE9BQUwsQ0FBYWdCLFlBQWIsR0FBNEJvdEIsU0FBNUIsR0FBd0MsQ0FBeEMsQ0FBWjs7QUFFQSxnQkFBSTVyQixJQUFKLEVBQVU7QUFDTjJyQixzQkFBTUUsb0JBQU4sQ0FBMkI3ckIsSUFBM0I7O0FBRUEsb0JBQUk4ckIsV0FBV0gsTUFBTUksbUJBQU4sRUFBZjs7QUFFQSxvQkFBSUQsWUFBWSxDQUFDLEtBQUt0dUIsT0FBTCxDQUFha1AsT0FBYixDQUFxQnNmLE1BQXJCLENBQTRCRixTQUFTRyxpQkFBVCxDQUEyQmpzQixJQUEzQixDQUE1QixDQUFqQixFQUFnRjtBQUM1RSx3QkFBSWtzQixhQUFhLEtBQUtobEIsSUFBTCxDQUFVNGtCLFNBQVNLLE9BQVQsRUFBVixDQUFqQjs7QUFFQSx3QkFBSUMsU0FBU0YsYUFBYUEsV0FBV3BlLEtBQVgsR0FBbUIsQ0FBaEMsR0FBb0MsQ0FBakQ7O0FBRUE2ZCwwQkFBTVUsUUFBTixDQUFlUCxRQUFmLEVBQXlCTSxNQUF6QjtBQUNBVCwwQkFBTVcsTUFBTixDQUFhUixRQUFiLEVBQXVCTSxNQUF2QjtBQUNIO0FBQ0o7O0FBRUQsaUJBQUs1dUIsT0FBTCxDQUFhZ0IsWUFBYixHQUE0Qit0QixZQUE1QixDQUF5QyxDQUFDWixLQUFELENBQXpDO0FBQ0gsU0FqQ1k7O0FBbUNiOzs7Ozs7Ozs7O0FBVUF6TyxnQkFBUSxnQkFBU3NQLEdBQVQsRUFBY3ZlLEtBQWQsRUFBcUIrTyxlQUFyQixFQUFzQztBQUMxQyxnQkFBSXJlLFlBQVksS0FBS25CLE9BQUwsQ0FBYWdCLFlBQWIsRUFBaEI7O0FBRUEsZ0JBQUltdEIsUUFBUWh0QixVQUFVaXRCLFNBQVYsR0FBc0IsQ0FBdEIsQ0FBWjs7QUFFQSxnQkFBSUQsTUFBTWMsU0FBVixFQUFxQjtBQUNqQixvQkFBSUMsT0FBTyxJQUFJdHdCLFNBQVN5RCxHQUFULENBQWE2c0IsSUFBakIsQ0FBc0JGLEdBQXRCLEVBQTJCLEtBQUtodkIsT0FBTCxDQUFhaUIsUUFBeEMsQ0FBWDtBQUNBa3RCLHNCQUFNZ0IsVUFBTixDQUFpQkQsSUFBakI7QUFDQWYsc0JBQU1pQixrQkFBTixDQUF5QkYsSUFBekI7QUFDSDs7QUFFREYsa0JBQU0sS0FBS0ssZUFBTCxDQUFxQkwsR0FBckIsQ0FBTjs7QUFFQSxnQkFBSXpQLFlBQVkzZ0IsU0FBU3dMLEtBQVQsQ0FBZUMsS0FBZixDQUFxQjtBQUNqQyx1Q0FBdUIya0IsR0FEVTtBQUVqQ3RzQixzQkFBTXNzQjtBQUYyQixhQUFyQixFQUdidmUsS0FIYSxDQUFoQjs7QUFLQSxnQkFBSWpHLFFBQVEsSUFBSTVMLFNBQVM0TCxLQUFiLENBQW1CO0FBQzNCN0gsNEJBQVk0YyxTQURlO0FBRTNCclEseUJBQVM7QUFGa0IsYUFBbkIsQ0FBWjs7QUFLQTFFLGtCQUFNMEQsSUFBTixHQUFhdFAsU0FBU3dqQixZQUF0QjtBQUNBNVgsa0JBQU04a0IsWUFBTixDQUFtQm5CLEtBQW5CLEVBQTBCLEtBQUtudUIsT0FBL0I7O0FBRUEsZ0JBQUl3ZixtQkFBbUJBLGdCQUFnQkosT0FBdkMsRUFBZ0Q7QUFDNUMscUJBQUtKLGdCQUFMO0FBQ0gsYUFGRCxNQUVPO0FBQ0htUCxzQkFBTW9CLE1BQU47QUFDSDtBQUNKLFNBNUVZOztBQThFYjs7Ozs7Ozs7QUFRQXpRLDBCQUFrQiw0QkFBVztBQUN6QixnQkFBSTNkLFlBQVksS0FBS25CLE9BQUwsQ0FBYWdCLFlBQWIsRUFBaEI7O0FBRUEsZ0JBQUkyWCxrQkFBa0J4WCxVQUFVeVgsa0JBQVYsRUFBdEI7O0FBRUEsZ0JBQUlELG1CQUFtQkEsZ0JBQWdCNlcsRUFBaEIsQ0FBbUIsR0FBbkIsQ0FBdkIsRUFBZ0Q7QUFDNUMsdUJBQU83VyxlQUFQO0FBQ0g7O0FBRUQsZ0JBQUl3VixRQUFRaHRCLFVBQVVpdEIsU0FBVixHQUFzQixDQUF0QixDQUFaOztBQUVBLGdCQUFJRCxLQUFKLEVBQVc7QUFDUEEsc0JBQU1zQixNQUFOLENBQWE3d0IsU0FBUzh3QixXQUF0Qjs7QUFFQSx1QkFBTyxLQUFLMXZCLE9BQUwsQ0FBYXNDLFdBQWIsQ0FBeUI2ckIsTUFBTU0saUJBQU4sRUFBekIsRUFBb0Q5RCxRQUFwRCxDQUE2RCxHQUE3RCxFQUFrRSxDQUFsRSxDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNILFNBeEdZOztBQTBHYjs7Ozs7Ozs7O0FBU0ExUSxnQkFBUSxnQkFBU3pYLElBQVQsRUFBZWdkLGVBQWYsRUFBZ0M7QUFDcEMsZ0JBQUk3Z0IsU0FBUyxLQUFLcUIsT0FBbEI7O0FBRUEsZ0JBQUl3QyxJQUFKLEVBQVU7QUFDTixvQkFBSWdkLG1CQUFtQkEsZ0JBQWdCSixPQUF2QyxFQUFnRDtBQUM1Qyx5QkFBS0osZ0JBQUw7QUFDSDs7QUFFRHhjLHFCQUFLeVgsTUFBTCxDQUFZdGIsTUFBWjtBQUNILGFBTkQsTUFNTztBQUNILG9CQUFJNkwsUUFBUSxJQUFJNUwsU0FBUzRMLEtBQWIsQ0FBbUI7QUFDM0JtbEIseUNBQXFCLENBRE07QUFFM0J6Z0IsNkJBQVMsR0FGa0I7QUFHM0JoQiwwQkFBTXRQLFNBQVN3akI7QUFIWSxpQkFBbkIsQ0FBWjs7QUFNQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQUlqaEIsWUFBWXhDLE9BQU9xQyxZQUFQLEVBQWhCO0FBQ0FHLDBCQUFVeXVCLGFBQVYsQ0FBd0J6dUIsVUFBVTB1QixlQUFWLEVBQXhCOztBQUVBbHhCLHVCQUFPOEosV0FBUCxDQUFtQitCLEtBQW5CO0FBQ0g7QUFDSixTQTVJWTs7QUE4SWI7Ozs7Ozs7Ozs7QUFVQWlWLGdCQUFRLGdCQUFTaFAsS0FBVCxFQUFnQmpPLElBQWhCLEVBQXNCZ2QsZUFBdEIsRUFBdUM7QUFDM0MsZ0JBQUl0QyxXQUFZLElBQWhCOztBQUVBMWEsbUJBQU9BLFFBQVEsS0FBS3NjLGdCQUFMLEVBQWY7O0FBRUEsZ0JBQUksT0FBT3JPLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0Isb0JBQUlxZixNQUFNNVMsU0FBU21TLGVBQVQsQ0FBeUI1ZSxLQUF6QixDQUFWOztBQUVBak8scUJBQUt1dEIsYUFBTCxDQUFtQjtBQUNmLDJDQUF1QkQsR0FEUjtBQUVmcHRCLDBCQUFNb3RCO0FBRlMsaUJBQW5CO0FBSUgsYUFQRCxNQU9PLElBQUksUUFBT3JmLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBckIsRUFBK0I7QUFDbEMsb0JBQUl1ZixjQUFjLEVBQWxCOztBQUVBLG9CQUFJQyxXQUFXLEVBQWY7O0FBRUE1Rix1QkFBTzNsQixJQUFQLENBQVkrTCxLQUFaLEVBQW1CWCxPQUFuQixDQUEyQixVQUFTeEUsR0FBVCxFQUFjO0FBQ3JDLHdCQUFJbUYsTUFBTW5GLEdBQU4sTUFBZSxJQUFuQixFQUF5QjtBQUNyQiw0QkFBSUEsUUFBUSxNQUFaLEVBQW9CO0FBQ2hCMGtCLHdDQUFZL25CLElBQVosQ0FBaUIscUJBQWpCO0FBQ0g7O0FBRUQrbkIsb0NBQVkvbkIsSUFBWixDQUFpQnFELEdBQWpCO0FBQ0gscUJBTkQsTUFNTztBQUNILDRCQUFJQSxRQUFRLE1BQVosRUFBb0I7QUFDaEIsZ0NBQUl3a0IsTUFBTTVTLFNBQVNtUyxlQUFULENBQXlCNWUsTUFBTW5GLEdBQU4sQ0FBekIsQ0FBVjs7QUFFQTJrQixxQ0FBUyxxQkFBVCxJQUFrQ0gsR0FBbEM7QUFDQUcscUNBQVMza0IsR0FBVCxJQUFnQndrQixHQUFoQjtBQUNILHlCQUxELE1BS087QUFDSEcscUNBQVMza0IsR0FBVCxJQUFnQm1GLE1BQU1uRixHQUFOLENBQWhCO0FBQ0g7QUFDSjtBQUNKLGlCQWpCRDs7QUFtQkE5SSxxQkFBSzB0QixnQkFBTCxDQUFzQkYsV0FBdEI7QUFDQXh0QixxQkFBS3V0QixhQUFMLENBQW1CRSxRQUFuQjtBQUNIOztBQUVELGdCQUFJelEsbUJBQW1CQSxnQkFBZ0JKLE9BQXZDLEVBQWdEO0FBQzVDLHFCQUFLSixnQkFBTCxDQUFzQnhjLElBQXRCO0FBQ0g7QUFDSixTQW5NWTs7QUFxTWI7Ozs7Ozs7Ozs7Ozs7O0FBY0E2c0IseUJBQWlCLHlCQUFTTCxHQUFULEVBQWM7QUFDM0IsZ0JBQUloQixzQkFBc0J4bUIsSUFBdEIsQ0FBMkJ3bkIsR0FBM0IsQ0FBSixFQUFxQztBQUNqQyx1QkFBT0EsR0FBUDtBQUNILGFBRkQsTUFFTyxJQUFJZixtQkFBbUJ6bUIsSUFBbkIsQ0FBd0J3bkIsR0FBeEIsQ0FBSixFQUFrQztBQUNyQ0Esc0JBQU0sWUFBWUEsR0FBbEI7QUFDSCxhQUZNLE1BRUEsSUFBSSxDQUFDZCxpQkFBaUIxbUIsSUFBakIsQ0FBc0J3bkIsR0FBdEIsQ0FBTCxFQUFpQztBQUNwQ0Esc0JBQU0sS0FBSzFQLGNBQUwsR0FBc0IsWUFBWTBQLEdBQWxDLEdBQXdDQSxHQUE5QztBQUNIOztBQUVELG1CQUFPQSxHQUFQO0FBQ0g7QUE3TlksS0FBakI7O0FBZ09BcHdCLGFBQVNpZ0IsSUFBVCxHQUFnQmpnQixTQUFTaWdCLElBQVQsSUFBaUJBLElBQWpDO0FBQ0gsQ0FwUEEsR0FBRCxDOzs7Ozs7Ozs7Ozs7OztBQ0FDLGFBQVc7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsUUFBSXNSLHNCQUFzQixTQUF0QkEsbUJBQXNCLENBQVM5QyxNQUFULEVBQWlCO0FBQ3ZDLFlBQUkrQyxVQUFVLENBQUMsWUFBRCxFQUFlLE1BQWYsRUFBdUIsV0FBdkIsQ0FBZDs7QUFFQUEsZ0JBQVF0Z0IsT0FBUixDQUFnQixVQUFTdWdCLFVBQVQsRUFBcUI7QUFDakMsZ0JBQUloRCxPQUFPZ0QsVUFBUCxDQUFKLEVBQXdCO0FBQ3BCaEQsdUJBQU9nRCxVQUFQLElBQXFCenhCLFNBQVN3TCxLQUFULENBQWVrbUIsUUFBZixDQUF3QmpELE9BQU9nRCxVQUFQLENBQXhCLEVBQTRDLFVBQVNFLG9CQUFULEVBQStCO0FBQzVGLHdCQUFJQyxVQUFVO0FBQ1ZDLCtCQUFPSixVQURHO0FBRVZoRCxnQ0FBUUE7QUFGRSxxQkFBZDs7QUFLQSwyQkFBTyxVQUFTMXVCLE1BQVQsRUFBaUI7QUFDcEJBLCtCQUFPeXVCLG9CQUFQLEdBQThCb0QsT0FBOUI7O0FBRUFELDZDQUFxQmp5QixJQUFyQixDQUEwQixJQUExQixFQUFnQ0ssTUFBaEM7O0FBRUFBLCtCQUFPeXVCLG9CQUFQLEdBQThCLElBQTlCO0FBQ0gscUJBTkQ7QUFPSCxpQkFib0IsQ0FBckI7QUFjSDtBQUNKLFNBakJEO0FBa0JILEtBckJEOztBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJc0QsNkJBQTZCLFNBQTdCQSwwQkFBNkIsQ0FBU0MsUUFBVCxFQUFtQjtBQUNoRCxZQUFJLE9BQU9BLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDOUJBLHVCQUFXQSxTQUFTbG1CLEtBQVQsQ0FBZSxHQUFmLENBQVg7QUFDSDs7QUFFRCxlQUFPa21CLFNBQVN4bEIsTUFBVCxDQUFnQixVQUFTeWxCLE9BQVQsRUFBa0I7QUFDckMsbUJBQU9BLFlBQVksU0FBbkI7QUFDSCxTQUZNLENBQVA7QUFHSCxLQVJEOztBQVVBOzs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7OztBQWFBaHlCLGFBQVM4dEIsT0FBVCxDQUFpQnpsQixJQUFqQixHQUF3QnJJLFNBQVN3TCxLQUFULENBQWVrbUIsUUFBZixDQUF3QjF4QixTQUFTOHRCLE9BQVQsQ0FBaUJ6bEIsSUFBekMsRUFBK0MsVUFBUzRwQixXQUFULEVBQXFCO0FBQ3hGO0FBQ0E7QUFDQSxlQUFPLFVBQVNDLEtBQVQsRUFBZ0IzcUIsUUFBaEIsRUFBMEI0cUIsS0FBMUIsRUFBaUM7QUFDcENGLHdCQUFZdnlCLElBQVosQ0FBaUIsSUFBakIsRUFBdUJ3eUIsS0FBdkIsRUFBOEIsVUFBU3BFLE9BQVQsRUFBa0I7QUFDNUMsb0JBQUl2bUIsUUFBSixFQUFjO0FBQ1Zra0IsMkJBQU8zbEIsSUFBUCxDQUFZZ29CLE9BQVosRUFBcUI1YyxPQUFyQixDQUE2QixVQUFTOUgsVUFBVCxFQUFxQjtBQUM5Qyw0QkFBSXFsQixTQUFTWCxRQUFRMWtCLFVBQVIsQ0FBYjs7QUFFQSw0QkFBSXFsQixPQUFPc0QsUUFBWCxFQUFxQjtBQUNqQnRELG1DQUFPc0QsUUFBUCxHQUFrQkQsMkJBQTJCckQsT0FBT3NELFFBQWxDLENBQWxCO0FBQ0g7O0FBRURSLDRDQUFvQjlDLE1BQXBCO0FBQ0gscUJBUkQ7O0FBVUFsbkIsNkJBQVM3SCxJQUFULENBQWN5eUIsS0FBZCxFQUFxQnJFLE9BQXJCO0FBQ0g7QUFDSixhQWREO0FBZUgsU0FoQkQ7QUFpQkgsS0FwQnVCLENBQXhCO0FBcUJILENBeEZBLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7QUNBQyxhQUFXO0FBQ1I7O0FBRUEsUUFBSTl0QixTQUFTOHRCLE9BQVQsQ0FBaUJqdUIsR0FBakIsQ0FBcUIsb0JBQXJCLENBQUosRUFBZ0Q7QUFDNUM7QUFDSDs7QUFFREcsYUFBU21OLHVCQUFULEdBQW1DLENBQW5DO0FBQ0FuTixhQUFTOFMsdUJBQVQsR0FBbUMsQ0FBbkM7QUFDQTlTLGFBQVM0VCx1QkFBVCxHQUFtQyxDQUFuQztBQUNBNVQsYUFBUzZULHVCQUFULEdBQW1DLENBQW5DOztBQUVBOzs7Ozs7Ozs7QUFTQSxhQUFTdWUsZUFBVCxHQUEyQixDQUFFOztBQUU3QkEsb0JBQWdCbmhCLFNBQWhCLEdBQTRCO0FBQ3hCeFIscUJBQWEyeUIsZUFEVzs7QUFHeEI7Ozs7Ozs7OztBQVNBQyxrQ0FBMEIsa0NBQVNyZ0IsQ0FBVCxFQUFZRSxDQUFaLEVBQWU7QUFDckMsaUJBQUtvZ0Isd0JBQUwsQ0FBOEJ0Z0IsQ0FBOUIsRUFBaUNFLENBQWpDLEVBQW9DRixDQUFwQyxFQUF1Q0UsQ0FBdkM7QUFDSCxTQWR1Qjs7QUFnQnhCOzs7Ozs7Ozs7OztBQVdBb2dCLGtDQUEwQixrQ0FBU0MsTUFBVCxFQUFpQkMsTUFBakIsRUFBeUJDLElBQXpCLEVBQStCQyxJQUEvQixFQUFxQztBQUMzRCxnQkFBSUMsR0FBSjtBQUNBLGdCQUFJQyxZQUFKO0FBQ0EsZ0JBQUlDLFNBQUo7QUFDQSxnQkFBSXRELEtBQUo7QUFDQSxnQkFBSXVELEtBQUo7QUFDQSxnQkFBSUMsY0FBSjtBQUNBLGdCQUFJQyxXQUFKOztBQUVBLGdCQUFJLE9BQU8zd0IsU0FBUzR3QixzQkFBaEIsS0FBMkMsVUFBL0MsRUFBMkQ7QUFDdkRILHdCQUFRendCLFNBQVM0d0Isc0JBQVQsQ0FBZ0NWLE1BQWhDLEVBQXdDQyxNQUF4QyxDQUFSO0FBQ0FHLHNCQUFNdHdCLFNBQVM0d0Isc0JBQVQsQ0FBZ0NSLElBQWhDLEVBQXNDQyxJQUF0QyxDQUFOOztBQUVBSyxpQ0FBaUJELE1BQU1JLFVBQXZCO0FBQ0FOLCtCQUFlRCxJQUFJTyxVQUFuQjs7QUFFQUYsOEJBQWNGLE1BQU05QyxNQUFwQjtBQUNBNkMsNEJBQVlGLElBQUkzQyxNQUFoQjs7QUFFQVQsd0JBQVEsS0FBSzRELFdBQUwsRUFBUjtBQUNILGFBWEQsTUFXTyxJQUFJLE9BQU85d0IsU0FBUyt3QixtQkFBaEIsS0FBd0MsVUFBNUMsRUFBd0Q7QUFDM0ROLHdCQUFRendCLFNBQVMrd0IsbUJBQVQsQ0FBNkJiLE1BQTdCLEVBQXFDQyxNQUFyQyxDQUFSO0FBQ0FHLHNCQUFNdHdCLFNBQVMrd0IsbUJBQVQsQ0FBNkJYLElBQTdCLEVBQW1DQyxJQUFuQyxDQUFOOztBQUVBSyxpQ0FBaUJELE1BQU1DLGNBQXZCO0FBQ0FILCtCQUFlRCxJQUFJSSxjQUFuQjs7QUFFQUMsOEJBQWNGLE1BQU1FLFdBQXBCO0FBQ0FILDRCQUFZRixJQUFJSyxXQUFoQjs7QUFFQXpELHdCQUFRLEtBQUs0RCxXQUFMLEVBQVI7QUFDSDs7QUFFRCxnQkFBSTVELFNBQVNsdEIsU0FBU0QsWUFBdEIsRUFBb0M7QUFDaENtdEIsc0JBQU1VLFFBQU4sQ0FBZSxJQUFJandCLFNBQVN5RCxHQUFULENBQWE3RCxJQUFqQixDQUFzQm16QixjQUF0QixDQUFmLEVBQXNEQyxXQUF0RDtBQUNBekQsc0JBQU1XLE1BQU4sQ0FBYSxJQUFJbHdCLFNBQVN5RCxHQUFULENBQWE3RCxJQUFqQixDQUFzQmd6QixZQUF0QixDQUFiLEVBQWtEQyxTQUFsRDs7QUFFQSxxQkFBS3p3QixZQUFMLEdBQW9CK3RCLFlBQXBCLENBQWlDLENBQUNaLEtBQUQsQ0FBakM7QUFDSCxhQUxELE1BS08sSUFBSSxPQUFPbHRCLFNBQVNxQyxJQUFULENBQWMydUIsZUFBckIsS0FBeUMsVUFBN0MsRUFBeUQ7QUFDNUQsb0JBQUk5d0IsWUFBWSxLQUFLSCxZQUFMLEVBQWhCOztBQUVBRywwQkFBVXdILE1BQVY7O0FBRUF3bEIsd0JBQVFsdEIsU0FBU3FDLElBQVQsQ0FBYzJ1QixlQUFkLEVBQVI7QUFDQTlELHNCQUFNdmEsV0FBTixDQUFrQnVkLE1BQWxCLEVBQTBCQyxNQUExQjs7QUFFQSxvQkFBSWMsV0FBVy9ELE1BQU1nRSxTQUFOLEVBQWY7QUFDQUQseUJBQVN0ZSxXQUFULENBQXFCeWQsSUFBckIsRUFBMkJDLElBQTNCOztBQUVBbkQsc0JBQU1pRSxXQUFOLENBQWtCLFVBQWxCLEVBQThCRixRQUE5QjtBQUNBL0Qsc0JBQU1vQixNQUFOOztBQUVBLHFCQUFLdnVCLFlBQUwsR0FBb0J3SCxJQUFwQjtBQUNIO0FBQ0osU0FqRnVCOztBQW1GeEI7Ozs7Ozs7Ozs7OztBQVlBNnBCLHdCQUFnQiwwQkFBVztBQUN2QixnQkFBSWx4QixZQUFZLEtBQUtILFlBQUwsRUFBaEI7O0FBRUEsZ0JBQUl1USxTQUFTO0FBQ1RjLHdCQUFRLENBREM7QUFFVHhCLHNCQUFNLENBRkc7QUFHVGlCLHVCQUFPLENBSEU7QUFJVGYscUJBQUs7QUFKSSxhQUFiOztBQU9BLGdCQUFJbU8sWUFBWS9kLFVBQVVnZSxlQUFWLEVBQWhCOztBQUVBLGdCQUFJLENBQUNELFVBQVVyWixNQUFmLEVBQXVCO0FBQ25CLHVCQUFPMEwsTUFBUDtBQUNIOztBQUVELGdCQUFJK2dCLGlCQUFpQnBULFVBQVUsQ0FBVixFQUFhcVQsU0FBYixDQUF1QnJ4QixDQUE1Qzs7QUFFQW94QiwyQkFBZTluQixLQUFmLENBQXFCMlEsT0FBckIsR0FBK0IsY0FBL0I7O0FBRUE1SixxQkFBUyxJQUFJM1MsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWpCLENBQXlCb2pCLGNBQXpCLEVBQXlDOUcsYUFBekMsRUFBVDs7QUFFQThHLDJCQUFlOXhCLFVBQWYsQ0FBMEJDLFdBQTFCLENBQXNDNnhCLGNBQXRDOztBQUVBLGdCQUFJRSxZQUFZLElBQUk1ekIsU0FBU3lELEdBQVQsQ0FBYXRCLE1BQWpCLENBQXdCQSxNQUF4QixFQUFnQzB4QixpQkFBaEMsRUFBaEI7O0FBRUFsaEIsbUJBQU9jLE1BQVAsR0FBZ0JtZ0IsVUFBVTFoQixDQUFWLEdBQWNTLE9BQU9jLE1BQXJDO0FBQ0FkLG1CQUFPVixJQUFQLEdBQWMyaEIsVUFBVTVoQixDQUFWLEdBQWNXLE9BQU9WLElBQW5DO0FBQ0FVLG1CQUFPTyxLQUFQLEdBQWUwZ0IsVUFBVTVoQixDQUFWLEdBQWNXLE9BQU9PLEtBQXBDO0FBQ0FQLG1CQUFPUixHQUFQLEdBQWF5aEIsVUFBVTFoQixDQUFWLEdBQWNTLE9BQU9SLEdBQWxDOztBQUVBLG1CQUFPUSxNQUFQO0FBQ0gsU0EvSHVCOztBQWlJeEI7Ozs7Ozs7Ozs7O0FBV0FnWiwwQkFBa0IsNEJBQVc7QUFDekIsZ0JBQUlwcEIsWUFBWSxLQUFLSCxZQUFMLEVBQWhCOztBQUVBLGdCQUFJLENBQUNHLFVBQVV1eEIsU0FBVixFQUFMLEVBQTRCO0FBQ3hCLHVCQUFPLElBQVA7QUFDSDs7QUFFRCxnQkFBSXZvQixTQUFTO0FBQ1QrRSx5QkFBUy9OLFVBQVV5WCxrQkFBVixFQURBO0FBRVRzVyxzQkFBTS90QixVQUFVMm1CLGVBQVY7QUFGRyxhQUFiOztBQUtBM2QsbUJBQU9vSCxNQUFQLEdBQWdCLEtBQUtvaEIsa0JBQUwsQ0FBd0J4eEIsU0FBeEIsQ0FBaEI7O0FBRUEsbUJBQU9nSixNQUFQO0FBQ0gsU0EzSnVCOztBQTZKeEI7Ozs7Ozs7Ozs7Ozs7O0FBY0F3b0IsNEJBQW9CLDhCQUFXO0FBQzNCLGdCQUFJcGhCLFNBQVMsS0FBS3FoQixvQkFBTCxFQUFiOztBQUVBcmhCLG1CQUFPekYsU0FBUCxHQUFtQixLQUFLK21CLHFCQUFMLEVBQW5COztBQUVBdGhCLG1CQUFPb0MsTUFBUCxHQUFnQnBDLE9BQU9jLE1BQVAsR0FBZ0JkLE9BQU9SLEdBQXZDO0FBQ0FRLG1CQUFPUCxLQUFQLEdBQWVPLE9BQU9PLEtBQVAsR0FBZVAsT0FBT1YsSUFBckM7O0FBRUEsbUJBQU9VLE1BQVA7QUFDSCxTQXBMdUI7O0FBc0x4Qjs7Ozs7Ozs7QUFRQXVoQiwwQkFBa0IsNEJBQVc7QUFDekIsZ0JBQUlDLE1BQUo7O0FBRUEsZ0JBQUk1eEIsWUFBWSxLQUFLSCxZQUFMLEVBQWhCOztBQUVBLG1CQUFRRyxVQUFVNnhCLE9BQVYsT0FBd0JwMEIsU0FBU3EwQixjQUFsQyxJQUNGLENBQUNGLFNBQVM1eEIsVUFBVWl0QixTQUFWLEVBQVYsS0FBb0MyRSxPQUFPbHRCLE1BQVAsS0FBa0IsQ0FBdEQsSUFBMkRrdEIsT0FBTyxDQUFQLEVBQVU5RCxTQUQxRTtBQUVILFNBck11Qjs7QUF1TXhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTJELDhCQUFzQixnQ0FBVztBQUM3QixnQkFBSXp4QixZQUFZLEtBQUtILFlBQUwsRUFBaEI7QUFDQSxnQkFBSWt5QixrQkFBa0IveEIsVUFBVXV4QixTQUFWLEVBQXRCOztBQUVBLGdCQUFJUyxjQUFjO0FBQ2Q5Z0Isd0JBQVEsQ0FETTtBQUVkc0Isd0JBQVEsQ0FGTTtBQUdkOUMsc0JBQU0sQ0FIUTtBQUlkaUIsdUJBQU8sQ0FKTztBQUtkZixxQkFBSyxDQUxTO0FBTWRDLHVCQUFPO0FBTk8sYUFBbEI7O0FBU0EsZ0JBQUlPLFNBQVM7QUFDVGMsd0JBQVEsQ0FEQztBQUVUYix5QkFBUzJoQixXQUZBO0FBR1R0aUIsc0JBQU0sQ0FIRztBQUlUaUIsdUJBQU8sQ0FKRTtBQUtUZixxQkFBSyxDQUxJO0FBTVRVLDJCQUFXMGhCO0FBTkYsYUFBYjs7QUFTQSxnQkFBSSxDQUFDRCxlQUFMLEVBQXNCO0FBQ2xCLHVCQUFPM2hCLE1BQVA7QUFDSDs7QUFFRCxnQkFBSWMsU0FBUyxDQUFiO0FBQ0EsZ0JBQUkrZ0IsV0FBSjtBQUNBLGdCQUFJdmlCLE9BQU93aUIsUUFBWDtBQUNBLGdCQUFJQyxVQUFKO0FBQ0EsZ0JBQUl4aEIsUUFBUSxDQUFDdWhCLFFBQWI7QUFDQSxnQkFBSXRpQixNQUFNc2lCLFFBQVY7O0FBRUEsZ0JBQUlILGdCQUFnQm5CLFdBQXBCLEVBQWlDO0FBQzdCcUIsOEJBQWNGLGdCQUFnQm5CLFdBQWhCLEdBQThCd0IsY0FBOUIsRUFBZDtBQUNILGFBRkQsTUFFTztBQUNIRCw2QkFBYUosZ0JBQWdCSSxVQUE3QjtBQUNBRiw4QkFBZUYsZ0JBQWdCSSxVQUFoQixHQUE2QixDQUE5QixHQUFtQ0osZ0JBQWdCTSxVQUFoQixDQUEyQixDQUEzQixFQUE4QkQsY0FBOUIsRUFBbkMsR0FBb0YsRUFBbEc7QUFDSDs7QUFFRCxnQkFBSUgsWUFBWXZ0QixNQUFaLEtBQXVCLENBQTNCLEVBQThCO0FBQzFCMEwseUJBQVMsS0FBSzhnQixjQUFMLEVBQVQ7QUFDSCxhQUZELE1BRU87QUFDSCxxQkFBSyxJQUFJenNCLElBQUksQ0FBUixFQUFXQyxTQUFTdXRCLFlBQVl2dEIsTUFBckMsRUFBNkNELElBQUlDLE1BQWpELEVBQXlERCxHQUF6RCxFQUE4RDtBQUMxRCx3QkFBSWtILE9BQU9zbUIsWUFBWXh0QixDQUFaLENBQVg7O0FBRUEsd0JBQUlrSCxLQUFLK0QsSUFBTCxHQUFZQSxJQUFoQixFQUFzQjtBQUNsQkEsK0JBQU8vRCxLQUFLK0QsSUFBWjtBQUNIOztBQUVELHdCQUFJL0QsS0FBS2dGLEtBQUwsR0FBYUEsS0FBakIsRUFBd0I7QUFDcEJBLGdDQUFRaEYsS0FBS2dGLEtBQWI7QUFDSDs7QUFFRCx3QkFBSWhGLEtBQUtpRSxHQUFMLEdBQVdBLEdBQWYsRUFBb0I7QUFDaEJBLDhCQUFNakUsS0FBS2lFLEdBQVg7QUFDSDs7QUFFRCx3QkFBSWpFLEtBQUt1RixNQUFMLEdBQWNBLE1BQWxCLEVBQTBCO0FBQ3RCQSxpQ0FBU3ZGLEtBQUt1RixNQUFkO0FBQ0g7QUFDSjs7QUFFRCxvQkFBSW1nQixZQUFZLElBQUk1ekIsU0FBU3lELEdBQVQsQ0FBYXRCLE1BQWpCLENBQXdCQSxNQUF4QixFQUFnQzB4QixpQkFBaEMsRUFBaEI7O0FBRUFsaEIsdUJBQU9jLE1BQVAsR0FBZ0JtZ0IsVUFBVTFoQixDQUFWLEdBQWN1QixNQUE5QjtBQUNBZCx1QkFBT1YsSUFBUCxHQUFjMmhCLFVBQVU1aEIsQ0FBVixHQUFjQyxJQUE1QjtBQUNBVSx1QkFBT08sS0FBUCxHQUFlMGdCLFVBQVU1aEIsQ0FBVixHQUFja0IsS0FBN0I7QUFDQVAsdUJBQU9SLEdBQVAsR0FBYXloQixVQUFVMWhCLENBQVYsR0FBY0MsR0FBM0I7O0FBRUEsb0JBQUlxaUIsWUFBWXZ0QixNQUFoQixFQUF3QjtBQUNwQix3QkFBSTJMLFVBQVU0aEIsWUFBWUEsWUFBWXZ0QixNQUFaLEdBQXFCLENBQWpDLENBQWQ7QUFDQSx3QkFBSTRMLFlBQVkyaEIsWUFBWSxDQUFaLENBQWhCOztBQUVBN2hCLDJCQUFPQyxPQUFQLEdBQWlCO0FBQ2JhLGdDQUFRbWdCLFVBQVUxaEIsQ0FBVixHQUFjVSxRQUFRYSxNQURqQjtBQUVic0IsZ0NBQVFuQyxRQUFRbUMsTUFGSDtBQUdiOUMsOEJBQU0yaEIsVUFBVTVoQixDQUFWLEdBQWNZLFFBQVFYLElBSGY7QUFJYmlCLCtCQUFPMGdCLFVBQVU1aEIsQ0FBVixHQUFjWSxRQUFRTSxLQUpoQjtBQUtiZiw2QkFBS3loQixVQUFVMWhCLENBQVYsR0FBY1UsUUFBUVQsR0FMZDtBQU1iQywrQkFBT1EsUUFBUVI7QUFORixxQkFBakI7O0FBU0FPLDJCQUFPRSxTQUFQLEdBQW1CO0FBQ2ZZLGdDQUFRbWdCLFVBQVUxaEIsQ0FBVixHQUFjVyxVQUFVWSxNQURqQjtBQUVmc0IsZ0NBQVFsQyxVQUFVa0MsTUFGSDtBQUdmOUMsOEJBQU0yaEIsVUFBVTVoQixDQUFWLEdBQWNhLFVBQVVaLElBSGY7QUFJZmlCLCtCQUFPMGdCLFVBQVU1aEIsQ0FBVixHQUFjYSxVQUFVSyxLQUpoQjtBQUtmZiw2QkFBS3loQixVQUFVMWhCLENBQVYsR0FBY1csVUFBVVYsR0FMZDtBQU1mQywrQkFBT1MsVUFBVVQ7QUFORixxQkFBbkI7QUFRSDtBQUNKOztBQUVELG1CQUFPTyxNQUFQO0FBQ0gsU0FuVXVCOztBQXFVeEI7Ozs7Ozs7Ozs7O0FBV0FzaEIsK0JBQXVCLGlDQUFXO0FBQzlCLGdCQUFJL21CLFlBQVlsTixTQUFTbU4sdUJBQXpCO0FBQ0EsZ0JBQUk1SyxZQUFZLEtBQUtILFlBQUwsRUFBaEI7QUFDQSxnQkFBSWt5QixrQkFBa0IveEIsVUFBVXV4QixTQUFWLEVBQXRCOztBQUVBLGdCQUFJLENBQUNRLGVBQUwsRUFBc0I7QUFDbEIsdUJBQU9wbkIsU0FBUDtBQUNIOztBQUVELGdCQUFJMm5CLFVBQUo7O0FBRUEsZ0JBQUksQ0FBQ0EsYUFBYVAsZ0JBQWdCTyxVQUE5QixLQUE2Q0EsV0FBV0MsdUJBQTVELEVBQXFGO0FBQ2pGLG9CQUFJaEksV0FBVytILFdBQVdDLHVCQUFYLENBQW1DUixnQkFBZ0JTLFNBQW5ELENBQWY7O0FBRUEsb0JBQUksQ0FBQ2pJLFFBQUQsSUFBYXdILGdCQUFnQlUsWUFBaEIsR0FBK0JWLGdCQUFnQlcsV0FBNUQsSUFBMkVuSSxhQUFhb0ksS0FBS0MsMkJBQWpHLEVBQThIO0FBQzFIam9CLGdDQUFZbE4sU0FBUzhTLHVCQUFyQjtBQUNIO0FBQ0o7O0FBRUQsbUJBQU81RixTQUFQO0FBQ0g7QUFwV3VCLEtBQTVCOztBQXVXQWxOLGFBQVM4dEIsT0FBVCxDQUFpQjNuQixHQUFqQixDQUNJLG9CQURKLEVBQzBCO0FBQ2xCaXZCLGNBQU0sY0FBU3IxQixNQUFULEVBQWlCO0FBQ25CLGdCQUFJczFCLElBQUosRUFDSUMsY0FESjs7QUFHQUEsNkJBQWlCN0osT0FBT3hhLFNBQVAsQ0FBaUJxa0IsY0FBbEM7O0FBRUEsaUJBQUtELElBQUwsSUFBYWpELGdCQUFnQm5oQixTQUE3QixFQUF3QztBQUNwQyxvQkFBSXFrQixlQUFlNTFCLElBQWYsQ0FBb0IweUIsZ0JBQWdCbmhCLFNBQXBDLEVBQStDb2tCLElBQS9DLEtBQXdELE9BQU90MUIsT0FBT3MxQixJQUFQLENBQVAsS0FBd0IsV0FBcEYsRUFBaUc7QUFDN0Z0MUIsMkJBQU9zMUIsSUFBUCxJQUFlakQsZ0JBQWdCbmhCLFNBQWhCLENBQTBCb2tCLElBQTFCLENBQWY7QUFDSDtBQUNKO0FBQ0o7QUFaaUIsS0FEMUI7QUFnQkgsQ0E5WUEsR0FBRCxDOzs7Ozs7Ozs7Ozs7OztBQ0FDLGFBQVc7QUFDUjs7QUFFQSxRQUFJRSxtQ0FBbUM7QUFDbkMsaUJBQVMsQ0FEMEI7QUFFbkMsZUFBTyxDQUY0QjtBQUduQyxvQkFBWSxDQUh1QjtBQUluQyxpQkFBUyxDQUowQjtBQUtuQyxjQUFNLENBTDZCO0FBTW5DLGlCQUFTLENBTjBCO0FBT25DLGNBQU0sQ0FQNkI7QUFRbkMsaUJBQVMsQ0FSMEI7QUFTbkMsY0FBTTtBQVQ2QixLQUF2Qzs7QUFZQTs7Ozs7Ozs7QUFRQSxhQUFTcFAsS0FBVCxDQUFlcG1CLE1BQWYsRUFBdUI7QUFDbkIsYUFBS3FCLE9BQUwsR0FBZXJCLE1BQWY7QUFDSDs7QUFFRG9tQixVQUFNcVAsWUFBTixHQUFxQixNQUFyQjtBQUNBclAsVUFBTXNQLFdBQU4sR0FBb0IsUUFBcEI7QUFDQXRQLFVBQU11UCxZQUFOLEdBQXFCLE1BQXJCO0FBQ0F2UCxVQUFNd1AsV0FBTixHQUFvQixLQUFwQjs7QUFFQXhQLFVBQU1sVixTQUFOLEdBQWtCO0FBQ2R4UixxQkFBYTBtQixLQURDOztBQUdkOzs7Ozs7Ozs7QUFTQXJGLGdCQUFRLGdCQUFTdmhCLE1BQVQsRUFBaUI7QUFDckIsZ0JBQUlRLFNBQVMsS0FBS3FCLE9BQWxCO0FBQ0EsZ0JBQUlnbkIsUUFBUSxLQUFLd04sY0FBTCxDQUFvQixPQUFwQixDQUFaOztBQUVBcjJCLHFCQUFTQSxVQUFVLEVBQW5COztBQUVBO0FBQ0EsZ0JBQUlzMkIsUUFBUXpOLE1BQU0wTixNQUFOLENBQWEsS0FBS0YsY0FBTCxDQUFvQixPQUFwQixDQUFiLENBQVo7QUFDQSxnQkFBSTNQLE9BQU8xbUIsT0FBTzBtQixJQUFQLElBQWUsQ0FBMUI7QUFDQSxnQkFBSUQsT0FBT3ptQixPQUFPeW1CLElBQVAsSUFBZSxDQUExQjs7QUFFQSxpQkFBSyxJQUFJaGYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaWYsSUFBcEIsRUFBMEJqZixHQUExQixFQUErQjtBQUMzQixvQkFBSStnQixNQUFNOE4sTUFBTUMsTUFBTixDQUFhLEtBQUtGLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBYixDQUFWO0FBQ0EscUJBQUssSUFBSUcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJL1AsSUFBcEIsRUFBMEIrUCxHQUExQixFQUErQjtBQUMzQix3QkFBSWhSLE9BQU9nRCxJQUFJK04sTUFBSixDQUFXLEtBQUtGLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBWCxDQUFYOztBQUVBN1EseUJBQUtpUixXQUFMO0FBQ0g7QUFDSjs7QUFFRCxpQkFBSzdFLGFBQUwsQ0FBbUIvSSxLQUFuQixFQUEwQjdvQixPQUFPc1MsS0FBakM7QUFDQSxpQkFBS29rQixVQUFMLENBQWdCN04sS0FBaEIsRUFBdUI3b0IsT0FBTzIyQixPQUE5Qjs7QUFFQTtBQUNBbjJCLG1CQUFPd1gsYUFBUCxDQUFxQjZRLEtBQXJCOztBQUVBLGdCQUFJK04sWUFBWSxJQUFJbjJCLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5QjhYLE1BQU05bEIsQ0FBTixDQUFRMmpCLElBQVIsQ0FBYSxDQUFiLEVBQWdCbVEsS0FBaEIsQ0FBc0IsQ0FBdEIsQ0FBekIsQ0FBaEI7QUFDQSxnQkFBSTdHLFFBQVF4dkIsT0FBT296QixXQUFQLEVBQVo7QUFDQTVELGtCQUFNOEcsY0FBTixDQUFxQkYsU0FBckIsRUFBZ0NuMkIsU0FBU3MyQixvQkFBekM7QUFDQS9HLGtCQUFNb0IsTUFBTjs7QUFFQSxtQkFBT3ZJLEtBQVA7QUFDSCxTQTVDYTs7QUE4Q2Q7Ozs7Ozs7O0FBUUFsSSwwQkFBa0IsNEJBQVc7QUFDekIsZ0JBQUlrSSxLQUFKO0FBQ0EsZ0JBQUk3bEIsWUFBWSxLQUFLbkIsT0FBTCxDQUFhZ0IsWUFBYixFQUFoQjtBQUNBLGdCQUFJNmIsV0FBVzFiLFVBQVV5WCxrQkFBVixFQUFmOztBQUVBLGdCQUFJaUUsWUFBWUEsU0FBUzJTLEVBQVQsQ0FBWSxPQUFaLENBQWhCLEVBQXNDO0FBQ2xDeEksd0JBQVFuSyxRQUFSO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsb0JBQUlrVyxTQUFTNXhCLFVBQVVpdEIsU0FBVixFQUFiOztBQUVBLG9CQUFJMkUsT0FBT2x0QixNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSx3QkFBSWpILFNBQVNXLEdBQVQsQ0FBYTQxQixNQUFqQixFQUF5QjtBQUNyQnBDLCtCQUFPLENBQVAsRUFBVXRELE1BQVYsQ0FBaUI3d0IsU0FBU3cyQixZQUExQjtBQUNIOztBQUVEcE8sNEJBQVEsS0FBS2huQixPQUFMLENBQWFzQyxXQUFiLENBQXlCeXdCLE9BQU8sQ0FBUCxFQUFVdEUsaUJBQVYsQ0FBNEIsSUFBNUIsQ0FBekIsRUFBNEQ5RCxRQUE1RCxDQUFxRSxPQUFyRSxFQUE4RSxDQUE5RSxDQUFSO0FBQ0g7QUFDSjs7QUFFRCxtQkFBTzNELEtBQVA7QUFDSCxTQTlFYTs7QUFnRmQ7Ozs7Ozs7Ozs7Ozs7OztBQWVBcU8sb0JBQVksb0JBQVVwZixFQUFWLEVBQWM7QUFDdEIsZ0JBQUksQ0FBQ3JYLFNBQVNXLEdBQVQsQ0FBYUMsRUFBZCxJQUFvQixDQUFDeVcsR0FBR3VaLEVBQUgsQ0FBTTJFLGdDQUFOLENBQXpCLEVBQWtFO0FBQzlELHVCQUFPLENBQUNsZSxHQUFHcWYsVUFBSCxFQUFSO0FBQ0g7O0FBRUQsZ0JBQUlyZixHQUFHc2YsWUFBSCxDQUFnQixpQkFBaEIsQ0FBSixFQUF3QztBQUNwQyx1QkFBUXRmLEdBQUdqRyxZQUFILENBQWdCLGlCQUFoQixNQUF1QyxPQUEvQztBQUNIOztBQUVELG1CQUFPLEtBQUtxbEIsVUFBTCxDQUFnQnBmLEdBQUd1ZixTQUFILEVBQWhCLENBQVA7QUFDSCxTQXpHYTs7QUEyR2Q7Ozs7Ozs7OztBQVNBelAsb0JBQVksb0JBQVNpQixLQUFULEVBQWdCO0FBQ3hCQSxvQkFBUUEsU0FBUyxLQUFLbEksZ0JBQUwsRUFBakI7O0FBRUEsZ0JBQUksQ0FBQ2tJLEtBQUwsRUFBWTtBQUNSLHVCQUFPLElBQVA7QUFDSDs7QUFFRCxnQkFBSXlPLHFCQUFxQnpPLE1BQU05bEIsQ0FBTixDQUFRdzBCLEtBQVIsS0FBa0IsSUFBM0M7O0FBRUEsZ0JBQUlDLHFCQUFxQixJQUF6Qjs7QUFFQTtBQUNBLGlCQUFLLElBQUloUCxNQUFNLENBQWYsRUFBa0JBLE1BQU1LLE1BQU05bEIsQ0FBTixDQUFRMmpCLElBQVIsQ0FBYWhmLE1BQXJDLEVBQTZDOGdCLEtBQTdDLEVBQW9EO0FBQ2hEO0FBQ0Esb0JBQUloRCxPQUFPcUQsTUFBTTlsQixDQUFOLENBQVEyakIsSUFBUixDQUFhOEIsR0FBYixFQUFrQnFPLEtBQWxCLENBQXdCLENBQXhCLENBQVg7O0FBRUEsb0JBQUlyUixRQUFRQSxLQUFLaVMsUUFBTCxDQUFjL3VCLFdBQWQsT0FBZ0MsSUFBNUMsRUFBa0Q7QUFDOUM4dUIseUNBQXFCLEtBQXJCO0FBQ0E7QUFDSDtBQUNKOztBQUVELGdCQUFJRSxrQkFBa0I5USxNQUFNdVAsWUFBNUI7O0FBRUEsZ0JBQUltQixrQkFBSixFQUF3QjtBQUNwQkksa0NBQWtCOVEsTUFBTXdQLFdBQXhCO0FBQ0g7O0FBRUQsZ0JBQUlvQixrQkFBSixFQUF3QjtBQUNwQkUsa0NBQW1CQSxvQkFBb0I5USxNQUFNd1AsV0FBMUIsR0FBd0N4UCxNQUFNcVAsWUFBOUMsR0FBNkRyUCxNQUFNc1AsV0FBdEY7QUFDSDs7QUFFRCxtQkFBT3dCLGVBQVA7QUFDSCxTQXJKYTs7QUF1SmQ7Ozs7Ozs7O0FBUUE1YixnQkFBUSxnQkFBUytNLEtBQVQsRUFBZ0I7QUFDcEIsZ0JBQUlyb0IsU0FBUyxLQUFLcUIsT0FBbEI7O0FBRUEsZ0JBQUlnbkIsS0FBSixFQUFXO0FBQ1BBLHNCQUFNL00sTUFBTjtBQUNILGFBRkQsTUFFTztBQUNIK00sd0JBQVFyb0IsT0FBTzJELFdBQVAsR0FBcUJxb0IsUUFBckIsQ0FBOEIsT0FBOUIsRUFBdUMsQ0FBdkMsQ0FBUjs7QUFFQSxvQkFBSTNELEtBQUosRUFBVztBQUNQO0FBQ0Esd0JBQUk4TyxTQUFTOU8sTUFBTXdPLFNBQU4sRUFBYjtBQUNBLHdCQUFJMzFCLFdBQVdsQixPQUFPa0IsUUFBUCxFQUFmOztBQUVBLHdCQUFJaTJCLE9BQU9DLGFBQVAsT0FBMkIsQ0FBM0IsSUFBZ0MsQ0FBQ0QsT0FBT3RHLEVBQVAsQ0FBVSxJQUFWLEVBQWdCLElBQWhCLENBQWpDLElBQTBELENBQUNzRyxPQUFPdEgsTUFBUCxDQUFjM3VCLFFBQWQsQ0FBL0QsRUFBd0Y7QUFDcEZtbkIsZ0NBQVE4TyxNQUFSO0FBQ0g7O0FBRUQsd0JBQUkzSCxRQUFReHZCLE9BQU9vekIsV0FBUCxFQUFaO0FBQ0E1RCwwQkFBTThHLGNBQU4sQ0FBcUJqTyxLQUFyQixFQUE0QnBvQixTQUFTbzNCLHFCQUFyQztBQUNBaFAsMEJBQU0vTSxNQUFOO0FBQ0FrVSwwQkFBTW9CLE1BQU47QUFDSDtBQUNKO0FBQ0osU0F0TGE7O0FBd0xkOzs7Ozs7Ozs7QUFTQVEsdUJBQWUsdUJBQVMvSSxLQUFULEVBQWdCdlcsS0FBaEIsRUFBdUI7QUFDbEMsZ0JBQUlBLEtBQUosRUFBVztBQUNQNFosdUJBQU8zbEIsSUFBUCxDQUFZK0wsS0FBWixFQUFtQlgsT0FBbkIsQ0FBMkIsVUFBU21rQixJQUFULEVBQWU7QUFDdENqTiwwQkFBTXRvQixZQUFOLENBQW1CdTFCLElBQW5CLEVBQXlCeGpCLE1BQU13akIsSUFBTixDQUF6QjtBQUNILGlCQUZEO0FBR0g7QUFDSixTQXZNYTs7QUF5TWQ7Ozs7Ozs7OztBQVNBWSxvQkFBWSxvQkFBUzdOLEtBQVQsRUFBZ0I4TixPQUFoQixFQUF5QjtBQUNqQzlOLG9CQUFRQSxTQUFTLEtBQUtsSSxnQkFBTCxFQUFqQjs7QUFFQSxnQkFBSWxaLENBQUosRUFBT3F3QixPQUFQO0FBQ0EsZ0JBQUlDLFNBQUo7QUFDQSxnQkFBSUMsWUFBWW5QLE1BQU1vUCxnQkFBTixDQUF1QixPQUF2QixFQUFnQ0MsT0FBaEMsQ0FBd0MsQ0FBeEMsQ0FBaEI7O0FBRUEsZ0JBQUlDLGVBQWUsS0FBS3ZRLFVBQUwsQ0FBZ0JpQixLQUFoQixDQUFuQjtBQUNBLGdCQUFJdVAsZ0JBQWlCRCxpQkFBaUJ2UixNQUFNc1AsV0FBdkIsSUFBc0NpQyxpQkFBaUJ2UixNQUFNcVAsWUFBbEY7O0FBRUEsZ0JBQUlvQyxpQkFBaUIxQixZQUFZL1AsTUFBTXNQLFdBQWxCLElBQWlDUyxZQUFZL1AsTUFBTXFQLFlBQXhFO0FBQ0EsZ0JBQUlxQyxpQkFBaUIzQixZQUFZL1AsTUFBTXdQLFdBQWxCLElBQWlDTyxZQUFZL1AsTUFBTXFQLFlBQXhFOztBQUVBO0FBQ0E7QUFDQSxnQkFBSSxDQUFDcE4sTUFBTTlsQixDQUFOLENBQVF3MEIsS0FBVCxJQUFrQmUsY0FBdEIsRUFBc0M7QUFDbEMsb0JBQUlDLGdCQUFnQlAsVUFBVUMsZ0JBQVYsQ0FBMkIsSUFBM0IsRUFBaUNDLE9BQWpDLENBQXlDLENBQXpDLENBQXBCO0FBQ0Esb0JBQUlNLDBCQUEwQkQsY0FBY1gsYUFBZCxFQUE5Qjs7QUFFQTtBQUNBLHFCQUFLbndCLElBQUksQ0FBVCxFQUFZQSxJQUFJK3dCLHVCQUFoQixFQUF5Qy93QixHQUF6QyxFQUE4QztBQUMxQyx3QkFBSStkLE9BQU8rUyxjQUFjRSxRQUFkLENBQXVCaHhCLENBQXZCLENBQVg7O0FBRUE7QUFDQSx3QkFBSStkLEtBQUt6VixJQUFMLEtBQWN0UCxTQUFTdzJCLFlBQXZCLElBQXVDLENBQUN6UixLQUFLaGlCLElBQUwsQ0FBVSxjQUFWLENBQTVDLEVBQXVFO0FBQ25FZ2lCLDZCQUFLa1QsVUFBTCxDQUFnQixJQUFoQjtBQUNBbFQsNkJBQUtqbEIsWUFBTCxDQUFrQixPQUFsQixFQUEyQixLQUEzQjtBQUNIO0FBQ0o7O0FBRUR3M0IsNEJBQVksS0FBSzFCLGNBQUwsQ0FBb0J4TixNQUFNOWxCLENBQU4sQ0FBUTQxQixXQUFSLEVBQXBCLENBQVo7QUFDQVosMEJBQVV4QixNQUFWLENBQWlCZ0MsY0FBY3pjLE1BQWQsRUFBakI7QUFDSDs7QUFFRDtBQUNBO0FBQ0EsZ0JBQUkrTSxNQUFNOWxCLENBQU4sQ0FBUXcwQixLQUFSLEtBQWtCLElBQWxCLElBQTBCLENBQUNlLGNBQS9CLEVBQStDO0FBQzNDO0FBQ0FQLDRCQUFZLEtBQUsxQixjQUFMLENBQW9CeE4sTUFBTTlsQixDQUFOLENBQVF3MEIsS0FBNUIsQ0FBWjs7QUFFQSxvQkFBSXFCLG1CQUFtQlosVUFBVWEsUUFBVixFQUF2Qjs7QUFFQSx1QkFBT2QsVUFBVUgsYUFBVixLQUE0QixDQUFuQyxFQUFzQztBQUNsQyx3QkFBSWtCLGNBQWNmLFVBQVVjLFFBQVYsRUFBbEI7QUFDQSx3QkFBSUUsd0JBQXdCRCxZQUFZbEIsYUFBWixFQUE1Qjs7QUFFQSx5QkFBS253QixJQUFJLENBQVQsRUFBWUEsSUFBSXN4QixxQkFBaEIsRUFBdUN0eEIsR0FBdkMsRUFBNEM7QUFDeENxd0Isa0NBQVVnQixZQUFZTCxRQUFaLENBQXFCaHhCLENBQXJCLENBQVY7O0FBRUEsNEJBQUlxd0IsUUFBUS9uQixJQUFSLEtBQWlCdFAsU0FBU3cyQixZQUE5QixFQUE0QztBQUN4Q2Esb0NBQVFZLFVBQVIsQ0FBbUIsSUFBbkI7QUFDQVosb0NBQVFrQixlQUFSLENBQXdCLE9BQXhCO0FBQ0g7QUFDSjs7QUFFREYsZ0NBQVlHLFlBQVosQ0FBeUJMLGdCQUF6QjtBQUNIOztBQUVEYiwwQkFBVWpjLE1BQVY7QUFDSDs7QUFFRHFjLDJCQUFlLEtBQUt2USxVQUFMLENBQWdCaUIsS0FBaEIsQ0FBZjtBQUNBLGdCQUFJcVEsZ0JBQWlCZixpQkFBaUJ2UixNQUFNc1AsV0FBdkIsSUFBc0NpQyxpQkFBaUJ2UixNQUFNcVAsWUFBbEY7O0FBRUE7QUFDQTtBQUNBLGdCQUFJLENBQUNpRCxhQUFELElBQWtCYixjQUF0QixFQUFzQztBQUNsQyxxQkFBSzV3QixJQUFJLENBQVQsRUFBWUEsSUFBSW9oQixNQUFNOWxCLENBQU4sQ0FBUTJqQixJQUFSLENBQWFoZixNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDdEMsd0JBQUlvaEIsTUFBTTlsQixDQUFOLENBQVEyakIsSUFBUixDQUFhamYsQ0FBYixFQUFnQm92QixLQUFoQixDQUFzQixDQUF0QixFQUF5QlksUUFBekIsQ0FBa0MvdUIsV0FBbEMsT0FBb0QsSUFBeEQsRUFBOEQ7QUFDMURvdkIsa0NBQVUsSUFBSXIzQixTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBeUI4WCxNQUFNOWxCLENBQU4sQ0FBUTJqQixJQUFSLENBQWFqZixDQUFiLEVBQWdCb3ZCLEtBQWhCLENBQXNCLENBQXRCLENBQXpCLENBQVY7QUFDQWlCLGdDQUFRWSxVQUFSLENBQW1CLElBQW5CO0FBQ0FaLGdDQUFRdjNCLFlBQVIsQ0FBcUIsT0FBckIsRUFBOEIsS0FBOUI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBLGdCQUFJNjNCLGlCQUFpQixDQUFDQyxjQUF0QixFQUFzQztBQUNsQyxxQkFBSzV3QixJQUFJLENBQVQsRUFBWUEsSUFBSW9oQixNQUFNOWxCLENBQU4sQ0FBUTJqQixJQUFSLENBQWFoZixNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDdEMsd0JBQUkrZ0IsTUFBTSxJQUFJL25CLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5QjhYLE1BQU05bEIsQ0FBTixDQUFRMmpCLElBQVIsQ0FBYWpmLENBQWIsQ0FBekIsQ0FBVjs7QUFFQSx3QkFBSStnQixJQUFJNk8sU0FBSixHQUFnQjhCLE9BQWhCLE9BQThCLE9BQWxDLEVBQTJDO0FBQ3ZDckIsa0NBQVUsSUFBSXIzQixTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBeUJ5WCxJQUFJemxCLENBQUosQ0FBTTh6QixLQUFOLENBQVksQ0FBWixDQUF6QixDQUFWO0FBQ0FpQixnQ0FBUVksVUFBUixDQUFtQixJQUFuQjtBQUNBWixnQ0FBUWtCLGVBQVIsQ0FBd0IsT0FBeEI7QUFDSDtBQUNKO0FBQ0o7QUFDSixTQTNTYTs7QUE2U2Q7Ozs7Ozs7Ozs7QUFVQTNDLHdCQUFnQix3QkFBU2xyQixJQUFULEVBQWU7QUFDM0IsbUJBQU8sSUFBSTFLLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5QjVGLElBQXpCLEVBQStCLEtBQUt0SixPQUFMLENBQWFpQixRQUE1QyxDQUFQO0FBQ0g7QUF6VGEsS0FBbEI7O0FBNFRBckMsYUFBUzJDLEVBQVQsQ0FBWSxlQUFaLEVBQTZCLFVBQVNFLEtBQVQsRUFBZ0I7QUFDekMsWUFBSTgxQixrQkFBa0IsQ0FBQ3hTLE1BQU11UCxZQUFQLEVBQXFCdlAsTUFBTXdQLFdBQTNCLEVBQXdDeFAsTUFBTXNQLFdBQTlDLEVBQTJEdFAsTUFBTXFQLFlBQWpFLENBQXRCOztBQUVBLFlBQUl0UCxhQUFhLElBQUlDLEtBQUosQ0FBVXRqQixNQUFNOUMsTUFBaEIsQ0FBakI7O0FBRUE0NEIsd0JBQWdCem5CLE9BQWhCLENBQXdCLFVBQVNnbEIsT0FBVCxFQUFrQjtBQUN0Q3J6QixrQkFBTTlDLE1BQU4sQ0FBYWtMLFVBQWIsQ0FBd0IsaUJBQWlCaXJCLE9BQXpDLEVBQWtEO0FBQzlDcHJCLHNCQUFNLGNBQVMvSyxNQUFULEVBQWlCO0FBQ25CbW1CLCtCQUFXK1AsVUFBWCxDQUFzQixJQUF0QixFQUE0QkMsT0FBNUI7QUFDSDtBQUg2QyxhQUFsRDtBQUtILFNBTkQ7QUFPSCxLQVpEOztBQWNBbDJCLGFBQVNtbUIsS0FBVCxHQUFpQm5tQixTQUFTbW1CLEtBQVQsSUFBa0JBLEtBQW5DO0FBQ0gsQ0EzV0EsR0FBRCxDOzs7Ozs7Ozs7Ozs7OztBQ0FDLGFBQVc7QUFDUjs7QUFFQTs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBbm1CLGFBQVN3TCxLQUFULENBQWVvdEIsS0FBZixHQUF1QixVQUFTQyxXQUFULEVBQXNCQyxTQUF0QixFQUFpQ3Z4QixRQUFqQyxFQUEyQ3d4QixhQUEzQyxFQUEwRDtBQUM3RSxZQUFJQyxjQUFjaDVCLFNBQVN3TCxLQUFULENBQWV5dEIsYUFBZixFQUFsQjs7QUFFQUgsb0JBQVlBLGFBQWEsRUFBekI7QUFDQUEsa0JBQVV2eEIsUUFBVixHQUFxQiwrQkFBK0J5eEIsV0FBL0IsR0FBNkMsR0FBbEU7O0FBRUEsWUFBSSxDQUFDaDVCLFNBQVNzdUIsQ0FBVCxDQUFXNEssY0FBaEIsRUFBZ0M7QUFDNUJsNUIscUJBQVNzdUIsQ0FBVCxDQUFXNEssY0FBWCxHQUE0QixFQUE1QjtBQUNIOztBQUVEbDVCLGlCQUFTc3VCLENBQVQsQ0FBVzRLLGNBQVgsQ0FBMEJGLFdBQTFCLElBQXlDLFVBQVNHLFFBQVQsRUFBbUI7QUFDeER6eEIsdUJBQVcsWUFBVztBQUNsQjB4Qjs7QUFFQTd4Qix5QkFBUzR4QixRQUFUO0FBQ0gsYUFKRDtBQUtILFNBTkQ7O0FBUUEsWUFBSUUsZ0JBQWdCLElBQUlyNUIsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWpCLENBQXlCLFFBQXpCLENBQXBCO0FBQ0Erb0Isc0JBQWN2NUIsWUFBZCxDQUEyQixLQUEzQixFQUFrQys0QixZQUFZeE4sTUFBWixDQUFtQnlOLFNBQW5CLENBQWxDO0FBQ0FPLHNCQUFjMTJCLEVBQWQsQ0FBaUIsT0FBakIsRUFBMEIsWUFBVztBQUNqQ3kyQjs7QUFFQSxnQkFBSUwsYUFBSixFQUFtQjtBQUNmQTtBQUNIO0FBQ0osU0FORDs7QUFRQSxpQkFBU0ssT0FBVCxHQUFtQjtBQUNmLGdCQUFJQyxhQUFKLEVBQW1CO0FBQ2ZBLDhCQUFjaGUsTUFBZDtBQUNBLHVCQUFPcmIsU0FBU3N1QixDQUFULENBQVc0SyxjQUFYLENBQTBCRixXQUExQixDQUFQO0FBQ0FLLGdDQUFnQixJQUFoQjtBQUNIO0FBQ0o7O0FBRURyNUIsaUJBQVNxQyxRQUFULENBQWtCaTNCLE9BQWxCLEdBQTRCeEQsTUFBNUIsQ0FBbUN1RCxhQUFuQzs7QUFFQSxlQUFPO0FBQ0hFLG9CQUFRSCxPQURMO0FBRUhJLGdCQUFJUjtBQUZELFNBQVA7QUFJSCxLQTFDRDs7QUE0Q0E7Ozs7Ozs7Ozs7Ozs7QUFhQWg1QixhQUFTd0wsS0FBVCxDQUFlQyxLQUFmLEdBQXVCekwsU0FBU3dMLEtBQVQsQ0FBZUMsS0FBZixJQUF3QixZQUFXO0FBQ3RELFlBQUlGLFNBQVMsRUFBYjs7QUFFQSxhQUFLLElBQUl2RSxJQUFJLENBQWIsRUFBZ0JBLElBQUlvbkIsVUFBVW5uQixNQUE5QixFQUFzQyxFQUFFRCxDQUF4QyxFQUEyQztBQUN2QyxnQkFBSXdHLE1BQU00Z0IsVUFBVXBuQixDQUFWLENBQVY7O0FBRUEsaUJBQUssSUFBSTBGLEdBQVQsSUFBZ0JjLEdBQWhCLEVBQXFCO0FBQ2pCLG9CQUFJaWUsT0FBT3hhLFNBQVAsQ0FBaUJxa0IsY0FBakIsQ0FBZ0M1MUIsSUFBaEMsQ0FBcUM4TixHQUFyQyxFQUEwQ2QsR0FBMUMsQ0FBSixFQUFvRDtBQUNoRG5CLDJCQUFPbUIsR0FBUCxJQUFjYyxJQUFJZCxHQUFKLENBQWQ7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsZUFBT25CLE1BQVA7QUFDSCxLQWREOztBQWdCQTs7Ozs7Ozs7O0FBU0F2TCxhQUFTd0wsS0FBVCxDQUFlaXVCLFFBQWYsR0FBMEIsVUFBU25wQixPQUFULEVBQWtCek4sS0FBbEIsRUFBeUI7QUFDL0MsWUFBSTYyQixnQkFBZ0JyM0IsU0FBU3MzQixXQUFULENBQXFCLFFBQXJCLENBQXBCO0FBQ0FELHNCQUFjRSxTQUFkLENBQXdCLzJCLEtBQXhCLEVBQStCLElBQS9CLEVBQXFDLEtBQXJDO0FBQ0F5TixnQkFBUXVwQixhQUFSLENBQXNCSCxhQUF0QjtBQUNILEtBSkQ7QUFLSCxDQTlHQSxHQUFELEM7Ozs7Ozs7Ozs7Ozs7O0FDQUMsYUFBVztBQUNSOztBQUVBLFFBQUkxNUIsU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLFdBQXJCLENBQUosRUFBdUM7QUFDbkM7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7OztBQVVBRyxhQUFTOHRCLE9BQVQsQ0FBaUIzbkIsR0FBakIsQ0FDSSxXQURKLEVBQ2lCO0FBQ1Q7Ozs7Ozs7O0FBUUFpdkIsY0FBTSxjQUFTcjFCLE1BQVQsRUFBaUI7QUFDbkIsZ0JBQUkrNUIsWUFBWSxFQUFoQjs7QUFFQSxnQkFBSUMsY0FBYyxLQUFLQyxrQkFBTCxDQUF3Qmo2QixPQUFPeTVCLEVBQS9CLENBQWxCOztBQUVBLGdCQUFJUyxpQkFBaUJsNkIsT0FBT1IsTUFBUCxDQUFjNHZCLE1BQWQsR0FBdUJwdkIsT0FBT1IsTUFBUCxDQUFjNHZCLE1BQWQsQ0FBcUJULE9BQTVDLEdBQXNELEVBQTNFOztBQUVBLGdCQUFJd0wsV0FBV2w2QixTQUFTd0wsS0FBVCxDQUFleWUsUUFBZixDQUNYLFVBQVNwbkIsS0FBVCxFQUFnQjtBQUNaaTNCLDRCQUFZLEVBQVo7O0FBRUEsb0JBQUlqM0IsTUFBTTZILElBQU4sS0FBZSxPQUFmLElBQTBCN0gsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWF5TixPQUFiLEtBQXlCLEVBQW5ELElBQXlEaFEsT0FBT1IsTUFBUCxDQUFjNDZCLFFBQTNFLEVBQXFGO0FBQ2pGLHdCQUFJNW5CLGdCQUFnQnhTLE9BQU80ckIsZ0JBQVAsRUFBcEI7O0FBRUEsd0JBQUlwWixhQUFKLEVBQW1CO0FBQ2Z4UywrQkFBT3dELElBQVAsQ0FBWSxtQkFBWixFQUFpQztBQUM3QmlQLHlDQUFhM1AsTUFBTUUsSUFBTixDQUFXVCxDQURLO0FBRTdCaVEsMkNBQWVBO0FBRmMseUJBQWpDO0FBSUg7QUFDSjtBQUNKLGFBZFUsRUFlWDBuQixjQWZXLENBQWY7O0FBa0JBLGdCQUFJRyxhQUFhcDZCLFNBQVN3TCxLQUFULENBQWV5ZSxRQUFmLENBQ2IsVUFBU3BuQixLQUFULEVBQWdCO0FBQ1prM0IsNEJBQVlNLFNBQVosR0FBd0JQLFVBQVV4TyxJQUFWLENBQWUsSUFBZixDQUF4QjtBQUNILGFBSFksRUFJYjJPLGNBSmEsQ0FBakI7O0FBT0EsZ0JBQUlLLG1CQUFtQnQ2QixTQUFTd0wsS0FBVCxDQUFleWUsUUFBZixDQUNuQixVQUFTcG5CLEtBQVQsRUFBZ0I7QUFDWixvQkFBSTAzQixZQUFZbDRCLFNBQVN5TyxnQkFBVCxDQUEwQixRQUExQixDQUFoQjs7QUFFQSxvQkFBSTBwQixLQUFKOztBQUVBLHFCQUFLLElBQUl4ekIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdXpCLFVBQVV0ekIsTUFBOUIsRUFBc0NELEdBQXRDLEVBQTJDO0FBQ3ZDLHdCQUFJdXpCLFVBQVV2ekIsQ0FBVixFQUFhK2tCLFFBQWIsQ0FBc0JscEIsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWFtNEIsYUFBbkMsQ0FBSixFQUF1RDtBQUNuREQsZ0NBQVEsSUFBUjtBQUNBO0FBQ0g7QUFDSjs7QUFFRCxvQkFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDUk4sNkJBQVNyM0IsS0FBVDtBQUNIO0FBQ0osYUFoQmtCLEVBaUJuQm8zQixjQWpCbUIsQ0FBdkI7O0FBb0JBbDZCLG1CQUFPNEMsRUFBUCxDQUFVLFlBQVYsRUFBd0IsVUFBU0UsS0FBVCxFQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBaTNCLDBCQUFVendCLElBQVYsQ0FBZXhHLE1BQU1FLElBQU4sQ0FBV3FuQixPQUExQjs7QUFFQWdRO0FBQ0gsYUFWRDs7QUFZQXI2QixtQkFBT2dCLElBQVAsQ0FBWSxZQUFaLEVBQTBCLFlBQVc7QUFDakMsb0JBQUlFLFdBQVdsQixPQUFPa0IsUUFBUCxFQUFmOztBQUVBLG9CQUFJeTVCLGVBQWV6NUIsU0FBUzA1QixjQUFULENBQXdCMTVCLFFBQXhCLEVBQWtDLE9BQWxDLEVBQTJDLFVBQVU0QixLQUFWLEVBQWlCO0FBQzNFNjNCLGlDQUFhRSxjQUFiOztBQUVBMzVCLDZCQUFTMDVCLGNBQVQsQ0FBd0IxNUIsUUFBeEIsRUFBa0MsT0FBbEMsRUFBMkNpNUIsUUFBM0M7QUFDQWo1Qiw2QkFBUzA1QixjQUFULENBQXdCMTVCLFFBQXhCLEVBQWtDLFNBQWxDLEVBQTZDaTVCLFFBQTdDO0FBQ0FqNUIsNkJBQVMwNUIsY0FBVCxDQUF3QjE1QixRQUF4QixFQUFrQyxZQUFsQyxFQUFnRHE1QixnQkFBaEQ7O0FBRUFKLDZCQUFTcjNCLEtBQVQ7QUFDSCxpQkFSa0IsQ0FBbkI7QUFTSCxhQVpEOztBQWNBOUMsbUJBQU80QyxFQUFQLENBQVUsU0FBVixFQUFxQixVQUFTRSxLQUFULEVBQWdCO0FBQ2pDazNCLDRCQUFZbjRCLFVBQVosQ0FBdUJDLFdBQXZCLENBQW1DazRCLFdBQW5DOztBQUVBRyx5QkFBUzFPLE1BQVQ7QUFDSCxhQUpEO0FBS0gsU0E1RlE7O0FBOEZUOzs7Ozs7Ozs7QUFTQXdPLDRCQUFvQiw0QkFBU1IsRUFBVCxFQUFhO0FBQzdCLGdCQUFJcUIsZ0JBQWdCeDRCLFNBQVNrQyxhQUFULENBQXVCLEtBQXZCLENBQXBCOztBQUVBczJCLDBCQUFjcjJCLFNBQWQsR0FBMEIsWUFBMUI7O0FBRUFxMkIsMEJBQWMvNkIsWUFBZCxDQUEyQixXQUEzQixFQUF3QyxRQUF4QztBQUNBKzZCLDBCQUFjLzZCLFlBQWQsQ0FBMkIsTUFBM0IsRUFBbUMsUUFBbkM7QUFDQSs2QiwwQkFBYy82QixZQUFkLENBQTJCLElBQTNCLEVBQWlDMDVCLEtBQUssWUFBdEM7O0FBRUFuM0IscUJBQVNxQyxJQUFULENBQWNDLFdBQWQsQ0FBMEJrMkIsYUFBMUI7O0FBRUEsbUJBQU9BLGFBQVA7QUFDSDtBQW5IUSxLQURqQjtBQXVISCxDQXBMQSxHQUFELEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7QUFFQTs7Ozs7O0FBTUEsU0FBU0MsU0FBVCxDQUFtQnY3QixNQUFuQixFQUEyQjtBQUN2QixTQUFLdzdCLFVBQUwsR0FBa0J4N0IsVUFBVSxFQUE1QjtBQUNBLFNBQUt5N0IsU0FBTCxHQUFpQixFQUFqQjtBQUNIOztBQUVERixVQUFVN3BCLFNBQVYsR0FBc0I7QUFDbEJ4UixpQkFBYXE3QixTQURLOztBQUdsQjs7Ozs7Ozs7O0FBU0FqN0IsU0FBSyxhQUFTdzFCLElBQVQsRUFBZTtBQUNoQixZQUFJNEYsY0FBYyxLQUFLeDdCLFdBQUwsQ0FBaUI2RixLQUFqQixDQUF1Qit2QixJQUF2QixDQUFsQjs7QUFFQSxZQUFJLENBQUM0RixXQUFMLEVBQWtCO0FBQ2Q7QUFDSDs7QUFFRCxZQUFJLENBQUMsS0FBS0MsY0FBTCxDQUFvQjdGLElBQXBCLENBQUwsRUFBZ0M7QUFDNUIsaUJBQUs4RixLQUFMLENBQVc5RixJQUFYO0FBQ0g7O0FBRUQsWUFBSStGLFdBQVcsS0FBS0osU0FBTCxDQUFlM0YsSUFBZixDQUFmOztBQUVBLFlBQUk0RixZQUFZcjFCLE1BQWhCLEVBQXdCO0FBQ3BCdzFCLHVCQUFXLEtBQUtDLHFCQUFMLENBQTJCSixZQUFZcjFCLE1BQXZDLEVBQStDdzFCLFFBQS9DLENBQVg7QUFDSDs7QUFFRCxlQUFPQSxRQUFQO0FBQ0gsS0E5QmlCOztBQWdDbEI7Ozs7Ozs7OztBQVNBRSxTQUFLLGFBQVNqRyxJQUFULEVBQWVyeEIsS0FBZixFQUFzQjtBQUN2QixZQUFJaTNCLGNBQWMsS0FBS3g3QixXQUFMLENBQWlCNkYsS0FBakIsQ0FBdUIrdkIsSUFBdkIsQ0FBbEI7O0FBRUEsWUFBSSxDQUFDNEYsV0FBTCxFQUFrQjtBQUNkO0FBQ0g7O0FBRUQsWUFBSSxDQUFDLEtBQUtDLGNBQUwsQ0FBb0I3RixJQUFwQixDQUFMLEVBQWdDO0FBQzVCLGlCQUFLOEYsS0FBTCxDQUFXOUYsSUFBWDtBQUNIOztBQUVELFlBQUk0RixZQUFZNzNCLFFBQWhCLEVBQTBCO0FBQ3RCO0FBQ0g7O0FBRUQsWUFBSTYzQixZQUFZejFCLFNBQVosSUFBeUIsS0FBSzAxQixjQUFMLENBQW9CN0YsSUFBcEIsQ0FBN0IsRUFBd0Q7QUFDcEQ7QUFDSDs7QUFFRCxZQUFJNEYsWUFBWTExQixTQUFaLElBQXlCLENBQUMsS0FBSzgxQixxQkFBTCxDQUEyQkosWUFBWTExQixTQUF2QyxFQUFrRHZCLEtBQWxELENBQTlCLEVBQXdGO0FBQ3BGO0FBQ0g7O0FBRUQsWUFBSWkzQixZQUFZLzBCLE1BQWhCLEVBQXdCO0FBQ3BCbEMsb0JBQVEsS0FBS3EzQixxQkFBTCxDQUEyQkosWUFBWS8wQixNQUF2QyxFQUErQ2xDLEtBQS9DLENBQVI7QUFDSDs7QUFFRCxhQUFLZzNCLFNBQUwsQ0FBZTNGLElBQWYsSUFBdUJyeEIsS0FBdkI7QUFDSCxLQXJFaUI7O0FBdUVsQjs7Ozs7Ozs7Ozs7OztBQWFBcTNCLDJCQUF1QiwrQkFBU0UsZ0JBQVQsRUFBMkI1TSxJQUEzQixFQUFpQztBQUNwRCxZQUFJcGpCLFNBQVMsSUFBYjs7QUFFQSxZQUFJLENBQUMsZUFBSzFGLE9BQUwsQ0FBYThvQixJQUFiLENBQUwsRUFBeUI7QUFDckJBLG1CQUFPLENBQUNBLElBQUQsQ0FBUDtBQUNIOztBQUVELFlBQUksZUFBSzVwQixRQUFMLENBQWN3MkIsZ0JBQWQsS0FBbUMsZUFBSy96QixVQUFMLENBQWdCLEtBQUsrekIsZ0JBQUwsQ0FBaEIsQ0FBdkMsRUFBZ0Y7QUFDNUVod0IscUJBQVMsS0FBS2d3QixnQkFBTCxFQUF1QnBOLEtBQXZCLENBQTZCLElBQTdCLEVBQW1DUSxJQUFuQyxDQUFUO0FBQ0gsU0FGRCxNQUVPLElBQUksZUFBS25uQixVQUFMLENBQWdCK3pCLGdCQUFoQixDQUFKLEVBQXVDO0FBQzFDaHdCLHFCQUFTZ3dCLGlCQUFpQnBOLEtBQWpCLENBQXVCLElBQXZCLEVBQTZCUSxJQUE3QixDQUFUO0FBQ0g7O0FBRUQsZUFBT3BqQixNQUFQO0FBQ0gsS0FsR2lCOztBQW9HbEI7Ozs7Ozs7Ozs7QUFVQTR2QixXQUFPLGVBQVM5RixJQUFULEVBQWU7QUFDbEIsWUFBSXJ4QixLQUFKOztBQUVBLFlBQUlpM0IsY0FBYyxLQUFLeDdCLFdBQUwsQ0FBaUI2RixLQUFqQixDQUF1Qit2QixJQUF2QixDQUFsQjs7QUFFQTtBQUNBLFlBQUltRyxrQkFBa0IvUCxPQUFPeGEsU0FBUCxDQUFpQnFrQixjQUFqQixDQUFnQzUxQixJQUFoQyxDQUFxQ3U3QixXQUFyQyxFQUFrRCxPQUFsRCxDQUF0QjtBQUNBLFlBQUlRLDBCQUEwQmhRLE9BQU94YSxTQUFQLENBQWlCcWtCLGNBQWpCLENBQWdDNTFCLElBQWhDLENBQXFDLEtBQUtxN0IsVUFBMUMsRUFBc0QxRixJQUF0RCxDQUE5Qjs7QUFFQTtBQUNBLFlBQUk0RixZQUFZUyxPQUFoQixFQUF5QjtBQUNyQjEzQixvQkFBUSxLQUFLcTNCLHFCQUFMLENBQTJCSixZQUFZUyxPQUF2QyxFQUFnRDEzQixLQUFoRCxDQUFSOztBQUVBLGlCQUFLZzNCLFNBQUwsQ0FBZTNGLElBQWYsSUFBdUJyeEIsS0FBdkI7QUFDSDtBQUNEO0FBQ0E7QUFOQSxhQU9LLElBQUlpM0IsWUFBWTczQixRQUFoQixFQUEwQjtBQUMzQlksd0JBQVFpM0IsWUFBWWozQixLQUFwQjtBQUNIO0FBQ0Q7QUFDQTtBQUpLLGlCQUtBLElBQUlpM0IsWUFBWXoxQixTQUFoQixFQUEyQjtBQUM1Qix3QkFBSWkyQix1QkFBSixFQUE2QjtBQUN6QnozQixnQ0FBUSxLQUFLKzJCLFVBQUwsQ0FBZ0IxRixJQUFoQixDQUFSO0FBQ0gscUJBRkQsTUFFTyxJQUFJbUcsZUFBSixFQUFxQjtBQUN4QngzQixnQ0FBUWkzQixZQUFZajNCLEtBQXBCO0FBQ0gscUJBRk0sTUFFQTtBQUNIO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFWSyxxQkFXQSxJQUFJeTNCLHVCQUFKLEVBQTZCO0FBQzlCejNCLGdDQUFRLEtBQUsrMkIsVUFBTCxDQUFnQjFGLElBQWhCLENBQVI7QUFDSCxxQkFGSSxNQUVFLElBQUltRyxlQUFKLEVBQXFCO0FBQ3hCeDNCLGdDQUFRaTNCLFlBQVlqM0IsS0FBcEI7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxZQUFJaTNCLFlBQVkxMUIsU0FBWixJQUF5QmsyQix1QkFBekIsSUFBb0QsQ0FBQyxLQUFLSixxQkFBTCxDQUEyQkosWUFBWTExQixTQUF2QyxFQUFrRHZCLEtBQWxELENBQXpELEVBQW1IO0FBQy9HLGdCQUFJdzNCLGVBQUosRUFBcUI7QUFDakJ4M0Isd0JBQVFpM0IsWUFBWWozQixLQUFwQjtBQUNILGFBRkQsTUFFTztBQUNIO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0EsWUFBSWkzQixZQUFZLzBCLE1BQVosSUFBc0J1MUIsdUJBQTFCLEVBQW1EO0FBQy9DejNCLG9CQUFRLEtBQUtxM0IscUJBQUwsQ0FBMkJKLFlBQVkvMEIsTUFBdkMsRUFBK0NsQyxLQUEvQyxDQUFSO0FBQ0g7O0FBRUQ7QUFDQSxhQUFLZzNCLFNBQUwsQ0FBZTNGLElBQWYsSUFBdUJyeEIsS0FBdkI7QUFDSCxLQXhLaUI7O0FBMEtsQjs7Ozs7Ozs7Ozs7O0FBWUFrM0Isb0JBQWdCLHdCQUFTN0YsSUFBVCxFQUFlO0FBQzNCLGVBQU81SixPQUFPeGEsU0FBUCxDQUFpQnFrQixjQUFqQixDQUFnQzUxQixJQUFoQyxDQUFxQyxLQUFLczdCLFNBQTFDLEVBQXFEM0YsSUFBckQsQ0FBUDtBQUNIO0FBeExpQixDQUF0Qjs7a0JBMkxleUYsUzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeE1mOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7OztBQU1BLFNBQVNhLElBQVQsQ0FBY3A4QixNQUFkLEVBQXNCO0FBQ2xCbzhCLFNBQUtuOEIsVUFBTCxDQUFnQkMsV0FBaEIsQ0FBNEJDLElBQTVCLENBQWlDLElBQWpDLEVBQXVDSCxNQUF2Qzs7QUFFQSxTQUFLNjFCLElBQUwsQ0FBVTcxQixNQUFWO0FBQ0g7O0FBRUQsbUJBQU9vOEIsSUFBUCx1QkFBd0I7QUFDcEI7Ozs7Ozs7OztBQVNBdkcsVUFBTSxjQUFTNzFCLE1BQVQsRUFBaUI7QUFDbkIsYUFBS3E4QixVQUFMLENBQWdCLGFBQWhCLEVBQStCcjhCLE1BQS9CO0FBQ0gsS0FabUI7O0FBY3BCOzs7Ozs7O0FBT0EwQyxhQUFTLG1CQUFXO0FBQ2hCLGFBQUsyNUIsVUFBTCxDQUFnQixZQUFoQjtBQUNILEtBdkJtQjs7QUF5QnBCOzs7Ozs7Ozs7O0FBVUFBLGdCQUFZLG9CQUFTQyxHQUFULEVBQWNsTixJQUFkLEVBQW9CO0FBQzVCLFlBQUltTixNQUFNLEVBQVY7O0FBRUEsWUFBSUMsT0FBTyxLQUFLdDhCLFdBQWhCOztBQUVBLGVBQU9zOEIsSUFBUCxFQUFhO0FBQ1QsZ0JBQUksZUFBS3YwQixVQUFMLENBQWdCdTBCLEtBQUs5cUIsU0FBTCxDQUFlNHFCLEdBQWYsQ0FBaEIsQ0FBSixFQUEwQztBQUN0Q0Msb0JBQUl6eUIsSUFBSixDQUFTMHlCLEtBQUs5cUIsU0FBTCxDQUFlNHFCLEdBQWYsQ0FBVDtBQUNIOztBQUVERSxtQkFBT0EsS0FBS3Y4QixVQUFMLEdBQWtCdThCLEtBQUt2OEIsVUFBTCxDQUFnQkMsV0FBbEMsR0FBZ0QsSUFBdkQ7QUFDSDs7QUFFRHE4QixjQUFNQSxJQUFJRSxPQUFKLEVBQU47O0FBRUFyTixlQUFPLGVBQUs5b0IsT0FBTCxDQUFhOG9CLElBQWIsSUFBcUJBLElBQXJCLEdBQTRCLENBQUNBLElBQUQsQ0FBbkM7O0FBRUEsYUFBSyxJQUFJM25CLElBQUksQ0FBYixFQUFnQkEsSUFBSTgwQixJQUFJNzBCLE1BQXhCLEVBQWdDRCxHQUFoQyxFQUFxQztBQUNqQyxnQkFBSWtILE9BQU80dEIsSUFBSTkwQixDQUFKLENBQVg7O0FBRUFrSCxpQkFBS2lnQixLQUFMLENBQVcsSUFBWCxFQUFpQlEsSUFBakI7QUFDSDtBQUNKO0FBekRtQixDQUF4Qjs7a0JBNERlZ04sSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1RWY7Ozs7O0FBS0EsSUFBTU0sT0FBTztBQUNUOzs7Ozs7Ozs7QUFTQXAyQixhQUFTLGlCQUFTN0IsS0FBVCxFQUFnQjtBQUNyQixlQUFPeW5CLE9BQU94YSxTQUFQLENBQWlCcEcsUUFBakIsQ0FBMEJuTCxJQUExQixDQUErQnNFLEtBQS9CLE1BQTBDLGdCQUFqRDtBQUNILEtBWlE7O0FBY1Q7Ozs7Ozs7OztBQVNBbUIsZUFBVyxtQkFBU25CLEtBQVQsRUFBZ0I7QUFDdkIsZUFBTyxPQUFPQSxLQUFQLEtBQWlCLFNBQXhCO0FBQ0gsS0F6QlE7O0FBMkJUOzs7Ozs7Ozs7QUFTQXdELGdCQUFZLG9CQUFTeEQsS0FBVCxFQUFnQjtBQUN4QixlQUFPLE9BQU9BLEtBQVAsS0FBa0IsVUFBekI7QUFDSCxLQXRDUTs7QUF3Q1Q7Ozs7Ozs7OztBQVNBcUIsWUFBUSxnQkFBU3JCLEtBQVQsRUFBZ0I7QUFDcEIsZUFBT0EsVUFBVSxJQUFqQjtBQUNILEtBbkRROztBQXFEVDs7Ozs7Ozs7O0FBU0EyQixjQUFVLGtCQUFTM0IsS0FBVCxFQUFnQjtBQUN0QixlQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJrNEIsU0FBU2w0QixLQUFULENBQXBDO0FBQ0gsS0FoRVE7O0FBa0VUOzs7Ozs7Ozs7QUFTQWtCLGNBQVUsa0JBQVNsQixLQUFULEVBQWdCO0FBQ3RCLFlBQUltNEIsbUJBQW1CbjRCLEtBQW5CLHlDQUFtQkEsS0FBbkIsQ0FBSjs7QUFFQSxlQUFRQSxVQUFVbTRCLGNBQWMsUUFBZCxJQUEwQkYsS0FBS3owQixVQUFMLENBQWdCeEQsS0FBaEIsQ0FBcEMsQ0FBUjtBQUNILEtBL0VROztBQWlGVDs7Ozs7Ozs7O0FBU0FlLGNBQVUsa0JBQVNmLEtBQVQsRUFBZ0I7QUFDdEIsZUFBTyxPQUFPQSxLQUFQLEtBQWlCLFFBQXhCO0FBQ0gsS0E1RlE7O0FBOEZUOzs7Ozs7Ozs7OztBQVdBdEQsU0FBSyxhQUFTMDdCLFFBQVQsRUFBbUJDLFFBQW5CLEVBQTZCO0FBQzlCLFlBQUkvRyxpQkFBaUI3SixPQUFPeGEsU0FBUCxDQUFpQnFrQixjQUF0Qzs7QUFFQSxhQUFLLElBQUk1b0IsR0FBVCxJQUFnQjJ2QixRQUFoQixFQUEwQjtBQUN0QixnQkFBSS9HLGVBQWU1MUIsSUFBZixDQUFvQjI4QixRQUFwQixFQUE4QjN2QixHQUE5QixDQUFKLEVBQXdDO0FBQ3BDMHZCLHlCQUFTMXZCLEdBQVQsSUFBZ0IydkIsU0FBUzN2QixHQUFULENBQWhCO0FBQ0g7QUFDSjtBQUNKLEtBakhROztBQW1IVDs7Ozs7Ozs7O0FBU0E4RSxXQUFPLGVBQVN4TixLQUFULEVBQWdCO0FBQ25CLGVBQU9zNEIsU0FBU3Q0QixLQUFULEVBQWdCLEVBQWhCLENBQVA7QUFDSDtBQTlIUSxDQUFiOztrQkFpSWVpNEIsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdElmOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBLElBQU1NLFNBQVMsU0FBVEEsTUFBUyxDQUFTSCxRQUFULEVBQW1CQyxRQUFuQixFQUE2QkcsVUFBN0IsRUFBeUNDLFdBQXpDLEVBQXNEO0FBQ2pFLFFBQUksQ0FBQ0osUUFBRCxJQUFhLENBQUNELFFBQWxCLEVBQTRCO0FBQ3hCLGNBQU0sb0NBQU47QUFDSDs7QUFFRCxRQUFJTSxnQkFBZ0JMLFNBQVNwckIsU0FBN0I7QUFBQSxRQUF3QzByQixnQkFBZ0JsUixPQUFPM0ssTUFBUCxDQUFjNGIsYUFBZCxDQUF4RDtBQUNBTixhQUFTbnJCLFNBQVQsR0FBcUIwckIsYUFBckI7O0FBRUFBLGtCQUFjbDlCLFdBQWQsR0FBNEIyOEIsUUFBNUI7QUFDQUEsYUFBUzU4QixVQUFULEdBQXNCazlCLGFBQXRCOztBQUVBO0FBQ0EsUUFBSUwsYUFBYTVRLE1BQWIsSUFBdUJpUixjQUFjajlCLFdBQWQsS0FBOEJnc0IsT0FBT3hhLFNBQVAsQ0FBaUJ4UixXQUExRSxFQUF1RjtBQUNuRmk5QixzQkFBY2o5QixXQUFkLEdBQTRCNDhCLFFBQTVCO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJRyxVQUFKLEVBQWdCO0FBQ1osdUJBQUs5N0IsR0FBTCxDQUFTaThCLGFBQVQsRUFBd0JILFVBQXhCO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJQyxXQUFKLEVBQWlCO0FBQ2IsdUJBQUsvN0IsR0FBTCxDQUFTMDdCLFFBQVQsRUFBbUJLLFdBQW5CO0FBQ0g7O0FBRUQsV0FBT0wsUUFBUDtBQUNILENBM0JEOztrQkE2QmVHLE07Ozs7Ozs7Ozs7Ozs7O0FDNUNkLGFBQVc7QUFDUjs7QUFFQSxRQUFJSyxPQUFPNThCLFNBQVNXLEdBQVQsQ0FBYUMsRUFBeEI7O0FBRUEsUUFBSVosU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLGNBQXJCLENBQUosRUFBMEM7QUFDdEM7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7O0FBVUFHLGFBQVM4dEIsT0FBVCxDQUFpQjNuQixHQUFqQixDQUNJLGNBREosRUFDb0I7QUFDWjs7Ozs7Ozs7O0FBU0FpdkIsY0FBTSxjQUFTcjFCLE1BQVQsRUFBaUI7QUFDbkJBLG1CQUFPZ0IsSUFBUCxDQUFZLFlBQVosRUFBMEIsWUFBVztBQUNqQyxvQkFBSUUsV0FBV2xCLE9BQU9rQixRQUFQLEVBQWY7O0FBRUFBLHlCQUFTMDVCLGNBQVQsQ0FBd0IxNUIsUUFBeEIsRUFBa0MsV0FBbEMsRUFBK0MsS0FBSzQ3QixZQUFwRCxFQUFrRSxJQUFsRSxFQUF3RTtBQUNwRTk4Qiw0QkFBUUE7QUFENEQsaUJBQXhFOztBQUlBa0IseUJBQVMwNUIsY0FBVCxDQUF3QjE1QixRQUF4QixFQUFrQyxVQUFsQyxFQUE4QyxLQUFLNjdCLFdBQW5ELEVBQWdFLElBQWhFLEVBQXNFO0FBQ2xFLzhCLDRCQUFRQTtBQUQwRCxpQkFBdEU7O0FBSUFrQix5QkFBUzA1QixjQUFULENBQXdCMTVCLFFBQXhCLEVBQWtDLE1BQWxDLEVBQTBDLEtBQUs4N0IsV0FBL0MsRUFBNEQsSUFBNUQsRUFBa0U7QUFDOURoOUIsNEJBQVFBO0FBRHNELGlCQUFsRTs7QUFJQWtCLHlCQUFTMDVCLGNBQVQsQ0FBd0IxNUIsUUFBeEIsRUFBa0MsT0FBbEMsRUFBMkMsS0FBSys3QixRQUFoRCxFQUEwRCxJQUExRCxFQUFnRTtBQUM1RGo5Qiw0QkFBUUE7QUFEb0QsaUJBQWhFO0FBR0gsYUFsQnlCLENBa0J4Qm9CLElBbEJ3QixDQWtCbkIsSUFsQm1CLENBQTFCO0FBbUJILFNBOUJXOztBQWdDWjs7Ozs7Ozs7Ozs7O0FBWUE4N0Isc0JBQWMsc0JBQVNwZ0IsS0FBVCxFQUFnQjljLE1BQWhCLEVBQXdCO0FBQ2xDLGdCQUFJaWQsSUFBSjtBQUNBLGdCQUFJaFcsQ0FBSjs7QUFFQSxnQkFBSWtXLGFBQWEsRUFBakI7O0FBRUEsaUJBQUtsVyxJQUFJLENBQVQsRUFBWUEsSUFBSTZWLE1BQU01VixNQUF0QixFQUE4QkQsR0FBOUIsRUFBbUM7QUFDL0JnVyx1QkFBT0gsTUFBTTdWLENBQU4sQ0FBUDs7QUFFQSxvQkFBSWdXLEtBQUsxTixJQUFMLENBQVVqSSxPQUFWLENBQWtCLE9BQWxCLE1BQStCLENBQW5DLEVBQXNDO0FBQ2xDNlYsK0JBQVc3VCxJQUFYLENBQWdCMlQsSUFBaEI7QUFDSDtBQUNKOztBQUVELGdCQUFJelIsU0FBU3hMLE9BQU93RCxJQUFQLENBQVksZ0JBQVosRUFBOEI7QUFDdkMyWiw0QkFBWUE7QUFEMkIsYUFBOUIsQ0FBYjs7QUFJQSxnQkFBSSxDQUFDLENBQUMzUixNQUFOLEVBQWM7QUFDVixxQkFBS3ZFLElBQUksQ0FBVCxFQUFZQSxJQUFJa1csV0FBV2pXLE1BQTNCLEVBQW1DRCxHQUFuQyxFQUF3QztBQUNwQ2dXLDJCQUFPRSxXQUFXbFcsQ0FBWCxDQUFQOztBQUVBLHlCQUFLazJCLFlBQUwsQ0FBa0JsZ0IsSUFBbEIsRUFBd0JqZCxNQUF4QjtBQUNIO0FBQ0o7O0FBRUQsbUJBQU8sS0FBUDtBQUNILFNBdkVXOztBQXlFWjs7Ozs7Ozs7Ozs7QUFXQWc5QixxQkFBYSxxQkFBU2w2QixLQUFULEVBQWdCO0FBQ3pCLGdCQUFJMlAsY0FBYzNQLE1BQU1FLElBQU4sQ0FBV1QsQ0FBN0I7O0FBRUEsZ0JBQUl0QyxTQUFTeUQsR0FBVCxDQUFhWixLQUFqQixDQUF1QjJQLFdBQXZCLEVBQW9DblAsY0FBcEM7O0FBRUEsZ0JBQUl0RCxTQUFTOEMsTUFBTVMsWUFBTixDQUFtQnZELE1BQWhDOztBQUVBOEMsa0JBQU1TLFlBQU4sQ0FBbUJ2RCxNQUFuQixDQUEwQnN5Qix3QkFBMUIsQ0FBbUQ3ZixZQUFZMnFCLE9BQS9ELEVBQXdFM3FCLFlBQVk0cUIsT0FBcEY7O0FBRUEsaUJBQUtILFlBQUwsQ0FBa0J6cUIsWUFBWTZxQixZQUFaLENBQXlCeGdCLEtBQTNDLEVBQWtEOWMsTUFBbEQ7QUFDSCxTQTlGVzs7QUFnR1o7Ozs7Ozs7OztBQVNBODhCLHNCQUFjLHNCQUFTaDZCLEtBQVQsRUFBZ0I7QUFDMUIsZ0JBQUkrNUIsSUFBSixFQUFVO0FBQ04scUJBQUtVLGFBQUwsQ0FBbUJ6NkIsS0FBbkI7QUFDSDtBQUNKLFNBN0dXOztBQStHWjs7Ozs7Ozs7O0FBU0FpNkIscUJBQWEscUJBQVNqNkIsS0FBVCxFQUFnQjtBQUN6QixnQkFBSSs1QixJQUFKLEVBQVU7QUFDTixxQkFBS1UsYUFBTCxDQUFtQno2QixLQUFuQjtBQUNIO0FBQ0osU0E1SFc7O0FBOEhaOzs7Ozs7Ozs7O0FBVUFtNkIsa0JBQVUsa0JBQVNuNkIsS0FBVCxFQUFnQjtBQUN0QixnQkFBSUEsTUFBTUUsSUFBTixJQUFjRixNQUFNRSxJQUFOLENBQVdULENBQXpCLElBQThCTyxNQUFNRSxJQUFOLENBQVdULENBQVgsQ0FBYWk3QixhQUEzQyxJQUE0RDE2QixNQUFNRSxJQUFOLENBQVdULENBQVgsQ0FBYWk3QixhQUFiLENBQTJCdHZCLEtBQXZGLElBQWdHcEwsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWFpN0IsYUFBYixDQUEyQnR2QixLQUEzQixDQUFpQ2hILE1BQWpDLEdBQTBDLENBQTlJLEVBQWlKO0FBQzdJLG9CQUFJdTJCLGFBQWEzNkIsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWFpN0IsYUFBYixDQUEyQnR2QixLQUEzQixDQUFpQyxDQUFqQyxDQUFqQjs7QUFFQSxvQkFBSXV2QixXQUFXbHVCLElBQVgsQ0FBZ0JqSSxPQUFoQixDQUF3QixPQUF4QixNQUFxQyxDQUF6QyxFQUE0QztBQUN4Qyx3QkFBSW8yQixZQUFZRCxXQUFXRSxTQUFYLEVBQWhCOztBQUVBLHlCQUFLUixZQUFMLENBQWtCTyxTQUFsQixFQUE2QjU2QixNQUFNUyxZQUFOLENBQW1CdkQsTUFBaEQ7QUFDSDtBQUNKO0FBQ0osU0FsSlc7O0FBb0paOzs7Ozs7Ozs7QUFTQXU5Qix1QkFBZSx1QkFBU3o2QixLQUFULEVBQWdCO0FBQzNCQSxvQkFBUSxJQUFJN0MsU0FBU3lELEdBQVQsQ0FBYVosS0FBakIsQ0FBdUJBLE1BQU1FLElBQU4sQ0FBV1QsQ0FBbEMsQ0FBUjs7QUFFQU8sa0JBQU1RLGNBQU47QUFDQVIsa0JBQU1zTSxlQUFOO0FBQ0gsU0FsS1c7O0FBb0taOzs7Ozs7Ozs7OztBQVdBK3RCLHNCQUFjLHNCQUFTbGdCLElBQVQsRUFBZWpkLE1BQWYsRUFBdUI7QUFDakMsZ0JBQUkrYyxTQUFTLElBQUlDLFVBQUosRUFBYjs7QUFFQUQsbUJBQU9uRixnQkFBUCxDQUF3QixTQUF4QixFQUFtQyxZQUFXO0FBQzFDLG9CQUFJZ21CLE1BQU03Z0IsT0FBT3ZSLE1BQWpCOztBQUVBLG9CQUFJOEwsS0FBS3JYLFNBQVN5RCxHQUFULENBQWE2TSxPQUFiLENBQXFCZ0gsY0FBckIsQ0FBb0MsZUFBZXFtQixHQUFmLEdBQXFCLElBQXpELENBQVQ7O0FBRUE1OUIsdUJBQU93WCxhQUFQLENBQXFCRixFQUFyQjs7QUFFQSxvQkFBSThGLFlBQVk7QUFDWjlGLHdCQUFJQSxFQURRO0FBRVoyRiwwQkFBTUE7QUFGTSxpQkFBaEI7O0FBS0FqZCx1QkFBT3dELElBQVAsQ0FBWSxVQUFaLEVBQXdCNFosU0FBeEI7QUFDSCxhQWJEOztBQWVBTCxtQkFBT00sYUFBUCxDQUFxQkosSUFBckI7QUFDSDtBQWxNVyxLQURwQjtBQXNNSCxDQTNPQSxHQUFELEM7Ozs7Ozs7Ozs7Ozs7O0FDQUMsYUFBVztBQUNSOztBQUVBLFFBQUloZCxTQUFTOHRCLE9BQVQsQ0FBaUJqdUIsR0FBakIsQ0FBcUIsYUFBckIsQ0FBSixFQUF5QztBQUNyQztBQUNIOztBQUVEO0FBQ0E7QUFDQSxRQUFJLHVDQUF1QytJLElBQXZDLENBQTRDZCxVQUFVODFCLFNBQXRELENBQUosRUFBc0U7QUFDbEV2N0IsaUJBQVNnSSxXQUFULENBQXFCLGVBQXJCLEVBQXNDLEtBQXRDLEVBQTZDLEtBQTdDO0FBQ0g7O0FBRUQsUUFBSXd6QixXQUFXLENBQWY7O0FBRUEsUUFBSUMsWUFBWSxHQUFoQjs7QUFFQSxRQUFJeGtCLFlBQVksRUFBaEI7O0FBRUEsUUFBSXlrQixnQkFBZ0IsR0FBcEI7O0FBRUEsUUFBSUMsWUFBWSxFQUFoQjs7QUFFQSxRQUFJQyxhQUFhLENBQUNILFNBQUQsRUFBWXhrQixTQUFaLEVBQXVCeWtCLGFBQXZCLEVBQXNDQyxTQUF0QyxDQUFqQjs7QUFFQSxRQUFJRSxrQkFBa0IsVUFBdEI7O0FBRUEsUUFBSUMsWUFBWSwrREFBaEI7O0FBRUE7Ozs7OztBQU1BbitCLGFBQVM4dEIsT0FBVCxDQUFpQjNuQixHQUFqQixDQUNJLGFBREosRUFDbUI7O0FBRVg7Ozs7Ozs7OztBQVNBaXZCLGNBQU0sY0FBU3IxQixNQUFULEVBQWlCO0FBQ25CQSxtQkFBT2dCLElBQVAsQ0FBWSxZQUFaLEVBQTBCLFlBQVc7QUFDakMsb0JBQUlFLFdBQVdsQixPQUFPa0IsUUFBUCxFQUFmOztBQUVBQSx5QkFBUzA1QixjQUFULENBQXdCMTVCLFFBQXhCLEVBQWtDLE9BQWxDLEVBQTJDLEtBQUttOUIsUUFBaEQsRUFBMEQsSUFBMUQsRUFBZ0U7QUFDNURyK0IsNEJBQVFBO0FBRG9ELGlCQUFoRTtBQUdILGFBTnlCLENBTXhCb0IsSUFOd0IsQ0FNbkIsSUFObUIsQ0FBMUI7QUFPSCxTQW5CVTs7QUFxQlg7Ozs7Ozs7Ozs7QUFVQWs5QixzQkFBYyxzQkFBU3QrQixNQUFULEVBQWlCO0FBQzNCLGdCQUFJd3ZCLFFBQVF4dkIsT0FBT3FDLFlBQVAsR0FBc0JvdEIsU0FBdEIsR0FBa0MsQ0FBbEMsQ0FBWjs7QUFFQSxnQkFBSVEsU0FBU1QsTUFBTXlELFdBQW5COztBQUVBLGdCQUFJc0wsZUFBZSxFQUFuQjs7QUFFQTtBQUNBLGdCQUFJLEtBQUtDLGVBQUwsS0FBeUJqbEIsU0FBN0IsRUFBd0M7QUFDcEMsb0JBQUlrbEIsZUFBZWpQLE1BQU13RCxjQUFOLENBQXFCMEwsV0FBckIsRUFBbkI7O0FBRUEsb0JBQUlDLFNBQUo7O0FBRUEsb0JBQUlGLFlBQUosRUFBa0I7QUFDZDtBQUNBO0FBQ0EsMkJBQU8sQ0FBQ0EsYUFBYUcsT0FBckIsRUFBOEI7QUFDMUJILHVDQUFlQSxhQUFhQyxXQUFiLEVBQWY7QUFDSDs7QUFFREMsZ0NBQVlGLGFBQWFHLE9BQWIsRUFBWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBT0QsYUFBYSxDQUFDQSxVQUFVM08sT0FBVixFQUFyQixFQUEwQztBQUN0QzJPLG9DQUFZQSxVQUFVRCxXQUFWLEVBQVo7QUFDSDtBQUNKOztBQUVEO0FBQ0Esb0JBQUksRUFBRUMsYUFBYUEsVUFBVXA4QixDQUFWLENBQVl3QixJQUEzQixDQUFKLEVBQXNDO0FBQ2xDLHlCQUFLODZCLGVBQUwsR0FBdUJGLFNBQXZCO0FBQ0FKLG1DQUFlSSxZQUFZQSxVQUFVM08sT0FBVixFQUFaLEdBQWtDLEVBQWpEO0FBQ0EseUJBQUs4TyxPQUFMLEdBQWVQLGFBQWFyM0IsTUFBNUI7QUFDSDtBQUNKLGFBNUJELE1BNEJPO0FBQ0gscUJBQUsyM0IsZUFBTCxHQUF1QnJQLE1BQU13RCxjQUE3Qjs7QUFFQTtBQUNBdUwsK0JBQWUsS0FBS00sZUFBTCxDQUFxQjdPLE9BQXJCLEdBQStCK08sU0FBL0IsQ0FBeUMsQ0FBekMsRUFBNEM5TyxTQUFTLENBQXJELENBQWY7O0FBRUEscUJBQUs2TyxPQUFMLEdBQWU3TyxTQUFTLENBQXhCO0FBQ0g7O0FBRUQsZ0JBQUkrTyxXQUFXLEVBQWY7O0FBRUEsZ0JBQUk3M0IsUUFBUW8zQixhQUFhcDNCLEtBQWIsQ0FBbUJnM0IsZUFBbkIsQ0FBWjs7QUFFQSxnQkFBSWgzQixLQUFKLEVBQVc7QUFDUDYzQiwyQkFBVzczQixNQUFNODNCLEdBQU4sRUFBWDtBQUNIOztBQUVELG1CQUFPRCxRQUFQO0FBQ0gsU0FyRlU7O0FBdUZYOzs7Ozs7Ozs7O0FBVUFFLHFCQUFhLHFCQUFTcjdCLElBQVQsRUFBZTtBQUN4QixtQkFBT3U2QixVQUFVdjFCLElBQVYsQ0FBZWhGLElBQWYsQ0FBUDtBQUNILFNBbkdVOztBQXFHWDs7Ozs7Ozs7OztBQVVBczdCLG9CQUFZLG9CQUFTcjhCLEtBQVQsRUFBZ0I7QUFDeEIsZ0JBQUkyUCxjQUFjM1AsTUFBTUUsSUFBTixDQUFXVCxDQUE3Qjs7QUFFQSxnQkFBSXZDLFNBQVM4QyxNQUFNUyxZQUFOLENBQW1CdkQsTUFBaEM7O0FBRUEsZ0JBQUlrQixXQUFXbEIsT0FBT2tCLFFBQVAsRUFBZjs7QUFFQUEscUJBQVMyNUIsY0FBVCxDQUF3QixTQUF4QixFQUFtQyxLQUFLc0UsVUFBeEM7O0FBRUEsZ0JBQUkxc0IsWUFBWXpDLE9BQVosS0FBd0I4dEIsUUFBNUIsRUFBc0M7QUFDbENoN0Isc0JBQU0wMkIsTUFBTjtBQUNBMTJCLHNCQUFNRSxJQUFOLENBQVdNLGNBQVg7O0FBRUEscUJBQUt3YyxXQUFMLENBQWlCOWYsTUFBakI7QUFDSDs7QUFFRCxpQkFBS28vQixPQUFMLEdBQWUsSUFBZjtBQUNILFNBaElVOztBQWtJWDs7Ozs7Ozs7OztBQVVBZixrQkFBVSxrQkFBU3Y3QixLQUFULEVBQWdCO0FBQ3RCLGdCQUFJMlAsY0FBYzNQLE1BQU1FLElBQU4sQ0FBV1QsQ0FBN0I7O0FBRUEsaUJBQUtpOEIsZUFBTCxHQUF1Qi9yQixZQUFZekMsT0FBbkM7O0FBRUEsZ0JBQUlrdUIsV0FBVzUyQixPQUFYLENBQW1CLEtBQUtrM0IsZUFBeEIsTUFBNkMsQ0FBQyxDQUFsRCxFQUFxRDtBQUNqRCxvQkFBSXgrQixTQUFTOEMsTUFBTVMsWUFBTixDQUFtQnZELE1BQWhDOztBQUVBLG9CQUFJZy9CLFdBQVcsS0FBS1YsWUFBTCxDQUFrQnQrQixNQUFsQixDQUFmOztBQUVBLG9CQUFJLEtBQUtrL0IsV0FBTCxDQUFpQkYsUUFBakIsQ0FBSixFQUFnQztBQUM1Qix5QkFBS0sscUJBQUwsQ0FBMkJyL0IsTUFBM0IsRUFBbUNnL0IsUUFBbkM7QUFDSDtBQUNKO0FBQ0osU0ExSlU7O0FBNEpYOzs7Ozs7Ozs7O0FBVUFLLCtCQUF1QiwrQkFBU3IvQixNQUFULEVBQWlCcy9CLE9BQWpCLEVBQTBCO0FBQzdDLGdCQUFJOVAsUUFBUXh2QixPQUFPb3pCLFdBQVAsRUFBWjtBQUNBLGdCQUFJdnpCLE9BQU9JLFNBQVN5RCxHQUFULENBQWE2TSxPQUFiLENBQXFCelEsR0FBckIsQ0FBeUIsS0FBSysrQixlQUE5QixDQUFYO0FBQ0EsZ0JBQUk1TyxTQUFTLEtBQUs2TyxPQUFsQjs7QUFFQTtBQUNBdFAsa0JBQU1VLFFBQU4sQ0FBZXJ3QixJQUFmLEVBQXFCb3dCLFNBQVNxUCxRQUFRcDRCLE1BQXRDO0FBQ0Fzb0Isa0JBQU1XLE1BQU4sQ0FBYXR3QixJQUFiLEVBQW1Cb3dCLE1BQW5CO0FBQ0FULGtCQUFNb0IsTUFBTjs7QUFFQSxnQkFBSTJPLFNBQVMsSUFBSXQvQixTQUFTaWdCLElBQWIsQ0FBa0JsZ0IsTUFBbEIsQ0FBYjtBQUNBdS9CLG1CQUFPeGUsTUFBUCxDQUFjdWUsT0FBZDtBQUNBLGlCQUFLRixPQUFMLEdBQWVHLE1BQWY7O0FBRUEsZ0JBQUlDLFdBQVdELE9BQU9wZixnQkFBUCxFQUFmO0FBQ0FuZ0IsbUJBQU93RCxJQUFQLENBQVksYUFBWixFQUEyQmc4QixRQUEzQjs7QUFFQSxpQkFBS0Msb0JBQUwsQ0FBMEJ6L0IsTUFBMUI7O0FBRUE7QUFDQTtBQUNBd3ZCLG9CQUFReHZCLE9BQU9xQyxZQUFQLEdBQXNCb3RCLFNBQXRCLEdBQWtDLENBQWxDLENBQVI7O0FBRUE7QUFDQTtBQUNBLGdCQUFJLEtBQUsrTyxlQUFMLEtBQXlCamxCLFNBQTdCLEVBQXdDO0FBQ3BDLG9CQUFJbW1CLG1CQUFtQmxRLE1BQU1JLG1CQUFOLEVBQXZCOztBQUVBSixzQkFBTVUsUUFBTixDQUFld1AsZ0JBQWYsRUFBaUMsQ0FBakM7QUFDQWxRLHNCQUFNVyxNQUFOLENBQWF1UCxnQkFBYixFQUErQixDQUEvQjtBQUNILGFBTEQsTUFLTztBQUNILG9CQUFJL1AsV0FBV0gsTUFBTW1RLFdBQU4sRUFBZjs7QUFFQW5RLHNCQUFNVSxRQUFOLENBQWVQLFFBQWYsRUFBeUIsQ0FBekI7QUFDQUgsc0JBQU1XLE1BQU4sQ0FBYVIsUUFBYixFQUF1QixDQUF2QjtBQUNIOztBQUVESCxrQkFBTW9CLE1BQU47QUFDSCxTQTVNVTs7QUE4TVg7Ozs7Ozs7O0FBUUE7Ozs7Ozs7O0FBUUE5USxxQkFBYSxxQkFBUzlmLE1BQVQsRUFBaUI7QUFDMUIsZ0JBQUl3dkIsUUFBUXh2QixPQUFPcUMsWUFBUCxHQUFzQm90QixTQUF0QixHQUFrQyxDQUFsQyxDQUFaO0FBQ0EsZ0JBQUltUSxjQUFjcFEsTUFBTXlELFdBQXhCOztBQUVBO0FBQ0EsZ0JBQUl1TSxXQUFXLEtBQUtYLGVBQUwsQ0FBcUJnQixPQUFyQixNQUFrQyxLQUFLaEIsZUFBdEQ7O0FBRUEsZ0JBQUlpQixXQUFXOS9CLE9BQU9vekIsV0FBUCxFQUFmO0FBQ0EwTSxxQkFBUzVQLFFBQVQsQ0FBa0JzUCxRQUFsQixFQUE0QixDQUE1QjtBQUNBTSxxQkFBU0MsV0FBVCxDQUFxQlAsUUFBckI7QUFDQU0scUJBQVNsUCxNQUFUOztBQUVBLGlCQUFLd08sT0FBTCxDQUFhOWpCLE1BQWI7O0FBRUE7QUFDQWtVLGtCQUFNVyxNQUFOLENBQWFYLE1BQU13RCxjQUFuQixFQUFtQzRNLFdBQW5DO0FBQ0FwUSxrQkFBTVUsUUFBTixDQUFlVixNQUFNd0QsY0FBckIsRUFBcUM0TSxXQUFyQzs7QUFFQXBRLGtCQUFNb0IsTUFBTjtBQUNILFNBalBVOztBQW1QWDs7Ozs7Ozs7QUFRQTZPLDhCQUFzQiw4QkFBU3ovQixNQUFULEVBQWlCO0FBQ25DLGdCQUFJa0IsV0FBV2xCLE9BQU9rQixRQUFQLEVBQWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0FBLHFCQUFTMDVCLGNBQVQsQ0FBd0IxNUIsUUFBeEIsRUFBa0MsU0FBbEMsRUFBNkMsS0FBS2krQixVQUFsRCxFQUE4RCxJQUE5RCxFQUFvRTtBQUNoRW4vQix3QkFBUUE7QUFEd0QsYUFBcEUsRUFFRyxDQUZIO0FBR0g7QUFwUVUsS0FEbkI7QUF3UUgsQ0EzU0EsR0FBRCxDOzs7Ozs7Ozs7Ozs7OztBQ0FDLGFBQVc7QUFDWDs7QUFFRyxRQUFJQyxTQUFTOHRCLE9BQVQsQ0FBaUJqdUIsR0FBakIsQ0FBcUIsYUFBckIsQ0FBSixFQUF5QztBQUNyQztBQUNIOztBQUVELFFBQUlnK0IsV0FBVyxDQUFmOztBQUVBLFFBQUlHLFlBQVksRUFBaEI7O0FBRUEsUUFBSStCLGlCQUFpQixDQUNqQjtBQUNJQyxlQUFPLE1BRFg7QUFFSTF3QixjQUFNO0FBRlYsS0FEaUIsRUFLakI7QUFDSTB3QixlQUFPLE9BRFg7QUFFSTF3QixjQUFNO0FBRlYsS0FMaUIsQ0FBckI7O0FBV0g7Ozs7OztBQU1HdFAsYUFBUzh0QixPQUFULENBQWlCM25CLEdBQWpCLENBQ0ksYUFESixFQUNtQjs7QUFFWDs7Ozs7Ozs7O0FBU0FpdkIsY0FBTSxjQUFTcjFCLE1BQVQsRUFBaUI7QUFDbkJBLG1CQUFPZ0IsSUFBUCxDQUFZLFlBQVosRUFBMEIsWUFBVztBQUNqQyxvQkFBSUUsV0FBV2xCLE9BQU9rQixRQUFQLEVBQWY7O0FBRUFBLHlCQUFTMDVCLGNBQVQsQ0FBd0IxNUIsUUFBeEIsRUFBa0MsU0FBbEMsRUFBNkMsS0FBS2krQixVQUFsRCxFQUE4RCxJQUE5RCxFQUFvRTtBQUNoRW4vQiw0QkFBUUE7QUFEd0QsaUJBQXBFO0FBSUgsYUFQeUIsQ0FPeEJvQixJQVB3QixDQU9uQixJQVBtQixDQUExQjtBQVFILFNBcEJVOztBQXNCWDs7Ozs7Ozs7O0FBU0E4K0IsbUNBQTJCLG1DQUFTcDlCLEtBQVQsRUFBZ0I7QUFDdkMsZ0JBQUk5QyxTQUFTOEMsTUFBTVMsWUFBTixDQUFtQnZELE1BQWhDOztBQUVBLGdCQUFJeVMsY0FBYzNQLE1BQU1FLElBQU4sQ0FBV1QsQ0FBN0I7O0FBRUEsZ0JBQUlyQixXQUFXbEIsT0FBT2tCLFFBQVAsRUFBZjs7QUFFQUEscUJBQVMyNUIsY0FBVCxDQUF3QixTQUF4QixFQUFtQyxLQUFLcUYseUJBQXhDOztBQUVBLGdCQUFJenRCLFlBQVl6QyxPQUFaLEtBQXdCOHRCLFFBQTVCLEVBQXNDO0FBQ2xDOTlCLHVCQUFPc0ssV0FBUCxDQUFtQixNQUFuQjtBQUNBdEssdUJBQU9tZ0MsVUFBUCxDQUFrQnI5QixNQUFNUyxZQUFOLENBQW1CNjhCLE1BQW5CLEdBQTRCLFFBQTlDO0FBQ0F0OUIsc0JBQU1FLElBQU4sQ0FBV00sY0FBWDtBQUNIO0FBQ0osU0E3Q1U7O0FBK0NYOzs7Ozs7Ozs7O0FBVUErOEIsd0JBQWdCLHdCQUFTcmdDLE1BQVQsRUFBaUI7QUFDN0IsZ0JBQUlzZ0MsY0FBY3RnQyxPQUFPUixNQUFQLENBQWMrZ0MsUUFBZCxJQUEwQlAsY0FBNUM7O0FBRUEsZ0JBQUl4USxRQUFReHZCLE9BQU9xQyxZQUFQLEdBQXNCb3RCLFNBQXRCLEdBQWtDLENBQWxDLENBQVo7O0FBRUEsZ0JBQUkrUSxnQkFBZ0JoUixNQUFNcUQsWUFBTixDQUFtQjdDLE9BQW5CLEVBQXBCOztBQUVBLGdCQUFJb1EsU0FBU0ksY0FBY3pCLFNBQWQsQ0FBd0IsQ0FBeEIsRUFBMkJ2UCxNQUFNeUQsV0FBakMsQ0FBYjs7QUFFQSxnQkFBSTFDLE9BQU9pUSxjQUFjekIsU0FBZCxDQUF3QnZQLE1BQU15RCxXQUE5QixFQUEyQ3VOLGNBQWN0NUIsTUFBekQsQ0FBWDs7QUFFQSxnQkFBSXlLLFFBQVEsQ0FBWjs7QUFFQSxnQkFBSTh1QixXQUFXSCxZQUFZcDVCLE1BQTNCOztBQUVBLGdCQUFJdzVCLGNBQWMsSUFBbEI7O0FBRUEsbUJBQU8sQ0FBQ0EsV0FBRCxJQUFnQkQsV0FBVzl1QixLQUFsQyxFQUF5QztBQUNyQyxvQkFBSWd2QixZQUFZTCxZQUFZM3VCLEtBQVosQ0FBaEI7O0FBRUEsb0JBQUlndkIsVUFBVVYsS0FBVixDQUFnQnAzQixJQUFoQixDQUFxQnUzQixNQUFyQixDQUFKLEVBQWtDO0FBQzlCTSxrQ0FBYztBQUNWTixnQ0FBUUEsTUFERTtBQUVWcGdDLGdDQUFRQSxNQUZFO0FBR1Z1d0IsOEJBQU1BLElBSEk7QUFJVmhoQiw4QkFBTW94QixVQUFVcHhCO0FBSk4scUJBQWQ7O0FBT0E7QUFDSDs7QUFFRG9DO0FBQ0g7O0FBRUQsbUJBQU8rdUIsV0FBUDtBQUNILFNBNUZVOztBQThGcEI7Ozs7Ozs7OztBQVNTRSxxQkFBYSxxQkFBU0MsVUFBVCxFQUFxQjtBQUM5QixnQkFBSTdnQyxTQUFTNmdDLFdBQVc3Z0MsTUFBeEI7O0FBRUEsZ0JBQUl3dkIsUUFBUXh2QixPQUFPcUMsWUFBUCxHQUFzQm90QixTQUF0QixHQUFrQyxDQUFsQyxDQUFaOztBQUVBRCxrQkFBTXFELFlBQU4sQ0FBbUJpTyxPQUFuQixDQUEyQkQsV0FBV3RRLElBQXRDO0FBQ0F2d0IsbUJBQU9zSyxXQUFQLENBQW1CdTJCLFdBQVd0eEIsSUFBOUI7O0FBRUEsZ0JBQUlyTyxXQUFXbEIsT0FBT2tCLFFBQVAsRUFBZjs7QUFFQTtBQUNBO0FBQ0FBLHFCQUFTMDVCLGNBQVQsQ0FBd0IxNUIsUUFBeEIsRUFBa0MsU0FBbEMsRUFBNkMsS0FBS2cvQix5QkFBbEQsRUFBNkUsSUFBN0UsRUFBbUY7QUFDL0VsZ0Msd0JBQVFBLE1BRHVFO0FBRS9Fb2dDLHdCQUFRUyxXQUFXVDtBQUY0RCxhQUFuRixFQUdHLENBSEg7QUFJSCxTQXZIVTs7QUF5SHBCOzs7Ozs7Ozs7O0FBVVNqQixvQkFBWSxvQkFBU3I4QixLQUFULEVBQWdCO0FBQ3hCLGdCQUFJMlAsY0FBYzNQLE1BQU1FLElBQU4sQ0FBV1QsQ0FBN0I7O0FBRUEsZ0JBQUlrUSxZQUFZekMsT0FBWixLQUF3Qml1QixTQUE1QixFQUF1QztBQUNuQyxvQkFBSTRDLGFBQWEsS0FBS1IsY0FBTCxDQUFvQnY5QixNQUFNUyxZQUFOLENBQW1CdkQsTUFBdkMsQ0FBakI7O0FBRUEsb0JBQUk2Z0MsVUFBSixFQUFnQjtBQUNaLzlCLDBCQUFNRSxJQUFOLENBQVdNLGNBQVg7QUFDQSx5QkFBS3M5QixXQUFMLENBQWlCQyxVQUFqQjtBQUNIO0FBQ0o7QUFDSjtBQTlJVSxLQURuQjtBQWtKSCxDQTlLQSxHQUFELEM7Ozs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7O0FBUUMsYUFBVztBQUNSOztBQUVBLFFBQUk1Z0MsU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLGVBQXJCLENBQUosRUFBMkM7QUFDdkM7QUFDSDs7QUFFRCxRQUFJaWhDLGdCQUFnQjtBQUNoQkMsY0FBTSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUEyQyxJQUEzQyxDQURVO0FBRWhCaHNCLGdCQUFRLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLENBRlE7QUFHaEJpc0IsZUFBTyxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixDQUhTO0FBSWhCNXVCLGVBQU8sQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0I7QUFKUyxLQUFwQjs7QUFPQSxRQUFJNnVCLHNCQUFzQjtBQUN0QkMsWUFBSSxZQUFTQyxNQUFULEVBQWlCbHZCLElBQWpCLEVBQXVCRSxHQUF2QixFQUE0Qml2QixHQUE1QixFQUFpQztBQUNqQ0MsNEJBQWdCRixNQUFoQixFQUF3QixDQUFDLENBQUQsR0FBS2x2QixJQUE3QixFQUFtQ212QixJQUFJcnNCLE1BQUosR0FBYSxDQUFiLEdBQWlCNUMsR0FBcEQ7QUFDSCxTQUhxQjtBQUl0Qm12QixZQUFJLFlBQVNILE1BQVQsRUFBaUJsdkIsSUFBakIsRUFBdUJFLEdBQXZCLEVBQTRCaXZCLEdBQTVCLEVBQWlDO0FBQ2pDQyw0QkFBZ0JGLE1BQWhCLEVBQXdCeDJCLEtBQUs0MkIsS0FBTCxDQUFXSCxJQUFJaHZCLEtBQUosR0FBWSxDQUF2QixJQUE0QixDQUE1QixHQUFnQ0gsSUFBeEQsRUFBOERtdkIsSUFBSXJzQixNQUFKLEdBQWEsQ0FBYixHQUFpQjVDLEdBQS9FO0FBQ0gsU0FOcUI7QUFPdEJxdkIsWUFBSSxZQUFTTCxNQUFULEVBQWlCbHZCLElBQWpCLEVBQXVCRSxHQUF2QixFQUE0Qml2QixHQUE1QixFQUFpQztBQUNqQ0MsNEJBQWdCRixNQUFoQixFQUF3QkMsSUFBSWh2QixLQUFKLEdBQVksQ0FBWixHQUFnQkgsSUFBeEMsRUFBOENtdkIsSUFBSXJzQixNQUFKLEdBQWEsQ0FBYixHQUFpQjVDLEdBQS9EO0FBQ0gsU0FUcUI7QUFVdEJzdkIsWUFBSSxZQUFTTixNQUFULEVBQWlCbHZCLElBQWpCLEVBQXVCRSxHQUF2QixFQUE0Qml2QixHQUE1QixFQUFpQztBQUNqQ0MsNEJBQWdCRixNQUFoQixFQUF3QixDQUFDLENBQUQsR0FBS2x2QixJQUE3QixFQUFtQ3RILEtBQUs0MkIsS0FBTCxDQUFXSCxJQUFJcnNCLE1BQUosR0FBYSxDQUF4QixJQUE2QixDQUE3QixHQUFpQzVDLEdBQXBFO0FBQ0gsU0FacUI7QUFhdEJ1dkIsWUFBSSxZQUFTUCxNQUFULEVBQWlCbHZCLElBQWpCLEVBQXVCRSxHQUF2QixFQUE0Qml2QixHQUE1QixFQUFpQztBQUNqQ0MsNEJBQWdCRixNQUFoQixFQUF3Qmx2QixPQUFPLENBQS9CLEVBQWtDRSxNQUFNLENBQXhDO0FBQ0gsU0FmcUI7QUFnQnRCd3ZCLFlBQUksWUFBU1IsTUFBVCxFQUFpQmx2QixJQUFqQixFQUF1QkUsR0FBdkIsRUFBNEJpdkIsR0FBNUIsRUFBaUM7QUFDakNDLDRCQUFnQkYsTUFBaEIsRUFBd0J4MkIsS0FBSzQyQixLQUFMLENBQVdILElBQUlodkIsS0FBSixHQUFZLENBQXZCLElBQTRCLENBQTVCLEdBQWdDSCxJQUF4RCxFQUE4RCxDQUFDLENBQUQsR0FBS0UsR0FBbkU7QUFDSCxTQWxCcUI7QUFtQnRCeXZCLFlBQUksWUFBU1QsTUFBVCxFQUFpQmx2QixJQUFqQixFQUF1QkUsR0FBdkIsRUFBNEJpdkIsR0FBNUIsRUFBaUM7QUFDakNDLDRCQUFnQkYsTUFBaEIsRUFBd0JDLElBQUlodkIsS0FBSixHQUFZLENBQVosR0FBZ0JILElBQXhDLEVBQThDLENBQUMsQ0FBRCxHQUFLRSxHQUFuRDtBQUNILFNBckJxQjtBQXNCdEIwdkIsWUFBSSxZQUFTVixNQUFULEVBQWlCbHZCLElBQWpCLEVBQXVCRSxHQUF2QixFQUE0Qml2QixHQUE1QixFQUFpQztBQUNqQ0MsNEJBQWdCRixNQUFoQixFQUF3QkMsSUFBSWh2QixLQUFKLEdBQVksQ0FBWixHQUFnQkgsSUFBeEMsRUFBOEN0SCxLQUFLNDJCLEtBQUwsQ0FBV0gsSUFBSXJzQixNQUFKLEdBQWEsQ0FBeEIsSUFBNkIsQ0FBN0IsR0FBaUM1QyxHQUEvRTtBQUNIO0FBeEJxQixLQUExQjs7QUEyQkEsUUFBSTJ2QixxQkFBcUIsQ0FBekI7O0FBRUEsUUFBSUMsWUFBYSxtQkFBbUIxL0IsU0FBUzIvQixlQUFULENBQXlCcDJCLEtBQTdEOztBQUVBLFFBQUlxMkIsV0FBWSxzQkFBc0I1L0IsU0FBUzIvQixlQUFULENBQXlCcDJCLEtBQS9EOztBQUVBLFFBQUlzMkIsZUFBZUQsWUFBWUYsU0FBL0I7O0FBRUEsUUFBSUcsWUFBSixFQUFrQjtBQUNkO0FBQ0FsaUMsaUJBQVNtaUMsTUFBVCxDQUFnQiwwZ0NBQWhCO0FBQ0g7O0FBRUQ7OztBQUdBbmlDLGFBQVM4dEIsT0FBVCxDQUFpQjNuQixHQUFqQixDQUFxQixlQUFyQixFQUFzQztBQUNsQ2k4QixnQkFBUSxrQkFBVztBQUNmLGdCQUFJLENBQUNGLFlBQUwsRUFBbUI7QUFDZjtBQUNIO0FBQ0osU0FMaUM7QUFNbEM5TSxjQUFNLGNBQVNyMUIsTUFBVCxFQUFpQjtBQUNuQixnQkFBSSxDQUFDbWlDLFlBQUwsRUFBbUI7QUFDZjtBQUNIOztBQUVEbmlDLG1CQUFPZ0IsSUFBUCxDQUFZLFlBQVosRUFBMEIsVUFBU3NoQyxHQUFULEVBQWM7QUFDcENqTixzQkFBS3IxQixNQUFMO0FBQ0gsYUFGRDtBQUdIO0FBZGlDLEtBQXRDOztBQWlCQSxhQUFTcTFCLEtBQVQsQ0FBY3IxQixNQUFkLEVBQXNCO0FBQ2xCLFlBQUlvQyxTQUFTcEMsT0FBT29DLE1BQVAsQ0FBY0csQ0FBM0I7QUFBQSxZQUNJRCxXQUFXdEMsT0FBT3NDLFFBQVAsQ0FBZ0JDLENBRC9COztBQUdBLFlBQUl5L0IsU0FBSixFQUFlO0FBQ1g7QUFDQTEvQixxQkFBU2dJLFdBQVQsQ0FBcUIsc0JBQXJCLEVBQTZDLEtBQTdDLEVBQW9ELEtBQXBEO0FBQ0g7O0FBRUQsWUFBSWk0QixhQUFjLE9BQU9SLGtCQUFQLEtBQThCLFdBQS9CLEdBQThDLElBQTlDLEdBQXFEQSxrQkFBdEU7O0FBRUEvaEMsZUFBT1IsTUFBUCxDQUFjZ2pDLGdCQUFkLEdBQWlDeGlDLE9BQU9SLE1BQVAsQ0FBY2dqQyxnQkFBZCxJQUFrQyxNQUFuRTs7QUFFQSxZQUFJQyxVQUFVLElBQUlDLE9BQUosQ0FBWTFpQyxNQUFaLEVBQW9CO0FBQzlCd2lDLDhCQUFrQnhpQyxPQUFPUixNQUFQLENBQWNnakMsZ0JBREY7QUFFOUJELHdCQUFZQTtBQUZrQixTQUFwQixDQUFkOztBQUtBLFlBQUlJLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVNDLENBQVQsRUFBWTtBQUNoQyxnQkFBSUgsUUFBUUksUUFBUixDQUFpQkQsRUFBRTErQixNQUFuQixDQUFKLEVBQWdDO0FBQzVCdStCLHdCQUFRSyxRQUFSLENBQWlCRixDQUFqQjtBQUNIO0FBQ0osU0FKRDs7QUFNQXRnQyxpQkFBU3NWLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDK3FCLGlCQUF2QyxFQUEwRCxLQUExRDs7QUFFQSxpQkFBU240QixlQUFULEdBQTJCO0FBQ3ZCLGdCQUFJaEksWUFBWXhDLE9BQU9xQyxZQUFQLEVBQWhCOztBQUVBLGdCQUFJLENBQUNHLFNBQUwsRUFBZ0I7QUFDaEI7QUFDQSxnQkFBSUEsVUFBVTZ4QixPQUFWLE9BQXdCcDBCLFNBQVNxMEIsY0FBakMsSUFBbUQ5eEIsVUFBVTB1QixlQUFWLEdBQTRCTCxFQUE1QixDQUErQixLQUEvQixDQUF2RCxFQUE4RjtBQUMxRjtBQUNBLG9CQUFJLENBQUN6dUIsT0FBT1UsS0FBUixJQUFpQixDQUFDVixPQUFPVSxLQUFQLENBQWEySixNQUEvQixJQUF5Q3JLLE9BQU9VLEtBQVAsQ0FBYTJKLE1BQWIsS0FBd0IsQ0FBckUsRUFBd0U7QUFDcEVnMkIsNEJBQVE5VixJQUFSLENBQWFucUIsVUFBVTB1QixlQUFWLEdBQTRCM3VCLENBQXpDO0FBQ0g7QUFDSixhQUxELE1BS087QUFDSGtnQyx3QkFBUU0sSUFBUjtBQUNIO0FBQ0o7O0FBRUQvaUMsZUFBTzRDLEVBQVAsQ0FBVSxpQkFBVixFQUE2QjRILGVBQTdCOztBQUVBeEssZUFBTzRDLEVBQVAsQ0FBVSxTQUFWLEVBQXFCLFVBQVNnZ0MsQ0FBVCxFQUFZO0FBQzdCLGdCQUFJSSxPQUFPSixFQUFFNS9CLElBQUYsQ0FBT2lnQyxTQUFQLElBQW9CLEVBQS9CO0FBQ0FELG1CQUFPQSxLQUFLamlDLE9BQUwsQ0FBYSxzQ0FBYixFQUFxRCxFQUFyRCxDQUFQO0FBQ0FpaUMsbUJBQU9BLEtBQUtqaUMsT0FBTCxDQUFhLGlCQUFiLEVBQWdDLEVBQWhDLENBQVA7QUFDQTZoQyxjQUFFNS9CLElBQUYsQ0FBT2lnQyxTQUFQLEdBQW1CRCxJQUFuQjtBQUNILFNBTEQ7O0FBT0FoakMsZUFBTzRDLEVBQVAsQ0FBVSxpQkFBVixFQUE2QixZQUFXO0FBQ3BDO0FBQ0E2L0Isb0JBQVFNLElBQVI7QUFDSCxTQUhEOztBQUtBL2lDLGVBQU80QyxFQUFQLENBQVUsZ0JBQVYsRUFBNEIsWUFBVztBQUNuQztBQUNBNEg7QUFDSCxTQUhEOztBQUtBeEssZUFBTzRDLEVBQVAsQ0FBVSxNQUFWLEVBQWtCLFlBQVc7QUFDekI7QUFDQTYvQixvQkFBUU0sSUFBUjtBQUNILFNBSEQ7O0FBS0EvaUMsZUFBTzRDLEVBQVAsQ0FBVSxrQkFBVixFQUE4QixTQUFTc2dDLElBQVQsR0FBZ0I7QUFDMUNsakMsbUJBQU82NkIsY0FBUCxDQUFzQixrQkFBdEIsRUFBMENxSSxJQUExQztBQUNBVCxvQkFBUU0sSUFBUjtBQUNILFNBSEQ7O0FBS0EvaUMsZUFBTzRDLEVBQVAsQ0FBVSxTQUFWLEVBQXFCLFlBQVc7QUFDNUIsZ0JBQUl1Z0MsZ0JBQWdCN2dDLFNBQVMyQyxjQUFULENBQXdCLFVBQXhCLENBQXBCOztBQUVBLGdCQUFJaytCLGFBQUosRUFBbUI7QUFDZkEsOEJBQWM3bkIsTUFBZDtBQUNIOztBQUVELGdCQUFJMG1CLFNBQUosRUFBZTtBQUNYMS9CLHlCQUFTZ0ksV0FBVCxDQUFxQixzQkFBckIsRUFBNkMsS0FBN0MsRUFBb0QsSUFBcEQ7QUFDSDs7QUFFRGhJLHFCQUFTa3BCLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDbVgsaUJBQTFDO0FBQ0gsU0FaRDs7QUFjQTtBQUNBLFlBQUlTLGFBQUo7QUFDQXBqQyxlQUFPb0MsTUFBUCxDQUFjUSxFQUFkLENBQWlCLFFBQWpCLEVBQTJCLFlBQVc7QUFDbEM7QUFDQWdiLHlCQUFhd2xCLGFBQWI7QUFDQTtBQUNBQSw0QkFBZ0J6N0IsV0FBVzZDLGVBQVgsRUFBNEIsRUFBNUIsQ0FBaEI7QUFDSCxTQUxEO0FBTUg7O0FBRUQsYUFBU2s0QixPQUFULENBQWlCMWlDLE1BQWpCLEVBQXlCNE0sR0FBekIsRUFBOEI7QUFDMUIsYUFBSzVNLE1BQUwsR0FBY0EsTUFBZDtBQUNBLGFBQUtvQyxNQUFMLEdBQWNwQyxPQUFPb0MsTUFBUCxDQUFjRyxDQUE1QjtBQUNBLGFBQUtELFFBQUwsR0FBZ0J0QyxPQUFPc0MsUUFBUCxDQUFnQkMsQ0FBaEM7QUFDQSxhQUFLcUssR0FBTCxHQUFXQSxPQUFPLEVBQWxCO0FBQ0EsYUFBS3lvQixJQUFMO0FBQ0g7O0FBRURxTixZQUFReHhCLFNBQVIsR0FBb0I7QUFDaEJta0IsY0FBTSxnQkFBVztBQUNiLGdCQUFJOVcsV0FBVyxJQUFmOztBQUVBLGdCQUFJOGtCLFlBQVksS0FBS0EsU0FBTCxHQUFpQixLQUFLL2dDLFFBQUwsQ0FBY2tDLGFBQWQsQ0FBNEIsS0FBNUIsQ0FBakM7O0FBRUE2K0Isc0JBQVU1SixFQUFWLEdBQWUsVUFBZjtBQUNBLGlCQUFLNkosT0FBTCxHQUFlLEtBQUtoaEMsUUFBTCxDQUFja0MsYUFBZCxDQUE0QixNQUE1QixDQUFmO0FBQ0E2K0Isc0JBQVV6K0IsV0FBVixDQUFzQixLQUFLMCtCLE9BQTNCOztBQUVBLGdCQUFJQyxVQUFVLEtBQUtBLE9BQUwsR0FBZSxFQUE3Qjs7QUFFQXhDLDBCQUFjLEtBQUtuMEIsR0FBTCxDQUFTNDFCLGdCQUF2QixFQUF5Q3J4QixPQUF6QyxDQUFpRCxVQUFVcXlCLFVBQVYsRUFBc0I3eEIsS0FBdEIsRUFBNkI7QUFDMUU0eEIsd0JBQVFDLFVBQVIsSUFBc0JqbEIsU0FBU2dsQixPQUFULENBQWlCQyxVQUFqQixJQUErQmpsQixTQUFTa2xCLFlBQVQsQ0FBc0JELFVBQXRCLENBQXJEO0FBQ0gsYUFGRDs7QUFJQSxpQkFBSyxJQUFJRSxDQUFULElBQWNILE9BQWQsRUFBdUI7QUFDbkJGLDBCQUFVeitCLFdBQVYsQ0FBc0IyK0IsUUFBUUcsQ0FBUixDQUF0QjtBQUNIO0FBQ0osU0FuQmU7QUFvQmhCRCxzQkFBYyxzQkFBUzk0QixJQUFULEVBQWU7QUFDekIsZ0JBQUkyTSxLQUFLLEtBQUtoVixRQUFMLENBQWNrQyxhQUFkLENBQTRCLEdBQTVCLENBQVQ7QUFDQThTLGVBQUdxc0IsU0FBSCxDQUFhdjlCLEdBQWIsQ0FBaUJ1RSxJQUFqQjtBQUNBLG1CQUFPMk0sRUFBUDtBQUNILFNBeEJlO0FBeUJoQnVyQixrQkFBVSxrQkFBU3ZyQixFQUFULEVBQWE7QUFDbkIsZ0JBQUlpc0IsVUFBVSxLQUFLQSxPQUFuQjtBQUNBLGlCQUFLLElBQUlHLENBQVQsSUFBY0gsT0FBZCxFQUF1QjtBQUNuQixvQkFBSUEsUUFBUUcsQ0FBUixNQUFlcHNCLEVBQW5CLEVBQXVCO0FBQ25CLDJCQUFPLElBQVA7QUFDSDtBQUNKO0FBQ0QsbUJBQU8sS0FBUDtBQUNILFNBakNlO0FBa0NoQnFWLGNBQU0sY0FBU3JWLEVBQVQsRUFBYTtBQUNmLGlCQUFLQSxFQUFMLEdBQVVBLEVBQVY7QUFDQSxnQkFBSSxLQUFLMUssR0FBTCxDQUFTMjFCLFVBQWIsRUFBeUI7QUFDckIscUJBQUtxQixXQUFMLEdBQW1CQyxRQUFRLEtBQUt2aEMsUUFBTCxDQUFjMEUsb0JBQWQsQ0FBbUMsS0FBbkMsQ0FBUixDQUFuQjtBQUNBLHFCQUFLNDhCLFdBQUwsQ0FBaUJFLE1BQWpCLENBQXdCLEtBQUtGLFdBQUwsQ0FBaUJ0OEIsT0FBakIsQ0FBeUJnUSxFQUF6QixDQUF4QixFQUFzRCxDQUF0RDtBQUNIO0FBQ0QsZ0JBQUkrcEIsTUFBTSxLQUFLQSxHQUFMLEdBQVcwQyxlQUFlLEtBQUszaEMsTUFBcEIsRUFBNEJrVixFQUE1QixDQUFyQjtBQUNBZ3FCLDRCQUFnQixLQUFLK0IsU0FBckIsRUFBZ0NoQyxJQUFJbnZCLElBQXBDLEVBQTBDbXZCLElBQUlqdkIsR0FBOUM7QUFDQSxpQkFBSzlQLFFBQUwsQ0FBY3FDLElBQWQsQ0FBbUJDLFdBQW5CLENBQStCLEtBQUt5K0IsU0FBcEM7QUFDQSxpQkFBSy9yQixFQUFMLENBQVFxc0IsU0FBUixDQUFrQnY5QixHQUFsQixDQUFzQixVQUF0QjtBQUNBLGlCQUFLNDlCLFdBQUw7QUFDSCxTQTdDZTtBQThDaEJqQixjQUFNLGdCQUFXO0FBQ2I7QUFDQSxnQkFBSWtCLFdBQVcsS0FBSzNoQyxRQUFMLENBQWM0aEMsc0JBQWQsQ0FBcUMsVUFBckMsQ0FBZjtBQUNBLGlCQUFLLElBQUlqOUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZzlCLFNBQVMvOEIsTUFBN0IsRUFBcUMsRUFBRUQsQ0FBdkMsRUFBMEM7QUFDdENnOUIseUJBQVNoOUIsQ0FBVCxFQUFZMDhCLFNBQVosQ0FBc0Jyb0IsTUFBdEIsQ0FBNkIsVUFBN0I7QUFDSDtBQUNELGlCQUFLNm9CLFdBQUw7QUFDQSxnQkFBSSxLQUFLZCxTQUFMLENBQWV4aEMsVUFBbkIsRUFBK0I7QUFDM0IscUJBQUt3aEMsU0FBTCxDQUFleGhDLFVBQWYsQ0FBMEJDLFdBQTFCLENBQXNDLEtBQUt1aEMsU0FBM0M7QUFDSDtBQUNKLFNBeERlO0FBeURoQlAsa0JBQVUsa0JBQVNGLENBQVQsRUFBWTtBQUNsQixnQkFBSUEsRUFBRW4yQixNQUFGLEtBQWEsQ0FBakIsRUFBb0I7QUFDaEI7QUFDQTtBQUNIO0FBQ0QsZ0JBQUlnMkIsVUFBVSxJQUFkO0FBQ0EsZ0JBQUkyQixPQUFPLElBQUlDLFNBQUosQ0FBYyxLQUFLamlDLE1BQW5CLEVBQTJCLEtBQUtFLFFBQWhDLENBQVg7QUFDQThoQyxpQkFBS0UsT0FBTCxHQUFlLFlBQVc7QUFDdEI3Qix3QkFBUThCLFdBQVI7QUFDQTlCLHdCQUFRK0IsVUFBUixHQUFxQixJQUFyQjtBQUNBL0Isd0JBQVF6aUMsTUFBUixDQUFlcUMsWUFBZixHQUE4QndILElBQTlCO0FBQ0gsYUFKRDtBQUtBdTZCLGlCQUFLSyxNQUFMLEdBQWMsWUFBVztBQUNyQmhDLHdCQUFRaUMsYUFBUixDQUFzQixJQUF0QjtBQUNBakMsd0JBQVFrQyxhQUFSO0FBQ0Esb0JBQUl0RCxNQUFNb0IsUUFBUW1DLFVBQWxCO0FBQ0FuQyx3QkFBUW9DLGFBQVIsQ0FBc0J4RCxHQUF0QixFQUEyQkEsSUFBSW52QixJQUEvQixFQUFxQ212QixJQUFJanZCLEdBQXpDO0FBQ0gsYUFMRDtBQU1BZ3lCLGlCQUFLVSxTQUFMLEdBQWlCLFlBQVc7QUFDeEJyQyx3QkFBUStCLFVBQVIsR0FBcUIsS0FBckI7QUFDQS9CLHdCQUFRc0MsV0FBUjtBQUNBdEMsd0JBQVFNLElBQVI7QUFDQU4sd0JBQVF6aUMsTUFBUixDQUFlcUMsWUFBZixHQUE4QjJILE1BQTlCO0FBQ0E7QUFDQXk0Qix3QkFBUXppQyxNQUFSLENBQWV3RCxJQUFmLENBQW9CLGNBQXBCO0FBQ0gsYUFQRDtBQVFBNGdDLGlCQUFLWSxVQUFMLEdBQWtCLFlBQVc7QUFDekJ2Qyx3QkFBUXdDLGNBQVI7QUFDQTtBQUNBeEMsd0JBQVF6aUMsTUFBUixDQUFld0QsSUFBZixDQUFvQixjQUFwQjtBQUNILGFBSkQ7QUFLQTRnQyxpQkFBS3JSLEtBQUwsQ0FBVzZQLENBQVg7QUFDSCxTQXpGZTtBQTBGaEJpQyx1QkFBZSx1QkFBU3hELEdBQVQsRUFBY252QixJQUFkLEVBQW9CRSxHQUFwQixFQUF5QjtBQUNwQ0YsbUJBQU9BLFFBQVEsQ0FBZjtBQUNBRSxrQkFBTUEsT0FBTyxDQUFiO0FBQ0EsZ0JBQUlteEIsVUFBVSxLQUFLQSxPQUFuQjs7QUFFQSxpQkFBSyxJQUFJbkMsTUFBVCxJQUFtQm1DLE9BQW5CLEVBQTRCO0FBQ3hCckMsb0NBQW9CRSxNQUFwQixFQUE0Qm1DLFFBQVFuQyxNQUFSLENBQTVCLEVBQTZDbHZCLElBQTdDLEVBQW1ERSxHQUFuRCxFQUF3RGl2QixHQUF4RDtBQUNIO0FBQ0osU0FsR2U7QUFtR2hCMkMscUJBQWEsdUJBQVc7QUFDcEIsZ0JBQUlULFVBQVUsS0FBS0EsT0FBbkI7QUFDQSxpQkFBS3NCLGFBQUwsQ0FBbUIsS0FBS3hELEdBQXhCO0FBQ0EsaUJBQUssSUFBSXFDLENBQVQsSUFBY0gsT0FBZCxFQUF1QjtBQUNuQkEsd0JBQVFHLENBQVIsRUFBVzczQixLQUFYLENBQWlCMlEsT0FBakIsR0FBMkIsT0FBM0I7QUFDSDtBQUNKLFNBekdlO0FBMEdoQjJuQixxQkFBYSx1QkFBVztBQUNwQixnQkFBSVosVUFBVSxLQUFLQSxPQUFuQjtBQUNBLGlCQUFLLElBQUlHLENBQVQsSUFBY0gsT0FBZCxFQUF1QjtBQUNuQkEsd0JBQVFHLENBQVIsRUFBVzczQixLQUFYLENBQWlCMlEsT0FBakIsR0FBMkIsTUFBM0I7QUFDSDtBQUNKLFNBL0dlO0FBZ0hoQituQixxQkFBYSx1QkFBVztBQUNwQixpQkFBS2pCLE9BQUwsQ0FBYXozQixLQUFiLENBQW1CcTVCLGVBQW5CLEdBQXFDLFVBQVUsS0FBSzV0QixFQUFMLENBQVFsUSxHQUFsQixHQUF3QixJQUE3RDtBQUNBLGlCQUFLczlCLGFBQUw7QUFDQSxpQkFBS0MsYUFBTDtBQUNBLGlCQUFLckIsT0FBTCxDQUFhejNCLEtBQWIsQ0FBbUIyUSxPQUFuQixHQUE2QixPQUE3QjtBQUNILFNBckhlO0FBc0hoQm1vQix1QkFBZSx5QkFBVztBQUN0QixnQkFBSXRELE1BQU0sS0FBS3VELFVBQWY7QUFDQXRELDRCQUFnQixLQUFLZ0MsT0FBckIsRUFBOEJqQyxJQUFJbnZCLElBQWxDLEVBQXdDbXZCLElBQUlqdkIsR0FBNUM7QUFDQSxpQkFBS2t4QixPQUFMLENBQWF6M0IsS0FBYixDQUFtQndHLEtBQW5CLEdBQTJCLEtBQUt1eUIsVUFBTCxDQUFnQnZ5QixLQUFoQixHQUF3QixJQUFuRDtBQUNBLGlCQUFLaXhCLE9BQUwsQ0FBYXozQixLQUFiLENBQW1CbUosTUFBbkIsR0FBNEIsS0FBSzR2QixVQUFMLENBQWdCNXZCLE1BQWhCLEdBQXlCLElBQXJEO0FBQ0gsU0EzSGU7QUE0SGhCK3ZCLHFCQUFhLHVCQUFXO0FBQ3BCLGdCQUFJMUQsTUFBTTBDLGVBQWUsS0FBSzNoQyxNQUFwQixFQUE0QixLQUFLa2hDLE9BQWpDLENBQVY7QUFDQSxpQkFBSzkzQixNQUFMLEdBQWM7QUFDVjZHLHVCQUFPZ3ZCLElBQUlodkIsS0FERDtBQUVWMkMsd0JBQVFxc0IsSUFBSXJzQjtBQUZGLGFBQWQ7QUFJQSxpQkFBS3N1QixPQUFMLENBQWF6M0IsS0FBYixDQUFtQjJRLE9BQW5CLEdBQTZCLE1BQTdCO0FBQ0gsU0FuSWU7QUFvSWhCa29CLHVCQUFlLHVCQUFTMWhDLElBQVQsRUFBZTtBQUMxQixnQkFBSXErQixNQUFNLEtBQUt1RCxVQUFMLEdBQWtCO0FBQ3hCeHlCLHFCQUFLLENBRG1CO0FBRXhCRixzQkFBTSxDQUZrQjtBQUd4QkcsdUJBQU8sS0FBS2d2QixHQUFMLENBQVNodkIsS0FIUTtBQUl4QjJDLHdCQUFRLEtBQUtxc0IsR0FBTCxDQUFTcnNCO0FBSk8sYUFBNUI7O0FBT0EsZ0JBQUksQ0FBQ2hTLElBQUwsRUFBVzs7QUFFWCxnQkFBSXN5QixPQUFPdHlCLEtBQUtrQixNQUFMLENBQVlPLFNBQXZCOztBQUVBLGdCQUFJLENBQUM2d0IsS0FBS2h1QixPQUFMLENBQWEsR0FBYixDQUFMLEVBQXdCO0FBQ3BCKzVCLG9CQUFJaHZCLEtBQUosR0FBWXpILEtBQUsrRixHQUFMLENBQVMsRUFBVCxFQUFhLEtBQUswd0IsR0FBTCxDQUFTaHZCLEtBQVQsR0FBaUJyUCxLQUFLbWlDLEtBQUwsQ0FBV2x6QixDQUF6QyxDQUFaO0FBQ0g7QUFDRCxnQkFBSSxDQUFDcWpCLEtBQUtodUIsT0FBTCxDQUFhLEdBQWIsQ0FBTCxFQUF3QjtBQUNwQis1QixvQkFBSXJzQixNQUFKLEdBQWFwSyxLQUFLK0YsR0FBTCxDQUFTLEVBQVQsRUFBYSxLQUFLMHdCLEdBQUwsQ0FBU3JzQixNQUFULEdBQWtCaFMsS0FBS21pQyxLQUFMLENBQVdoekIsQ0FBMUMsQ0FBYjtBQUNIO0FBQ0QsZ0JBQUksQ0FBQ21qQixLQUFLaHVCLE9BQUwsQ0FBYSxHQUFiLENBQUwsRUFBd0I7QUFDcEIrNUIsb0JBQUlodkIsS0FBSixHQUFZekgsS0FBSytGLEdBQUwsQ0FBUyxFQUFULEVBQWEsS0FBSzB3QixHQUFMLENBQVNodkIsS0FBVCxHQUFpQnJQLEtBQUttaUMsS0FBTCxDQUFXbHpCLENBQXpDLENBQVo7QUFDSDtBQUNELGdCQUFJLENBQUNxakIsS0FBS2h1QixPQUFMLENBQWEsR0FBYixDQUFMLEVBQXdCO0FBQ3BCKzVCLG9CQUFJcnNCLE1BQUosR0FBYXBLLEtBQUsrRixHQUFMLENBQVMsRUFBVCxFQUFhLEtBQUswd0IsR0FBTCxDQUFTcnNCLE1BQVQsR0FBa0JoUyxLQUFLbWlDLEtBQUwsQ0FBV2h6QixDQUExQyxDQUFiO0FBQ0g7QUFDRDtBQUNBLGdCQUFJbWpCLEtBQUtodUIsT0FBTCxDQUFhLEdBQWIsSUFBb0IsQ0FBcEIsSUFBeUIsQ0FBQ3RFLEtBQUsrQyxJQUFMLENBQVVrRyxLQUF4QyxFQUErQztBQUMzQyxvQkFBSW01QixRQUFRLEtBQUsvRCxHQUFMLENBQVNodkIsS0FBVCxHQUFpQixLQUFLZ3ZCLEdBQUwsQ0FBU3JzQixNQUF0QztBQUNBLG9CQUFJcXNCLElBQUlodkIsS0FBSixHQUFZZ3ZCLElBQUlyc0IsTUFBaEIsR0FBeUJvd0IsS0FBN0IsRUFBb0M7QUFDaEMvRCx3QkFBSXJzQixNQUFKLEdBQWFwSyxLQUFLNDJCLEtBQUwsQ0FBV0gsSUFBSWh2QixLQUFKLEdBQVkreUIsS0FBdkIsQ0FBYjtBQUNILGlCQUZELE1BRU87QUFDSC9ELHdCQUFJaHZCLEtBQUosR0FBWXpILEtBQUs0MkIsS0FBTCxDQUFXSCxJQUFJcnNCLE1BQUosR0FBYW93QixLQUF4QixDQUFaO0FBQ0g7QUFDSjs7QUFFRCxnQkFBSTdDLGFBQWEsS0FBSzMxQixHQUFMLENBQVMyMUIsVUFBMUI7O0FBRUEsZ0JBQUlBLFVBQUosRUFBZ0I7QUFDWixvQkFBSThDLFNBQVMsS0FBS3pCLFdBQWxCO0FBQ0EscUJBQUssSUFBSTM4QixJQUFJLENBQWIsRUFBZ0JBLElBQUlvK0IsT0FBT24rQixNQUEzQixFQUFtQ0QsR0FBbkMsRUFBd0M7QUFDcEMsd0JBQUlxK0IsUUFBUXZCLGVBQWUsS0FBSzNoQyxNQUFwQixFQUE0QmlqQyxPQUFPcCtCLENBQVAsQ0FBNUIsQ0FBWjtBQUNBLHdCQUFJMkQsS0FBS3lJLEdBQUwsQ0FBU2d1QixJQUFJaHZCLEtBQUosR0FBWWl6QixNQUFNanpCLEtBQTNCLEtBQXFDa3dCLFVBQXJDLElBQW1EMzNCLEtBQUt5SSxHQUFMLENBQVNndUIsSUFBSXJzQixNQUFKLEdBQWFzd0IsTUFBTXR3QixNQUE1QixLQUF1Q3V0QixVQUE5RixFQUEwRztBQUN0R2xCLDRCQUFJaHZCLEtBQUosR0FBWWl6QixNQUFNanpCLEtBQWxCO0FBQ0FndkIsNEJBQUlyc0IsTUFBSixHQUFhc3dCLE1BQU10d0IsTUFBbkI7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBLGdCQUFJLENBQUNzZ0IsS0FBS2h1QixPQUFMLENBQWEsR0FBYixDQUFMLEVBQXdCO0FBQ3BCKzVCLG9CQUFJbnZCLElBQUosR0FBVyxLQUFLbXZCLEdBQUwsQ0FBU2h2QixLQUFULEdBQWlCZ3ZCLElBQUlodkIsS0FBaEM7QUFDSDtBQUNELGdCQUFJLENBQUNpakIsS0FBS2h1QixPQUFMLENBQWEsR0FBYixDQUFMLEVBQXdCO0FBQ3BCKzVCLG9CQUFJanZCLEdBQUosR0FBVSxLQUFLaXZCLEdBQUwsQ0FBU3JzQixNQUFULEdBQWtCcXNCLElBQUlyc0IsTUFBaEM7QUFDSDtBQUNKLFNBM0xlO0FBNExoQml3Qix3QkFBZ0IsMEJBQVc7QUFDdkI5QiwwQkFBY3hqQyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLEtBQUsyWCxFQUE5QixFQUFrQyxLQUFLOUwsTUFBTCxDQUFZNkcsS0FBOUMsRUFBcUQsS0FBSzdHLE1BQUwsQ0FBWXdKLE1BQWpFO0FBQ0g7QUE5TGUsS0FBcEI7O0FBaU1BLGFBQVNxdkIsU0FBVCxDQUFtQmppQyxNQUFuQixFQUEyQkUsUUFBM0IsRUFBcUM7QUFDakMsYUFBS0YsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS0UsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxhQUFLaWpDLE1BQUwsR0FBYztBQUNWQyx1QkFBV3BrQyxLQUFLLEtBQUtva0MsU0FBVixFQUFxQixJQUFyQixDQUREO0FBRVZDLHFCQUFTcmtDLEtBQUssS0FBS3FrQyxPQUFWLEVBQW1CLElBQW5CLENBRkM7QUFHVkMscUJBQVN0a0MsS0FBSyxLQUFLc2tDLE9BQVYsRUFBbUIsSUFBbkI7QUFIQyxTQUFkO0FBS0g7O0FBRURyQixjQUFVbnpCLFNBQVYsR0FBc0I7QUFDbEI2aEIsZUFBTyxlQUFTNlAsQ0FBVCxFQUFZO0FBQ2ZBLGNBQUV0L0IsY0FBRjtBQUNBcy9CLGNBQUV4ekIsZUFBRjtBQUNBLGlCQUFLbEwsTUFBTCxHQUFjMCtCLEVBQUUxK0IsTUFBaEI7QUFDQSxpQkFBS294QixJQUFMLEdBQVlzTixFQUFFMStCLE1BQUYsQ0FBU08sU0FBckI7QUFDQSxpQkFBS2toQyxRQUFMLEdBQWdCO0FBQ1oxekIsbUJBQUcyd0IsRUFBRXhGLE9BRE87QUFFWmpyQixtQkFBR3l3QixFQUFFdkY7QUFGTyxhQUFoQjtBQUlBLGlCQUFLdmMsTUFBTCxDQUFZOGhCLENBQVo7QUFDQSxnQkFBSTJDLFNBQVMsS0FBS0EsTUFBbEI7QUFDQSxpQkFBS2pqQyxRQUFMLENBQWNzVixnQkFBZCxDQUErQixXQUEvQixFQUE0QzJ0QixPQUFPQyxTQUFuRCxFQUE4RCxLQUE5RDtBQUNBLGlCQUFLbGpDLFFBQUwsQ0FBY3NWLGdCQUFkLENBQStCLFNBQS9CLEVBQTBDMnRCLE9BQU9FLE9BQWpELEVBQTBELEtBQTFEO0FBQ0EsaUJBQUtuakMsUUFBTCxDQUFjc1YsZ0JBQWQsQ0FBK0IsU0FBL0IsRUFBMEMydEIsT0FBT0csT0FBakQsRUFBMEQsS0FBMUQ7QUFDQSxpQkFBS3BqQyxRQUFMLENBQWNxQyxJQUFkLENBQW1CZy9CLFNBQW5CLENBQTZCdjlCLEdBQTdCLENBQWlDLGNBQWMsS0FBS2t2QixJQUFwRDtBQUNBLGlCQUFLZ1AsT0FBTCxJQUFnQixLQUFLQSxPQUFMLEVBQWhCO0FBQ0gsU0FqQmlCO0FBa0JsQnhqQixnQkFBUSxnQkFBUzhoQixDQUFULEVBQVk7QUFDaEIsaUJBQUtnRCxVQUFMLEdBQWtCO0FBQ2QzekIsbUJBQUcyd0IsRUFBRXhGLE9BRFM7QUFFZGpyQixtQkFBR3l3QixFQUFFdkY7QUFGUyxhQUFsQjtBQUlBLGlCQUFLOEgsS0FBTCxHQUFhO0FBQ1RsekIsbUJBQUcyd0IsRUFBRXhGLE9BQUYsR0FBWSxLQUFLdUksUUFBTCxDQUFjMXpCLENBRHBCO0FBRVRFLG1CQUFHeXdCLEVBQUV2RixPQUFGLEdBQVksS0FBS3NJLFFBQUwsQ0FBY3h6QjtBQUZwQixhQUFiO0FBSUEsaUJBQUtwTSxJQUFMLEdBQVk7QUFDUmtHLHVCQUFPMjJCLEVBQUVpRCxRQUREO0FBRVJDLHNCQUFNbEQsRUFBRTEvQixPQUZBO0FBR1I2aUMscUJBQUtuRCxFQUFFOVc7QUFIQyxhQUFaO0FBS0gsU0FoQ2lCO0FBaUNsQjBaLG1CQUFXLG1CQUFTNUMsQ0FBVCxFQUFZO0FBQ25CLGlCQUFLOWhCLE1BQUwsQ0FBWThoQixDQUFaO0FBQ0EsaUJBQUs2QixNQUFMLElBQWUsS0FBS0EsTUFBTCxFQUFmO0FBQ0EsZ0JBQUk3QixFQUFFb0QsS0FBRixLQUFZLENBQWhCLEVBQW1CO0FBQ2Y7QUFDQSxxQkFBS04sT0FBTCxDQUFhOUMsQ0FBYjtBQUNIO0FBQ0osU0F4Q2lCO0FBeUNsQjZDLGlCQUFTLGlCQUFTN0MsQ0FBVCxFQUFZO0FBQ2pCO0FBQ0EsZ0JBQUlBLEVBQUU1eUIsT0FBRixLQUFjLEVBQWxCLEVBQXNCO0FBQ2xCLHFCQUFLaTJCLE9BQUw7QUFDSDtBQUNKLFNBOUNpQjtBQStDbEJQLGlCQUFTLGlCQUFTOUMsQ0FBVCxFQUFZO0FBQ2pCLGlCQUFLOWhCLE1BQUwsQ0FBWThoQixDQUFaO0FBQ0EsaUJBQUtxRCxPQUFMO0FBQ0EsaUJBQUtqQixVQUFMLElBQW1CLEtBQUtBLFVBQUwsRUFBbkI7QUFDSCxTQW5EaUI7QUFvRGxCaUIsaUJBQVMsbUJBQVc7QUFDaEIsaUJBQUszakMsUUFBTCxDQUFjcUMsSUFBZCxDQUFtQmcvQixTQUFuQixDQUE2QnJvQixNQUE3QixDQUFvQyxjQUFjLEtBQUtnYSxJQUF2RDtBQUNBLGdCQUFJaVEsU0FBUyxLQUFLQSxNQUFsQjtBQUNBLGlCQUFLampDLFFBQUwsQ0FBY2twQixtQkFBZCxDQUFrQyxXQUFsQyxFQUErQytaLE9BQU9DLFNBQXRELEVBQWlFLEtBQWpFO0FBQ0EsaUJBQUtsakMsUUFBTCxDQUFja3BCLG1CQUFkLENBQWtDLFNBQWxDLEVBQTZDK1osT0FBT0UsT0FBcEQsRUFBNkQsS0FBN0Q7QUFDQSxpQkFBS25qQyxRQUFMLENBQWNrcEIsbUJBQWQsQ0FBa0MsU0FBbEMsRUFBNkMrWixPQUFPRyxPQUFwRCxFQUE2RCxLQUE3RDtBQUNBLGlCQUFLWixTQUFMLElBQWtCLEtBQUtBLFNBQUwsRUFBbEI7QUFDSDtBQTNEaUIsS0FBdEI7O0FBOERBO0FBQ0EsYUFBU2pCLE9BQVQsQ0FBaUJwMkIsR0FBakIsRUFBc0I7QUFDbEIsWUFBSXVoQixNQUFNdmhCLElBQUl2RyxNQUFkO0FBQUEsWUFDSTYwQixNQUFNLElBQUk5cUIsS0FBSixDQUFVK2QsR0FBVixDQURWO0FBRUEsYUFBSyxJQUFJL25CLElBQUksQ0FBYixFQUFnQkEsSUFBSStuQixHQUFwQixFQUF5Qi9uQixHQUF6QixFQUE4QjtBQUMxQjgwQixnQkFBSTkwQixDQUFKLElBQVN3RyxJQUFJeEcsQ0FBSixDQUFUO0FBQ0g7QUFDRCxlQUFPODBCLEdBQVA7QUFDSDs7QUFFRCxhQUFTMzZCLElBQVQsQ0FBYzZKLEVBQWQsRUFBa0JpN0IsR0FBbEIsRUFBdUI7QUFDbkIsWUFBSWo3QixHQUFHN0osSUFBUCxFQUFhO0FBQ1QsbUJBQU82SixHQUFHN0osSUFBSCxDQUFROGtDLEdBQVIsQ0FBUDtBQUNIO0FBQ0QsZUFBTyxZQUFXO0FBQ2RqN0IsZUFBR21qQixLQUFILENBQVM4WCxHQUFULEVBQWM3WCxTQUFkO0FBQ0gsU0FGRDtBQUdIOztBQUVELGFBQVNpVCxlQUFULENBQXlCaHFCLEVBQXpCLEVBQTZCcEYsSUFBN0IsRUFBbUNFLEdBQW5DLEVBQXdDO0FBQ3BDa0YsV0FBR3pMLEtBQUgsQ0FBU3FHLElBQVQsR0FBZ0JpMEIsT0FBT2owQixJQUFQLElBQWUsSUFBL0I7QUFDQW9GLFdBQUd6TCxLQUFILENBQVN1RyxHQUFULEdBQWUrekIsT0FBTy96QixHQUFQLElBQWMsSUFBN0I7QUFDSDs7QUFFRCxhQUFTK3dCLGFBQVQsQ0FBdUI3ckIsRUFBdkIsRUFBMkJqRixLQUEzQixFQUFrQzJDLE1BQWxDLEVBQTBDO0FBQ3RDLFlBQUl3dEIsbUJBQW1CLEtBQUt4aUMsTUFBTCxDQUFZUixNQUFaLENBQW1CZ2pDLGdCQUExQztBQUNBLFlBQUlBLHFCQUFxQixNQUF6QixFQUFpQztBQUM3QmxyQixlQUFHekwsS0FBSCxDQUFTd0csS0FBVCxHQUFpQjh6QixPQUFPOXpCLEtBQVAsSUFBZ0IsSUFBakM7QUFDQWlGLGVBQUd6TCxLQUFILENBQVNtSixNQUFULEdBQWtCbXhCLE9BQU9ueEIsTUFBUCxJQUFpQixJQUFuQztBQUNILFNBSEQsTUFJSyxJQUFJd3RCLHFCQUFxQixPQUFyQixJQUFnQ0EscUJBQXFCLE9BQXpELEVBQWtFO0FBQ25FbHJCLGVBQUd6TCxLQUFILENBQVNtSixNQUFULEdBQWtCLE1BQWxCO0FBQ0FzQyxlQUFHekwsS0FBSCxDQUFTd0csS0FBVCxHQUFpQjh6QixPQUFPOXpCLEtBQVAsSUFBZ0IsSUFBakM7QUFDSCxTQUhJLE1BSUEsSUFBSW13QixxQkFBcUIsUUFBekIsRUFBbUM7QUFDcENsckIsZUFBR3pMLEtBQUgsQ0FBU21KLE1BQVQsR0FBa0JteEIsT0FBT254QixNQUFQLElBQWlCLElBQW5DO0FBQ0FzQyxlQUFHekwsS0FBSCxDQUFTd0csS0FBVCxHQUFpQixNQUFqQjtBQUNIO0FBQ0o7O0FBRUQsYUFBUzB4QixjQUFULENBQXdCM2hDLE1BQXhCLEVBQWdDa1YsRUFBaEMsRUFBb0M7QUFDaEMsWUFBSTh1QixPQUFPOXVCLEdBQUcrdUIscUJBQUgsRUFBWDtBQUNBLGVBQU87QUFDSG4wQixrQkFBTWswQixLQUFLbDBCLElBQUwsR0FBWTlQLE9BQU9ra0MsV0FEdEI7QUFFSGwwQixpQkFBS2cwQixLQUFLaDBCLEdBQUwsR0FBV2hRLE9BQU9ta0MsV0FGcEI7QUFHSGwwQixtQkFBTyt6QixLQUFLL3pCLEtBSFQ7QUFJSDJDLG9CQUFRb3hCLEtBQUtweEI7QUFKVixTQUFQO0FBTUg7QUFDSixDQTFlQSxHQUFELEM7Ozs7Ozs7Ozs7Ozs7O0FDUkE7Ozs7QUFJQSxDQUFDLFlBQVk7QUFDVDs7QUFFQSxRQUFJL1UsU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLGtCQUFyQixDQUFKLEVBQThDO0FBQzFDO0FBQ0g7O0FBRUQsUUFBSTBtQyxnQkFBZ0I7QUFDaEJDLGdCQUFRLENBRFE7QUFFaEJ2MEIsY0FBTSxDQUZVO0FBR2hCaUIsZUFBTztBQUhTLEtBQXBCOztBQU1BOzs7O0FBSUEsUUFBSXV6QixTQUFTO0FBQ1QxRixjQUFNLGFBREc7QUFFVGhzQixnQkFBUSxXQUZDO0FBR1Rpc0IsZUFBTyxhQUhFO0FBSVQ1dUIsZUFBTztBQUpFLEtBQWI7O0FBT0EsUUFBSXMwQixlQUFlLGtCQUFuQjs7QUFFQSxRQUFJbGMsV0FBVyx1QkFBZjs7QUFFQXhxQixhQUFTOHRCLE9BQVQsQ0FBaUIzbkIsR0FBakIsQ0FBcUIsa0JBQXJCLEVBQXlDO0FBQ3JDd2dDLGVBQU8sSUFEOEI7O0FBR3JDQyxlQUFPLE9BSDhCOztBQUtyQ3hSLGNBQU0sY0FBVXIxQixNQUFWLEVBQWtCO0FBQ3BCLGdCQUFJeWMsUUFBUXFxQixVQUFVOW1DLE1BQVYsQ0FBWjs7QUFFQTtBQUNBQSxtQkFBTyttQyxPQUFQLENBQWUzZ0MsR0FBZixDQUFtQixPQUFuQixFQUE0QnFXLEtBQTVCO0FBQ0gsU0FWb0M7O0FBWXJDNGxCLGdCQUFRLGtCQUFZO0FBQ2hCcGlDLHFCQUFTbWlDLE1BQVQsQ0FDSSxvQ0FDQSxzQkFEQSxHQUVBLEdBRkEsR0FHQSwrQkFIQSxHQUlBLG9CQUpBLEdBS0EsR0FMQSxHQU1BLGlDQU5BLEdBT0Esc0JBUEEsR0FRQSxHQVJBLEdBU0EsK0JBVEEsR0FVQSxvQkFWQSxHQVdBLEdBWEEsR0FZQSx1QkFaQTtBQWFBO0FBQ0E7QUFDQSwyQkFmQSxHQWdCQSxHQWhCQSxHQWlCQSxxQkFqQkEsR0FrQkEsZUFsQkEsR0FtQkEsb0JBbkJBLEdBb0JBLGFBcEJBLEdBcUJBLGNBckJBLEdBc0JBLGNBdEJBLEdBdUJBLGFBdkJBLEdBd0JBLGtCQXhCQSxHQXlCQSx5QkF6QkE7QUEwQkE7QUFDQSw0QkEzQkEsR0E0QkEscUJBNUJBLEdBNkJBLEdBN0JBLEdBOEJBLDZCQTlCQSxHQStCQSxvQkEvQkEsR0FnQ0EsdUJBaENBLEdBaUNBLGdCQWpDQSxHQWtDQSxHQWxDQSxHQW1DQSwrQ0FuQ0EsR0FvQ0Esd0NBcENBLEdBcUNBLGVBckNBLEdBc0NBLEdBdkNKO0FBeUNILFNBdERvQzs7QUF3RHJDcFEsa0JBQVU7QUF4RDJCLEtBQXpDOztBQTJEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBUzhVLFNBQVQsQ0FBbUI5bUMsTUFBbkIsRUFBMkI7QUFDdkJBLGVBQU9SLE1BQVAsQ0FBY2dqQyxnQkFBZCxHQUFpQ3hpQyxPQUFPUixNQUFQLENBQWNnakMsZ0JBQWQsSUFBa0MsTUFBbkU7O0FBRUF4aUMsZUFBTzRDLEVBQVAsQ0FBVSxVQUFWLEVBQXNCLFVBQVV3YSxTQUFWLEVBQXFCO0FBQ3ZDcGQsbUJBQU8rbUMsT0FBUCxDQUFlQyxNQUFmLENBQXNCNXBCLFVBQVVwYSxJQUFWLENBQWVzVSxFQUFyQyxFQUF5QyxPQUF6QztBQUNILFNBRkQ7O0FBSUEsWUFBSTJ2QixlQUFlam5DLE9BQU9SLE1BQVAsQ0FBYzBuQyxtQkFBakM7O0FBRUEsWUFBSUMsaUJBQWlCbm5DLE9BQU9SLE1BQVAsQ0FBYzRuQyxxQkFBbkM7O0FBRUEsZUFBTztBQUNIL1Isa0JBQU0sZ0JBQVk7QUFDZCxvQkFBSWdTLFVBQVVwbkMsU0FBUzh0QixPQUFULENBQWlCdVosTUFBL0I7O0FBRUEsb0JBQUk3cUIsUUFBUSxLQUFLeFUsS0FBTCxDQUFXd1UsS0FBdkI7O0FBRUEsb0JBQUl6WixPQUFPO0FBQ1AraUMseUJBQUt0cEIsTUFBTXBMLFlBQU4sQ0FBbUIsS0FBbkIsS0FBNkIsRUFEM0I7QUFFUGsyQixnQ0FBWSxDQUFDLENBQUMsS0FBS3QvQixLQUFMLENBQVd1L0IsT0FGbEI7QUFHUHh5Qiw0QkFBUXlILE1BQU1wTCxZQUFOLENBQW1CLFFBQW5CLEtBQWdDLEVBSGpDO0FBSVA7QUFDQXhILDBCQUFNLEtBQUs0OUIsS0FBTCxHQUFhSixRQUFRSyxvQkFBUixDQUE2QmpyQixLQUE3QixDQUFiLEdBQW1ELElBTGxEO0FBTVByVix5QkFBS3FWLE1BQU1wTCxZQUFOLENBQW1CLEtBQW5CLENBTkU7QUFPUGdCLDJCQUFPb0ssTUFBTXBMLFlBQU4sQ0FBbUIsT0FBbkIsS0FBK0I7QUFQL0IsaUJBQVg7O0FBVUE7QUFDQTtBQUNBO0FBQ0Esb0JBQUl4TixPQUFPNFksTUFBTXBCLFlBQU4sQ0FBbUIsR0FBbkIsQ0FBWDs7QUFFQSxvQkFBSXhYLFFBQVEsS0FBSzhqQyxPQUFMLENBQWEzYixRQUFiLENBQXNCbm9CLElBQXRCLENBQVosRUFBeUM7QUFDckMseUJBQUtvRSxLQUFMLENBQVdwRSxJQUFYLEdBQWtCQSxJQUFsQjtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQUksQ0FBQ2IsS0FBSzRrQyxLQUFWLEVBQWlCO0FBQ2Isd0JBQUlDLGVBQWU3a0MsS0FBS3VrQyxVQUFMLEdBQWtCLEtBQUtoM0IsT0FBdkIsR0FBaUNrTSxLQUFwRDs7QUFFQTtBQUNBLHdCQUFJd3FCLFlBQUosRUFBa0I7QUFDZCw0QkFBSVksYUFBYTd6QixRQUFiLENBQXNCaXpCLGFBQWEsQ0FBYixDQUF0QixDQUFKLEVBQTRDO0FBQ3hDamtDLGlDQUFLNGtDLEtBQUwsR0FBYSxNQUFiO0FBQ0gseUJBRkQsTUFFTyxJQUFJQyxhQUFhN3pCLFFBQWIsQ0FBc0JpekIsYUFBYSxDQUFiLENBQXRCLENBQUosRUFBNEM7QUFDL0Nqa0MsaUNBQUs0a0MsS0FBTCxHQUFhLE9BQWI7QUFDSDs7QUFFRCw0QkFBSTVrQyxLQUFLNGtDLEtBQVQsRUFBZ0I7QUFDWkMseUNBQWE3bEMsV0FBYixDQUF5QmlsQyxhQUFhVCxjQUFjeGpDLEtBQUs0a0MsS0FBbkIsQ0FBYixDQUF6QjtBQUNILHlCQUZELE1BRU87QUFDSDVrQyxpQ0FBSzRrQyxLQUFMLEdBQWEsTUFBYjtBQUNIO0FBQ0o7QUFDRDtBQWJBLHlCQWNLO0FBQ0Q1a0MsaUNBQUs0a0MsS0FBTCxHQUFhQyxhQUFhbCtCLFFBQWIsQ0FBc0IsT0FBdEIsS0FBa0MsTUFBL0M7QUFDQWsrQix5Q0FBYS85QixXQUFiLENBQXlCLE9BQXpCO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0EscUJBQUs2OUIsT0FBTCxDQUFhLENBQUMza0MsS0FBS3VrQyxVQUFMLEdBQWtCLFFBQWxCLEdBQTZCLEtBQTlCLElBQXVDLE9BQXBELEVBQTZELHFCQUE3RDs7QUFFQSxxQkFBS08sT0FBTCxDQUFhOWtDLElBQWI7O0FBRUEsb0JBQUloRCxPQUFPUixNQUFQLENBQWN1b0MscUJBQWQsS0FBd0MsSUFBNUMsRUFBa0Q7QUFDOUNDLGlDQUFhLElBQWI7QUFDSDtBQUNKLGFBOURFOztBQWdFSDtBQUNBO0FBQ0E3bUMsc0JBQVUsa0JBQVVzRCxTQUFWLEVBQXFCO0FBQzNCd2pDLG9DQUFvQixJQUFwQixFQUEwQjltQyxRQUExQixDQUFtQ3NELFNBQW5DO0FBQ0gsYUFwRUU7O0FBc0VIdEUsNEJBQWdCK25DLHdCQUF3QmxvQyxNQUF4QixDQXRFYjs7QUF3RUg7QUFDQW1vQyxvQ0FBd0IsQ0FDcEIsQ0FBQyw2QkFBRCxDQURvQixDQXpFckI7O0FBNkVIbmxDLGtCQUFNLGdCQUFZO0FBQ2Qsb0JBQUlvbEMsV0FBVyxLQUFLQSxRQUFwQjs7QUFFQTtBQUNBLG9CQUFJLEtBQUtwbEMsSUFBTCxDQUFVdWtDLFVBQVYsSUFBd0IsQ0FBQ3ZuQyxPQUFPd00sTUFBUCxDQUFjNjdCLFlBQWQsQ0FBMkJELFNBQVNaLE9BQXBDLENBQTdCLEVBQTJFO0FBQ3ZFLHlCQUFLeGtDLElBQUwsQ0FBVXVrQyxVQUFWLEdBQXVCLEtBQXZCO0FBQ0g7O0FBRUQ7QUFDQSxvQkFBSSxLQUFLdmtDLElBQUwsQ0FBVTRrQyxLQUFWLElBQW1CLE1BQW5CLElBQTZCLENBQUM1bkMsT0FBT3dNLE1BQVAsQ0FBYzY3QixZQUFkLENBQTJCRCxTQUFTUixLQUFwQyxDQUFsQyxFQUE4RTtBQUMxRSx5QkFBSzVrQyxJQUFMLENBQVU0a0MsS0FBVixHQUFrQixNQUFsQjtBQUNIOztBQUVEO0FBQ0E7QUFDQSxvQkFBSSxDQUFDLEtBQUs1a0MsSUFBTCxDQUFVYSxJQUFmLEVBQXFCO0FBQ2pCLHdCQUFJLEtBQUtvRSxLQUFMLENBQVdwRSxJQUFmLEVBQXFCO0FBQ2pCLCtCQUFPLEtBQUtvRSxLQUFMLENBQVdwRSxJQUFsQjtBQUNIO0FBQ0osaUJBSkQsTUFJTztBQUNILHdCQUFJLENBQUMsS0FBS29FLEtBQUwsQ0FBV3BFLElBQWhCLEVBQXNCO0FBQ2xCLDZCQUFLb0UsS0FBTCxDQUFXcEUsSUFBWCxHQUFrQixLQUFLb0UsS0FBTCxDQUFXd1UsS0FBWCxDQUFpQm9hLFNBQWpCLEVBQWxCO0FBQ0g7QUFDSjs7QUFFRCxxQkFBSzV1QixLQUFMLENBQVd3VSxLQUFYLENBQWlCMlUsYUFBakIsQ0FBK0I7QUFDM0IyVSx5QkFBSyxLQUFLL2lDLElBQUwsQ0FBVStpQyxHQURZOztBQUczQnVDLHFDQUFpQixLQUFLcmdDLEtBQUwsQ0FBV3dVLEtBQVgsQ0FBaUJwTCxZQUFqQixDQUE4QixpQkFBOUIsSUFBbUQsS0FBS3BKLEtBQUwsQ0FBV3dVLEtBQVgsQ0FBaUJwTCxZQUFqQixDQUE4QixpQkFBOUIsQ0FBbkQsR0FBc0csSUFINUY7O0FBSzNCO0FBQ0EsMENBQXNCLEtBQUtyTyxJQUFMLENBQVVvRSxHQU5MOztBQVEzQkEseUJBQUssS0FBS3BFLElBQUwsQ0FBVW9FO0FBUlksaUJBQS9COztBQVdBO0FBQ0E7QUFDQSxvQkFBSSxLQUFLbWhDLE9BQUwsSUFBZ0IsQ0FBQyxLQUFLQSxPQUFMLENBQWFoQixVQUE5QixJQUE0QyxLQUFLdmtDLElBQUwsQ0FBVXVrQyxVQUExRCxFQUFzRTtBQUNsRSx5QkFBSyxJQUFJaUIsQ0FBVCxJQUFjLEtBQUt4bEMsSUFBTCxDQUFVeWxDLE9BQXhCLEVBQWlDO0FBQzdCLDZCQUFLeGdDLEtBQUwsQ0FBV3dVLEtBQVgsQ0FBaUJ6YSxXQUFqQixDQUE2QndtQyxDQUE3QjtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBLG9CQUFJeG9DLE9BQU93TSxNQUFQLENBQWM2N0IsWUFBZCxDQUEyQkQsU0FBU00sU0FBcEMsQ0FBSixFQUFvRDtBQUNoREMsa0NBQWMsSUFBZDtBQUNIOztBQUVEO0FBQ0EscUJBQUtKLE9BQUwsR0FBZXRvQyxTQUFTd0wsS0FBVCxDQUFlK3dCLE1BQWYsQ0FBc0IsRUFBdEIsRUFBMEIsS0FBS3g1QixJQUEvQixDQUFmO0FBQ0gsYUFqSUU7O0FBbUlINGxDLHNCQUFVQyxzQkFBc0I3b0MsTUFBdEIsQ0FuSVA7O0FBcUlIOG9DLHVCQUFXLEtBcklSOztBQXVJSDtBQUNBQyx1QkFBVztBQUNQdkIseUJBQVM7QUFDTHdCLDhCQUFVLFlBREw7QUFFTDdvQyxvQ0FBZ0I7QUFGWDtBQURGLGFBeElSOztBQStJSGlvQyxzQkFBVWEsa0JBQWtCanBDLE1BQWxCLENBL0lQOztBQWlKSDtBQUNBO0FBQ0FrcEMsd0JBQWEsWUFBWTtBQUNyQixvQkFBSUMsYUFBYSxJQUFJQyxNQUFKLENBQVcsT0FBTyxHQUFHbGdDLE1BQUgsQ0FBVWkrQixjQUFWLEVBQTBCRixZQUExQixFQUF3QzFiLElBQXhDLENBQTZDLEdBQTdDLENBQVAsR0FBMkQsSUFBdEUsQ0FBakI7O0FBRUEsdUJBQU8sWUFBWTtBQUNmLHdCQUFJa2QsVUFBVSxLQUFLWSxVQUFMLENBQWdCQyxtQkFBaEIsQ0FBb0NyQixvQkFBb0IsSUFBcEIsRUFBMEI1MkIsWUFBMUIsQ0FBdUMsT0FBdkMsQ0FBcEMsQ0FBZDs7QUFFQTtBQUNBO0FBQ0EseUJBQUssSUFBSW0zQixDQUFULElBQWNDLE9BQWQsRUFBdUI7QUFDbkIsNEJBQUlVLFdBQVd0Z0MsSUFBWCxDQUFnQjIvQixDQUFoQixDQUFKLEVBQXdCO0FBQ3BCLG1DQUFPQyxRQUFRRCxDQUFSLENBQVA7QUFDSDtBQUNKOztBQUVELDJCQUFPQyxPQUFQO0FBQ0gsaUJBWkQ7QUFhSCxhQWhCVyxFQW5KVDs7QUFxS0hjLHNCQUFVLG9CQUFZO0FBQ2xCLG9CQUFJaHhCLFFBQVEsQ0FBQyxLQUFLdlYsSUFBTCxDQUFVK2lDLEdBQVYsSUFBaUIsRUFBbEIsSUFBd0IsR0FBeEIsR0FBOEIsS0FBS3lELFFBQS9DOztBQUVBLHVCQUFPanhCLEtBQVA7QUFDSCxhQXpLRTs7QUEyS0g7QUFDQTtBQUNBdkUsc0JBQVUsa0JBQVV2UCxTQUFWLEVBQXFCO0FBQzNCLHVCQUFPd2pDLG9CQUFvQixJQUFwQixFQUEwQmowQixRQUExQixDQUFtQ3ZQLFNBQW5DLENBQVA7QUFDSCxhQS9LRTs7QUFpTEh3RCxtQkFBTztBQUNIdS9CLHlCQUFTLFlBRE47QUFFSC9xQix1QkFBTztBQUZKLGFBakxKOztBQXNMSDtBQUNBO0FBQ0F6YSx5QkFBYSxxQkFBVXlDLFNBQVYsRUFBcUI7QUFDOUJ3akMsb0NBQW9CLElBQXBCLEVBQTBCam1DLFdBQTFCLENBQXNDeUMsU0FBdEM7QUFDSCxhQTFMRTs7QUE0TEhnbEMsNkJBQWlCLGNBNUxkOztBQThMSEMsK0JBQW1CLFlBOUxoQjs7QUFnTUg7QUFDQWpmLHNCQUFVQSxRQWpNUDs7QUFtTUhrZixvQkFBUUMsb0JBQW9CNXBDLE1BQXBCO0FBbk1MLFNBQVA7QUFxTUg7O0FBRUQ7Ozs7OztBQU1BQyxhQUFTOHRCLE9BQVQsQ0FBaUJ1WixNQUFqQixHQUEwQjtBQUN0Qjs7Ozs7OztBQU9BSSw4QkFBc0IsOEJBQVVqckIsS0FBVixFQUFpQjtBQUNuQyxnQkFBSWxhLElBQUlrYSxNQUFNbGEsQ0FBZDtBQUFBLGdCQUNJc25DLFVBQVUsS0FBS0MsVUFBTCxDQUFnQnJ0QixLQUFoQixDQURkOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU83UixLQUFLNDJCLEtBQUwsQ0FBV2ovQixFQUFFd25DLFdBQUYsR0FBZ0JGLFFBQVF4M0IsS0FBeEIsR0FBZ0N3M0IsUUFBUTcwQixNQUFuRCxLQUE4RHpTLEVBQUV5bkMsWUFBaEUsSUFDSHAvQixLQUFLNDJCLEtBQUwsQ0FBV2ovQixFQUFFeW5DLFlBQUYsR0FBaUJILFFBQVE3MEIsTUFBekIsR0FBa0M2MEIsUUFBUXgzQixLQUFyRCxLQUErRDlQLEVBQUV3bkMsV0FEckU7QUFFSCxTQWxCcUI7O0FBb0J0Qjs7Ozs7Ozs7QUFRQUQsb0JBQVksb0JBQVVydEIsS0FBVixFQUFpQjtBQUN6QixnQkFBSXd0QixVQUFKOztBQUVBLGdCQUFJeHRCLE1BQU1sYSxDQUFOLENBQVEybkMsWUFBWixFQUEwQjtBQUN0QkQsNkJBQWE7QUFDVGoxQiw0QkFBUXlILE1BQU1sYSxDQUFOLENBQVE0bkMsWUFEUDtBQUVUOTNCLDJCQUFPb0ssTUFBTWxhLENBQU4sQ0FBUTJuQztBQUZOLGlCQUFiO0FBSUgsYUFMRCxNQUtPO0FBQ0gsb0JBQUlFLE1BQU0sSUFBSUMsS0FBSixFQUFWOztBQUVBRCxvQkFBSWhqQyxHQUFKLEdBQVVxVixNQUFNcEwsWUFBTixDQUFtQixLQUFuQixDQUFWOztBQUVBNDRCLDZCQUFhO0FBQ1RqMUIsNEJBQVFvMUIsSUFBSUUsS0FESDtBQUVUajRCLDJCQUFPKzNCLElBQUkvM0I7QUFGRixpQkFBYjtBQUlIOztBQUVELG1CQUFPNDNCLFVBQVA7QUFDSDtBQWhEcUIsS0FBMUI7O0FBbURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFTTCxtQkFBVCxDQUE2QjVwQyxNQUE3QixFQUFxQztBQUNqQyxZQUFJdXFDLGtCQUFrQkMscUJBQXFCeHFDLE1BQXJCLENBQXRCOztBQUVBLFlBQUltbkMsaUJBQWlCbm5DLE9BQU9SLE1BQVAsQ0FBYzRuQyxxQkFBbkM7O0FBRUE7QUFDQTtBQUNBLGVBQU8sVUFBVTl2QixFQUFWLEVBQWN0VSxJQUFkLEVBQW9CO0FBQ3ZCLGdCQUFJaW5DLGFBQWE7QUFDYmoxQix3QkFBUSxDQURLO0FBRWIzQyx1QkFBTztBQUZNLGFBQWpCOztBQUtBLGdCQUFJMUgsT0FBTzJNLEdBQUczTSxJQUFkOztBQUVBLGdCQUFJOFIsS0FBSjs7QUFFQTtBQUNBLGdCQUFJbkYsR0FBR3RULFVBQUgsQ0FBYyxzQkFBZCxDQUFKLEVBQTJDO0FBQ3ZDO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQUl1bUMsZ0JBQWdCanpCLEVBQWhCLENBQUosRUFBeUI7QUFDckIsb0JBQUkzTSxRQUFRLEtBQVosRUFBbUI7QUFDZix3QkFBSTgvQixTQUFTbnpCLEdBQUcrZ0IsUUFBSCxDQUFZLFFBQVosQ0FBYjs7QUFFQTtBQUNBLHdCQUFJb1MsTUFBSixFQUFZO0FBQ1JuekIsMkJBQUdvekIsV0FBSCxDQUFlRCxNQUFmO0FBQ0FuekIsNkJBQUttekIsTUFBTDtBQUNIO0FBQ0o7QUFDRDs7QUFFQTtBQUNBem5DLHFCQUFLNGtDLEtBQUwsR0FBYSxRQUFiOztBQUVBO0FBQ0FuckIsd0JBQVFuRixHQUFHK2dCLFFBQUgsQ0FBWSxLQUFaLEtBQXNCL2dCLEdBQUcrZ0IsUUFBSCxDQUFZLEdBQVosRUFBaUJBLFFBQWpCLENBQTBCLEtBQTFCLENBQTlCO0FBQ0g7O0FBRUQ7QUFuQkEsaUJBb0JLLElBQUkxdEIsUUFBUSxRQUFSLElBQW9CMk0sR0FBR3RELFFBQUgsQ0FBWW16QixjQUFaLENBQXhCLEVBQXFEO0FBQ3REMXFCLDRCQUFRbkYsR0FBRytnQixRQUFILENBQVksS0FBWixLQUFzQi9nQixHQUFHK2dCLFFBQUgsQ0FBWSxHQUFaLEVBQWlCQSxRQUFqQixDQUEwQixLQUExQixDQUE5Qjs7QUFFQTtBQUNILGlCQUpJLE1BSUUsSUFBSXNTLDBCQUEwQnJ6QixFQUExQixDQUFKLEVBQW1DO0FBQ3RDbUYsNEJBQVFuRixHQUFHM00sSUFBSCxJQUFXLEdBQVgsR0FBaUIyTSxHQUFHZ0MsUUFBSCxDQUFZLENBQVosQ0FBakIsR0FBa0NoQyxFQUExQztBQUNIOztBQUVELGdCQUFJLENBQUNtRixLQUFMLEVBQVk7QUFDUjtBQUNIOztBQUVEO0FBQ0E7QUFDQSxpQkFBSyxJQUFJbXVCLENBQVQsSUFBY1gsVUFBZCxFQUEwQjtBQUN0QixvQkFBSXZCLFlBQVlqc0IsTUFBTXpZLFVBQU4sQ0FBaUI0bUMsQ0FBakIsQ0FBaEI7O0FBRUEsb0JBQUlsQyxhQUFhQSxVQUFVdmhDLEtBQVYsQ0FBZ0J3L0IsWUFBaEIsQ0FBakIsRUFBZ0Q7QUFDNUMsMkJBQU9scUIsTUFBTXpZLFVBQU4sQ0FBaUI0bUMsQ0FBakIsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsbUJBQU90ekIsRUFBUDtBQUNILFNBdEVEO0FBdUVIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBU3V4QixxQkFBVCxDQUErQjdvQyxNQUEvQixFQUF1QztBQUNuQyxZQUFJaW5DLGVBQWVqbkMsT0FBT1IsTUFBUCxDQUFjMG5DLG1CQUFqQzs7QUFFQTtBQUNBLGVBQU8sVUFBVTV2QixFQUFWLEVBQWM7QUFDakI7QUFDQTtBQUNBLGdCQUFJdXpCLGNBQWN2ekIsR0FBRzNNLElBQUgsSUFBVyxHQUFYLEdBQWlCMk0sR0FBRytnQixRQUFILEVBQWpCLEdBQWlDL2dCLEVBQW5EOztBQUVBLGdCQUFJeEYsUUFBUSs0QixZQUFZN21DLFVBQXhCOztBQUVBLGdCQUFJNGpDLFFBQVEsS0FBSzVrQyxJQUFMLENBQVU0a0MsS0FBdEI7O0FBRUE7QUFDQTtBQUNBLGdCQUFJLENBQUMsS0FBSzFuQyxNQUFWLEVBQWtCO0FBQ2Qsb0JBQUk0cUMsZ0JBQWdCeHpCLEdBQUcrZ0IsUUFBSCxDQUFZLE1BQVosQ0FBcEI7O0FBRUEsb0JBQUl5UyxhQUFKLEVBQW1CO0FBQ2ZBLGtDQUFjSixXQUFkLENBQTBCSSxjQUFjelMsUUFBZCxDQUF1QjtBQUM3QzltQiwyQkFBRyxDQUQwQztBQUU3QzY0Qiw2QkFBSztBQUZ3QyxxQkFBdkIsQ0FBMUI7QUFJSDtBQUNKOztBQUVELGdCQUFJeEMsU0FBU0EsU0FBUyxNQUF0QixFQUE4QjtBQUMxQixvQkFBSXJoQyxTQUFTdEcsU0FBU3dMLEtBQVQsQ0FBZXMvQixZQUFmLENBQTRCajVCLE1BQU1qRyxLQUFOLElBQWUsRUFBM0MsQ0FBYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBSSs3QixTQUFTLFFBQVQsSUFBcUJ0d0IsR0FBRzNNLElBQUgsSUFBVyxRQUFwQyxFQUE4QztBQUMxQzJNLHlCQUFLQSxHQUFHMHpCLFFBQUgsQ0FBWSxJQUFJL3FDLFNBQVNnckMsVUFBVCxDQUFvQjE2QixPQUF4QixDQUFnQyxLQUFoQyxFQUNiMDJCLGVBQWU7QUFDWCxpQ0FBU0EsYUFBYSxDQUFiO0FBREUscUJBQWYsR0FFSTtBQUNBcDdCLCtCQUFPO0FBRFAscUJBSFMsQ0FBWixDQUFMO0FBTUg7O0FBRUQ7QUFUQSxxQkFVSyxJQUFJKzdCLFNBQVM7QUFDVjExQiw4QkFBTSxDQURJO0FBRVZpQiwrQkFBTztBQUZHLHFCQUFiLEVBR0U7QUFDSCw0QkFBSTh6QixZQUFKLEVBQWtCO0FBQ2Q0RCx3Q0FBWTFwQyxRQUFaLENBQXFCOGxDLGFBQWFULGNBQWNvQixLQUFkLENBQWIsQ0FBckI7QUFDSCx5QkFGRCxNQUVPO0FBQ0hyaEMsbUNBQU8sT0FBUCxJQUFrQnFoQyxLQUFsQjtBQUNIO0FBQ0o7O0FBRUQ7QUFDQSxvQkFBSSxDQUFDWCxZQUFELElBQWlCLENBQUNobkMsU0FBU3dMLEtBQVQsQ0FBZXkvQixPQUFmLENBQXVCM2tDLE1BQXZCLENBQXRCLEVBQXNEO0FBQ2xEdUwsMEJBQU1qRyxLQUFOLEdBQWM1TCxTQUFTd0wsS0FBVCxDQUFlMC9CLFlBQWYsQ0FBNEI1a0MsTUFBNUIsQ0FBZDtBQUNIO0FBQ0o7O0FBRUQsbUJBQU8rUSxFQUFQO0FBQ0gsU0FqRUQ7QUFrRUg7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFTa3pCLG9CQUFULENBQThCeHFDLE1BQTlCLEVBQXNDO0FBQ2xDLFlBQUltbkMsaUJBQWlCbm5DLE9BQU9SLE1BQVAsQ0FBYzRuQyxxQkFBbkM7O0FBRUEsWUFBSUgsZUFBZWpuQyxPQUFPUixNQUFQLENBQWMwbkMsbUJBQWpDOztBQUVBLFlBQUlrRSxnQkFBZ0I7QUFDaEI3NUIsZUFBRyxDQURhO0FBRWhCazVCLG9CQUFRLENBRlE7QUFHaEJMLGlCQUFLO0FBSFcsU0FBcEI7O0FBTUEsZUFBTyxVQUFVOXlCLEVBQVYsRUFBYztBQUNqQjtBQUNBLGdCQUFJLEVBQUVBLEdBQUczTSxJQUFILElBQVc7QUFDVDBnQyxxQkFBSyxDQURJO0FBRVRDLG1CQUFHO0FBRk0sYUFBYixDQUFKLEVBR1E7QUFDSix1QkFBTyxLQUFQO0FBQ0g7O0FBRUQsZ0JBQUloeUIsV0FBV2hDLEdBQUdnQyxRQUFsQjs7QUFFQTtBQUNBLGdCQUFJQSxTQUFTcFMsTUFBVCxLQUFvQixDQUF4QixFQUEyQjtBQUN2Qix1QkFBTyxLQUFQO0FBQ0g7O0FBRUQsZ0JBQUlxa0MsUUFBUWp5QixTQUFTLENBQVQsQ0FBWjs7QUFFQTtBQUNBO0FBQ0EsZ0JBQUksRUFBRWl5QixNQUFNNWdDLElBQU4sSUFBY3lnQyxhQUFoQixDQUFKLEVBQW9DO0FBQ2hDLHVCQUFPLEtBQVA7QUFDSDs7QUFFRDtBQUNBO0FBQ0EsZ0JBQUk5ekIsR0FBRzNNLElBQUgsSUFBVyxHQUFmLEVBQW9CO0FBQ2hCLG9CQUFJLENBQUNnZ0MsMEJBQTBCWSxLQUExQixDQUFMLEVBQXVDO0FBQ25DLDJCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0Q7QUFMQSxpQkFNSztBQUNEO0FBQ0E7QUFDQSx3QkFBSUEsTUFBTTVnQyxJQUFOLElBQWMsUUFBbEIsRUFBNEI7QUFDeEIsNEJBQUksQ0FBQzRnQyxNQUFNdjNCLFFBQU4sQ0FBZW16QixjQUFmLENBQUwsRUFBcUM7QUFDakMsbUNBQU8sS0FBUDtBQUNIO0FBQ0oscUJBSkQsTUFJTztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQUlubkMsT0FBT3dyQyxTQUFQLElBQW9CdnJDLFNBQVN3ckMsT0FBakMsRUFBMEM7QUFDdEMsbUNBQU8sS0FBUDtBQUNIOztBQUVEO0FBQ0E7QUFDQSw0QkFBSSxDQUFDZCwwQkFBMEJZLEtBQTFCLENBQUwsRUFBdUM7QUFDbkMsbUNBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0EsZ0JBQUl0RSxlQUFlM3ZCLEdBQUd0RCxRQUFILENBQVlpekIsYUFBYSxDQUFiLENBQVosQ0FBZixHQUNBaG5DLFNBQVN3TCxLQUFULENBQWVzL0IsWUFBZixDQUE0Qnp6QixHQUFHdFQsVUFBSCxDQUFjNkgsS0FBZCxJQUF1QixFQUFuRCxFQUF1RCxJQUF2RCxFQUE2RCxZQUE3RCxLQUE4RSxRQURsRixFQUM0RjtBQUN4Rix1QkFBTyxJQUFQO0FBQ0g7O0FBRUQsbUJBQU8sS0FBUDtBQUNILFNBaEVEO0FBaUVIOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQVM4K0IseUJBQVQsQ0FBbUNyekIsRUFBbkMsRUFBdUM7QUFDbkMsWUFBSUEsR0FBRzNNLElBQUgsSUFBVyxLQUFmLEVBQXNCO0FBQ2xCLG1CQUFPLElBQVA7QUFDSCxTQUZELE1BRU8sSUFBSTJNLEdBQUczTSxJQUFILElBQVcsR0FBZixFQUFvQjtBQUN2QixtQkFBTzJNLEdBQUdnQyxRQUFILENBQVlwUyxNQUFaLElBQXNCLENBQXRCLElBQTJCb1EsR0FBRytnQixRQUFILENBQVksS0FBWixDQUFsQztBQUNIOztBQUVELGVBQU8sS0FBUDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQVNzUSxhQUFULENBQXVCK0MsTUFBdkIsRUFBK0I7QUFDM0IsWUFBSTFvQyxPQUFPMG9DLE9BQU8xb0MsSUFBbEI7O0FBRUEsWUFBSWluQyxhQUFhO0FBQ2JqMUIsb0JBQVFoUyxLQUFLZ1MsTUFEQTtBQUViM0MsbUJBQU9yUCxLQUFLcVA7QUFGQyxTQUFqQjs7QUFLQSxZQUFJb0ssUUFBUWl2QixPQUFPempDLEtBQVAsQ0FBYXdVLEtBQXpCOztBQUVBLGFBQUssSUFBSW11QixDQUFULElBQWNYLFVBQWQsRUFBMEI7QUFDdEIsZ0JBQUlBLFdBQVdXLENBQVgsQ0FBSixFQUFtQjtBQUNmbnVCLHNCQUFNMWMsWUFBTixDQUFtQjZxQyxDQUFuQixFQUFzQlgsV0FBV1csQ0FBWCxDQUF0QjtBQUNILGFBRkQsTUFFTztBQUNIbnVCLHNCQUFNK2IsZUFBTixDQUFzQm9TLENBQXRCO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQVM1QyxZQUFULENBQXNCMEQsTUFBdEIsRUFBOEI7QUFDMUIsWUFBSTFyQyxTQUFTMHJDLE9BQU8xckMsTUFBcEI7O0FBRUEsWUFBSWtCLFdBQVdsQixPQUFPa0IsUUFBUCxFQUFmOztBQUVBLFlBQUl5cUMsTUFBTTNyQyxPQUFPc0MsUUFBakI7O0FBRUE7QUFDQSxZQUFJbWdDLFVBQVVpSixPQUFPakosT0FBUCxHQUFpQmtKLElBQUlubkMsYUFBSixDQUFrQixNQUFsQixDQUEvQjs7QUFFQWkrQixnQkFBUXRoQyxRQUFSLENBQWlCLG1CQUFqQjtBQUNBc2hDLGdCQUFRdGhDLFFBQVIsQ0FBaUIsdUJBQXVCdWxDLE9BQU8xbUMsT0FBT1IsTUFBUCxDQUFjZ2pDLGdCQUFyQixDQUF4QztBQUNBQyxnQkFBUTFNLE1BQVIsQ0FBZSxJQUFJOTFCLFNBQVN5RCxHQUFULENBQWE2c0IsSUFBakIsQ0FBc0IsUUFBdEIsRUFBZ0NvYixHQUFoQyxDQUFmOztBQUVBO0FBQ0EsWUFBSSxDQUFDRCxPQUFPeHJDLE1BQVosRUFBb0I7QUFDaEIsZ0JBQUkwckMsY0FBY0YsT0FBT3pqQyxLQUFQLENBQWFwRSxJQUFiLElBQXFCNm5DLE9BQU96akMsS0FBUCxDQUFhd1UsS0FBcEQ7O0FBRUEsZ0JBQUlvdkIsbUJBQW1CRCxZQUFZL1UsU0FBWixFQUF2Qjs7QUFFQSxnQkFBSWlVLGdCQUFnQmEsSUFBSW5uQyxhQUFKLENBQWtCLE1BQWxCLENBQXBCOztBQUVBc21DLDBCQUFjM3BDLFFBQWQsQ0FBdUIsMkJBQXZCO0FBQ0EycEMsMEJBQWMvVSxNQUFkLENBQXFCNlYsV0FBckI7QUFDQWQsMEJBQWMvVSxNQUFkLENBQXFCME0sT0FBckI7QUFDQWlKLG1CQUFPbjdCLE9BQVAsQ0FBZXdsQixNQUFmLENBQXNCK1UsYUFBdEIsRUFBcUMsSUFBckM7O0FBRUE7QUFDQTtBQUNBLGdCQUFJZSxpQkFBaUJoYixFQUFqQixDQUFvQixNQUFwQixDQUFKLEVBQWlDO0FBQzdCZ2IsaUNBQWlCdndCLE1BQWpCO0FBQ0g7QUFDSixTQWpCRCxNQWlCTztBQUNIb3dCLG1CQUFPL0QsT0FBUCxDQUFlNVIsTUFBZixDQUFzQjBNLE9BQXRCO0FBQ0g7O0FBRUQ7QUFDQUEsZ0JBQVE3L0IsRUFBUixDQUFXLFdBQVgsRUFBd0IsVUFBVTAvQixHQUFWLEVBQWU7QUFDbkMsZ0JBQUk3bEIsUUFBUWl2QixPQUFPempDLEtBQVAsQ0FBYXdVLEtBQXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFJcXZCLFNBQVNKLE9BQU8xb0MsSUFBUCxDQUFZNGtDLEtBQVosSUFBcUIsT0FBckIsR0FBK0IsQ0FBQyxDQUFoQyxHQUFvQyxDQUFqRDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQUlwVixTQUFTOFAsSUFBSXQvQixJQUFKLENBQVNULENBQVQsQ0FBV3dwQyxPQUF4Qjs7QUFFQSxnQkFBSXRaLFNBQVM2UCxJQUFJdC9CLElBQUosQ0FBU1QsQ0FBVCxDQUFXeXBDLE9BQXhCOztBQUVBO0FBQ0EsZ0JBQUlDLGFBQWF4dkIsTUFBTWxhLENBQU4sQ0FBUXduQyxXQUF6Qjs7QUFFQSxnQkFBSW1DLGNBQWN6dkIsTUFBTWxhLENBQU4sQ0FBUXluQyxZQUExQjs7QUFFQSxnQkFBSW1DLFlBQVksRUFBaEI7O0FBRUE7QUFDQSxnQkFBSUMsY0FBYyxpQkFBaUIsQ0FBQyxDQUFDTixNQUFGLEdBQVcsR0FBWCxHQUFpQixHQUFsQyxDQUFsQjs7QUFFQSxnQkFBSU8sU0FBSixFQUFlQyxRQUFmLEVBQXlCQyxTQUF6QixFQUFvQ0MsVUFBcEM7O0FBRUEsZ0JBQUlDLFNBQUosRUFBZUMsU0FBZixFQUEwQkMsU0FBMUI7O0FBRUE7QUFDQTNzQyxtQkFBT3dELElBQVAsQ0FBWSxjQUFaOztBQUVBO0FBQ0FvcEMsOEJBQWtCLFdBQWxCLEVBQStCQyxXQUEvQixFQUE0Q1YsU0FBNUM7O0FBRUE7QUFDQVMsOEJBQWtCLFNBQWxCLEVBQTZCRSxTQUE3QixFQUF3Q1gsU0FBeEM7O0FBRUE7QUFDQWpyQyxxQkFBU0MsUUFBVCxDQUFrQmlyQyxXQUFsQjs7QUFFQTtBQUNBM0osb0JBQVF0aEMsUUFBUixDQUFpQixvQkFBakI7O0FBRUE7QUFDQTtBQUNBLHFCQUFTeXJDLGlCQUFULENBQTJCamlDLElBQTNCLEVBQWlDbkQsUUFBakMsRUFBMkN1bEMsVUFBM0MsRUFBdUQ7QUFDbkQsb0JBQUlDLFlBQVkvc0MsU0FBU3FDLFFBQXpCOztBQUVBLG9CQUFJNnBDLFlBQVksRUFBaEI7O0FBRUEsb0JBQUksQ0FBQ1IsSUFBSTliLE1BQUosQ0FBV21kLFNBQVgsQ0FBTCxFQUE0QjtBQUN4QmIsOEJBQVU3aUMsSUFBVixDQUFlMGpDLFVBQVVwcUMsRUFBVixDQUFhK0gsSUFBYixFQUFtQm5ELFFBQW5CLENBQWY7QUFDSDs7QUFFRDJrQywwQkFBVTdpQyxJQUFWLENBQWVxaUMsSUFBSS9vQyxFQUFKLENBQU8rSCxJQUFQLEVBQWFuRCxRQUFiLENBQWY7O0FBRUEsb0JBQUl1bEMsVUFBSixFQUFnQjtBQUNaLHlCQUFLLElBQUk5bEMsSUFBSWtsQyxVQUFVamxDLE1BQXZCLEVBQStCRCxHQUEvQixHQUFxQztBQUNqQzhsQyxtQ0FBV3pqQyxJQUFYLENBQWdCNmlDLFVBQVVsTixHQUFWLEVBQWhCO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFTNE4sV0FBVCxDQUFxQnZLLEdBQXJCLEVBQTBCO0FBQ3RCLG9CQUFJRSxtQkFBbUJ4aUMsT0FBT1IsTUFBUCxDQUFjZ2pDLGdCQUFyQzs7QUFFQTZKLDRCQUFZL0osSUFBSXQvQixJQUFKLENBQVNULENBQXJCOztBQUVBO0FBQ0FrcUMsNEJBQVlKLFVBQVVOLE9BQVYsR0FBb0J2WixNQUFoQztBQUNBa2EsNEJBQVlqYSxTQUFTNFosVUFBVUwsT0FBL0I7O0FBRUE7QUFDQVcsNEJBQVkvaEMsS0FBS3lJLEdBQUwsQ0FBU281QixZQUFZQyxTQUFyQixDQUFaOztBQUVBLG9CQUFJbEsscUJBQXFCLE9BQXJCLElBQWdDQSxxQkFBcUIsTUFBckQsSUFBK0RBLHFCQUFxQixPQUF4RixFQUFpRztBQUM3RjhKLCtCQUFXTCxhQUFhSCxTQUFTVyxTQUFqQztBQUNIOztBQUVELG9CQUFJaksscUJBQXFCLFFBQXJCLElBQWlDQSxxQkFBcUIsTUFBMUQsRUFBa0U7QUFDOUQrSixnQ0FBWUwsY0FBY1EsU0FBMUI7QUFDSDs7QUFFRCxvQkFBSWxLLHFCQUFxQixPQUF6QixFQUFrQztBQUM5QitKLGdDQUFZLE1BQVo7QUFDSDs7QUFFREQsMkJBQVdBLFlBQVlMLFVBQXZCO0FBQ0FNLDRCQUFZQSxhQUFhTCxXQUF6Qjs7QUFFQTtBQUNBO0FBQ0Esb0JBQUlJLFlBQVksRUFBWixLQUFtQkMsYUFBYSxFQUFiLElBQW1CQSxjQUFjLE1BQXBELENBQUosRUFBaUU7QUFDN0Q5dkIsMEJBQU0yVSxhQUFOLENBQW9CO0FBQ2hCL2UsK0JBQU9pNkIsUUFEUztBQUVoQnQzQixnQ0FBUXUzQjtBQUZRLHFCQUFwQjtBQUlBQyxpQ0FBYSxJQUFiO0FBQ0gsaUJBTkQsTUFNTztBQUNIQSxpQ0FBYSxLQUFiO0FBQ0g7QUFDSjs7QUFFRCxxQkFBU00sU0FBVCxHQUFxQjtBQUNqQixvQkFBSUcsQ0FBSjs7QUFFQSx1QkFBUUEsSUFBSWQsVUFBVWxOLEdBQVYsRUFBWixFQUE4QjtBQUMxQmdPLHNCQUFFcFMsY0FBRjtBQUNIOztBQUVEO0FBQ0EzNUIseUJBQVNjLFdBQVQsQ0FBcUJvcUMsV0FBckI7O0FBRUE7QUFDQTNKLHdCQUFRemdDLFdBQVIsQ0FBb0Isb0JBQXBCOztBQUVBLG9CQUFJd3FDLFVBQUosRUFBZ0I7QUFDWmQsMkJBQU81RCxPQUFQLENBQWU7QUFDWDl5QixnQ0FBUXUzQixTQURHO0FBRVhsNkIsK0JBQU9pNkI7QUFGSSxxQkFBZjs7QUFLQTtBQUNBdHNDLDJCQUFPd0QsSUFBUCxDQUFZLGNBQVo7QUFDSDs7QUFFRDtBQUNBZ3BDLDZCQUFhLEtBQWI7QUFDSDtBQUNKLFNBbEpEOztBQW9KQTtBQUNBZCxlQUFPOW9DLEVBQVAsQ0FBVSxNQUFWLEVBQWtCLFlBQVk7QUFDMUI2L0Isb0JBQVFpSixPQUFPMW9DLElBQVAsQ0FBWTRrQyxLQUFaLElBQXFCLE9BQXJCLEdBQStCLFVBQS9CLEdBQTRDLGFBQXBELEVBQW1FLHdCQUFuRTtBQUNILFNBRkQ7O0FBSUE4RCxlQUFPempDLEtBQVAsQ0FBYXdVLEtBQWIsQ0FBbUI3WixFQUFuQixDQUFzQixPQUF0QixFQUErQixZQUFZOztBQUV2QzVDLG1CQUFPdXVCLENBQVAsQ0FBU3J0QixRQUFULENBQWtCbEIsTUFBbEIsQ0FBeUJxQyxZQUF6QixHQUF3QzR1QixhQUF4QyxDQUFzRCxJQUF0RDs7QUFFQSxnQkFBSXplLGdCQUFnQnhTLE9BQU91dUIsQ0FBUCxDQUFTcnRCLFFBQVQsQ0FBa0JsQixNQUFsQixDQUF5QjRyQixnQkFBekIsRUFBcEI7QUFDQSxnQkFBSXBaLGFBQUosRUFBbUI7QUFDZnhTLHVCQUFPd0QsSUFBUCxDQUFZLG1CQUFaLEVBQWlDO0FBQzdCaVAsaUNBQWEzUCxLQURnQjtBQUU3QjBQLG1DQUFlQTtBQUZjLGlCQUFqQztBQUlIO0FBQ0osU0FYRDtBQWFIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVMwMUIsdUJBQVQsQ0FBaUNsb0MsTUFBakMsRUFBeUM7QUFDckMsWUFBSWt0QyxRQUFRO0FBQ1JDLHdCQUFZLElBREo7QUFFUjFDLG9CQUFRO0FBQ0poQyx5QkFBUyxNQUFNem9DLE9BQU9SLE1BQVAsQ0FBYzRuQztBQUR6QixhQUZBO0FBS1JnRCxpQkFBSztBQUNEcG1DLDRCQUFZO0FBRFg7QUFMRyxTQUFaOztBQVVBLGVBQU9rcEMsS0FBUDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBU2pFLGlCQUFULENBQTJCanBDLE1BQTNCLEVBQW1DO0FBQy9CLFlBQUlpbkMsZUFBZWpuQyxPQUFPUixNQUFQLENBQWMwbkMsbUJBQWpDOztBQUVBLFlBQUlrQixXQUFXO0FBQ1hSLG1CQUFPO0FBQ0g2QixpQ0FBaUIsU0FDWnhDLGVBQWUsTUFBTUEsYUFBYSxDQUFiLENBQU4sR0FBd0IsR0FBdkMsR0FBNkMsU0FEakM7QUFEZCxhQURJO0FBS1hPLHFCQUFTO0FBQ0xpQyxpQ0FBaUI7QUFEWixhQUxFO0FBUVhmLHVCQUFXO0FBQ1BlLGlDQUFpQjtBQURWO0FBUkEsU0FBZjs7QUFhQSxlQUFPckIsUUFBUDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVNILG1CQUFULENBQTZCeUQsTUFBN0IsRUFBcUM7QUFDakMsZUFBT0EsT0FBTzFvQyxJQUFQLENBQVl1a0MsVUFBWixHQUF5Qm1FLE9BQU9uN0IsT0FBaEMsR0FBMENtN0IsT0FBT3pqQyxLQUFQLENBQWF3VSxLQUE5RDtBQUNIO0FBQ0osQ0EzOUJEOztBQTY5QkF4YyxTQUFTVCxNQUFULENBQWdCNG5DLHFCQUFoQixHQUF3QyxPQUF4QyxDOzs7Ozs7Ozs7Ozs7OztBQ2orQkMsYUFBVztBQUNSOztBQUVBOztBQUNBLFFBQUlubkMsU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLFVBQXJCLENBQUosRUFBc0M7QUFDbEM7QUFDSDs7QUFFRCxRQUFJc3RDLGFBQWEsU0FBakI7O0FBRUEsUUFBSUMscUJBQXFCLFVBQXpCOztBQUVBLFFBQUlDLFlBQVksQ0FBQyxTQUFELEVBQVksU0FBWixDQUFoQjs7QUFFQXJ0QyxhQUFTc3RDLHdCQUFULEdBQW9DLGlFQUFwQztBQUNBdHRDLGFBQVN1dEMsMkJBQVQsR0FBdUMsdUNBQXZDO0FBQ0F2dEMsYUFBU3d0QyxpQ0FBVCxHQUE2QywyQkFBN0M7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUF4dEMsYUFBUzh0QixPQUFULENBQWlCM25CLEdBQWpCLENBQ0ksVUFESixFQUNnQjtBQUNSNHJCLGtCQUFVLFFBREY7QUFFUnFELGNBQU0sY0FBU3IxQixNQUFULEVBQWlCO0FBQ25CLGdCQUFJMHRDLG1CQUFtQixJQUFJenRDLFNBQVN3cUIsUUFBYixDQUFzQnpxQixPQUFPUixNQUFQLENBQWNtdUMsZ0JBQWQsSUFBa0MxdEMsU0FBU3N0Qyx3QkFBakUsQ0FBdkI7QUFDQSxnQkFBSUssc0JBQXNCLElBQUkzdEMsU0FBU3dxQixRQUFiLENBQXNCenFCLE9BQU9SLE1BQVAsQ0FBY3F1QyxjQUFkLElBQWdDNXRDLFNBQVN1dEMsMkJBQS9ELENBQTFCO0FBQ0EsZ0JBQUlNLDRCQUE0QixJQUFJN3RDLFNBQVN3cUIsUUFBYixDQUFzQnpxQixPQUFPUixNQUFQLENBQWN1dUMsbUJBQWQsSUFBcUM5dEMsU0FBU3d0QyxpQ0FBcEUsQ0FBaEM7O0FBRUE7QUFDQTtBQUNBLGdCQUFJTyw2QkFBNkIsU0FBN0JBLDBCQUE2QixDQUFTejlCLE9BQVQsRUFBa0J2TixJQUFsQixFQUF3QjtBQUNyRCxvQkFBSXVOLFFBQVE1RixJQUFSLEtBQWlCLEtBQWpCLElBQTBCNEYsUUFBUXZNLFVBQVIsQ0FBbUIsbUJBQW5CLENBQTlCLEVBQXVFO0FBQ25FaEIseUJBQUtpWSxHQUFMLEdBQVcxSyxRQUFRdk0sVUFBUixDQUFtQixtQkFBbkIsQ0FBWDs7QUFFQSwyQkFBTyxJQUFQO0FBQ0g7QUFDSixhQU5EOztBQVFBO0FBQ0FoRSxtQkFBT2tMLFVBQVAsQ0FBa0IsVUFBbEIsRUFBOEI7QUFDMUJILHNCQUFNLGNBQVMvSyxNQUFULEVBQWlCZ0QsSUFBakIsRUFBdUI7QUFDekJoRCwyQkFBT21nQyxVQUFQLENBQ0l5TixvQkFBb0J0aUIsTUFBcEIsQ0FBMkI7QUFDdkJyUSw2QkFBS2pZLEtBQUtpWTtBQURhLHFCQUEzQixDQURKO0FBS0g7QUFQeUIsYUFBOUI7O0FBVUE7QUFDQWpiLG1CQUFPK21DLE9BQVAsQ0FBZTNnQyxHQUFmLENBQW1CLFVBQW5CLEVBQStCOztBQUczQjZuQyxzQkFBTSxJQUhxQjtBQUkzQnhFLGlDQUFpQix3QkFKVTs7QUFNM0I7Ozs7Ozs7O0FBUUF6bUMsc0JBQU0sY0FBU0YsS0FBVCxFQUFnQjtBQUNsQix3QkFBSTRvQyxTQUFTLElBQWI7O0FBRUEsd0JBQUl6d0IsTUFBTW5ZLE1BQU1FLElBQU4sQ0FBV2lZLEdBQXJCOztBQUVBLHdCQUFJQSxHQUFKLEVBQVM7QUFDTGhiLGlDQUFTd0wsS0FBVCxDQUFlb3RCLEtBQWYsQ0FBcUI2VSxnQkFBckIsRUFBdUM7QUFDbkN6eUIsaUNBQUtpekIsbUJBQW1CanpCLEdBQW5CO0FBRDhCLHlCQUF2QyxFQUVHLFVBQVNtZSxRQUFULEVBQW1CO0FBQ2xCLGdDQUFJQSxTQUFTNEosSUFBYixFQUFtQjtBQUNmLG9DQUFJcUssbUJBQW1CeGtDLElBQW5CLENBQXdCdXdCLFNBQVM0SixJQUFqQyxDQUFKLEVBQTRDO0FBQ3hDMEksMkNBQU95QyxVQUFQLENBQWtCbHpCLEdBQWxCO0FBQ0gsaUNBRkQsTUFFTztBQUNIeXdCLDJDQUFPbjdCLE9BQVAsQ0FBZTY5QixPQUFmLENBQXVCaFYsU0FBUzRKLElBQWhDO0FBQ0g7QUFDSiw2QkFORCxNQU1PO0FBQ0gwSSx1Q0FBT3lDLFVBQVAsQ0FBa0JsekIsR0FBbEI7QUFDSDtBQUNKLHlCQVpELEVBWUcsVUFBU296QixHQUFULEVBQWM7QUFDYjNDLG1DQUFPeUMsVUFBUCxDQUFrQmx6QixHQUFsQjtBQUNILHlCQWREO0FBZUg7QUFDSixpQkFwQzBCOztBQXNDM0JrekIsNEJBQVksb0JBQVNsekIsR0FBVCxFQUFjO0FBQ3RCLHlCQUFLamIsTUFBTCxDQUFZc0ssV0FBWixDQUF3QixNQUF4Qjs7QUFFQSx3QkFBSThpQixtQkFBbUIsS0FBS3B0QixNQUFMLENBQVlxQyxZQUFaLEdBQTJCNFgsa0JBQTNCLEVBQXZCOztBQUVBLHdCQUFJcTBCLFdBQVdSLDBCQUEwQnhpQixNQUExQixDQUFpQztBQUM1Q3JRLDZCQUFLQTtBQUR1QyxxQkFBakMsQ0FBZjs7QUFJQSx5QkFBS2piLE1BQUwsQ0FBWW1nQyxVQUFaLENBQXVCbU8sUUFBdkI7QUFDQSx5QkFBS3R1QyxNQUFMLENBQVl3RCxJQUFaLENBQWlCLGlCQUFqQixFQUFvQyxJQUFwQztBQUNILGlCQWpEMEI7O0FBbUQzQjs7Ozs7OztBQU9BbW1DLHdCQUFRLGdCQUFTcDVCLE9BQVQsRUFBa0J2TixJQUFsQixFQUF3QjtBQUM1Qix3QkFBSXVyQyxzQkFBc0J2dUMsT0FBT1IsTUFBUCxDQUFjK3VDLG1CQUFkLElBQXFDUCwwQkFBL0Q7O0FBRUEsMkJBQU9PLG9CQUFvQmgrQixPQUFwQixFQUE2QnZOLElBQTdCLENBQVA7QUFDSDtBQTlEMEIsYUFBL0I7O0FBaUVBO0FBQ0FoRCxtQkFBT2dCLElBQVAsQ0FBWSxZQUFaLEVBQTBCLFlBQVc7QUFDakNoQix1QkFBTzRDLEVBQVAsQ0FBVSxPQUFWLEVBQW1CLFVBQVNFLEtBQVQsRUFBZ0I7QUFDL0Isd0JBQUllLE9BQU9mLE1BQU1FLElBQU4sQ0FBV2lnQyxTQUF0Qjs7QUFFQSx3QkFBSW1LLFdBQVd2a0MsSUFBWCxDQUFnQmhGLElBQWhCLENBQUosRUFBMkI7QUFDdkJmLDhCQUFNaVQsSUFBTjs7QUFFQS9WLCtCQUFPc0ssV0FBUCxDQUFtQixVQUFuQixFQUErQjtBQUMzQjJRLGlDQUFLblksTUFBTUUsSUFBTixDQUFXaWdDO0FBRFcseUJBQS9CO0FBR0g7QUFDSixpQkFWRDtBQVdILGFBWkQ7O0FBY0E7QUFDQTtBQUNBampDLG1CQUFPNEMsRUFBUCxDQUFVLGlCQUFWLEVBQTZCLFVBQVNFLEtBQVQsRUFBZ0I7QUFDekMsb0JBQUlOLFlBQVl4QyxPQUFPcUMsWUFBUCxFQUFoQjs7QUFFQSxvQkFBSUcsU0FBSixFQUFjO0FBQ1Ysd0JBQUkrTixVQUFVL04sVUFBVXlYLGtCQUFWLEVBQWQ7O0FBRUEsd0JBQUkxSixPQUFKLEVBQWE7QUFDVCw0QkFBSWkrQixnQkFBZ0JqK0IsUUFBUTJKLE9BQVIsQ0FBZ0IsMEJBQWhCLENBQXBCOztBQUVBLDRCQUFJczBCLGFBQUosRUFBbUI7QUFDZixnQ0FBSTU3QixTQUFTckMsUUFBUXNjLGFBQVIsRUFBYjs7QUFFQSxnQ0FBSTRoQixpQkFBaUIsSUFBSXh1QyxTQUFTeUQsR0FBVCxDQUFhdEIsTUFBakIsQ0FBd0JBLE1BQXhCLEVBQWdDMHhCLGlCQUFoQyxFQUFyQjtBQUNBbGhCLG1DQUFPVixJQUFQLElBQWV1OEIsZUFBZXg4QixDQUE5QjtBQUNBVyxtQ0FBT1IsR0FBUCxJQUFjcThCLGVBQWV0OEIsQ0FBN0I7O0FBRUFTLG1DQUFPekYsU0FBUCxHQUFtQmxOLFNBQVM4Uyx1QkFBNUI7O0FBRUEvUyxtQ0FBT3dELElBQVAsQ0FBWSxtQkFBWixFQUFpQztBQUM3QmlQLDZDQUFhLEVBRGdCO0FBRTdCRCwrQ0FBZTtBQUNYakMsNkNBQVNpK0IsYUFERTtBQUVYNTdCLDRDQUFRQTtBQUZHO0FBRmMsNkJBQWpDO0FBT0g7QUFDSjtBQUNKO0FBQ0osYUE1QkQ7O0FBOEJBO0FBQ0E1UyxtQkFBT3dNLE1BQVAsQ0FBY2tpQyxrQkFBZCxDQUFpQyxVQUFTbitCLE9BQVQsRUFBa0I7QUFDL0Msb0JBQUksdUJBQXVCQSxRQUFRdk0sVUFBbkMsRUFBK0M7QUFDM0MsMkJBQU8vRCxTQUFTMHVDLGdCQUFoQjtBQUNIO0FBQ0osYUFKRDtBQUtIO0FBbkpPLEtBRGhCO0FBdUpILENBcExBLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7O0FBRUMsYUFBVztBQUNSOztBQUVBLFFBQUkxdUMsU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLG1CQUFyQixDQUFKLEVBQStDO0FBQzNDO0FBQ0g7O0FBRUQ7Ozs7QUFJQSxRQUFJOHVDLGtCQUFrQjtBQUNsQkMsZ0JBQVEsUUFEVTtBQUVsQkMsY0FBTSxNQUZZO0FBR2xCQyxlQUFPO0FBSFcsS0FBdEI7O0FBTUE7Ozs7QUFJQSxRQUFJQyxlQUFlLENBQ2ZKLGdCQUFnQkUsSUFERCxFQUVmRixnQkFBZ0JHLEtBRkQsRUFHZkgsZ0JBQWdCQyxNQUhELENBQW5COztBQU1BOzs7O0FBSUEsUUFBSUksdUJBQXVCLENBQUM7QUFDeEJ0a0MsY0FBTSxTQURrQjtBQUV4QjFHLGVBQU87QUFGaUIsS0FBRCxFQUd4QjtBQUNDMEcsY0FBTSxhQURQO0FBRUMxRyxlQUFPO0FBRlIsS0FId0IsRUFNeEI7QUFDQzBHLGNBQU0sY0FEUDtBQUVDMUcsZUFBTztBQUZSLEtBTndCLENBQTNCOztBQVdBOzs7Ozs7QUFNQSxRQUFJaXJDLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVN6eUIsS0FBVCxFQUFnQjtBQUNwQyxZQUFJMHlCLGlCQUFpQjF5QixNQUFNOVMsUUFBTixDQUFlLE9BQWYsQ0FBckI7O0FBRUEsWUFBSSxDQUFDd2xDLGNBQUQsSUFBbUJBLG1CQUFtQixTQUF0QyxJQUFtREEsbUJBQW1CLE1BQTFFLEVBQWtGO0FBQzlFQSw2QkFBaUIxeUIsTUFBTXBMLFlBQU4sQ0FBbUIsT0FBbkIsQ0FBakI7QUFDSDs7QUFFRCxZQUFJLENBQUM4OUIsY0FBTCxFQUFxQjtBQUNqQixnQkFBSUMsZ0JBQWdCSCxxQkFBcUJJLEtBQXJCLENBQTJCLFVBQVN4akMsS0FBVCxFQUFnQjtBQUMzRCxvQkFBSXlqQyxhQUFhN3lCLE1BQU05UyxRQUFOLENBQWVrQyxNQUFNbEIsSUFBckIsTUFBK0JrQixNQUFNNUgsS0FBdEQ7O0FBRUEsb0JBQUksQ0FBQ3FyQyxVQUFELElBQWV6akMsTUFBTTBqQyxjQUF6QixFQUF5QztBQUNyQ0QsaUNBQWF6akMsTUFBTTBqQyxjQUFOLENBQXFCNzlCLElBQXJCLENBQTBCLFVBQVM4OUIsWUFBVCxFQUF1QjtBQUMxRCwrQkFBTy95QixNQUFNOVMsUUFBTixDQUFlNmxDLGVBQWUzakMsTUFBTWxCLElBQXBDLE1BQThDa0IsTUFBTTVILEtBQTNEO0FBQ0gscUJBRlksQ0FBYjtBQUdIOztBQUVELHVCQUFPcXJDLFVBQVA7QUFDSCxhQVZtQixDQUFwQjs7QUFZQUgsNkJBQWlCQyxnQkFBZ0JSLGdCQUFnQkMsTUFBaEMsR0FBeUMsSUFBMUQ7QUFDSDs7QUFFRCxlQUFPTSxjQUFQO0FBQ0gsS0F4QkQ7O0FBMEJBOzs7Ozs7QUFNQSxRQUFJTSx1QkFBdUIsU0FBdkJBLG9CQUF1QixDQUFTaHpCLEtBQVQsRUFBZ0IweUIsY0FBaEIsRUFBZ0M7QUFDdkQsWUFBSUEsbUJBQW1CUCxnQkFBZ0JFLElBQW5DLElBQTJDSyxtQkFBbUJQLGdCQUFnQkcsS0FBbEYsRUFBeUY7QUFDckZ0eUIsa0JBQU0zUyxXQUFOLENBQWtCLE9BQWxCOztBQUVBLGdCQUFJcWxDLG1CQUFtQkQsa0JBQWtCenlCLEtBQWxCLENBQXZCLEVBQWlEO0FBQzdDQSxzQkFBTStiLGVBQU4sQ0FBc0IsT0FBdEI7QUFDSDtBQUNKLFNBTkQsTUFNTyxJQUFJMlcsbUJBQW1CUCxnQkFBZ0JDLE1BQXZDLEVBQStDO0FBQ2xESSxpQ0FBcUI5OUIsT0FBckIsQ0FBNkIsVUFBU3RGLEtBQVQsRUFBZ0I7QUFDekM0USxzQkFBTTNTLFdBQU4sQ0FBa0IrQixNQUFNbEIsSUFBeEI7O0FBRUEsb0JBQUlrQixNQUFNMGpDLGNBQVYsRUFBMEI7QUFDdEIxakMsMEJBQU0wakMsY0FBTixDQUFxQnArQixPQUFyQixDQUE2QixVQUFTcStCLFlBQVQsRUFBdUI7QUFDaEQveUIsOEJBQU0zUyxXQUFOLENBQWtCMGxDLGVBQWUzakMsTUFBTWxCLElBQXZDO0FBQ0gscUJBRkQ7QUFHSDtBQUNKLGFBUkQ7QUFTSDtBQUNKLEtBbEJEOztBQW9CQTs7Ozs7O0FBTUEsUUFBSStrQyxvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFTanpCLEtBQVQsRUFBZ0IweUIsY0FBaEIsRUFBZ0M7QUFDcERNLDZCQUFxQmh6QixLQUFyQixFQUE0Qnl5QixrQkFBa0J6eUIsS0FBbEIsQ0FBNUI7O0FBRUEsWUFBSTB5QixtQkFBbUJQLGdCQUFnQkUsSUFBbkMsSUFBMkNLLG1CQUFtQlAsZ0JBQWdCRyxLQUFsRixFQUF5RjtBQUNyRnR5QixrQkFBTWt6QixRQUFOLENBQWUsT0FBZixFQUF3QlIsY0FBeEI7QUFDSCxTQUZELE1BRU8sSUFBSUEsbUJBQW1CUCxnQkFBZ0JDLE1BQXZDLEVBQStDO0FBQ2xESSxpQ0FBcUI5OUIsT0FBckIsQ0FBNkIsVUFBU3RGLEtBQVQsRUFBZ0I7QUFDekM0USxzQkFBTWt6QixRQUFOLENBQWU5akMsTUFBTWxCLElBQXJCLEVBQTJCa0IsTUFBTTVILEtBQWpDOztBQUVBLG9CQUFJNEgsTUFBTTBqQyxjQUFWLEVBQTBCO0FBQ3RCMWpDLDBCQUFNMGpDLGNBQU4sQ0FBcUJwK0IsT0FBckIsQ0FBNkIsVUFBU3ErQixZQUFULEVBQXVCO0FBQ2hEL3lCLDhCQUFNa3pCLFFBQU4sQ0FBZUgsZUFBZTNqQyxNQUFNbEIsSUFBcEMsRUFBMENrQixNQUFNNUgsS0FBaEQ7QUFDSCxxQkFGRDtBQUdIO0FBQ0osYUFSRDtBQVNIO0FBQ0osS0FoQkQ7O0FBa0JBOzs7Ozs7O0FBT0FoRSxhQUFTOHRCLE9BQVQsQ0FBaUIzbkIsR0FBakIsQ0FDSSxtQkFESixFQUN5QjtBQUNqQjs7Ozs7OztBQU9Bd3BDLG1CQUFXLG1CQUFTNXZDLE1BQVQsRUFBaUI7QUFDeEIsZ0JBQUlrakMsT0FBTyxJQUFYOztBQUVBOEwseUJBQWE3OUIsT0FBYixDQUFxQixVQUFTbE4sS0FBVCxFQUFnQjtBQUNqQyxvQkFBSWlHLFVBQVVsSyxPQUFPbUssVUFBUCxDQUFrQixZQUFZbEcsS0FBOUIsQ0FBZDs7QUFFQSxvQkFBSWlHLE9BQUosRUFBYTtBQUNUQSw0QkFBUXRILEVBQVIsQ0FBVyxNQUFYLEVBQW1CLFVBQVNFLEtBQVQsRUFBZ0I7QUFDL0IsNEJBQUkwUCxnQkFBZ0J4UyxPQUFPNHJCLGdCQUFQLEVBQXBCOztBQUVBLDRCQUFJcFosaUJBQWlCLHdCQUFjaUssS0FBZCxDQUFvQixFQUFDelosTUFBTSxFQUFDd1AsZUFBZUEsYUFBaEIsRUFBUCxFQUFwQixDQUFyQixFQUFrRjtBQUM5RSxnQ0FBSWlLLFFBQVFqSyxjQUFjakMsT0FBMUI7O0FBRUEsZ0NBQUk0K0IsaUJBQWlCRCxrQkFBa0J6eUIsS0FBbEIsQ0FBckI7O0FBRUEsZ0NBQUkweUIsbUJBQW1CbHJDLEtBQXZCLEVBQThCO0FBQzFCd3JDLHFEQUFxQmh6QixLQUFyQixFQUE0QnhZLEtBQTVCO0FBQ0gsNkJBRkQsTUFFTztBQUNIeXJDLGtEQUFrQmp6QixLQUFsQixFQUF5QnhZLEtBQXpCO0FBQ0g7O0FBRURuQixrQ0FBTTAyQixNQUFOOztBQUVBMEosaUNBQUsyTSxlQUFMLENBQXFCN3ZDLE1BQXJCLEVBQTZCLElBQUlDLFNBQVN5RCxHQUFULENBQWFDLFdBQWpCLENBQTZCOFksS0FBN0IsQ0FBN0I7QUFDSDtBQUNKLHFCQWxCRDs7QUFvQkF2Uyw0QkFBUXRILEVBQVIsQ0FBVyxTQUFYLEVBQXNCLFVBQVNFLEtBQVQsRUFBZ0I7QUFDbEMsNEJBQUkwUCxnQkFBZ0I7QUFDaEJqQyxxQ0FBU3pOLE1BQU1FLElBQU4sQ0FBVzZELElBQVgsQ0FBZ0IvQztBQURULHlCQUFwQjs7QUFJQSw0QkFBSSx3QkFBYzJZLEtBQWQsQ0FBb0IsRUFBQ3paLE1BQU0sRUFBQ3dQLGVBQWVBLGFBQWhCLEVBQVAsRUFBcEIsQ0FBSixFQUFpRTtBQUM3RCxnQ0FBSTI4QixpQkFBaUJELGtCQUFrQjE4QixjQUFjakMsT0FBaEMsQ0FBckI7O0FBRUEsaUNBQUsvQyxRQUFMLENBQWMyaEMsbUJBQW1CbHJDLEtBQW5CLEdBQTJCaEUsU0FBU29LLFdBQXBDLEdBQWtEcEssU0FBUzZ2QyxZQUF6RTs7QUFFQWh0QyxrQ0FBTTAyQixNQUFOO0FBQ0g7QUFDSixxQkFaRDtBQWFIO0FBQ0osYUF0Q0Q7QUF1Q0gsU0FsRGdCOztBQW9EakI7Ozs7Ozs7O0FBUUFxVyx5QkFBaUIseUJBQVM3dkMsTUFBVCxFQUFpQjJELFdBQWpCLEVBQThCO0FBQzNDcXJDLHlCQUFhNzlCLE9BQWIsQ0FBcUIsVUFBU2xOLEtBQVQsRUFBZ0I7QUFDakMsb0JBQUlpRyxVQUFVbEssT0FBT21LLFVBQVAsQ0FBa0IsWUFBWWxHLEtBQTlCLENBQWQ7O0FBRUEsb0JBQUlpRyxPQUFKLEVBQWE7QUFDVEEsNEJBQVE2bEMsT0FBUixDQUFnQi92QyxNQUFoQixFQUF3QjJELFdBQXhCO0FBQ0g7QUFDSixhQU5EO0FBT0g7QUFwRWdCLEtBRHpCO0FBd0VILENBM01BLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O1FBR0lxc0MsUztRQUNBQyxRO1FBQ0ExUCxRO1FBQ0EyUCxVO1FBQ0FDLFk7UUFDQXAyQixLO1FBQ0FxMkIsYztRQUNBQyxXO1FBQ0F6d0IsVztRQUNBMHdCLG1CO1FBQ0FDLFc7UUFDQUMsVTs7Ozs7Ozs7Ozs7Ozs7QUN6QkgsYUFBVztBQUNSOztBQUVBLFFBQUl2d0MsU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLGdCQUFyQixDQUFKLEVBQTRDO0FBQ3hDO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBOzs7Ozs7QUFNQTs7Ozs7Ozs7QUFRQUcsYUFBUzh0QixPQUFULENBQWlCM25CLEdBQWpCLENBQ0ksZ0JBREosRUFDc0I7QUFDZDs7Ozs7OztBQU9BaXZCLGNBQU0sY0FBU3IxQixNQUFULEVBQWlCO0FBQ25CQSxtQkFBT2dCLElBQVAsQ0FBWSxZQUFaLEVBQTBCLFlBQVc7QUFDakMsb0JBQUlFLFdBQVdsQixPQUFPa0IsUUFBUCxFQUFmOztBQUVBQSx5QkFBUzA1QixjQUFULENBQXdCMTVCLFFBQXhCLEVBQWtDLE9BQWxDLEVBQTJDLEtBQUsrN0IsUUFBaEQsRUFBMEQsSUFBMUQsRUFBZ0U7QUFDNURqOUIsNEJBQVFBO0FBRG9ELGlCQUFoRTtBQUdILGFBTnlCLENBTXhCb0IsSUFOd0IsQ0FNbkIsSUFObUIsQ0FBMUI7QUFPSCxTQWhCYTs7QUFrQmQ7Ozs7Ozs7Ozs7O0FBV0E2N0Isa0JBQVUsa0JBQVNuNkIsS0FBVCxFQUFnQjtBQUN0QixnQkFBSUEsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWFpN0IsYUFBakIsRUFBZ0M7QUFDNUIsb0JBQUlDLGFBQWEzNkIsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWFpN0IsYUFBYixDQUEyQnR2QixLQUEzQixDQUFpQyxDQUFqQyxDQUFqQjtBQUNBLG9CQUFJbE8sU0FBUzhDLE1BQU1TLFlBQU4sQ0FBbUJ2RCxNQUFoQzs7QUFFQSxvQkFBSXk5QixXQUFXbHVCLElBQVgsQ0FBZ0JqSSxPQUFoQixDQUF3QixPQUF4QixNQUFxQyxDQUF6QyxFQUE0QztBQUN4Qyx3QkFBSXlWLFNBQVMsSUFBSUMsVUFBSixFQUFiO0FBQ0Esd0JBQUkwZ0IsWUFBWUQsV0FBV0UsU0FBWCxFQUFoQjs7QUFFQTVnQiwyQkFBT0csTUFBUCxHQUFnQixVQUFTcGEsS0FBVCxFQUFnQjtBQUM1Qiw0QkFBSTBJLFNBQVN4TCxPQUFPd0QsSUFBUCxDQUFZLGdCQUFaLEVBQThCO0FBQ3ZDMlosd0NBQVl1Z0I7QUFEMkIseUJBQTlCLENBQWI7O0FBSUEsNEJBQUksQ0FBQyxDQUFDbHlCLE1BQU4sRUFBYztBQUNWLGdDQUFJOEwsS0FBS3JYLFNBQVN5RCxHQUFULENBQWE2TSxPQUFiLENBQXFCZ0gsY0FBckIsQ0FBb0MsZUFBZXpVLE1BQU1vQixNQUFOLENBQWFzSCxNQUE1QixHQUFxQyxJQUF6RSxDQUFUOztBQUVBeEwsbUNBQU93WCxhQUFQLENBQXFCRixFQUFyQjs7QUFFQSxnQ0FBSThGLFlBQVk7QUFDWjlGLG9DQUFJQSxFQURRO0FBRVoyRixzQ0FBTXlnQjtBQUZNLDZCQUFoQjs7QUFLQTE5QixtQ0FBT3dELElBQVAsQ0FBWSxVQUFaLEVBQXdCNFosU0FBeEI7QUFDSDtBQUNKLHFCQWpCZSxDQWlCZGhjLElBakJjLENBaUJULElBakJTLENBQWhCOztBQW1CQTJiLDJCQUFPTSxhQUFQLENBQXFCcWdCLFNBQXJCO0FBQ0g7QUFDSjtBQUNKO0FBNURhLEtBRHRCO0FBZ0VILENBOUZBLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7QUNBQyxhQUFXO0FBQ1I7O0FBRUEsUUFBSXo5QixTQUFTOHRCLE9BQVQsQ0FBaUJqdUIsR0FBakIsQ0FBcUIsZ0JBQXJCLENBQUosRUFBNEM7QUFDeEM7QUFDSDs7QUFFRDs7Ozs7OztBQU9BLFFBQUkyd0MsV0FBV3h3QyxTQUFTVyxHQUFULENBQWE4dkMsYUFBYixHQUE2QixNQUE3QixHQUFzQyxFQUFyRDs7QUFFQSxRQUFJQyxzQkFBc0I7QUFDdEIsV0FBRyxDQUFDLFFBQVFGLFFBQVIsR0FBbUIsTUFBcEIsQ0FEbUI7QUFFdEIsV0FBRyxDQUFDLEVBQUQsRUFBSyxHQUFMLEVBQVVBLFFBQVYsQ0FGbUI7QUFHdEIsV0FBRyxDQUFDLFVBQVVBLFFBQVYsR0FBcUIsUUFBdEI7QUFIbUIsS0FBMUI7O0FBTUE7Ozs7Ozs7QUFPQTs7Ozs7Ozs7QUFRQXh3QyxhQUFTOHRCLE9BQVQsQ0FBaUIzbkIsR0FBakIsQ0FDSSxnQkFESixFQUNzQjs7QUFFZDs7Ozs7OztBQU9BaXZCLGNBQU0sY0FBU3IxQixNQUFULEVBQWlCO0FBQ25CQSxtQkFBTzRDLEVBQVAsQ0FBVSxNQUFWLEVBQWtCLEtBQUtndUMsZUFBdkIsRUFBd0MsSUFBeEM7QUFDQTV3QyxtQkFBTzRDLEVBQVAsQ0FBVSxRQUFWLEVBQW9CLEtBQUtndUMsZUFBekIsRUFBMEMsSUFBMUM7QUFDQTV3QyxtQkFBTzRDLEVBQVAsQ0FBVSxPQUFWLEVBQW1CLEtBQUtpdUMsdUJBQXhCLEVBQWlELElBQWpEO0FBQ0E3d0MsbUJBQU9nQixJQUFQLENBQVksWUFBWixFQUEwQixLQUFLNHZDLGVBQS9CLEVBQWdELElBQWhEO0FBQ0gsU0FkYTs7QUFnQmQ7Ozs7Ozs7O0FBUUFBLHlCQUFpQix5QkFBUzl0QyxLQUFULEVBQWdCO0FBQzdCLGdCQUFJOUMsU0FBUzhDLE1BQU05QyxNQUFuQjs7QUFFQSxnQkFBSTh3QyxlQUFlOXdDLE9BQU9rQixRQUFQLEVBQW5COztBQUVBLGdCQUFJNnZDLFlBQVlELGFBQWF2dUMsQ0FBYixDQUFlKzNCLFNBQWYsQ0FBeUIwVyxJQUF6QixFQUFoQjs7QUFFQSxnQkFBSTlGLFVBQVV5RixvQkFBb0Izd0MsT0FBT1IsTUFBUCxDQUFjZ3NDLFNBQWxDLEVBQTZDOTVCLElBQTdDLENBQWtELFVBQVNuQixPQUFULEVBQWtCO0FBQzlFLHVCQUFPd2dDLGNBQWN4Z0MsT0FBckI7QUFDSCxhQUZhLENBQWQ7O0FBSUEsZ0JBQUkyNkIsT0FBSixFQUFhO0FBQ1Q0Riw2QkFBYTN2QyxRQUFiLENBQXNCbkIsT0FBT1IsTUFBUCxDQUFjZSxnQkFBcEM7QUFDSCxhQUZELE1BRU87QUFDSHV3Qyw2QkFBYTl1QyxXQUFiLENBQXlCaEMsT0FBT1IsTUFBUCxDQUFjZSxnQkFBdkM7QUFDSDtBQUNKLFNBeENhOztBQTBDZDs7Ozs7OztBQU9Bc3dDLGlDQUF5QixpQ0FBUy90QyxLQUFULEVBQWdCO0FBQ3JDLGdCQUFJOUMsU0FBUzhDLE1BQU05QyxNQUFuQjs7QUFFQSxnQkFBSWl4QyxhQUFhLElBQUloeEMsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWpCLENBQXlCdlEsT0FBT3VRLE9BQVAsQ0FBZWhPLENBQXhDLENBQWpCOztBQUVBMHVDLHVCQUFXanZDLFdBQVgsQ0FBdUJoQyxPQUFPUixNQUFQLENBQWNlLGdCQUFyQztBQUNIO0FBdkRhLEtBRHRCO0FBMkRILENBaEdBLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7QUNBQyxhQUFXO0FBQ1I7O0FBRUEsUUFBSU4sU0FBUzh0QixPQUFULENBQWlCanVCLEdBQWpCLENBQXFCLHdCQUFyQixDQUFKLEVBQW9EO0FBQ2hEO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BRyxhQUFTOHRCLE9BQVQsQ0FBaUIzbkIsR0FBakIsQ0FDSSx3QkFESixFQUM4QjtBQUN0QjRyQixrQkFBVSxvQkFEWTs7QUFHdEI7Ozs7Ozs7O0FBUUFxRCxjQUFNLGNBQVNyMUIsTUFBVCxFQUFpQjtBQUNuQixnQkFBSUEsT0FBT1IsTUFBUCxDQUFja0IsbUJBQWxCLEVBQXVDO0FBQ25DVix1QkFBT1IsTUFBUCxDQUFja0IsbUJBQWQsQ0FBa0N5USxPQUFsQyxDQUEwQyxVQUFTKy9CLGtCQUFULEVBQTZCO0FBQ25FLHdCQUFJaG5DLFVBQVUsSUFBSWpLLFNBQVNpSyxPQUFiLENBQXFCbEssTUFBckIsRUFBNkI7QUFDdkMrSyw4QkFBTSxjQUFTL0ssTUFBVCxFQUFpQjtBQUNuQkEsbUNBQU93RCxJQUFQLENBQVksbUJBQVosRUFBaUM7QUFDN0JxVyxpREFBaUJxM0IsbUJBQW1CMXVDLFNBRFA7QUFFN0JpUSw2Q0FBYSxFQUZnQjtBQUc3QkQsK0NBQWV4UyxPQUFPNHJCLGdCQUFQO0FBSGMsNkJBQWpDO0FBS0g7QUFQc0MscUJBQTdCLENBQWQ7O0FBVUEsd0JBQUlsaEIsY0FBYyx1QkFBdUJ3bUMsbUJBQW1CMXVDLFNBQTVEOztBQUVBeEMsMkJBQU9rTCxVQUFQLENBQWtCUixXQUFsQixFQUErQlIsT0FBL0I7QUFDQWxLLDJCQUFPc0wsWUFBUCxDQUFvQjRsQyxtQkFBbUJuckMsSUFBdkMsRUFBNkMyRSxXQUE3QztBQUNILGlCQWZEO0FBZ0JIO0FBQ0o7QUE5QnFCLEtBRDlCO0FBa0NILENBL0NBLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7QUFLQyxhQUFXO0FBQ1I7O0FBRUEsUUFBSXpLLFNBQVM4dEIsT0FBVCxDQUFpQmp1QixHQUFqQixDQUFxQixnQkFBckIsQ0FBSixFQUE0QztBQUN4QztBQUNIOztBQUVELFFBQUlxeEMsU0FBU2x4QyxTQUFTd0wsS0FBVCxDQUFlMmxDLFNBQTVCOztBQUVBLGFBQVNDLFFBQVQsQ0FBa0IvNUIsRUFBbEIsRUFBc0I7QUFDbEIsZUFBT3JYLFNBQVNXLEdBQVQsQ0FBYUMsRUFBYixHQUFrQnlXLEdBQUcvVSxDQUFILENBQUt3bkMsV0FBdkIsR0FBcUN4TixTQUFTamxCLEdBQUdnNkIsZ0JBQUgsQ0FBb0IsT0FBcEIsQ0FBVCxFQUF1QyxFQUF2QyxDQUE1QztBQUNIOztBQUVELGFBQVNDLGNBQVQsQ0FBd0JoaEMsT0FBeEIsRUFBaUNpaEMsSUFBakMsRUFBdUM7QUFDbkMsWUFBSUMsV0FBV2xoQyxRQUFRK2dDLGdCQUFSLENBQXlCLFlBQVlFLElBQVosR0FBbUIsUUFBNUMsQ0FBZjtBQUFBLFlBQ0lFLFlBQVk7QUFDUkMsa0JBQU0sS0FERTtBQUVSQyxvQkFBUSxLQUZBO0FBR1JDLG1CQUFPO0FBSEMsU0FEaEI7O0FBT0EsWUFBSUosU0FBU25xQyxPQUFULENBQWlCLElBQWpCLElBQXlCLENBQTdCLEVBQWdDO0FBQzVCO0FBQ0EsZ0JBQUltcUMsWUFBWUMsU0FBWixJQUF5Qm5oQyxRQUFRK2dDLGdCQUFSLENBQXlCLGNBQXpCLEtBQTRDLE1BQXpFLEVBQWlGO0FBQzdFRywyQkFBV0MsVUFBVUQsUUFBVixDQUFYO0FBQ0gsYUFGRCxNQUVPO0FBQ0hBLDJCQUFXLENBQVg7QUFDSDtBQUNKOztBQUVELGVBQU9sVixTQUFTa1YsUUFBVCxFQUFtQixFQUFuQixDQUFQO0FBQ0g7O0FBRUQ7QUFDQSxhQUFTSyxrQkFBVCxDQUE0QnpwQixLQUE1QixFQUFtQztBQUMvQixZQUFJMHBCLFFBQVExcEIsTUFBTTlsQixDQUFOLENBQVEyakIsSUFBcEI7QUFBQSxZQUNJOHJCLFdBQVcsQ0FEZjtBQUFBLFlBRUlDLFVBRko7QUFBQSxZQUVnQkMsUUFGaEI7QUFBQSxZQUUwQkMsR0FGMUI7O0FBSUEsYUFBSyxJQUFJbHJDLElBQUksQ0FBUixFQUFXK25CLE1BQU0raUIsTUFBTTdxQyxNQUE1QixFQUFvQ0QsSUFBSStuQixHQUF4QyxFQUE2Qy9uQixHQUE3QyxFQUFrRDtBQUM5Q2tyQyxrQkFBTUosTUFBTTlxQyxDQUFOLENBQU47QUFDQWdyQyx5QkFBYUUsSUFBSTliLEtBQUosQ0FBVW52QixNQUF2Qjs7QUFFQSxnQkFBSStxQyxhQUFhRCxRQUFqQixFQUEyQjtBQUN2QkEsMkJBQVdDLFVBQVg7QUFDQUMsMkJBQVdDLEdBQVg7QUFDSDtBQUNKOztBQUVELGVBQU9ELFFBQVA7QUFDSDs7QUFFRCxhQUFTRSx1QkFBVCxDQUFpQy9wQixLQUFqQyxFQUF3QztBQUNwQyxZQUFJZ3FCLFVBQVUsRUFBZDtBQUFBLFlBQ0lDLGNBQWMsQ0FBQyxDQURuQjtBQUFBLFlBRUlDLE1BQU9scUIsTUFBTWlwQixnQkFBTixDQUF1QixXQUF2QixNQUF3QyxLQUZuRDs7QUFJQTtBQUNBLFlBQUlhLE1BQU1MLG1CQUFtQnpwQixLQUFuQixDQUFWOztBQUVBO0FBQ0E7QUFDQSxZQUFJeU4sUUFBUSxJQUFJNzFCLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5QjhYLE1BQU05bEIsQ0FBTixDQUFRaXdDLE9BQVIsQ0FBZ0IsQ0FBaEIsQ0FBekIsQ0FBWjtBQUFBLFlBQ0lDLGdCQUFnQjNjLE1BQU00YyxtQkFBTixFQURwQjs7QUFHQTtBQUNBLGFBQUssSUFBSXpyQyxJQUFJLENBQVIsRUFBVytuQixNQUFNbWpCLElBQUk5YixLQUFKLENBQVVudkIsTUFBaEMsRUFBd0NELElBQUkrbkIsR0FBNUMsRUFBaUQvbkIsR0FBakQsRUFBc0Q7QUFDbEQ7QUFDQTtBQUNBLGdCQUFJMHJDLEtBQUssSUFBSTF5QyxTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBeUI0aEMsSUFBSTliLEtBQUosQ0FBVXB2QixDQUFWLENBQXpCLENBQVQ7QUFBQSxnQkFDSTJyQyxTQUFTVCxJQUFJOWIsS0FBSixDQUFVcHZCLElBQUksQ0FBZCxLQUFvQixJQUFJaEgsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWpCLENBQXlCNGhDLElBQUk5YixLQUFKLENBQVVwdkIsSUFBSSxDQUFkLENBQXpCLENBRGpDOztBQUdBcXJDLDJCQUFlSyxHQUFHcHdDLENBQUgsQ0FBS3N3QyxPQUFMLElBQWdCLENBQS9COztBQUVBO0FBQ0EsZ0JBQUlDLFVBQUosRUFBZ0JDLFdBQWhCLEVBQTZCQyxXQUE3Qjs7QUFFQSxnQkFBSS9nQyxJQUFJMGdDLEdBQUdELG1CQUFILEdBQXlCemdDLENBQWpDOztBQUVBO0FBQ0FzZ0Msa0JBQU1RLGNBQWM5Z0MsSUFBSXMvQixlQUFlb0IsRUFBZixFQUFtQixNQUFuQixDQUF4QixHQUFxREcsYUFBYTdnQyxJQUFJMGdDLEdBQUdwd0MsQ0FBSCxDQUFLcVIsV0FBVCxHQUF1QjI5QixlQUFlb0IsRUFBZixFQUFtQixPQUFuQixDQUF6Rjs7QUFFQTtBQUNBLGdCQUFJQyxNQUFKLEVBQVk7QUFDUjNnQyxvQkFBSTJnQyxPQUFPRixtQkFBUCxHQUE2QnpnQyxDQUFqQzs7QUFFQXNnQyxzQkFBTU8sYUFBYTdnQyxJQUFJMmdDLE9BQU9yd0MsQ0FBUCxDQUFTcVIsV0FBYixHQUEyQjI5QixlQUFlcUIsTUFBZixFQUF1QixPQUF2QixDQUE5QyxHQUFnRkcsY0FBYzlnQyxJQUFJcy9CLGVBQWVxQixNQUFmLEVBQXVCLE1BQXZCLENBQWxHO0FBQ0g7QUFDRDtBQUxBLGlCQU1LO0FBQ0QzZ0Msd0JBQUlvVyxNQUFNcXFCLG1CQUFOLEdBQTRCemdDLENBQWhDOztBQUVBc2dDLDBCQUFNTyxhQUFhN2dDLENBQW5CLEdBQXVCOGdDLGNBQWM5Z0MsSUFBSW9XLE1BQU05bEIsQ0FBTixDQUFRcVIsV0FBakQ7QUFDSDs7QUFFRG8vQiwwQkFBY3BvQyxLQUFLK0YsR0FBTCxDQUFTb2lDLGNBQWNELFVBQXZCLEVBQW1DLENBQW5DLENBQWQ7O0FBRUE7QUFDQTtBQUNBVCxvQkFBUS9vQyxJQUFSLENBQWE7QUFDVCtlLHVCQUFPQSxLQURFO0FBRVQxVyx1QkFBTzJnQyxXQUZFO0FBR1RyZ0MsbUJBQUc2Z0MsVUFITTtBQUlUM2dDLG1CQUFHc2dDLGNBQWN0Z0MsQ0FKUjtBQUtURSx1QkFBTzJnQyxXQUxFO0FBTVRoK0Isd0JBQVE4Z0IsTUFBTXZ6QixDQUFOLENBQVFrUixZQU5QO0FBT1Q4K0IscUJBQUtBO0FBUEksYUFBYjtBQVNIOztBQUVELGVBQU9GLE9BQVA7QUFDSDs7QUFFRCxhQUFTWSxtQkFBVCxDQUE2QlosT0FBN0IsRUFBc0NhLFNBQXRDLEVBQWlEO0FBQzdDLGFBQUssSUFBSWpzQyxJQUFJLENBQVIsRUFBVytuQixNQUFNcWpCLFFBQVFuckMsTUFBOUIsRUFBc0NELElBQUkrbkIsR0FBMUMsRUFBK0MvbkIsR0FBL0MsRUFBb0Q7QUFDaEQsZ0JBQUlrc0MsU0FBU2QsUUFBUXByQyxDQUFSLENBQWI7O0FBRUEsZ0JBQUlpc0MsYUFBYUMsT0FBT2xoQyxDQUFwQixJQUF5QmloQyxhQUFjQyxPQUFPbGhDLENBQVAsR0FBV2toQyxPQUFPOWdDLEtBQTdELEVBQXFFO0FBQ2pFLHVCQUFPOGdDLE1BQVA7QUFDSDtBQUNKOztBQUVELGVBQU8sSUFBUDtBQUNIOztBQUVELGFBQVMzWixNQUFULENBQWdCOEksR0FBaEIsRUFBcUI7QUFDakIsU0FBQ0EsSUFBSXQvQixJQUFKLElBQVlzL0IsR0FBYixFQUFrQmgvQixjQUFsQjtBQUNIOztBQUVELGFBQVM4dkMsYUFBVCxDQUF1QnB6QyxNQUF2QixFQUErQjtBQUMzQixZQUFJbXpDLE1BQUosRUFBWTd3QyxRQUFaLEVBQXNCbWdDLE9BQXRCLEVBQStCNFEsVUFBL0IsRUFBMkNwZ0IsV0FBM0MsRUFBd0RxZ0IsWUFBeEQ7O0FBRUEsWUFBSUMsYUFBSixFQUFtQkMsY0FBbkIsRUFBbUNDLGlCQUFuQyxFQUFzREMsa0JBQXREOztBQUVBLGlCQUFTam9CLE1BQVQsR0FBa0I7QUFDZDBuQixxQkFBUyxJQUFUO0FBQ0FHLDJCQUFlLENBQWY7QUFDQUQseUJBQWEsQ0FBYjs7QUFFQS93QyxxQkFBU3U0QixjQUFULENBQXdCLFNBQXhCLEVBQW1DaVMsU0FBbkM7QUFDQXJLLG9CQUFRNUgsY0FBUixDQUF1QixXQUF2QixFQUFvQzhZLFdBQXBDO0FBQ0FsUixvQkFBUTVILGNBQVIsQ0FBdUIsV0FBdkIsRUFBb0NnUyxXQUFwQzs7QUFFQXZxQyxxQkFBU2kzQixPQUFULEdBQW1Cb1csUUFBbkIsQ0FBNEIsUUFBNUIsRUFBc0MsTUFBdEM7QUFDSDs7QUFFRCxpQkFBU2lFLFdBQVQsR0FBdUI7QUFDbkI7QUFDQTs7QUFFQSxnQkFBSUMsY0FBY1YsT0FBT3hoQyxLQUF6QjtBQUFBLGdCQUNJakYsTUFBTXpNLFNBQVN3TCxLQUFULENBQWVxb0MsYUFBZixDQUE2QlgsT0FBTzlxQixLQUFwQyxDQURWO0FBQUEsZ0JBRUkwckIsa0JBQWtCLEVBRnRCO0FBQUEsZ0JBR0lDLG1CQUFtQixFQUh2QjtBQUFBLGdCQUlJQyxjQUFjQyxPQUFPQyxTQUp6QjtBQUFBLGdCQUtJQyxlQUFlSCxXQUxuQjtBQUFBLGdCQU1JMUIsTUFBTVksT0FBT1osR0FOakI7O0FBUUEsaUJBQUssSUFBSXRyQyxJQUFJLENBQVIsRUFBVytuQixNQUFNdGlCLElBQUl4RixNQUExQixFQUFrQ0QsSUFBSStuQixHQUF0QyxFQUEyQy9uQixHQUEzQyxFQUFnRDtBQUM1QyxvQkFBSStnQixNQUFNdGIsSUFBSXpGLENBQUosQ0FBVjtBQUFBLG9CQUNJb3RDLFdBQVdyc0IsSUFBSTZyQixlQUFldEIsTUFBTSxDQUFOLEdBQVUsQ0FBekIsQ0FBSixDQURmO0FBQUEsb0JBRUkrQixZQUFZdHNCLElBQUk2ckIsZUFBZXRCLE1BQU0sQ0FBTixHQUFVLENBQXpCLENBQUosQ0FGaEI7O0FBSUE4QiwyQkFBV0EsWUFBWSxJQUFJcDBDLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5QjhqQyxRQUF6QixDQUF2QjtBQUNBQyw0QkFBWUEsYUFBYSxJQUFJcjBDLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUF5QitqQyxTQUF6QixDQUF6Qjs7QUFFQSxvQkFBSSxDQUFDRCxRQUFELElBQWEsQ0FBQ0MsU0FBZCxJQUEyQixDQUFDRCxTQUFTeGtCLE1BQVQsQ0FBZ0J5a0IsU0FBaEIsQ0FBaEMsRUFBNEQ7QUFDeERELGlDQUFhSixjQUFjcnBDLEtBQUtnRyxHQUFMLENBQVNxakMsV0FBVCxFQUFzQjVDLFNBQVNnRCxRQUFULENBQXRCLENBQTNCO0FBQ0FDLGtDQUFjRixlQUFleHBDLEtBQUtnRyxHQUFMLENBQVN3akMsWUFBVCxFQUF1Qi9DLFNBQVNpRCxTQUFULENBQXZCLENBQTdCOztBQUVBUCxvQ0FBZ0J6cUMsSUFBaEIsQ0FBcUIrcUMsUUFBckI7QUFDQUwscUNBQWlCMXFDLElBQWpCLENBQXNCZ3JDLFNBQXRCO0FBQ0g7QUFDSjs7QUFFRDtBQUNBZiw0QkFBZ0JRLGVBQWhCO0FBQ0FQLDZCQUFpQlEsZ0JBQWpCOztBQUVBO0FBQ0FQLGdDQUFvQk4sT0FBT2xoQyxDQUFQLEdBQVdnaUMsV0FBL0I7QUFDQVAsaUNBQXFCUCxPQUFPbGhDLENBQVAsR0FBV21pQyxZQUFoQzs7QUFFQTNSLG9CQUFROFIsVUFBUixDQUFtQixHQUFuQjtBQUNBdGhCLDBCQUFjc0osU0FBU2tHLFFBQVE5NEIsUUFBUixDQUFpQixNQUFqQixDQUFULEVBQW1DLEVBQW5DLENBQWQ7QUFDQTJwQywyQkFBZSxDQUFmO0FBQ0FELHlCQUFhLENBQWI7O0FBRUE1USxvQkFBUTcvQixFQUFSLENBQVcsV0FBWCxFQUF3QmlxQyxXQUF4Qjs7QUFFQTtBQUNBdnFDLHFCQUFTTSxFQUFULENBQVksV0FBWixFQUF5QjQyQixNQUF6QjtBQUNIOztBQUVELGlCQUFTZ2IsU0FBVCxHQUFxQjtBQUNqQm5CLHlCQUFhLENBQWI7O0FBRUE1USxvQkFBUThSLFVBQVIsQ0FBbUIsQ0FBbkI7O0FBRUFqQiw0QkFBZ0JtQixjQUFoQjs7QUFFQSxnQkFBSXBzQixRQUFROHFCLE9BQU85cUIsS0FBbkI7QUFDQTFnQix1QkFBVyxZQUFXO0FBQ2xCMGdCLHNCQUFNcXNCLGdCQUFOLENBQXVCLG9CQUF2QjtBQUNILGFBRkQsRUFFRyxDQUZIOztBQUlBcHlDLHFCQUFTdTRCLGNBQVQsQ0FBd0IsV0FBeEIsRUFBcUNyQixNQUFyQztBQUNIOztBQUVELGlCQUFTaWIsWUFBVCxHQUF3QjtBQUNwQixnQkFBSWxDLE1BQU1ZLE9BQU9aLEdBQWpCO0FBQUEsZ0JBQ0lOLGFBQWFNLE1BQU1pQixlQUFldHNDLE1BQXJCLEdBQThCcXNDLGNBQWNyc0MsTUFEN0Q7O0FBR0E7QUFDQSxpQkFBSyxJQUFJRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlnckMsVUFBcEIsRUFBZ0NockMsR0FBaEMsRUFBcUM7QUFDakMsb0JBQUlvdEMsV0FBV2QsY0FBY3RzQyxDQUFkLENBQWY7QUFBQSxvQkFDSXF0QyxZQUFZZCxlQUFldnNDLENBQWYsQ0FEaEI7QUFBQSxvQkFFSW9oQixRQUFROHFCLE9BQU85cUIsS0FGbkI7O0FBSUE7QUFDQXBvQix5QkFBU3dMLEtBQVQsQ0FBZTlELFVBQWYsQ0FBMEIsVUFBUzBzQyxRQUFULEVBQW1CTSxZQUFuQixFQUFpQ0wsU0FBakMsRUFBNENNLGFBQTVDLEVBQTJEQyxVQUEzRCxFQUF1RUMsU0FBdkUsRUFBa0Y7QUFDeEc7QUFDQVQsZ0NBQVlBLFNBQVMxRSxRQUFULENBQWtCLE9BQWxCLEVBQTJCd0IsT0FBT3ZtQyxLQUFLK0YsR0FBTCxDQUFTZ2tDLGVBQWVHLFNBQXhCLEVBQW1DLENBQW5DLENBQVAsQ0FBM0IsQ0FBWjtBQUNBUixpQ0FBYUEsVUFBVTNFLFFBQVYsQ0FBbUIsT0FBbkIsRUFBNEJ3QixPQUFPdm1DLEtBQUsrRixHQUFMLENBQVNpa0MsZ0JBQWdCRSxTQUF6QixFQUFvQyxDQUFwQyxDQUFQLENBQTVCLENBQWI7O0FBRUE7QUFDQSx3QkFBSUQsVUFBSixFQUFnQjtBQUNaeHNCLDhCQUFNc25CLFFBQU4sQ0FBZSxPQUFmLEVBQXdCd0IsT0FBTzBELGFBQWFDLGFBQWF2QyxNQUFNLENBQUMsQ0FBUCxHQUFXLENBQXhCLENBQXBCLENBQXhCO0FBQ0g7QUFDSixpQkFURCxFQVNHLENBVEgsRUFTTSxJQVROLEVBU1ksQ0FDUjhCLFFBRFEsRUFDRUEsWUFBWWhELFNBQVNnRCxRQUFULENBRGQsRUFFUkMsU0FGUSxFQUVHQSxhQUFhakQsU0FBU2lELFNBQVQsQ0FGaEIsRUFFcUMsQ0FBQyxDQUFDRCxRQUFELElBQWEsQ0FBQ0MsU0FBZixLQUE4QmpELFNBQVNocEIsS0FBVCxJQUFrQmtwQixlQUFlbHBCLEtBQWYsRUFBc0IsTUFBdEIsQ0FBbEIsR0FBa0RrcEIsZUFBZWxwQixLQUFmLEVBQXNCLE9BQXRCLENBRnJILEVBR1JpckIsWUFIUSxDQVRaO0FBY0g7QUFDSjs7QUFFRCxpQkFBU0ssV0FBVCxDQUFxQnJSLEdBQXJCLEVBQTBCO0FBQ3RCOUksbUJBQU84SSxHQUFQOztBQUVBc1I7O0FBRUF0eEMscUJBQVNNLEVBQVQsQ0FBWSxTQUFaLEVBQXVCa3FDLFNBQXZCLEVBQWtDLElBQWxDO0FBQ0g7O0FBRUQsaUJBQVNBLFNBQVQsQ0FBbUJ4SyxHQUFuQixFQUF3QjtBQUNwQkEsZ0JBQUl6SCxjQUFKOztBQUVBMlo7QUFDSDs7QUFFRCxpQkFBUzNILFdBQVQsQ0FBcUJ2SyxHQUFyQixFQUEwQjtBQUN0QnlTLGlCQUFLelMsSUFBSXQvQixJQUFKLENBQVNneUMsYUFBVCxHQUF5Qi9pQyxDQUE5QjtBQUNIOztBQUVEM1AsbUJBQVd0QyxPQUFPc0MsUUFBbEI7O0FBRUFtZ0Msa0JBQVV4aUMsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWIsQ0FBcUJnSCxjQUFyQixDQUFvQyxnRUFDMUMsK0VBRDBDLEdBRTFDLDBGQUZNLEVBRXNGalYsUUFGdEYsQ0FBVjs7QUFJQTtBQUNBdEMsZUFBTzRDLEVBQVAsQ0FBVSxTQUFWLEVBQXFCLFlBQVc7QUFDNUI2L0Isb0JBQVFubkIsTUFBUjtBQUNILFNBRkQ7O0FBSUE7QUFDQTtBQUNBaFosaUJBQVMyeUMsa0JBQVQsR0FBOEJsZixNQUE5QixDQUFxQzBNLE9BQXJDOztBQUVBLGFBQUt5UyxRQUFMLEdBQWdCLFVBQVNDLFlBQVQsRUFBdUI7QUFDbkM7QUFDQSxnQkFBSTlCLFVBQUosRUFBZ0I7QUFDWjtBQUNIOztBQUVERixxQkFBU2dDLFlBQVQ7O0FBRUExUyxvQkFBUXR1QixTQUFSLENBQWtCO0FBQ2Q5Qix1QkFBTzgrQixPQUFPZ0UsYUFBYTlpQyxLQUFwQixDQURPO0FBRWQyQyx3QkFBUW04QixPQUFPZ0UsYUFBYW5nQyxNQUFwQixDQUZNO0FBR2Q5QyxzQkFBTWkvQixPQUFPZ0UsYUFBYWxqQyxDQUFwQixDQUhRO0FBSWRHLHFCQUFLKytCLE9BQU9nRSxhQUFhaGpDLENBQXBCO0FBSlMsYUFBbEI7O0FBT0Fzd0Isb0JBQVE3L0IsRUFBUixDQUFXLFdBQVgsRUFBd0Ird0MsV0FBeEIsRUFBcUMsSUFBckM7O0FBRUFyeEMscUJBQVNpM0IsT0FBVCxHQUFtQm9XLFFBQW5CLENBQTRCLFFBQTVCLEVBQXNDLFlBQXRDOztBQUVBO0FBQ0E7QUFDQWxOLG9CQUFROVYsSUFBUjtBQUNILFNBdEJEOztBQXdCQSxZQUFJb29CLE9BQU8sS0FBS0EsSUFBTCxHQUFZLFVBQVNLLElBQVQsRUFBZTtBQUNsQyxnQkFBSSxDQUFDakMsTUFBTCxFQUFZO0FBQ1IsdUJBQU8sQ0FBUDtBQUNIOztBQUVELGdCQUFJLENBQUNFLFVBQUQsS0FBZ0IrQixPQUFPakMsT0FBT2xoQyxDQUFkLElBQW1CbWpDLE9BQVFqQyxPQUFPbGhDLENBQVAsR0FBV2toQyxPQUFPOWdDLEtBQTdELENBQUosRUFBMEU7QUFDdEVvWjtBQUNBLHVCQUFPLENBQVA7QUFDSDs7QUFFRCxnQkFBSTRwQixxQkFBcUJELE9BQU94cUMsS0FBSzQyQixLQUFMLENBQVdpQixRQUFRbGdDLENBQVIsQ0FBVXFSLFdBQVYsR0FBd0IsQ0FBbkMsQ0FBaEM7O0FBRUEsZ0JBQUl5L0IsVUFBSixFQUFnQjtBQUNaLG9CQUFJZ0MsdUJBQXVCNUIsaUJBQXZCLElBQTRDNEIsdUJBQXVCM0Isa0JBQXZFLEVBQTJGO0FBQ3ZGLDJCQUFPLENBQVA7QUFDSDs7QUFFRDJCLHFDQUFxQnpxQyxLQUFLK0YsR0FBTCxDQUFTMGtDLGtCQUFULEVBQTZCNUIsaUJBQTdCLENBQXJCO0FBQ0E0QixxQ0FBcUJ6cUMsS0FBS2dHLEdBQUwsQ0FBU3lrQyxrQkFBVCxFQUE2QjNCLGtCQUE3QixDQUFyQjs7QUFFQUosK0JBQWUrQixxQkFBcUJwaUIsV0FBcEM7QUFDSDs7QUFFRHdQLG9CQUFRa04sUUFBUixDQUFpQixNQUFqQixFQUF5QndCLE9BQU9rRSxrQkFBUCxDQUF6Qjs7QUFFQSxtQkFBTyxDQUFQO0FBQ0gsU0ExQkQ7QUEyQkg7O0FBRUQsYUFBU0MsaUJBQVQsQ0FBMkJoVCxHQUEzQixFQUFnQztBQUM1QixZQUFJcCtCLFNBQVNvK0IsSUFBSXQvQixJQUFKLENBQVNZLFNBQVQsRUFBYjs7QUFFQSxZQUFJMCtCLElBQUkzM0IsSUFBSixLQUFhLFVBQWpCLEVBQTZCO0FBQ3pCO0FBQ0EsZ0JBQUksQ0FBQ3pHLE9BQU8yc0IsRUFBUCxDQUFVLE9BQVYsQ0FBTCxFQUF5QjtBQUNyQjtBQUNIOztBQUVELGdCQUFJMGtCLE9BQU8sSUFBSXQxQyxTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBeUIreEIsSUFBSXQvQixJQUFKLENBQVNULENBQVQsQ0FBV200QixhQUFYLElBQTRCNEgsSUFBSXQvQixJQUFKLENBQVNULENBQVQsQ0FBV2l6QyxTQUFoRSxDQUFYO0FBQ0EsbUJBQU9ELFFBQVFBLEtBQUtoekMsQ0FBYixJQUFrQixDQUFDZ3pDLEtBQUsxbEIsTUFBTCxDQUFZM3JCLE1BQVosQ0FBbkIsSUFBMEMsQ0FBQ3F4QyxLQUFLMWtCLEVBQUwsQ0FBUSxNQUFSLENBQWxELEVBQW1FO0FBQy9EMGtCLHVCQUFPQSxLQUFLMWUsU0FBTCxFQUFQO0FBQ0g7QUFDRCxnQkFBSSxDQUFDMGUsSUFBRCxJQUFTQSxLQUFLMWxCLE1BQUwsQ0FBWTNyQixNQUFaLENBQWIsRUFBa0M7QUFDOUI7QUFDSDtBQUNKOztBQUVEQSxlQUFPbVgsWUFBUCxDQUFvQixPQUFwQixFQUE2QixDQUE3QixFQUFnQ3E1QixnQkFBaEMsQ0FBaUQsb0JBQWpEO0FBQ0FwUyxZQUFJekgsY0FBSjtBQUNIOztBQUVENTZCLGFBQVM4dEIsT0FBVCxDQUFpQjNuQixHQUFqQixDQUFxQixnQkFBckIsRUFBdUM7QUFDbkM0ckIsa0JBQVUsZUFEeUI7O0FBR25DcUQsY0FBTSxjQUFTcjFCLE1BQVQsRUFBaUI7QUFDbkJBLG1CQUFPNEMsRUFBUCxDQUFVLFlBQVYsRUFBd0IsWUFBVztBQUMvQixvQkFBSTYvQixPQUFKO0FBQUEsb0JBQ0l2aEMsV0FBV2xCLE9BQU9rQixRQUFQLEVBRGY7O0FBR0E7QUFDQTtBQUNBQSx5QkFBUzA1QixjQUFULENBQXdCMTVCLFNBQVN1MEMsUUFBVCxLQUFzQnYwQyxRQUF0QixHQUFpQ2xCLE9BQU9zQyxRQUFoRSxFQUEwRSxXQUExRSxFQUF1RixVQUFTZ2dDLEdBQVQsRUFBYztBQUNqR0EsMEJBQU1BLElBQUl0L0IsSUFBVjs7QUFFQSx3QkFBSWtCLFNBQVNvK0IsSUFBSTErQixTQUFKLEVBQWI7O0FBRUE7QUFDQTtBQUNBLHdCQUFJTSxPQUFPcUwsSUFBUCxLQUFnQnRQLFNBQVN3MkIsWUFBN0IsRUFBMkM7QUFDdkM7QUFDSDs7QUFFRCx3QkFBSTlqQixRQUFRMnZCLElBQUkwUyxhQUFKLEdBQW9CL2lDLENBQWhDOztBQUVBO0FBQ0E7QUFDQSx3QkFBSXd3QixXQUFXQSxRQUFRc1MsSUFBUixDQUFhcGlDLEtBQWIsQ0FBZixFQUFvQztBQUNoQzZtQiwrQkFBTzhJLEdBQVA7QUFDQTtBQUNIOztBQUVEO0FBQ0Esd0JBQUlqYSxLQUFKLEVBQVdncUIsT0FBWDs7QUFFQSx3QkFBSSxDQUFDbnVDLE9BQU8yc0IsRUFBUCxDQUFVLE9BQVYsQ0FBRCxJQUF1QixDQUFDM3NCLE9BQU9tWCxZQUFQLENBQW9CLE9BQXBCLEVBQTZCLENBQTdCLENBQTVCLEVBQTZEO0FBQ3pEO0FBQ0g7O0FBRURnTiw0QkFBUW5rQixPQUFPbVgsWUFBUCxDQUFvQixPQUFwQixFQUE2QixDQUE3QixDQUFSOztBQUVBO0FBQ0E7QUFDQSx3QkFBSSxDQUFDcmIsT0FBT2tCLFFBQVAsR0FBa0I4cUIsUUFBbEIsQ0FBMkIzRCxLQUEzQixDQUFMLEVBQXdDO0FBQ3BDO0FBQ0g7O0FBRUQsd0JBQUksRUFBRWdxQixVQUFVaHFCLE1BQU1xdEIsYUFBTixDQUFvQixvQkFBcEIsQ0FBWixDQUFKLEVBQTREO0FBQ3hEO0FBQ0FydEIsOEJBQU1zdEIsYUFBTixDQUFvQixvQkFBcEIsRUFBMkN0RCxVQUFVRCx3QkFBd0IvcEIsS0FBeEIsQ0FBckQ7QUFDQUEsOEJBQU16bEIsRUFBTixDQUFTLFVBQVQsRUFBcUIweUMsaUJBQXJCO0FBQ0FqdEIsOEJBQU16bEIsRUFBTixDQUFTLFdBQVQsRUFBc0IweUMsaUJBQXRCO0FBQ0g7O0FBRUQsd0JBQUluQyxTQUFTRixvQkFBb0JaLE9BQXBCLEVBQTZCMS9CLEtBQTdCLENBQWI7QUFDQSx3QkFBSXdnQyxNQUFKLEVBQVk7QUFDUix5QkFBQzFRLE9BQUQsS0FBYUEsVUFBVSxJQUFJMlEsYUFBSixDQUFrQnB6QyxNQUFsQixDQUF2QjtBQUNBeWlDLGdDQUFReVMsUUFBUixDQUFpQi9CLE1BQWpCO0FBQ0g7QUFDSixpQkEvQ0Q7QUFnREgsYUF0REQ7QUF1REg7QUEzRGtDLEtBQXZDO0FBOERILENBdlpBLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7QUNMQTs7Ozs7QUFLQSxDQUFFLFlBQVc7QUFDWjs7QUFFRyxLQUFJbHpDLFNBQVM4dEIsT0FBVCxDQUFpQmp1QixHQUFqQixDQUFxQixlQUFyQixDQUFKLEVBQTBDO0FBQzVDO0FBQ0c7O0FBRUosS0FBSTgxQyxnQkFBZ0IsYUFBcEI7O0FBRUEsVUFBU0MsZ0JBQVQsQ0FBMkJyekMsU0FBM0IsRUFBdUM7QUFDdEMsTUFBSTR4QixTQUFTNXhCLFVBQVVpdEIsU0FBVixFQUFiO0FBQ0EsTUFBSXFtQixTQUFTLEVBQWI7QUFDQSxNQUFJQyxXQUFXLEVBQWY7O0FBRUEsV0FBU0Msa0JBQVQsQ0FBNkJuMkMsSUFBN0IsRUFBb0M7QUFDbkM7QUFDQSxPQUFLaTJDLE9BQU81dUMsTUFBUCxHQUFnQixDQUFyQixFQUNDOztBQUVEO0FBQ0E7QUFDQSxPQUFLckgsS0FBSzBQLElBQUwsSUFBYXRQLFNBQVN3MkIsWUFBdEIsSUFBc0NtZixjQUFjL3NDLElBQWQsQ0FBb0JoSixLQUFLODRCLE9BQUwsRUFBcEIsQ0FBdEMsSUFBOEUsQ0FBQzk0QixLQUFLNjFDLGFBQUwsQ0FBb0IsZUFBcEIsQ0FBcEYsRUFBNEg7QUFDM0h6MUMsYUFBU3lELEdBQVQsQ0FBYTZNLE9BQWIsQ0FBcUIwbEMsU0FBckIsQ0FBZ0NGLFFBQWhDLEVBQTBDbDJDLElBQTFDLEVBQWdELGVBQWhELEVBQWlFLElBQWpFO0FBQ0FpMkMsV0FBT3hzQyxJQUFQLENBQWF6SixJQUFiO0FBQ0E7QUFDRDs7QUFFRCxPQUFNLElBQUlvSCxJQUFJLENBQWQsRUFBaUJBLElBQUltdEIsT0FBT2x0QixNQUE1QixFQUFvQ0QsR0FBcEMsRUFBMEM7QUFDekMsT0FBSXVvQixRQUFRNEUsT0FBUW50QixDQUFSLENBQVo7O0FBRUEsT0FBS3VvQixNQUFNYyxTQUFYLEVBQXVCO0FBQ3RCO0FBQ0EsUUFBSXNELFlBQVlwRSxNQUFNTSxpQkFBTixFQUFoQjtBQUNBLFFBQUlvbUIsY0FBY3RpQixVQUFVdlksWUFBVixDQUF3QixJQUF4QixFQUE4QixJQUE5QixLQUF3Q3VZLFVBQVV2WSxZQUFWLENBQXdCLElBQXhCLEVBQThCLElBQTlCLENBQTFEO0FBQ0EsUUFBSzY2QixXQUFMLEVBQ0NKLE9BQU94c0MsSUFBUCxDQUFhNHNDLFdBQWI7QUFDRCxJQU5ELE1BTU87QUFDTixRQUFJQyxTQUFTLElBQUlsMkMsU0FBU3lELEdBQVQsQ0FBYXl5QyxNQUFqQixDQUF5QjNtQixLQUF6QixDQUFiO0FBQ0EsUUFBSTN2QixJQUFKO0FBQ0FzMkMsV0FBT0MsS0FBUCxHQUFlSixrQkFBZjs7QUFFQSxXQUFVbjJDLE9BQU9zMkMsT0FBTy9sQyxJQUFQLEVBQWpCLEVBQW1DO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFLdlEsS0FBSzBQLElBQUwsSUFBYXRQLFNBQVN3MkIsWUFBdEIsSUFBc0MsQ0FBQzUyQixLQUFLZ3hCLEVBQUwsQ0FBUzV3QixTQUFTbzJDLEdBQVQsQ0FBYWh1QixLQUF0QixDQUE1QyxFQUE0RTtBQUMzRSxVQUFJOE8sU0FBU3QzQixLQUFLd2IsWUFBTCxDQUFtQixJQUFuQixFQUF5QixJQUF6QixLQUFtQ3hiLEtBQUt3YixZQUFMLENBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQWhEO0FBQ0EsVUFBSzhiLFVBQVUsQ0FBQ0EsT0FBT3VlLGFBQVAsQ0FBc0IsZUFBdEIsQ0FBaEIsRUFBMEQ7QUFDekR6MUMsZ0JBQVN5RCxHQUFULENBQWE2TSxPQUFiLENBQXFCMGxDLFNBQXJCLENBQWdDRixRQUFoQyxFQUEwQzVlLE1BQTFDLEVBQWtELGVBQWxELEVBQW1FLElBQW5FO0FBQ0EyZSxjQUFPeHNDLElBQVAsQ0FBYTZ0QixNQUFiO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDs7QUFFRGwzQixXQUFTeUQsR0FBVCxDQUFhNk0sT0FBYixDQUFxQitsQyxlQUFyQixDQUFzQ1AsUUFBdEM7O0FBRUEsU0FBT0QsTUFBUDtBQUNBOztBQUVELFVBQVNTLDRCQUFULENBQXVDQyxhQUF2QyxFQUF1RDtBQUN0RCxNQUFJdnZDLElBQUksQ0FBUjtBQUFBLE1BQ0N3dkMsT0FBT0QsY0FBY3R2QyxNQUFkLEdBQXVCLENBRC9CO0FBQUEsTUFFQzZ1QyxXQUFXLEVBRlo7QUFBQSxNQUdDL3dCLElBSEQ7QUFBQSxNQUdPMHhCLFdBSFA7QUFBQSxNQUdvQjdVLEVBSHBCOztBQUtBLFNBQVU3YyxPQUFPd3hCLGNBQWV2dkMsR0FBZixDQUFqQjtBQUNDaEgsWUFBU3lELEdBQVQsQ0FBYTZNLE9BQWIsQ0FBcUIwbEMsU0FBckIsQ0FBZ0NGLFFBQWhDLEVBQTBDL3dCLElBQTFDLEVBQWdELGFBQWhELEVBQStELElBQS9EO0FBREQsR0FOc0QsQ0FTdEQ7QUFDQS9kLE1BQUksQ0FBSjtBQUNBLFNBQVUrZCxPQUFPd3hCLGNBQWV2dkMsR0FBZixDQUFqQixFQUEwQztBQUN6QyxPQUFLLENBQUV5dkMsY0FBYzF4QixLQUFLMFosV0FBTCxFQUFoQixLQUF3QyxDQUFDZ1ksWUFBWWhCLGFBQVosQ0FBMkIsYUFBM0IsQ0FBekMsSUFBdUYsQ0FBRWdCLGNBQWMxeEIsS0FBSzZhLE9BQUwsRUFBaEIsS0FBb0MsQ0FBQzZXLFlBQVloQixhQUFaLENBQTJCLGFBQTNCLENBQWpJLEVBQThLO0FBQzdLejFDLGFBQVN5RCxHQUFULENBQWE2TSxPQUFiLENBQXFCK2xDLGVBQXJCLENBQXNDUCxRQUF0QztBQUNBLFdBQU9XLFdBQVA7QUFDQTtBQUNEOztBQUVEejJDLFdBQVN5RCxHQUFULENBQWE2TSxPQUFiLENBQXFCK2xDLGVBQXJCLENBQXNDUCxRQUF0Qzs7QUFFQTtBQUNBbFUsT0FBSzJVLGNBQWUsQ0FBZixFQUFtQjNmLFNBQW5CLEVBQUw7QUFDQSxNQUFPZ0wsS0FBS0EsR0FBR25ELFdBQUgsRUFBWixFQUNDLE9BQU9tRCxHQUFHakQsT0FBSCxFQUFQOztBQUVEO0FBQ0FpRCxPQUFLMlUsY0FBZUMsSUFBZixFQUFzQjVmLFNBQXRCLEVBQUw7QUFDQSxNQUFPZ0wsS0FBS0EsR0FBR2hDLE9BQUgsRUFBWixFQUNDLE9BQU9nQyxHQUFHNUosUUFBSCxDQUFhLENBQWIsQ0FBUDs7QUFFRCxTQUFPLElBQVA7QUFDQTs7QUFFRCxVQUFTMGUsU0FBVCxDQUFvQm4wQyxTQUFwQixFQUErQmkyQixZQUEvQixFQUE4QztBQUM3QyxNQUFJcEMsUUFBUXdmLGlCQUFrQnJ6QyxTQUFsQixDQUFaO0FBQUEsTUFDQzR6QixZQUFZQyxNQUFPLENBQVAsQ0FEYjtBQUFBLE1BRUNoTyxRQUFRK04sVUFBVS9hLFlBQVYsQ0FBd0IsT0FBeEIsQ0FGVDtBQUFBLE1BR0Nzd0IsTUFBTXZWLFVBQVV3Z0IsV0FBVixFQUhQO0FBQUEsTUFJQ0MsV0FBV3hnQixNQUFPLENBQVAsRUFBV1EsU0FBWCxFQUpaO0FBQUEsTUFLQ2lnQixnQkFBZ0JELFNBQVN0MEMsQ0FBVCxDQUFXdzBDLFFBTDVCO0FBQUEsTUFNQ0MsV0FBVzNnQixNQUFPQSxNQUFNbnZCLE1BQU4sR0FBZSxDQUF0QixDQU5aO0FBQUEsTUFPQyt2QyxjQUFjRCxTQUFTbmdCLFNBQVQsR0FBcUJ0MEIsQ0FBckIsQ0FBdUJ3MEMsUUFBdkIsR0FBa0NDLFNBQVN6MEMsQ0FBVCxDQUFXMjBDLE9BQTdDLEdBQXVELENBUHRFO0FBQUEsTUFRQ0MsU0FBUyxJQUFJbDNDLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUEwQjhYLE1BQU05bEIsQ0FBTixDQUFRMmpCLElBQVIsQ0FBYyt3QixXQUFkLENBQTFCLENBUlY7QUFBQSxNQVNDRixXQUFXdGUsZUFBZXFlLGFBQWYsR0FBK0JHLFdBVDNDO0FBQUEsTUFVQ2p2QixNQUFNeVEsZUFBZW9lLFFBQWYsR0FBMEJNLE1BVmpDOztBQVlBLE1BQUl6cUMsTUFBTXpNLFNBQVN3TCxLQUFULENBQWVxb0MsYUFBZixDQUE4QnpyQixLQUE5QixDQUFWO0FBQUEsTUFDQyt1QixXQUFXMXFDLElBQUtxcUMsUUFBTCxDQURaO0FBQUEsTUFFQ00sVUFBVTVlLGVBQWUvckIsSUFBS3FxQyxXQUFXLENBQWhCLENBQWYsR0FBcUNycUMsSUFBS3FxQyxXQUFXLENBQWhCLENBRmhEO0FBQUEsTUFHQzFrQyxRQUFRM0YsSUFBSyxDQUFMLEVBQVN4RixNQUhsQjs7QUFLQSxNQUFJb3dDLFNBQVMzTCxJQUFJbm5DLGFBQUosQ0FBbUIsSUFBbkIsQ0FBYjtBQUNBLE9BQU0sSUFBSXlDLElBQUksQ0FBZCxFQUFpQm13QyxTQUFVbndDLENBQVYsS0FBaUJBLElBQUlvTCxLQUF0QyxFQUE2Q3BMLEdBQTdDLEVBQW1EO0FBQ2xELE9BQUkrZCxJQUFKO0FBQ0E7QUFDQSxPQUFLb3lCLFNBQVVud0MsQ0FBVixFQUFjaXdDLE9BQWQsR0FBd0IsQ0FBeEIsSUFBNkJHLE9BQTdCLElBQXdDRCxTQUFVbndDLENBQVYsS0FBaUJvd0MsUUFBU3B3QyxDQUFULENBQTlELEVBQTZFO0FBQzVFK2QsV0FBT295QixTQUFVbndDLENBQVYsQ0FBUDtBQUNBK2QsU0FBS2t5QixPQUFMLElBQWdCLENBQWhCO0FBQ0EsSUFIRCxNQUdPO0FBQ05seUIsV0FBTyxJQUFJL2tCLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUEwQjZtQyxTQUFVbndDLENBQVYsQ0FBMUIsRUFBMENzd0MsS0FBMUMsRUFBUDtBQUNBdnlCLFNBQUt3VCxlQUFMLENBQXNCLFNBQXRCO0FBQ0F4VCxTQUFLaVIsV0FBTDtBQUNBcWhCLFdBQU92aEIsTUFBUCxDQUFlL1EsSUFBZjtBQUNBQSxXQUFPQSxLQUFLemlCLENBQVo7QUFDQTs7QUFFRDBFLFFBQUsrZCxLQUFLNnRCLE9BQUwsR0FBZSxDQUFwQjtBQUNBOztBQUVEcGEsaUJBQWU2ZSxPQUFPN2UsWUFBUCxDQUFxQnpRLEdBQXJCLENBQWYsR0FBNENzdkIsT0FBT0UsV0FBUCxDQUFvQnh2QixHQUFwQixDQUE1QztBQUNBOztBQUVELFVBQVN5dkIsVUFBVCxDQUFxQkMsY0FBckIsRUFBc0M7QUFDckMsTUFBS0EsMEJBQTBCejNDLFNBQVN5RCxHQUFULENBQWFsQixTQUE1QyxFQUF3RDtBQUN2RCxPQUFJNnpCLFFBQVF3ZixpQkFBa0I2QixjQUFsQixDQUFaO0FBQUEsT0FDQ3RoQixZQUFZQyxNQUFPLENBQVAsQ0FEYjtBQUFBLE9BRUNoTyxRQUFRK04sVUFBVS9hLFlBQVYsQ0FBd0IsT0FBeEIsQ0FGVDtBQUFBLE9BR0MzTyxNQUFNek0sU0FBU3dMLEtBQVQsQ0FBZXFvQyxhQUFmLENBQThCenJCLEtBQTlCLENBSFA7QUFBQSxPQUlDd3VCLFdBQVd4Z0IsTUFBTyxDQUFQLEVBQVdRLFNBQVgsRUFKWjtBQUFBLE9BS0NpZ0IsZ0JBQWdCRCxTQUFTdDBDLENBQVQsQ0FBV3cwQyxRQUw1QjtBQUFBLE9BTUNDLFdBQVczZ0IsTUFBT0EsTUFBTW52QixNQUFOLEdBQWUsQ0FBdEIsQ0FOWjtBQUFBLE9BT0MrdkMsY0FBY0QsU0FBU25nQixTQUFULEdBQXFCdDBCLENBQXJCLENBQXVCdzBDLFFBQXZCLEdBQWtDQyxTQUFTejBDLENBQVQsQ0FBVzIwQyxPQUE3QyxHQUF1RCxDQVB0RTtBQUFBLE9BUUNTLGVBQWUsRUFSaEI7O0FBVUE7QUFDQSxRQUFNLElBQUkxd0MsSUFBSTZ2QyxhQUFkLEVBQTZCN3ZDLEtBQUtnd0MsV0FBbEMsRUFBK0Nod0MsR0FBL0MsRUFBcUQ7QUFDcEQsUUFBSTJ3QyxTQUFTbHJDLElBQUt6RixDQUFMLENBQWI7QUFBQSxRQUNDK2dCLE1BQU0sSUFBSS9uQixTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBMEI4WCxNQUFNOWxCLENBQU4sQ0FBUTJqQixJQUFSLENBQWNqZixDQUFkLENBQTFCLENBRFA7O0FBR0EsU0FBTSxJQUFJK3VCLElBQUksQ0FBZCxFQUFpQkEsSUFBSTRoQixPQUFPMXdDLE1BQTVCLEVBQW9DOHVCLEdBQXBDLEVBQTBDO0FBQ3pDLFNBQUloUixPQUFPLElBQUkva0IsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWpCLENBQTBCcW5DLE9BQVE1aEIsQ0FBUixDQUExQixDQUFYO0FBQUEsU0FDQzZoQixlQUFlN3lCLEtBQUs2UixTQUFMLEdBQWlCdDBCLENBQWpCLENBQW1CdzBDLFFBRG5DOztBQUdBLFNBQUsveEIsS0FBS3ppQixDQUFMLENBQU8yMEMsT0FBUCxJQUFrQixDQUF2QixFQUNDbHlCLEtBQUsxSixNQUFMO0FBQ0Q7QUFGQSxVQUdLO0FBQ0o7QUFDQTBKLFlBQUt6aUIsQ0FBTCxDQUFPMjBDLE9BQVAsSUFBa0IsQ0FBbEI7QUFDQTtBQUNBLFdBQUtXLGdCQUFnQjV3QyxDQUFyQixFQUF5QjtBQUN4QixZQUFJNndDLGFBQWFwckMsSUFBS3pGLElBQUksQ0FBVCxDQUFqQjtBQUNBNndDLG1CQUFZOWhCLElBQUksQ0FBaEIsSUFBc0JoUixLQUFLd3lCLFdBQUwsQ0FBa0IsSUFBSXYzQyxTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBMEJ1bkMsV0FBWTloQixJQUFJLENBQWhCLENBQTFCLENBQWxCLENBQXRCLEdBQTRGLElBQUkvMUIsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWpCLENBQTBCOFgsTUFBTTlsQixDQUFOLENBQVEyakIsSUFBUixDQUFjamYsSUFBSSxDQUFsQixDQUExQixFQUFrRDh1QixNQUFsRCxDQUEwRC9RLElBQTFELEVBQWdFLENBQWhFLENBQTVGO0FBQ0E7QUFDRDs7QUFFRGdSLFVBQUtoUixLQUFLemlCLENBQUwsQ0FBT3N3QyxPQUFQLEdBQWlCLENBQXRCO0FBQ0E7O0FBRUQ4RSxpQkFBYXJ1QyxJQUFiLENBQW1CMGUsR0FBbkI7QUFDQTs7QUFFRCxPQUFJOUIsT0FBT21DLE1BQU05bEIsQ0FBTixDQUFRMmpCLElBQW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBSTZ4QixpQkFBaUIsSUFBSTkzQyxTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBMEIyVixLQUFNK3dCLGNBQWMsQ0FBcEIsTUFBNkJILGdCQUFnQixDQUFoQixHQUFvQjV3QixLQUFNNHdCLGdCQUFnQixDQUF0QixDQUFwQixHQUFnRCxJQUE3RSxLQUF1Rnp1QixNQUFNOWxCLENBQU4sQ0FBUVYsVUFBekgsQ0FBckI7O0FBRUEsUUFBTW9GLElBQUkwd0MsYUFBYXp3QyxNQUF2QixFQUErQkQsS0FBSyxDQUFwQyxFQUF1Q0EsR0FBdkM7QUFDQ3d3QyxlQUFZRSxhQUFjMXdDLENBQWQsQ0FBWjtBQURELElBR0EsT0FBTzh3QyxjQUFQO0FBQ0EsR0FuREQsTUFtRE8sSUFBS0wsMEJBQTBCejNDLFNBQVN5RCxHQUFULENBQWE2TSxPQUE1QyxFQUFzRDtBQUM1RDhYLFdBQVFxdkIsZUFBZXI4QixZQUFmLENBQTZCLE9BQTdCLENBQVI7O0FBRUEsT0FBS2dOLE1BQU05bEIsQ0FBTixDQUFRMmpCLElBQVIsQ0FBYWhmLE1BQWIsSUFBdUIsQ0FBNUIsRUFDQ21oQixNQUFNL00sTUFBTixHQURELEtBR0NvOEIsZUFBZXA4QixNQUFmO0FBQ0Q7O0FBRUQsU0FBTyxJQUFQO0FBQ0E7O0FBRUQsVUFBUzA4QixlQUFULENBQTBCaHpCLElBQTFCLEVBQWdDaXpCLE9BQWhDLEVBQTBDO0FBQ3pDLE1BQUlqd0IsTUFBTWhELEtBQUs2UixTQUFMLEVBQVY7QUFBQSxNQUNDcWhCLFdBQVdsd0IsSUFBSXpsQixDQUFKLENBQU04ekIsS0FEbEI7O0FBR0EsTUFBSThoQixXQUFXLENBQWY7QUFDQSxPQUFNLElBQUlseEMsSUFBSSxDQUFkLEVBQWlCQSxJQUFJaXhDLFNBQVNoeEMsTUFBOUIsRUFBc0NELEdBQXRDLEVBQTRDO0FBQzNDLE9BQUlteEMsVUFBVUYsU0FBVWp4QyxDQUFWLENBQWQ7QUFDQWt4QyxlQUFZRixVQUFVLENBQVYsR0FBY0csUUFBUXZGLE9BQWxDO0FBQ0EsT0FBS3VGLFdBQVdwekIsS0FBS3ppQixDQUFyQixFQUNDO0FBQ0Q7O0FBRUQsU0FBTzQxQyxXQUFXLENBQWxCO0FBQ0E7O0FBRUQsVUFBU0UsaUJBQVQsQ0FBNEJoaUIsS0FBNUIsRUFBbUM0aEIsT0FBbkMsRUFBNkM7QUFDNUMsTUFBSW5DLFNBQVNtQyxVQUFVdmpCLFFBQVYsR0FBcUIsQ0FBbEM7QUFDQSxPQUFNLElBQUl6dEIsSUFBSSxDQUFkLEVBQWlCQSxJQUFJb3ZCLE1BQU1udkIsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXlDO0FBQ3hDLE9BQUlreEMsV0FBV0gsZ0JBQWlCM2hCLE1BQU9wdkIsQ0FBUCxDQUFqQixFQUE2Qmd4QyxPQUE3QixDQUFmO0FBQ0EsT0FBS0EsVUFBVUUsV0FBV3JDLE1BQXJCLEdBQThCcUMsV0FBV3JDLE1BQTlDLEVBQ0NBLFNBQVNxQyxRQUFUO0FBQ0Q7QUFDRCxTQUFPckMsTUFBUDtBQUNBOztBQUVELFVBQVN3QyxZQUFULENBQXVCOTFDLFNBQXZCLEVBQWtDaTJCLFlBQWxDLEVBQWlEO0FBQ2hELE1BQUlwQyxRQUFRd2YsaUJBQWtCcnpDLFNBQWxCLENBQVo7QUFBQSxNQUNDNHpCLFlBQVlDLE1BQU8sQ0FBUCxDQURiO0FBQUEsTUFFQ2hPLFFBQVErTixVQUFVL2EsWUFBVixDQUF3QixPQUF4QixDQUZUO0FBQUEsTUFHQ2s5QixXQUFXRixrQkFBbUJoaUIsS0FBbkIsRUFBMEIsQ0FBMUIsQ0FIWjtBQUFBLE1BSUNtaUIsVUFBVUgsa0JBQW1CaGlCLEtBQW5CLENBSlg7QUFBQSxNQUtDOGhCLFdBQVcxZixlQUFlOGYsUUFBZixHQUEwQkMsT0FMdEM7O0FBT0EsTUFBSTlyQyxNQUFNek0sU0FBU3dMLEtBQVQsQ0FBZXFvQyxhQUFmLENBQThCenJCLEtBQTlCLENBQVY7QUFBQSxNQUNDb3dCLFdBQVcsRUFEWjtBQUFBLE1BRUNDLFVBQVUsRUFGWDtBQUFBLE1BR0MxakMsU0FBU3RJLElBQUl4RixNQUhkOztBQUtBLE9BQU0sSUFBSUQsSUFBSSxDQUFkLEVBQWlCQSxJQUFJK04sTUFBckIsRUFBNkIvTixHQUE3QixFQUFtQztBQUNsQ3d4QyxZQUFTbnZDLElBQVQsQ0FBZW9ELElBQUt6RixDQUFMLEVBQVVreEMsUUFBVixDQUFmO0FBQ0EsT0FBSVEsV0FBV2xnQixlQUFlL3JCLElBQUt6RixDQUFMLEVBQVVreEMsV0FBVyxDQUFyQixDQUFmLEdBQTBDenJDLElBQUt6RixDQUFMLEVBQVVreEMsV0FBVyxDQUFyQixDQUF6RDtBQUNBTyxXQUFRcHZDLElBQVIsQ0FBY3F2QyxRQUFkO0FBQ0E7O0FBRUQsT0FBTTF4QyxJQUFJLENBQVYsRUFBYUEsSUFBSStOLE1BQWpCLEVBQXlCL04sR0FBekIsRUFBK0I7QUFDOUIsT0FBSStkLElBQUo7O0FBRUEsT0FBSyxDQUFDeXpCLFNBQVV4eEMsQ0FBVixDQUFOLEVBQ0M7O0FBRUQ7QUFDQSxPQUFLd3hDLFNBQVV4eEMsQ0FBVixFQUFjNHJDLE9BQWQsR0FBd0IsQ0FBeEIsSUFBNkI2RixRQUFTenhDLENBQVQsS0FBZ0J3eEMsU0FBVXh4QyxDQUFWLENBQWxELEVBQWtFO0FBQ2pFK2QsV0FBT3l6QixTQUFVeHhDLENBQVYsQ0FBUDtBQUNBK2QsU0FBSzZ0QixPQUFMLElBQWdCLENBQWhCO0FBQ0EsSUFIRCxNQUdPO0FBQ043dEIsV0FBTyxJQUFJL2tCLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUEwQmtvQyxTQUFVeHhDLENBQVYsQ0FBMUIsRUFBMENzd0MsS0FBMUMsRUFBUDtBQUNBdnlCLFNBQUt3VCxlQUFMLENBQXNCLFNBQXRCO0FBQ0F4VCxTQUFLaVIsV0FBTDtBQUNBalIsU0FBTXlULGVBQWUsY0FBZixHQUFnQyxhQUF0QyxFQUFzRDk0QixJQUF0RCxDQUE0RHFsQixJQUE1RCxFQUFrRSxJQUFJL2tCLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUEwQmtvQyxTQUFVeHhDLENBQVYsQ0FBMUIsQ0FBbEU7QUFDQStkLFdBQU9BLEtBQUt6aUIsQ0FBWjtBQUNBOztBQUVEMEUsUUFBSytkLEtBQUtreUIsT0FBTCxHQUFlLENBQXBCO0FBQ0E7QUFDRDs7QUFFRCxVQUFTMEIsYUFBVCxDQUF3QkMsZUFBeEIsRUFBMEM7QUFDekMsTUFBSXhpQixRQUFRd2YsaUJBQWtCZ0QsZUFBbEIsQ0FBWjtBQUFBLE1BQ0N6aUIsWUFBWUMsTUFBTyxDQUFQLENBRGI7QUFBQSxNQUVDMmdCLFdBQVczZ0IsTUFBT0EsTUFBTW52QixNQUFOLEdBQWUsQ0FBdEIsQ0FGWjtBQUFBLE1BR0NtaEIsUUFBUStOLFVBQVUvYSxZQUFWLENBQXdCLE9BQXhCLENBSFQ7QUFBQSxNQUlDM08sTUFBTXpNLFNBQVN3TCxLQUFULENBQWVxb0MsYUFBZixDQUE4QnpyQixLQUE5QixDQUpQO0FBQUEsTUFLQ3l3QixhQUxEO0FBQUEsTUFLZ0JDLFdBTGhCO0FBQUEsTUFNQ3BCLGVBQWUsRUFOaEI7O0FBUUE7QUFDQSxPQUFNLElBQUkxd0MsSUFBSSxDQUFSLEVBQVdpZixPQUFPeFosSUFBSXhGLE1BQTVCLEVBQW9DRCxJQUFJaWYsSUFBeEMsRUFBOENqZixHQUE5QyxFQUFvRDtBQUNuRCxRQUFNLElBQUkrdUIsSUFBSSxDQUFSLEVBQVcvUCxPQUFPdlosSUFBS3pGLENBQUwsRUFBU0MsTUFBakMsRUFBeUM4dUIsSUFBSS9QLElBQTdDLEVBQW1EK1AsR0FBbkQsRUFBeUQ7QUFDeEQsUUFBS3RwQixJQUFLekYsQ0FBTCxFQUFVK3VCLENBQVYsS0FBaUJJLFVBQVU3ekIsQ0FBaEMsRUFDQ3UyQyxnQkFBZ0I5aUIsQ0FBaEI7QUFDRCxRQUFLdHBCLElBQUt6RixDQUFMLEVBQVUrdUIsQ0FBVixLQUFpQmdoQixTQUFTejBDLENBQS9CLEVBQ0N3MkMsY0FBYy9pQixDQUFkO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLE9BQU0vdUIsSUFBSTZ4QyxhQUFWLEVBQXlCN3hDLEtBQUs4eEMsV0FBOUIsRUFBMkM5eEMsR0FBM0MsRUFBaUQ7QUFDaEQsUUFBTSt1QixJQUFJLENBQVYsRUFBYUEsSUFBSXRwQixJQUFJeEYsTUFBckIsRUFBNkI4dUIsR0FBN0IsRUFBbUM7QUFDbEMsUUFBSTRoQixTQUFTbHJDLElBQUtzcEIsQ0FBTCxDQUFiO0FBQUEsUUFDQ2hPLE1BQU0sSUFBSS9uQixTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBMEI4WCxNQUFNOWxCLENBQU4sQ0FBUTJqQixJQUFSLENBQWM4UCxDQUFkLENBQTFCLENBRFA7QUFBQSxRQUVDaFIsT0FBTyxJQUFJL2tCLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUEwQnFuQyxPQUFRM3dDLENBQVIsQ0FBMUIsQ0FGUjs7QUFJQSxRQUFLK2QsS0FBS3ppQixDQUFWLEVBQWM7QUFDYixTQUFLeWlCLEtBQUt6aUIsQ0FBTCxDQUFPc3dDLE9BQVAsSUFBa0IsQ0FBdkIsRUFDQzd0QixLQUFLMUosTUFBTDtBQUNEO0FBRkEsVUFJQzBKLEtBQUt6aUIsQ0FBTCxDQUFPc3dDLE9BQVAsSUFBa0IsQ0FBbEI7O0FBRUQ3YyxVQUFLaFIsS0FBS3ppQixDQUFMLENBQU8yMEMsT0FBUCxHQUFpQixDQUF0Qjs7QUFFQSxTQUFLLENBQUNsdkIsSUFBSXpsQixDQUFKLENBQU04ekIsS0FBTixDQUFZbnZCLE1BQWxCLEVBQ0N5d0MsYUFBYXJ1QyxJQUFiLENBQW1CMGUsR0FBbkI7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsTUFBSWd4QixnQkFBZ0Izd0IsTUFBTTlsQixDQUFOLENBQVEyakIsSUFBUixDQUFjLENBQWQsS0FBcUJtQyxNQUFNOWxCLENBQU4sQ0FBUTJqQixJQUFSLENBQWMsQ0FBZCxFQUFrQm1RLEtBQTNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSTBoQixpQkFBaUIsSUFBSTkzQyxTQUFTeUQsR0FBVCxDQUFhNk0sT0FBakIsQ0FBMEJ5b0MsY0FBZUYsYUFBZixNQUFvQ0EsZ0JBQWdCRSxjQUFlRixnQkFBZ0IsQ0FBL0IsQ0FBaEIsR0FBcUR6d0IsTUFBTTlsQixDQUFOLENBQVFWLFVBQWpHLENBQTFCLENBQXJCOztBQUVBO0FBQ0EsTUFBSzgxQyxhQUFhendDLE1BQWIsSUFBdUJnZixJQUE1QixFQUNDbUMsTUFBTS9NLE1BQU47O0FBRUQsU0FBT3k4QixjQUFQO0FBQ0E7O0FBRUQsVUFBU2tCLFVBQVQsQ0FBcUJ6MkMsU0FBckIsRUFBZ0NpMkIsWUFBaEMsRUFBK0M7QUFDOUMsTUFBSXlnQixlQUFlMTJDLFVBQVUwdUIsZUFBVixFQUFuQjtBQUNBLE1BQUlsTSxPQUFPazBCLGFBQWE3OUIsWUFBYixDQUEyQixJQUEzQixFQUFpQyxDQUFqQyxLQUF3QzY5QixhQUFhNzlCLFlBQWIsQ0FBMkIsSUFBM0IsRUFBaUMsQ0FBakMsQ0FBbkQ7O0FBRUEsTUFBSyxDQUFDMkosSUFBTixFQUNDOztBQUVEO0FBQ0EsTUFBSXNTLFVBQVV0UyxLQUFLdXlCLEtBQUwsRUFBZDtBQUNBamdCLFVBQVFyQixXQUFSOztBQUVBLE1BQUt3QyxZQUFMLEVBQ0NuQixRQUFRbUIsWUFBUixDQUFzQnpULElBQXRCLEVBREQsS0FHQ3NTLFFBQVFrZ0IsV0FBUixDQUFxQnh5QixJQUFyQjtBQUNEOztBQUVELFVBQVNtMEIsV0FBVCxDQUFzQk4sZUFBdEIsRUFBd0M7QUFDdkMsTUFBS0EsMkJBQTJCNTRDLFNBQVN5RCxHQUFULENBQWFsQixTQUE3QyxFQUF5RDtBQUN4RCxPQUFJZzBDLGdCQUFnQlgsaUJBQWtCZ0QsZUFBbEIsQ0FBcEI7QUFDQSxPQUFJeHdCLFFBQVFtdUIsY0FBZSxDQUFmLEtBQXNCQSxjQUFlLENBQWYsRUFBbUJuN0IsWUFBbkIsQ0FBaUMsT0FBakMsQ0FBbEM7QUFDQSxPQUFJKzlCLGNBQWM3Qyw2QkFBOEJDLGFBQTlCLENBQWxCOztBQUVBLFFBQU0sSUFBSXZ2QyxJQUFJdXZDLGNBQWN0dkMsTUFBZCxHQUF1QixDQUFyQyxFQUF3Q0QsS0FBSyxDQUE3QyxFQUFnREEsR0FBaEQ7QUFDQ2t5QyxnQkFBYTNDLGNBQWV2dkMsQ0FBZixDQUFiO0FBREQsSUFHQSxJQUFLbXlDLFdBQUwsRUFDQ0Msa0JBQW1CRCxXQUFuQixFQUFnQyxJQUFoQyxFQURELEtBRUssSUFBSy93QixLQUFMLEVBQ0pBLE1BQU0vTSxNQUFOO0FBQ0QsR0FaRCxNQVlPLElBQUt1OUIsMkJBQTJCNTRDLFNBQVN5RCxHQUFULENBQWE2TSxPQUE3QyxFQUF1RDtBQUM3RCxPQUFJc3hCLEtBQUtnWCxnQkFBZ0JoaUIsU0FBaEIsRUFBVDtBQUNBLE9BQUtnTCxHQUFHekssYUFBSCxNQUFzQixDQUEzQixFQUNDeUssR0FBR3ZtQixNQUFILEdBREQsS0FHQ3U5QixnQkFBZ0J2OUIsTUFBaEI7QUFDRDtBQUNEOztBQUVEO0FBQ0EsVUFBU2crQixRQUFULENBQW1CdDBCLElBQW5CLEVBQTBCO0FBQ3pCLE1BQUl1MEIsUUFBUXYwQixLQUFLdzBCLFFBQUwsRUFBWjtBQUNBRCxXQUFTQSxNQUFNaitCLE1BQU4sRUFBVDtBQUNBMEosT0FBS2dzQixJQUFMO0FBQ0E7O0FBRUQsVUFBU3FJLGlCQUFULENBQTRCcjBCLElBQTVCLEVBQWtDeTBCLFVBQWxDLEVBQStDO0FBQzlDLE1BQUlDLFdBQVcxMEIsS0FBSzR4QixXQUFMLEVBQWY7QUFBQSxNQUNDK0MsV0FBVzE1QyxTQUFTcUMsUUFEckI7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLckMsU0FBU1csR0FBVCxDQUFhQyxFQUFiLElBQW1CWixTQUFTVyxHQUFULENBQWFnNUMsT0FBYixJQUF3QixFQUFoRCxFQUFxRDtBQUNwREQsWUFBUzNyQyxLQUFUO0FBQ0EwckMsWUFBUzFyQyxLQUFUO0FBQ0E7O0FBRUQsTUFBSXdoQixRQUFRLElBQUl2dkIsU0FBU3lELEdBQVQsQ0FBYThyQixLQUFqQixDQUF3QmtxQixRQUF4QixDQUFaO0FBQ0EsTUFBSyxDQUFDbHFCLE1BQU8sdUJBQXdCaXFCLGFBQWEsS0FBYixHQUFxQixPQUE3QyxDQUFQLEVBQWlFejBCLElBQWpFLENBQU4sRUFBZ0Y7QUFDL0V3SyxTQUFNaUIsa0JBQU4sQ0FBMEJ6TCxJQUExQjtBQUNBd0ssU0FBTXFxQixRQUFOLENBQWdCSixhQUFhLEtBQWIsR0FBcUIsSUFBckM7QUFDQTtBQUNEanFCLFFBQU1vQixNQUFOLENBQWMsSUFBZDtBQUNBOztBQUVELFVBQVNrcEIsU0FBVCxDQUFvQkMsUUFBcEIsRUFBOEJoRCxRQUE5QixFQUF3Qy94QixJQUF4QyxFQUErQztBQUM5QyxNQUFJZzFCLE9BQU9ELFNBQVVoRCxRQUFWLENBQVg7QUFDQSxNQUFLLE9BQU8veEIsSUFBUCxJQUFlLFdBQXBCLEVBQ0MsT0FBT2cxQixJQUFQOztBQUVELE9BQU0sSUFBSXhSLElBQUksQ0FBZCxFQUFpQndSLFFBQVF4UixJQUFJd1IsS0FBSzl5QyxNQUFsQyxFQUEwQ3NoQyxHQUExQyxFQUFnRDtBQUMvQyxPQUFLeGpCLEtBQUs2TCxFQUFMLElBQVdtcEIsS0FBTXhSLENBQU4sS0FBYXhqQixLQUFLemlCLENBQWxDLEVBQ0MsT0FBT2ltQyxDQUFQLENBREQsS0FFSyxJQUFLQSxLQUFLeGpCLElBQVYsRUFDSixPQUFPLElBQUkva0IsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWpCLENBQTBCeXBDLEtBQU14UixDQUFOLENBQTFCLENBQVA7QUFDRDtBQUNELFNBQU94akIsS0FBSzZMLEVBQUwsR0FBVSxDQUFDLENBQVgsR0FBZSxJQUF0QjtBQUNBOztBQUVELFVBQVNvcEIsU0FBVCxDQUFvQkYsUUFBcEIsRUFBOEI1QixRQUE5QixFQUF5QztBQUN4QyxNQUFJK0IsT0FBTyxFQUFYO0FBQ0EsT0FBTSxJQUFJQyxJQUFJLENBQWQsRUFBaUJBLElBQUlKLFNBQVM3eUMsTUFBOUIsRUFBc0NpekMsR0FBdEMsRUFBNEM7QUFDM0MsT0FBSW55QixNQUFNK3hCLFNBQVVJLENBQVYsQ0FBVjtBQUNBRCxRQUFLNXdDLElBQUwsQ0FBVzBlLElBQUttd0IsUUFBTCxDQUFYOztBQUVBO0FBQ0EsT0FBS253QixJQUFLbXdCLFFBQUwsRUFBZ0JqQixPQUFoQixHQUEwQixDQUEvQixFQUNDaUQsS0FBS255QixJQUFLbXdCLFFBQUwsRUFBZ0JqQixPQUFoQixHQUEwQixDQUEvQjtBQUNEO0FBQ0QsU0FBT2dELElBQVA7QUFDQTs7QUFFRCxVQUFTRSxVQUFULENBQXFCNTNDLFNBQXJCLEVBQWdDNjNDLGNBQWhDLEVBQWdEQyxRQUFoRCxFQUEyRDtBQUMxRCxNQUFJamtCLFFBQVF3ZixpQkFBa0JyekMsU0FBbEIsQ0FBWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUkrM0MsY0FBSjtBQUNBLE1BQUssQ0FBRUYsaUJBQWlCaGtCLE1BQU1udkIsTUFBTixJQUFnQixDQUFqQyxHQUFxQ212QixNQUFNbnZCLE1BQU4sR0FBZSxDQUF0RCxLQUE2RCxDQUFFcXpDLGlCQUFpQi8zQyxVQUFVc3RCLGlCQUFWLEVBQW5CLEtBQXNEeXFCLGVBQWVockMsSUFBZixJQUF1QnRQLFNBQVN3MkIsWUFBdEYsSUFBc0c4akIsZUFBZTFwQixFQUFmLENBQW1CLE9BQW5CLENBQXhLLEVBQ0MsT0FBTyxLQUFQOztBQUVELE1BQUk3TCxJQUFKO0FBQUEsTUFDQ29SLFlBQVlDLE1BQU8sQ0FBUCxDQURiO0FBQUEsTUFFQ2hPLFFBQVErTixVQUFVL2EsWUFBVixDQUF3QixPQUF4QixDQUZUO0FBQUEsTUFHQzNPLE1BQU16TSxTQUFTd0wsS0FBVCxDQUFlcW9DLGFBQWYsQ0FBOEJ6ckIsS0FBOUIsQ0FIUDtBQUFBLE1BSUNteUIsWUFBWTl0QyxJQUFJeEYsTUFKakI7QUFBQSxNQUtDdXpDLFdBQVcvdEMsSUFBSyxDQUFMLEVBQVN4RixNQUxyQjtBQUFBLE1BTUMydkMsV0FBV3pnQixVQUFVUyxTQUFWLEdBQXNCdDBCLENBQXRCLENBQXdCdzBDLFFBTnBDO0FBQUEsTUFPQzJELGNBQWNaLFVBQVdwdEMsR0FBWCxFQUFnQm1xQyxRQUFoQixFQUEwQnpnQixTQUExQixDQVBmOztBQVNBLE1BQUtpa0IsY0FBTCxFQUFzQjtBQUNyQixPQUFJTSxVQUFKO0FBQ0EsT0FBSTtBQUNILFFBQUlDLFVBQVVyZSxTQUFVbkcsVUFBVS9rQixZQUFWLENBQXdCLFNBQXhCLENBQVYsRUFBK0MsRUFBL0MsS0FBdUQsQ0FBckU7QUFDQSxRQUFJd3BDLFVBQVV0ZSxTQUFVbkcsVUFBVS9rQixZQUFWLENBQXdCLFNBQXhCLENBQVYsRUFBK0MsRUFBL0MsS0FBdUQsQ0FBckU7O0FBRUFzcEMsaUJBQWFqdUMsSUFBSzJ0QyxrQkFBa0IsSUFBbEIsR0FBMkJ4RCxXQUFXK0QsT0FBdEMsR0FBa0RQLGtCQUFrQixNQUFsQixHQUE2QnhELFdBQVcrRCxPQUF4QyxHQUFvRC9ELFFBQTNHLEVBQ1p3RCxrQkFBa0IsTUFBbEIsR0FDR0ssY0FBY0csT0FEakIsR0FFQVIsa0JBQWtCLE9BQWxCLEdBQThCSyxjQUFjRyxPQUE1QyxHQUF3REgsV0FINUMsQ0FBYjtBQUtBLElBVEQsQ0FTRSxPQUFRSSxFQUFSLEVBQWE7QUFDZCxXQUFPLEtBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsT0FBSyxDQUFDSCxVQUFELElBQWV2a0IsVUFBVTd6QixDQUFWLElBQWVvNEMsVUFBbkMsRUFDQyxPQUFPLEtBQVA7O0FBRUQ7QUFDQXRrQixTQUFTZ2tCLGtCQUFrQixJQUFsQixJQUEwQkEsa0JBQWtCLE1BQTlDLEdBQXlELFNBQXpELEdBQXFFLE1BQTVFLEVBQXNGLElBQUlwNkMsU0FBU3lELEdBQVQsQ0FBYTZNLE9BQWpCLENBQTBCb3FDLFVBQTFCLENBQXRGO0FBQ0E7O0FBRUQ7QUFDQSxNQUFJaFAsTUFBTXZWLFVBQVV3Z0IsV0FBVixFQUFWO0FBQUEsTUFDQ21FLGVBQWVsRSxRQURoQjtBQUFBLE1BRUNtRSxlQUFlLENBRmhCO0FBQUEsTUFHQ0MsZUFBZSxDQUhoQjs7QUFJQztBQUNBQyxTQUFPLENBQUNaLFFBQUQsSUFBYSxJQUFJcjZDLFNBQVN5RCxHQUFULENBQWF5M0MsZ0JBQWpCLENBQW1DeFAsR0FBbkMsQ0FMckI7QUFBQSxNQU1DakQsWUFBWSxDQU5iOztBQVFBLE9BQU0sSUFBSXpoQyxJQUFJLENBQWQsRUFBaUJBLElBQUlvdkIsTUFBTW52QixNQUEzQixFQUFtQ0QsR0FBbkMsRUFBeUM7QUFDeEMrZCxVQUFPcVIsTUFBT3B2QixDQUFQLENBQVA7O0FBRUEsT0FBSTQ2QixLQUFLN2MsS0FBSzZSLFNBQUwsRUFBVDtBQUFBLE9BQ0N1a0IsaUJBQWlCcDJCLEtBQUtxVCxRQUFMLEVBRGxCO0FBQUEsT0FFQ3dhLFVBQVU3dEIsS0FBS3ppQixDQUFMLENBQU9zd0MsT0FGbEI7QUFBQSxPQUdDcUUsVUFBVWx5QixLQUFLemlCLENBQUwsQ0FBTzIwQyxPQUhsQjtBQUFBLE9BSUNILFdBQVdsVixHQUFHdC9CLENBQUgsQ0FBS3cwQyxRQUpqQjtBQUFBLE9BS0NvQixXQUFXMkIsVUFBV3B0QyxHQUFYLEVBQWdCcXFDLFFBQWhCLEVBQTBCL3hCLElBQTFCLENBTFo7O0FBT0E7QUFDQTBqQixnQkFBYW1LLFVBQVVxRSxPQUF2QjtBQUNBO0FBQ0ErRCxrQkFBZXJ3QyxLQUFLK0YsR0FBTCxDQUFVc3FDLFlBQVYsRUFBd0I5QyxXQUFXdUMsV0FBWCxHQUF5QjdILE9BQWpELENBQWY7QUFDQW1JLGtCQUFlcHdDLEtBQUsrRixHQUFMLENBQVVxcUMsWUFBVixFQUF3QmpFLFdBQVdGLFFBQVgsR0FBc0JLLE9BQTlDLENBQWY7O0FBRUEsT0FBSyxDQUFDb0QsUUFBTixFQUFpQjtBQUNoQjtBQUNBLFFBQUtoQixTQUFVdDBCLElBQVYsR0FBa0JBLEtBQUtxMkIsV0FBTCxHQUFtQkMsS0FBbkIsRUFBdkIsRUFBb0Q7QUFDbkQ7QUFDQSxTQUFLdkUsWUFBWWdFLFlBQVosSUFBNEJLLGNBQTVCLElBQThDLEVBQUdBLGVBQWVHLGVBQWYsSUFBa0NILGVBQWVHLGVBQWYsQ0FBZ0MsRUFBRTlaLElBQUksQ0FBTixFQUFoQyxDQUFyQyxDQUFuRCxFQUF3STtBQUN2SSxVQUFJZ1YsT0FBT3lFLEtBQUt0YyxPQUFMLENBQWMzK0IsU0FBU3lELEdBQVQsQ0FBYXl5QyxNQUFiLENBQW9CcUYsV0FBcEIsQ0FBaUMsSUFBakMsQ0FBZCxDQUFYO0FBQ0EsVUFBSy9FLFFBQVEsRUFBR0EsS0FBSzVsQixFQUFMLElBQVc0bEIsS0FBSzVsQixFQUFMLENBQVMsSUFBVCxDQUFkLENBQWIsRUFDQ3FxQixLQUFLbmxCLE1BQUwsQ0FBYSxJQUFiO0FBQ0Q7O0FBRUQvUSxVQUFLeTJCLFlBQUwsQ0FBbUJQLElBQW5CO0FBQ0E7QUFDRGowQyxRQUFJK2QsS0FBSzFKLE1BQUwsRUFBSixHQUFvQjBKLEtBQUtvcEIsT0FBTCxDQUFjLEVBQWQsQ0FBcEI7QUFDQTtBQUNEMk0sa0JBQWVoRSxRQUFmO0FBQ0E7O0FBRUQsTUFBSyxDQUFDdUQsUUFBTixFQUFpQjtBQUNoQlksUUFBS08sWUFBTCxDQUFtQnJsQixTQUFuQjs7QUFFQUEsYUFBVUgsV0FBVjs7QUFFQSxPQUFLZ2xCLGdCQUFnQlIsUUFBckIsRUFDQ3JrQixVQUFVb0MsZUFBVixDQUEyQixTQUEzQixFQURELEtBR0NwQyxVQUFVN3pCLENBQVYsQ0FBWTIwQyxPQUFaLEdBQXNCOEQsWUFBdEI7O0FBRUQsT0FBS0EsZ0JBQWdCUixTQUFyQixFQUNDcGtCLFVBQVVvQyxlQUFWLENBQTJCLFNBQTNCLEVBREQsS0FHQ3BDLFVBQVU3ekIsQ0FBVixDQUFZc3dDLE9BQVosR0FBc0JvSSxZQUF0Qjs7QUFFRDtBQUNBLE9BQUlTLE1BQU0sSUFBSXo3QyxTQUFTeUQsR0FBVCxDQUFhaTRDLFFBQWpCLENBQTJCdHpCLE1BQU05bEIsQ0FBTixDQUFRMmpCLElBQW5DLENBQVY7QUFBQSxPQUNDbzFCLFFBQVFJLElBQUlKLEtBQUosRUFEVDs7QUFHQSxRQUFNcjBDLElBQUlxMEMsUUFBUSxDQUFsQixFQUFxQnIwQyxLQUFLLENBQTFCLEVBQTZCQSxHQUE3QixFQUFtQztBQUNsQyxRQUFJMjBDLFNBQVNGLElBQUloa0IsT0FBSixDQUFhendCLENBQWIsQ0FBYjtBQUNBLFFBQUssQ0FBQzIwQyxPQUFPcjVDLENBQVAsQ0FBUzh6QixLQUFULENBQWVudkIsTUFBckIsRUFBOEI7QUFDN0IwMEMsWUFBT3RnQyxNQUFQO0FBQ0FnZ0M7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQsVUFBT2xsQixTQUFQO0FBQ0E7QUFDRDtBQUNBO0FBL0JBLE9BZ0NLO0FBQ0osV0FBUzRrQixlQUFlQyxZQUFqQixJQUFtQ3ZTLFNBQTFDO0FBQ0E7QUFDRDs7QUFFRCxVQUFTbVQsaUJBQVQsQ0FBNEJyNUMsU0FBNUIsRUFBdUM4M0MsUUFBdkMsRUFBa0Q7QUFDakQsTUFBSWprQixRQUFRd2YsaUJBQWtCcnpDLFNBQWxCLENBQVo7QUFDQSxNQUFLNnpCLE1BQU1udkIsTUFBTixHQUFlLENBQXBCLEVBQ0MsT0FBTyxLQUFQLENBREQsS0FFSyxJQUFLb3pDLFFBQUwsRUFDSixPQUFPLElBQVA7O0FBRUQsTUFBSXQxQixPQUFPcVIsTUFBTyxDQUFQLENBQVg7QUFBQSxNQUNDd0wsS0FBSzdjLEtBQUs2UixTQUFMLEVBRE47QUFBQSxNQUVDeE8sUUFBUXdaLEdBQUd4bUIsWUFBSCxDQUFpQixPQUFqQixDQUZUO0FBQUEsTUFHQzNPLE1BQU16TSxTQUFTd0wsS0FBVCxDQUFlcW9DLGFBQWYsQ0FBOEJ6ckIsS0FBOUIsQ0FIUDtBQUFBLE1BSUMwdUIsV0FBV2xWLEdBQUd0L0IsQ0FBSCxDQUFLdzBDLFFBSmpCO0FBQUEsTUFLQ29CLFdBQVcyQixVQUFXcHRDLEdBQVgsRUFBZ0JxcUMsUUFBaEIsRUFBMEIveEIsSUFBMUIsQ0FMWjtBQUFBLE1BTUNreUIsVUFBVWx5QixLQUFLemlCLENBQUwsQ0FBTzIwQyxPQU5sQjtBQUFBLE1BT0M1ZixPQVBEO0FBQUEsTUFPVXdrQixVQVBWO0FBQUEsTUFPc0JDLGNBUHRCO0FBQUEsTUFPc0NDLFdBUHRDOztBQVNBLE1BQUs5RSxVQUFVLENBQWYsRUFBbUI7QUFDbEI0RSxnQkFBYWx4QyxLQUFLcXhDLElBQUwsQ0FBVy9FLFVBQVUsQ0FBckIsQ0FBYjtBQUNBNkUsb0JBQWlCbnhDLEtBQUtxaUIsS0FBTCxDQUFZaXFCLFVBQVUsQ0FBdEIsQ0FBakI7QUFDQThFLGlCQUFjakYsV0FBVytFLFVBQXpCO0FBQ0EsT0FBSUksWUFBWSxJQUFJajhDLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUEwQjhYLE1BQU05bEIsQ0FBTixDQUFRMmpCLElBQVIsQ0FBYzgxQixXQUFkLENBQTFCLENBQWhCO0FBQUEsT0FDQ0csYUFBYXJDLFVBQVdwdEMsR0FBWCxFQUFnQnN2QyxXQUFoQixDQURkO0FBQUEsT0FFQ0ksYUFGRDs7QUFJQTlrQixhQUFVdFMsS0FBS3V5QixLQUFMLEVBQVY7O0FBRUE7QUFDQSxRQUFNLElBQUkvTyxJQUFJLENBQWQsRUFBaUJBLElBQUkyVCxXQUFXajFDLE1BQWhDLEVBQXdDc2hDLEdBQXhDLEVBQThDO0FBQzdDNFQsb0JBQWdCRCxXQUFZM1QsQ0FBWixDQUFoQjtBQUNBO0FBQ0EsUUFBSzRULGNBQWN2NkMsVUFBZCxJQUE0QnE2QyxVQUFVMzVDLENBQXRDLElBQTJDaW1DLElBQUkyUCxRQUFwRCxFQUErRDtBQUM5RDdnQixhQUFRbUIsWUFBUixDQUFzQixJQUFJeDRCLFNBQVN5RCxHQUFULENBQWE2TSxPQUFqQixDQUEwQjZyQyxhQUExQixDQUF0QjtBQUNBO0FBQ0EsS0FIRCxNQUdPO0FBQ05BLHFCQUFnQixJQUFoQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFLLENBQUNBLGFBQU4sRUFDQ0YsVUFBVW5tQixNQUFWLENBQWtCdUIsT0FBbEI7QUFDRCxHQXpCRCxNQXlCTztBQUNOeWtCLG9CQUFpQkQsYUFBYSxDQUE5Qjs7QUFFQUksZUFBWXJhLEdBQUcwVixLQUFILEVBQVo7QUFDQTJFLGFBQVUxRSxXQUFWLENBQXVCM1YsRUFBdkI7QUFDQXFhLGFBQVVubUIsTUFBVixDQUFrQnVCLFVBQVV0UyxLQUFLdXlCLEtBQUwsRUFBNUI7O0FBRUEsT0FBSThFLGlCQUFpQnZDLFVBQVdwdEMsR0FBWCxFQUFnQnFxQyxRQUFoQixDQUFyQjtBQUNBLFFBQU0sSUFBSTl2QyxJQUFJLENBQWQsRUFBaUJBLElBQUlvMUMsZUFBZW4xQyxNQUFwQyxFQUE0Q0QsR0FBNUM7QUFDQ28xQyxtQkFBZ0JwMUMsQ0FBaEIsRUFBb0Jpd0MsT0FBcEI7QUFERDtBQUVBOztBQUVENWYsVUFBUXJCLFdBQVI7O0FBRUFqUixPQUFLemlCLENBQUwsQ0FBTzIwQyxPQUFQLEdBQWlCNEUsVUFBakI7QUFDQXhrQixVQUFRLzBCLENBQVIsQ0FBVTIwQyxPQUFWLEdBQW9CNkUsY0FBcEI7QUFDQSxNQUFLRCxjQUFjLENBQW5CLEVBQ0M5MkIsS0FBS3dULGVBQUwsQ0FBc0IsU0FBdEI7QUFDRCxNQUFLdWpCLGtCQUFrQixDQUF2QixFQUNDemtCLFFBQVFrQixlQUFSLENBQXlCLFNBQXpCOztBQUVELFNBQU9sQixPQUFQO0FBQ0E7O0FBRUQsVUFBU2dsQixtQkFBVCxDQUE4Qjk1QyxTQUE5QixFQUF5QzgzQyxRQUF6QyxFQUFvRDtBQUNuRCxNQUFJamtCLFFBQVF3ZixpQkFBa0JyekMsU0FBbEIsQ0FBWjtBQUNBLE1BQUs2ekIsTUFBTW52QixNQUFOLEdBQWUsQ0FBcEIsRUFDQyxPQUFPLEtBQVAsQ0FERCxLQUVLLElBQUtvekMsUUFBTCxFQUNKLE9BQU8sSUFBUDs7QUFFRCxNQUFJdDFCLE9BQU9xUixNQUFPLENBQVAsQ0FBWDtBQUFBLE1BQ0N3TCxLQUFLN2MsS0FBSzZSLFNBQUwsRUFETjtBQUFBLE1BRUN4TyxRQUFRd1osR0FBR3htQixZQUFILENBQWlCLE9BQWpCLENBRlQ7QUFBQSxNQUdDM08sTUFBTXpNLFNBQVN3TCxLQUFULENBQWVxb0MsYUFBZixDQUE4QnpyQixLQUE5QixDQUhQO0FBQUEsTUFJQzB1QixXQUFXbFYsR0FBR3QvQixDQUFILENBQUt3MEMsUUFKakI7QUFBQSxNQUtDb0IsV0FBVzJCLFVBQVdwdEMsR0FBWCxFQUFnQnFxQyxRQUFoQixFQUEwQi94QixJQUExQixDQUxaO0FBQUEsTUFNQzZ0QixVQUFVN3RCLEtBQUt6aUIsQ0FBTCxDQUFPc3dDLE9BTmxCO0FBQUEsTUFPQ3ZiLE9BUEQ7QUFBQSxNQU9VaWxCLFVBUFY7QUFBQSxNQU9zQkMsY0FQdEI7O0FBU0EsTUFBSzNKLFVBQVUsQ0FBZixFQUFtQjtBQUNsQjBKLGdCQUFhM3hDLEtBQUtxeEMsSUFBTCxDQUFXcEosVUFBVSxDQUFyQixDQUFiO0FBQ0EySixvQkFBaUI1eEMsS0FBS3FpQixLQUFMLENBQVk0bEIsVUFBVSxDQUF0QixDQUFqQjtBQUNBLEdBSEQsTUFHTztBQUNOMkosb0JBQWlCRCxhQUFhLENBQTlCO0FBQ0EsT0FBSUUsaUJBQWlCeEMsVUFBV3Z0QyxHQUFYLEVBQWdCeXJDLFFBQWhCLENBQXJCO0FBQ0EsUUFBTSxJQUFJbHhDLElBQUksQ0FBZCxFQUFpQkEsSUFBSXcxQyxlQUFldjFDLE1BQXBDLEVBQTRDRCxHQUE1QztBQUNDdzFDLG1CQUFnQngxQyxDQUFoQixFQUFvQjRyQyxPQUFwQjtBQUREO0FBRUE7QUFDRHZiLFlBQVV0UyxLQUFLdXlCLEtBQUwsRUFBVjtBQUNBamdCLFVBQVFrZ0IsV0FBUixDQUFxQnh5QixJQUFyQjtBQUNBc1MsVUFBUXJCLFdBQVI7O0FBRUFqUixPQUFLemlCLENBQUwsQ0FBT3N3QyxPQUFQLEdBQWlCMEosVUFBakI7QUFDQWpsQixVQUFRLzBCLENBQVIsQ0FBVXN3QyxPQUFWLEdBQW9CMkosY0FBcEI7QUFDQSxNQUFLRCxjQUFjLENBQW5CLEVBQ0N2M0IsS0FBS3dULGVBQUwsQ0FBc0IsU0FBdEI7QUFDRCxNQUFLZ2tCLGtCQUFrQixDQUF2QixFQUNDbGxCLFFBQVFrQixlQUFSLENBQXlCLFNBQXpCOztBQUVELFNBQU9sQixPQUFQO0FBQ0E7O0FBRURyM0IsVUFBUzh0QixPQUFULENBQWlCM25CLEdBQWpCLENBQXFCLGVBQXJCLEVBQXNDO0FBQ3JDaXZCLFFBQU0sY0FBVXIxQixNQUFWLEVBQW1CO0FBQ3hCLE9BQUltSSxPQUFPbkksT0FBT21JLElBQVAsQ0FBWWtnQixLQUF2Qjs7QUFFQSxZQUFTcTBCLFNBQVQsQ0FBb0JDLEdBQXBCLEVBQTBCO0FBQ3pCLFdBQU8xOEMsU0FBU3dMLEtBQVQsQ0FBZSt3QixNQUFmLENBQXVCbWdCLE9BQU8sRUFBOUIsRUFBa0M7QUFDeENDLHVCQUFrQixDQURzQjtBQUV4QzdNLGNBQVMsaUJBQVUvdkMsTUFBVixFQUFrQjZHLElBQWxCLEVBQXlCO0FBQ2pDLFdBQUsyRyxRQUFMLENBQWUzRyxLQUFLbWxCLFFBQUwsQ0FBZSxFQUFFMm1CLElBQUksQ0FBTixFQUFTa0ssSUFBSSxDQUFiLEVBQWYsRUFBaUMsQ0FBakMsSUFBdUM1OEMsU0FBUzZ2QyxZQUFoRCxHQUErRDd2QyxTQUFTNjhDLGlCQUF2RjtBQUNBO0FBSnVDLEtBQWxDLENBQVA7QUFNQTtBQUNELFlBQVNDLE1BQVQsQ0FBaUJweUMsSUFBakIsRUFBdUJneUMsR0FBdkIsRUFBNkI7QUFDNUIsUUFBSUssTUFBTWg5QyxPQUFPbUssVUFBUCxDQUFrQlEsSUFBbEIsQ0FBVjs7QUFFQSxRQUFJcXlDLEdBQUosRUFBUztBQUNSO0FBQ0E7O0FBRURBLFVBQU1oOUMsT0FBT2tMLFVBQVAsQ0FBa0JQLElBQWxCLEVBQXdCZ3lDLEdBQXhCLENBQU47QUFDQTM4QyxXQUFPaTlDLFVBQVAsQ0FBa0JELEdBQWxCO0FBQ0E7O0FBRURELFVBQVEsV0FBUixFQUFxQkwsVUFBVztBQUMvQmpULHFCQUFpQixPQURjO0FBRS9CMStCLFVBQU0sY0FBVS9LLE1BQVYsRUFBbUI7QUFDeEIsU0FBSXdDLFlBQVl4QyxPQUFPcUMsWUFBUCxFQUFoQjtBQUNBZzNDLHVCQUFtQjVCLFdBQVlqMUMsU0FBWixDQUFuQjtBQUNBO0FBTDhCLElBQVgsQ0FBckI7O0FBUUF1NkMsVUFBUSxpQkFBUixFQUEyQkwsVUFBVztBQUNyQ2pULHFCQUFpQixPQURvQjtBQUVyQzErQixVQUFNLGNBQVUvSyxNQUFWLEVBQW1CO0FBQ3hCLFNBQUl3QyxZQUFZeEMsT0FBT3FDLFlBQVAsRUFBaEI7QUFDQXMwQyxlQUFXbjBDLFNBQVgsRUFBc0IsSUFBdEI7QUFDQTtBQUxvQyxJQUFYLENBQTNCOztBQVFBdTZDLFVBQVEsZ0JBQVIsRUFBMEJMLFVBQVc7QUFDcENqVCxxQkFBaUIsT0FEbUI7QUFFcEMxK0IsVUFBTSxjQUFVL0ssTUFBVixFQUFtQjtBQUN4QixTQUFJd0MsWUFBWXhDLE9BQU9xQyxZQUFQLEVBQWhCO0FBQ0FzMEMsZUFBV24wQyxTQUFYO0FBQ0E7QUFMbUMsSUFBWCxDQUExQjs7QUFRQXU2QyxVQUFRLGNBQVIsRUFBd0JMLFVBQVc7QUFDbENqVCxxQkFBaUIsT0FEaUI7QUFFbEMxK0IsVUFBTSxjQUFVL0ssTUFBVixFQUFtQjtBQUN4QixTQUFJd0MsWUFBWXhDLE9BQU9xQyxZQUFQLEVBQWhCO0FBQ0EsU0FBSWtPLFVBQVVxb0MsY0FBZXAyQyxTQUFmLENBQWQ7QUFDQStOLGdCQUFXOG9DLGtCQUFtQjlvQyxPQUFuQixFQUE0QixJQUE1QixDQUFYO0FBQ0E7QUFOaUMsSUFBWCxDQUF4Qjs7QUFTQXdzQyxVQUFRLG9CQUFSLEVBQThCTCxVQUFXO0FBQ3hDalQscUJBQWlCLE9BRHVCO0FBRXhDMStCLFVBQU0sY0FBVS9LLE1BQVYsRUFBbUI7QUFDeEIsU0FBSXdDLFlBQVl4QyxPQUFPcUMsWUFBUCxFQUFoQjtBQUNBaTJDLGtCQUFjOTFDLFNBQWQsRUFBeUIsSUFBekI7QUFDQTtBQUx1QyxJQUFYLENBQTlCOztBQVFBdTZDLFVBQVEsbUJBQVIsRUFBNkJMLFVBQVc7QUFDdkNqVCxxQkFBaUIsT0FEc0I7QUFFdkMxK0IsVUFBTSxjQUFVL0ssTUFBVixFQUFtQjtBQUN4QixTQUFJd0MsWUFBWXhDLE9BQU9xQyxZQUFQLEVBQWhCO0FBQ0FpMkMsa0JBQWM5MUMsU0FBZDtBQUNBO0FBTHNDLElBQVgsQ0FBN0I7O0FBUUF1NkMsVUFBUSxZQUFSLEVBQXNCTCxVQUFXO0FBQ2hDalQscUJBQWlCLE9BRGU7QUFFaEMxK0IsVUFBTSxjQUFVL0ssTUFBVixFQUFtQjtBQUN4QixTQUFJd0MsWUFBWXhDLE9BQU9xQyxZQUFQLEVBQWhCO0FBQ0E4MkMsaUJBQWEzMkMsU0FBYjtBQUNBO0FBTCtCLElBQVgsQ0FBdEI7O0FBUUF1NkMsVUFBUSxXQUFSLEVBQXFCTCxVQUFXO0FBQy9CdjhDLG9CQUFnQixxQkFEZTtBQUUvQnNwQyxxQkFBaUIscUJBRmM7QUFHL0IxK0IsVUFBTSxjQUFVL0ssTUFBVixFQUFtQjtBQUN4QnE1Qyx1QkFBbUJlLFdBQVlwNkMsT0FBT3FDLFlBQVAsRUFBWixDQUFuQixFQUF3RCxJQUF4RDtBQUNBO0FBTDhCLElBQVgsQ0FBckI7O0FBUUEwNkMsVUFBUSxnQkFBUixFQUEwQkwsVUFBVztBQUNwQ3Y4QyxvQkFBZ0IsYUFEb0I7QUFFcENzcEMscUJBQWlCLGFBRm1CO0FBR3BDMStCLFVBQU0sY0FBVS9LLE1BQVYsRUFBbUI7QUFDeEJxNUMsdUJBQW1CZSxXQUFZcDZDLE9BQU9xQyxZQUFQLEVBQVosRUFBbUMsT0FBbkMsQ0FBbkIsRUFBaUUsSUFBakU7QUFDQTtBQUxtQyxJQUFYLENBQTFCOztBQVFBMDZDLFVBQVEsZUFBUixFQUF5QkwsVUFBVztBQUNuQ3Y4QyxvQkFBZ0IsYUFEbUI7QUFFbkNzcEMscUJBQWlCLGFBRmtCO0FBR25DMStCLFVBQU0sY0FBVS9LLE1BQVYsRUFBbUI7QUFDeEJxNUMsdUJBQW1CZSxXQUFZcDZDLE9BQU9xQyxZQUFQLEVBQVosRUFBbUMsTUFBbkMsQ0FBbkIsRUFBZ0UsSUFBaEU7QUFDQTtBQUxrQyxJQUFYLENBQXpCOztBQVFBMDZDLFVBQVEsbUJBQVIsRUFBNkJMLFVBQVc7QUFDdkN2OEMsb0JBQWdCLGFBRHVCO0FBRXZDc3BDLHFCQUFpQixhQUZzQjtBQUd2QzErQixVQUFNLGNBQVUvSyxNQUFWLEVBQW1CO0FBQ3hCcTVDLHVCQUFtQndDLGtCQUFtQjc3QyxPQUFPcUMsWUFBUCxFQUFuQixDQUFuQjtBQUNBO0FBTHNDLElBQVgsQ0FBN0I7O0FBUUEwNkMsVUFBUSxxQkFBUixFQUErQkwsVUFBVztBQUN6Q3Y4QyxvQkFBZ0IsYUFEeUI7QUFFekNzcEMscUJBQWlCLGFBRndCO0FBR3pDMStCLFVBQU0sY0FBVS9LLE1BQVYsRUFBbUI7QUFDeEJxNUMsdUJBQW1CaUQsb0JBQXFCdDhDLE9BQU9xQyxZQUFQLEVBQXJCLENBQW5CO0FBQ0E7QUFMd0MsSUFBWCxDQUEvQjs7QUFRQTA2QyxVQUFRLGtCQUFSLEVBQTRCTCxVQUFXO0FBQ3RDalQscUJBQWlCLE9BRHFCO0FBRXRDMStCLFVBQU0sY0FBVS9LLE1BQVYsRUFBbUI7QUFDeEIsU0FBSXdDLFlBQVl4QyxPQUFPcUMsWUFBUCxFQUFoQjtBQUNBNDJDLGdCQUFZejJDLFNBQVosRUFBdUIsSUFBdkI7QUFDQTtBQUxxQyxJQUFYLENBQTVCOztBQVFBdTZDLFVBQVEsaUJBQVIsRUFBMkJMLFVBQVc7QUFDckNqVCxxQkFBaUIsT0FEb0I7QUFFckMxK0IsVUFBTSxjQUFVL0ssTUFBVixFQUFtQjtBQUN4QixTQUFJd0MsWUFBWXhDLE9BQU9xQyxZQUFQLEVBQWhCO0FBQ0E0MkMsZ0JBQVl6MkMsU0FBWjtBQUNBO0FBTG9DLElBQVgsQ0FBM0I7QUFPQSxHQXZJb0M7O0FBeUlyQ3F6QyxvQkFBa0JBOztBQXpJbUIsRUFBdEM7QUE0SUEsQ0FoeEJEOztBQWt4QkE7Ozs7Ozs7QUFPQTUxQyxTQUFTd0wsS0FBVCxDQUFlcW9DLGFBQWYsR0FBK0IsVUFBVXpyQixLQUFWLEVBQWtCO0FBQ2hELEtBQUk2MEIsUUFBUTcwQixNQUFNOWxCLENBQU4sQ0FBUTJqQixJQUFwQjs7QUFFQTtBQUNBLEtBQUlpMEIsSUFBSSxDQUFDLENBQVQ7O0FBRUEsS0FBSWdELE9BQU8sRUFBWDs7QUFFQSxNQUFNLElBQUlsMkMsSUFBSSxDQUFkLEVBQWlCQSxJQUFJaTJDLE1BQU1oMkMsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXlDO0FBQ3hDa3pDO0FBQ0EsR0FBQ2dELEtBQU1oRCxDQUFOLENBQUQsS0FBZ0JnRCxLQUFNaEQsQ0FBTixJQUFZLEVBQTVCOztBQUVBLE1BQUkzUixJQUFJLENBQUMsQ0FBVDs7QUFFQSxPQUFNLElBQUl4UyxJQUFJLENBQWQsRUFBaUJBLElBQUlrbkIsTUFBT2oyQyxDQUFQLEVBQVdvdkIsS0FBWCxDQUFpQm52QixNQUF0QyxFQUE4Qzh1QixHQUE5QyxFQUFvRDtBQUNuRCxPQUFJb25CLFFBQVFGLE1BQU9qMkMsQ0FBUCxFQUFXb3ZCLEtBQVgsQ0FBa0JMLENBQWxCLENBQVo7O0FBRUF3UztBQUNBLFVBQVEyVSxLQUFNaEQsQ0FBTixFQUFXM1IsQ0FBWCxDQUFSO0FBQ0NBO0FBREQsSUFHQSxJQUFJNlUsV0FBV3ZsQyxNQUFPc2xDLE1BQU12SyxPQUFiLElBQXlCLENBQXpCLEdBQTZCdUssTUFBTXZLLE9BQWxEO0FBQ0EsT0FBSXlLLFdBQVd4bEMsTUFBT3NsQyxNQUFNbEcsT0FBYixJQUF5QixDQUF6QixHQUE2QmtHLE1BQU1sRyxPQUFsRDs7QUFFQSxRQUFNLElBQUlxRyxLQUFLLENBQWYsRUFBa0JBLEtBQUtELFFBQXZCLEVBQWlDQyxJQUFqQyxFQUF3QztBQUN2QyxRQUFLLENBQUNKLEtBQU1oRCxJQUFJb0QsRUFBVixDQUFOLEVBQ0NKLEtBQU1oRCxJQUFJb0QsRUFBVixJQUFpQixFQUFqQjs7QUFFRCxTQUFNLElBQUlDLEtBQUssQ0FBZixFQUFrQkEsS0FBS0gsUUFBdkIsRUFBaUNHLElBQWpDLEVBQXdDO0FBQ3ZDTCxVQUFNaEQsSUFBSW9ELEVBQVYsRUFBZ0IvVSxJQUFJZ1YsRUFBcEIsSUFBMkJOLE1BQU9qMkMsQ0FBUCxFQUFXb3ZCLEtBQVgsQ0FBa0JMLENBQWxCLENBQTNCO0FBQ0E7QUFDRDs7QUFFRHdTLFFBQUs2VSxXQUFXLENBQWhCO0FBQ0E7QUFDRDtBQUNELFFBQU9GLElBQVA7QUFDQSxDQXJDRCxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzl4QkEsSUFBSU0sbUNBQW1DLFNBQW5DQSxnQ0FBbUMsR0FBVztBQUM5QyxXQUFPLGtDQUFQO0FBQ0gsQ0FGRDs7QUFJQSxJQUFNQyw4QkFBOEI7QUFDaENyMUIsV0FBT28xQjtBQUR5QixDQUFwQzs7a0JBSWVDLDJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSZjs7Ozs7O0FBRUE7QUFDQSxJQUFJQyxpQkFBaUI7QUFDakJ6ckMsVUFBTSxDQURXO0FBRWpCRSxTQUFLO0FBRlksQ0FBckI7O0FBS0E7Ozs7Ozs7QUFPQSxJQUFJd3JDLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBU3h5QixPQUFULEVBQWtCZ2IsSUFBbEIsRUFBd0I7QUFDeEMsUUFBSXlYLGNBQWMsbUJBQVM5dkMsV0FBVCxDQUFxQnFkLE9BQXJCLENBQWxCOztBQUVBLFFBQUkweUIsZ0JBQWdCRCxZQUFZanFDLFdBQVosR0FBMEIsQ0FBOUM7QUFDQSxRQUFJNjZCLGlCQUFpQixJQUFJeHVDLFNBQVN5RCxHQUFULENBQWF0QixNQUFqQixDQUF3QkEsTUFBeEIsRUFBZ0MweEIsaUJBQWhDLEVBQXJCOztBQUVBLFFBQUluZ0IsU0FBU3lYLFFBQVF4aEIsS0FBUixDQUFjK0osTUFBZCxJQUF3QmdxQyxjQUFyQzs7QUFFQSxRQUFJSSxXQUFXM3lCLFFBQVFqVyxnQkFBUixDQUF5Qml4QixLQUFLbDBCLElBQUwsR0FBWWswQixLQUFLL3pCLEtBQUwsR0FBYSxDQUF6QixHQUE2Qm84QixlQUFleDhCLENBQXJFLEVBQXdFbTBCLEtBQUtoMEIsR0FBTCxHQUFXcThCLGVBQWV0OEIsQ0FBbEcsRUFBcUdsUyxTQUFTOFMsdUJBQTlHLENBQWY7O0FBRUFxWSxZQUFRblcsV0FBUixDQUFvQixDQUNoQjhvQyxTQUFTLENBQVQsQ0FEZ0IsRUFFaEJBLFNBQVMsQ0FBVCxDQUZnQixDQUFwQixFQUdHLENBQ0MzWCxLQUFLbDBCLElBQUwsR0FBWWswQixLQUFLL3pCLEtBQUwsR0FBYSxDQUF6QixHQUE2QnlyQyxhQUE3QixHQUE2Q3JQLGVBQWV4OEIsQ0FEN0QsRUFFQ20wQixLQUFLaDBCLEdBQUwsR0FBV3lyQyxZQUFZcHFDLFlBQXZCLEdBQXNDZzdCLGVBQWV0OEIsQ0FBckQsR0FBeUR3QixPQUFPdkIsR0FGakUsQ0FISDtBQU9ILENBakJEOztBQW1CQTs7Ozs7Ozs7QUFRQSxJQUFJNHJDLDRCQUE0QixTQUE1QkEseUJBQTRCLENBQVNuc0IsT0FBVCxFQUFrQjtBQUM5QytyQixrQkFBYyxJQUFkLEVBQW9CL3JCLFFBQVFyZixhQUFSLENBQXNCakMsT0FBdEIsQ0FBOEJzYyxhQUE5QixFQUFwQjs7QUFFQSxXQUFPLElBQVA7QUFDSCxDQUpEOztBQU1BOzs7Ozs7OztBQVFBLElBQUlveEIsNEJBQTRCLFNBQTVCQSx5QkFBNEIsQ0FBU3BzQixPQUFULEVBQWtCO0FBQzlDLFFBQUk5dkIsZUFBZTh2QixRQUFRN3hCLE1BQVIsQ0FBZUYsR0FBZixDQUFtQixjQUFuQixDQUFuQjs7QUFFQSxRQUFJdW9CLFFBQVEsSUFBSXBvQixTQUFTbW1CLEtBQWIsQ0FBbUJya0IsWUFBbkIsRUFBaUNvZSxnQkFBakMsRUFBWjs7QUFFQXk5QixrQkFBYyxJQUFkLEVBQW9CdjFCLE1BQU13RSxhQUFOLEVBQXBCOztBQUVBLFdBQU8sSUFBUDtBQUNILENBUkQ7O0FBVUEsSUFBTXF4Qix1QkFBdUI7QUFDekJ6aEMsV0FBT3VoQyx5QkFEa0I7QUFFekIzMUIsV0FBTzQxQjtBQUZrQixDQUE3Qjs7a0JBS2VDLG9COzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFZixJQUFJQyx1QkFBdUIsU0FBdkJBLG9CQUF1QixDQUFTM3VCLEtBQVQsRUFBZ0JqZixPQUFoQixFQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBT0EsUUFBUXlmLE9BQVIsR0FBa0I5b0IsTUFBbEIsS0FBNkJzb0IsTUFBTXNELFNBQW5DLElBRUN2aUIsUUFBUXNmLE1BQVIsQ0FBZUwsTUFBTXdELGNBQXJCLEtBQ0F6aUIsUUFBUXNmLE1BQVIsQ0FBZUwsTUFBTXFELFlBQXJCLENBREEsSUFFQXJELE1BQU15RCxXQUFOLEtBQXNCekQsTUFBTXNELFNBRjVCLElBR0F0RCxNQUFNc0QsU0FBTixLQUFvQixDQUw1QjtBQU9ILENBZkQ7O0FBaUJBLElBQUlzckIscUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBU3ZzQixPQUFULEVBQWtCO0FBQ3ZDLFFBQUlyZixnQkFBZ0JxZixRQUFRN3VCLElBQVIsQ0FBYXdQLGFBQWpDOztBQUVBLFdBQU8sQ0FBQyxFQUNKQSxjQUFjakMsT0FBZCxJQUNBaUMsY0FBY2pDLE9BQWQsQ0FBc0JjLFlBQXRCLENBQW1DLGFBQW5DLE1BQXNELFVBRmxELENBQVI7QUFJSCxDQVBEOztBQVNBLElBQUlndEMsb0JBQW9CLFNBQXBCQSxpQkFBb0IsQ0FBU3hzQixPQUFULEVBQWtCO0FBQ3RDLFFBQUk5dkIsZUFBZTh2QixRQUFRN3hCLE1BQVIsQ0FBZUYsR0FBZixDQUFtQixjQUFuQixDQUFuQjtBQUNBLFFBQUkwdkIsUUFBUXp0QixhQUFhTSxZQUFiLEdBQTRCb3RCLFNBQTVCLEdBQXdDLENBQXhDLENBQVo7O0FBRUEsUUFBSWxmLE9BQUo7O0FBRUEsV0FBTyxDQUFDLEVBQ0p4TyxhQUFhb3lCLGdCQUFiLE9BQ0M1akIsVUFBVyxJQUFJdFEsU0FBU2lnQixJQUFiLENBQWtCbmUsWUFBbEIsQ0FBRCxDQUFrQ29lLGdCQUFsQyxFQURYLEtBRUE1UCxRQUFReWYsT0FBUixHQUFrQjlvQixNQUFsQixLQUE2QnNvQixNQUFNc0QsU0FGbkMsSUFHQSxDQUFDdmlCLFFBQVFvbUIsVUFBUixFQUhELElBSUEsQ0FBQ3duQixxQkFBcUIzdUIsS0FBckIsRUFBNEJqZixPQUE1QixDQUxHLENBQVI7QUFPSCxDQWJEOztBQWVBLElBQUkrdEMscUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBU3pzQixPQUFULEVBQWtCO0FBQ3ZDLFFBQUlyZixnQkFBZ0JxZixRQUFRN3VCLElBQVIsQ0FBYXdQLGFBQWpDOztBQUVBLFdBQU8sQ0FBQyxFQUNKQSxjQUFjakMsT0FBZCxJQUNBaUMsY0FBY2pDLE9BQWQsQ0FBc0Jvb0IsT0FBdEIsT0FBb0MsS0FEcEMsSUFFQSxDQUFDbm1CLGNBQWNqQyxPQUFkLENBQXNCb21CLFVBQXRCLEVBSEcsQ0FBUjtBQUtILENBUkQ7O0FBVUEsSUFBSTRuQixvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFTMXNCLE9BQVQsRUFBa0I7QUFDdEMsUUFBSTl2QixlQUFlOHZCLFFBQVE3eEIsTUFBUixDQUFlRixHQUFmLENBQW1CLGNBQW5CLENBQW5COztBQUVBLFFBQUkwK0MsaUJBQWlCejhDLGFBQWFveUIsZ0JBQWIsRUFBckI7O0FBRUEsUUFBSTNoQixnQkFBZ0JxZixRQUFRN3VCLElBQVIsQ0FBYXdQLGFBQWpDOztBQUVBLFdBQU8sQ0FBQyxFQUNKLENBQUNBLGNBQWNqQyxPQUFmLElBQ0FpQyxjQUFjSSxNQURkLElBRUEsQ0FBQzRyQyxjQUZELElBR0EsQ0FBQ3o4QyxhQUFhTSxZQUFiLEdBQTRCeXRCLGlCQUE1QixHQUFnRDZHLFVBQWhELEVBSkcsQ0FBUjtBQU1ILENBYkQ7O0FBZUEsSUFBSThuQixxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFTNXNCLE9BQVQsRUFBa0I7QUFDdkMsUUFBSTl2QixlQUFlOHZCLFFBQVE3eEIsTUFBUixDQUFlRixHQUFmLENBQW1CLGNBQW5CLENBQW5COztBQUVBLFFBQUl1b0IsUUFBUSxJQUFJcG9CLFNBQVNtbUIsS0FBYixDQUFtQnJrQixZQUFuQixDQUFaO0FBQ0EsUUFBSXdPLFVBQVU4WCxNQUFNbEksZ0JBQU4sRUFBZDs7QUFFQSxXQUFPLENBQUMsRUFBRTVQLFdBQVc4WCxNQUFNcU8sVUFBTixDQUFpQm5tQixPQUFqQixDQUFiLENBQVI7QUFDSCxDQVBEOztBQVNBLElBQU0vRyxnQkFBZ0I7QUFDbEJ1USxXQUFPcWtDLGtCQURXO0FBRWxCM2hDLFdBQU82aEMsa0JBRlc7QUFHbEJ6NkMsVUFBTXc2QyxpQkFIWTtBQUlsQmgyQixXQUFPbzJCLGtCQUpXO0FBS2xCbHVCLFVBQU1ndUI7QUFMWSxDQUF0Qjs7a0JBUWUvMEMsYTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkZmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTWsxQyxhQUFhLENBQUM7QUFDaEIvekMsVUFBTSxPQURVO0FBRWhCdEUsYUFBUyxDQUFDLGFBQUQsRUFBZ0IsV0FBaEIsQ0FGTztBQUdoQndDLFVBQU0sd0JBQWNrUjtBQUhKLENBQUQsRUFJaEI7QUFDQ3BQLFVBQU0sTUFEUDtBQUVDdEUsYUFBUyxDQUFDLFVBQUQsQ0FGVjtBQUdDd0MsVUFBTSx3QkFBY2hGO0FBSHJCLENBSmdCLEVBUWhCO0FBQ0M4RyxVQUFNLE9BRFA7QUFFQ3RFLGFBQVMsQ0FBQyxXQUFELEVBQWMsYUFBZCxFQUE2QixZQUE3QixDQUZWO0FBR0N5bkIsaUJBQWEsNEJBQXFCclIsS0FIbkM7QUFJQzVULFVBQU0sd0JBQWM0VDtBQUpyQixDQVJnQixFQWFoQjtBQUNDOVIsVUFBTSxNQURQO0FBRUN0RSxhQUFTLENBQUMsUUFBRCxFQUFXLE1BQVgsRUFBbUIsUUFBbkIsRUFBNkIsV0FBN0IsRUFBMEMsTUFBMUMsRUFBa0QsU0FBbEQsQ0FGVjtBQUdDd0MsVUFBTSx3QkFBYzBuQjtBQUhyQixDQWJnQixFQWlCaEI7QUFDQzVsQixVQUFNLE9BRFA7QUFFQ3RFLGFBQVMsQ0FBQyxjQUFELEVBQWlCLFVBQWpCLEVBQTZCLGFBQTdCLEVBQTRDLFdBQTVDLEVBQXlELGFBQXpELENBRlY7QUFHQ29tQix3QkFBb0IsNEJBQTRCcEUsS0FIakQ7QUFJQ3lGLGlCQUFhLDRCQUFxQnpGLEtBSm5DO0FBS0N4ZixVQUFNLHdCQUFjd2Y7QUFMckIsQ0FqQmdCLENBQW5COztrQkF5QmVxMkIsVTs7Ozs7Ozs7Ozs7QUM3QmYsYUFBYSxrQ0FBa0MsRUFBRSxJOzs7Ozs7Ozs7OztBQ0FqRCxhQUFhLHFDQUFxQyxFQUFFLEkiLCJmaWxlIjoiYWxsb3ktZWRpdG9yLWNvcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvYWRhcHRlci9tYWluLmpzXCIpO1xuIiwiaW1wb3J0ICcuLi9jb3JlJztcbmltcG9ydCAnLi4vcGx1Z2lucyc7XG5cbmltcG9ydCAnLi4vY29tcG9uZW50cy91aWJyaWRnZS91aWJyaWRnZS5qcyc7XG5cbmltcG9ydCBleHRlbmQgZnJvbSAnLi4vb29wL29vcCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi9vb3AvbGFuZyc7XG5pbXBvcnQgQmFzZSBmcm9tICcuLi9vb3AvYmFzZSc7XG5pbXBvcnQgU2VsZWN0aW9ucyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbnMnO1xuaW1wb3J0IFVJIGZyb20gJy4uL2NvbXBvbmVudHMvbWFpbi5qc3gnO1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogQWxsb3lFZGl0b3IgbWFpbiBjbGFzcy4gQ3JlYXRlcyBpbnN0YW5jZSBvZiB0aGUgZWRpdG9yIGFuZCBwcm92aWRlcyB0aGUgdXNlciBjb25maWd1cmF0aW9uXG4gKiB0byB0aGUgVUkuXG4gKlxuICogQGNsYXNzIENvcmVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb3JlKGNvbmZpZykge1xuICAgIENvcmUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGNvbmZpZyk7XG59XG5cbmV4dGVuZChDb3JlLCBCYXNlLCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXIgbGlmZWN5Y2xlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgQWxsb3lFZGl0b3IgY2xhc3MuIENyZWF0ZXMgYSBDS0VkaXRvclxuICAgICAqIGluc3RhbmNlLCBwYXNzaW5nIGl0IHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVyXG4gICAgICogQHBhcmFtIGNvbmZpZyB7T2JqZWN0fSBDb25maWd1cmF0aW9uIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIGluaXRpYWxpemVyOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldCgnc3JjTm9kZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmdldCgnZW5hYmxlQ29udGVudEVkaXRhYmxlJykpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IENLRURJVE9SLmlubGluZShub2RlKTtcblxuICAgICAgICBlZGl0b3IuY29uZmlnLmFsbG93ZWRDb250ZW50ID0gdGhpcy5nZXQoJ2FsbG93ZWRDb250ZW50Jyk7XG5cbiAgICAgICAgZWRpdG9yLmNvbmZpZy50b29sYmFycyA9IHRoaXMuZ2V0KCd0b29sYmFycycpO1xuXG4gICAgICAgIGVkaXRvci5jb25maWcucmVtb3ZlUGx1Z2lucyA9IHRoaXMuZ2V0KCdyZW1vdmVQbHVnaW5zJyk7XG4gICAgICAgIGVkaXRvci5jb25maWcuZXh0cmFQbHVnaW5zID0gdGhpcy5nZXQoJ2V4dHJhUGx1Z2lucycpO1xuICAgICAgICBlZGl0b3IuY29uZmlnLnBsYWNlaG9sZGVyQ2xhc3MgPSB0aGlzLmdldCgncGxhY2Vob2xkZXJDbGFzcycpO1xuXG4gICAgICAgIGVkaXRvci5jb25maWcucGFzdGVGcm9tV29yZFJlbW92ZVN0eWxlcyA9IGZhbHNlO1xuICAgICAgICBlZGl0b3IuY29uZmlnLnBhc3RlRnJvbVdvcmRSZW1vdmVGb250U3R5bGVzID0gZmFsc2U7XG5cbiAgICAgICAgZWRpdG9yLmNvbmZpZy5zZWxlY3Rpb25LZXlzdHJva2VzID0gdGhpcy5nZXQoJ3NlbGVjdGlvbktleXN0cm9rZXMnKTtcblxuICAgICAgICBMYW5nLm1peChlZGl0b3IuY29uZmlnLCBjb25maWcpO1xuXG4gICAgICAgIGlmIChDS0VESVRPUi5lbnYuaWUgJiYgIUNLRURJVE9SLmVudi5lZGdlKSB7XG4gICAgICAgICAgICBlZGl0b3IuY29uZmlnLmV4dHJhUGx1Z2lucyA9IGVkaXRvci5jb25maWcuZXh0cmFQbHVnaW5zLnJlcGxhY2UoJ2FlX2RyYWdyZXNpemUnLCAnYWVfZHJhZ3Jlc2l6ZV9pZScpO1xuICAgICAgICAgICAgZWRpdG9yLmNvbmZpZy5yZW1vdmVQbHVnaW5zID0gZWRpdG9yLmNvbmZpZy5yZW1vdmVQbHVnaW5zLnJlcGxhY2UoJ2FlX2RyYWdyZXNpemUnLCAnYWVfZHJhZ3Jlc2l6ZV9pZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdGhpcy5fYWRkUmVhZE9ubHlMaW5rQ2xpY2tMaXN0ZW5lcihlZGl0b3IpO1xuXG4gICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgZWRpdGFibGUuYWRkQ2xhc3MoJ2FlLWVkaXRhYmxlJyk7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgICAgQWxsb3lFZGl0b3IubG9hZExhbmd1YWdlUmVzb3VyY2VzKHRoaXMuX3JlbmRlclVJLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cnVjdG9yIGxpZmVjeWNsZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIEFsbG95RWR0b3IgY2xhc3MuIERlc3Ryb3lzIHRoZSBDS0VkaXRvclxuICAgICAqIGluc3RhbmNlIGFuZCBkZXN0cm95cyBhbGwgY3JlYXRlZCB0b29sYmFycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgZGVzdHJ1Y3RvclxuICAgICAqL1xuICAgIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLl9lZGl0b3JVSUVsZW1lbnQpIHtcbiAgICAgICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5fZWRpdG9yVUlFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRvclVJRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2VkaXRvclVJRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdGhpcy5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGlmIChuYXRpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IG5hdGl2ZUVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICBpZiAoZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBlZGl0YWJsZS5yZW1vdmVDbGFzcygnYWUtZWRpdGFibGUnKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldCgnZW5hYmxlQ29udGVudEVkaXRhYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXQoJ3NyY05vZGUnKS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxlY3Rpb25zKCk7XG5cbiAgICAgICAgICAgIG5hdGl2ZUVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBzZWxlY3Rpb25zIGZyb20gd2luZG93IG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfY2xlYXJTZWxlY3Rpb25zXG4gICAgICovXG4gICAgX2NsZWFyU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciBpc01TU2VsZWN0aW9uID0gdHlwZW9mIHdpbmRvdy5nZXRTZWxlY3Rpb24gIT0gJ2Z1bmN0aW9uJztcblxuICAgICAgICBpZiAoaXNNU1NlbGVjdGlvbikge1xuICAgICAgICAgICAgbmF0aXZlRWRpdG9yLmRvY3VtZW50LiQuc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYXRpdmVFZGl0b3IuZG9jdW1lbnQuZ2V0V2luZG93KCkuJC5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gc2V0IGRlZmF1bHQgbGluayBiZWhhdmlvclxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfYWRkUmVhZE9ubHlMaW5rQ2xpY2tMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3JcbiAgICAgKi9cbiAgICBfYWRkUmVhZE9ubHlMaW5rQ2xpY2tMaXN0ZW5lcjogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIGVkaXRvci5lZGl0YWJsZSgpLm9uKCdjbGljaycsIHRoaXMuX2RlZmF1bHRSZWFkT25seUNsaWNrRm4sIHRoaXMsIHtcbiAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gYGNsaWNrYCBldmVudCB3aGVuIHRoZSBlZGl0b3IgaXMgaW4gcmVhZCBvbmx5IG1vZGUuIE5hdmlnYXRlcyB0byBsaW5rJ3MgVVJMIG9yIG9wZW5zXG4gICAgICogdGhlIGxpbmsgaW4gYSBuZXcgd2luZG93LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZXZlbnQgcmVhZE9ubHlDbGlja1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9kZWZhdWx0UmVhZE9ubHlDbGlja0ZuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBmaXJlZCBgY2xpY2tgIGV2ZW50IHBheWxvYWRcbiAgICAgKi9cbiAgICBfZGVmYXVsdFJlYWRPbmx5Q2xpY2tGbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG4gICAgICAgIHZhciBoYXNDdHJsS2V5ID0gbW91c2VFdmVudC5jdHJsS2V5IHx8IG1vdXNlRXZlbnQubWV0YUtleTtcbiAgICAgICAgdmFyIHNob3VsZE9wZW4gPSB0aGlzLl9lZGl0b3IuY29uZmlnLnJlYWRPbmx5IHx8IGhhc0N0cmxLZXk7XG5cbiAgICAgICAgbW91c2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghc2hvdWxkT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3IuZWRpdGFibGUoKS5lZGl0b3IuZmlyZSgncmVhZE9ubHlDbGljaycsIGV2ZW50LmRhdGEpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIGNrRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudFBhdGgoZXZlbnQuZGF0YS5nZXRUYXJnZXQoKSwgdGhpcyk7XG4gICAgICAgICAgICB2YXIgbGluayA9IGNrRWxlbWVudC5sYXN0RWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IGxpbmsuJC5hdHRyaWJ1dGVzLmhyZWYgPyBsaW5rLiQuYXR0cmlidXRlcy5ocmVmLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gaGFzQ3RybEtleSA/ICdfYmxhbmsnIDogbGluay4kLmF0dHJpYnV0ZXMudGFyZ2V0ID8gbGluay4kLmF0dHJpYnV0ZXMudGFyZ2V0LnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWRpcmVjdExpbmsoaHJlZiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5hdGl2ZSBDS0VkaXRvciBpbnN0YW5jZS4gSGF2aW5nIHRoaXMsIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSB0aGUgQVBJIG9mIENLRWRpdG9yIE9PVEIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9nZXROYXRpdmVFZGl0b3JcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIG9mIENLRWRpdG9yLlxuICAgICAqL1xuICAgIF9nZXROYXRpdmVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWRpcmVjdHMgdGhlIGJyb3dzZXIgdG8gYSBnaXZlbiBsaW5rXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9yZWRpcmVjdExpbmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiBUaGUgaHJlZiB0byB0YWtlIHRoZSBicm93c2VyIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0YXJnZXQgU3BlY2lmaWVzIHdoZXJlIHRvIGRpc3BsYXkgdGhlIGxpbmtcbiAgICAgKi9cbiAgICBfcmVkaXJlY3RMaW5rOiBmdW5jdGlvbihocmVmLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiBocmVmKSB7XG4gICAgICAgICAgICB3aW5kb3cub3BlbihocmVmLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBzcGVjaWZpZWQgZnJvbSB0aGUgdXNlciB0b29sYmFycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX3JlbmRlclVJXG4gICAgICovXG4gICAgX3JlbmRlclVJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3JVSUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGVkaXRvclVJRWxlbWVudC5jbGFzc05hbWUgPSAnYWUtdWknO1xuXG4gICAgICAgICAgICB2YXIgdWlOb2RlID0gdGhpcy5nZXQoJ3VpTm9kZScpIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgICAgIHVpTm9kZS5hcHBlbmRDaGlsZChlZGl0b3JVSUVsZW1lbnQpO1xuXG4gICAgICAgICAgICB0aGlzLl9tYWluVUkgPSBSZWFjdERPTS5yZW5kZXIoPFVJXG4gICAgICAgICAgICAgICAgZWRpdG9yPXt0aGlzfVxuICAgICAgICAgICAgICAgIGV2ZW50c0RlbGF5PXt0aGlzLmdldCgnZXZlbnRzRGVsYXknKX1cbiAgICAgICAgICAgICAgICB0b29sYmFycz17dGhpcy5nZXQoJ3Rvb2xiYXJzJyl9IC8+LCBlZGl0b3JVSUVsZW1lbnQpO1xuXG4gICAgICAgICAgICB0aGlzLl9lZGl0b3JVSUVsZW1lbnQgPSBlZGl0b3JVSUVsZW1lbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0KCduYXRpdmVFZGl0b3InKS5maXJlKCd1aVJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYW4gSFRNTCBlbGVtZW50IGZyb20gdGhlIHBhc3NlZCB2YWx1ZS4gSWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIHN0cmluZywgaXQgc2hvdWxkIGJlXG4gICAgICogdGhlIElkIG9mIHRoZSBlbGVtZW50IHdoaWNoIGhhdmUgdG8gYmUgcmV0cmlldmVkIGZyb20gdGhlIERPTS5cbiAgICAgKiBJZiBhbiBIVE1MIEVsZW1lbnQgaXMgcGFzc2VkLCB0aGUgZWxlbWVudCBpdHNlbGYgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1ldGhvZCBfdG9FbGVtZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7IShTdHJpbmd8SFRNTEVsZW1lbnQpfSB2YWx1ZSBTdHJpbmcsIHdoaWNoIGhhdmUgdG8gY29ycmVzcG9uZCB0byBhbiBIVE1MIGVsZW1lbnQgZnJvbSB0aGUgRE9NLFxuICAgICAqIG9yIHRoZSBIVE1MIGVsZW1lbnQgaXRzZWxmLiBJZiBJZCBpcyBwYXNzZWQsIHRoZSBIVE1MIGVsZW1lbnQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBBbiBIVE1MIGVsZW1lbnQuXG4gICAgICovXG4gICAgX3RvRWxlbWVudDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKExhbmcuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBhbGxvd2VkIGNvbnRlbnQgYXR0cmlidXRlLiBMb29rXG4gICAgICogW2hlcmVdKGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1IuY29uZmlnLWNmZy1hbGxvd2VkQ29udGVudCkgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gICAgICogc3VwcG9ydGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX3ZhbGlkYXRlQWxsb3dlZENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge0FueX0gVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjdXJyZW50IHZhbHVlIGlzIHZhbGlkIGNvbmZpZ3VyYXRpb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIF92YWxpZGF0ZUFsbG93ZWRDb250ZW50OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTGFuZy5pc1N0cmluZyh2YWx1ZSkgfHwgTGFuZy5pc09iamVjdCh2YWx1ZSkgfHwgTGFuZy5pc0Jvb2xlYW4odmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHZhbHVlIG9mIHRvb2xiYXJzIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfdmFsaWRhdGVUb29sYmFyc1xuICAgICAqIEBwYXJhbSB7QW55fSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgdmFsaWQgdG9vbGJhcnMgY29uZmlndXJhdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlVG9vbGJhcnM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBMYW5nLmlzT2JqZWN0KHZhbHVlKSB8fCBMYW5nLmlzTnVsbCh2YWx1ZSk7XG4gICAgfVxufSwge1xuICAgIEFUVFJTOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoZSBhbGxvd2VkIGNvbnRlbnQgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIEFsbG95RWRpdG9yLlxuICAgICAgICAgKiBMb29rIG9uIHRoZSBbb2ZmaWNpYWwgQ0tFZGl0b3IgQVBJXShodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLmNvbmZpZy1jZmctYWxsb3dlZENvbnRlbnQpXG4gICAgICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2YWxpZCB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgYWxsb3dlZENvbnRlbnRcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKiBAd3JpdGVPbmNlXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFuLCBTdHJpbmcsIE9iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGFsbG93ZWRDb250ZW50OiB7XG4gICAgICAgICAgICB2YWxpZGF0b3I6ICdfdmFsaWRhdGVBbGxvd2VkQ29udGVudCcsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBBbGxveUVkaXRvciBzZXQgdGhlIGNvbnRlbnRlZGl0YWJsZSBhdHRyaWJ1dGVcbiAgICAgICAgICogdG8gXCJ0cnVlXCIgb24gaXRzIHNyY05vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgZW5hYmxlQ29udGVudEVkaXRhYmxlXG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKiBAd3JpdGVPbmNlXG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGVDb250ZW50RWRpdGFibGU6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogTGFuZy5pc0Jvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgKHRpbWVvdXQpLCBpbiBtcywgYWZ0ZXIgd2hpY2ggZXZlbnRzIHN1Y2ggbGlrZSBrZXkgb3IgbW91c2UgZXZlbnRzIHdpbGwgYmUgcHJvY2Vzc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IGV2ZW50c0RlbGF5XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBldmVudHNEZWxheToge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBMYW5nLmlzTnVtYmVyLFxuICAgICAgICAgICAgdmFsdWU6IDEwMFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGV4dHJhIHBsdWdpbnMgd2hpY2ggaGF2ZSB0byBiZSBsb2FkZWQgdG8gdGhlIGN1cnJlbnQgQ0tFZGl0b3IgaW5zdGFuY2UgaW4gb3JkZXIgdG9cbiAgICAgICAgICogbWFrZSBBbGxveUVkaXRvciB0byB3b3JrIHByb3Blcmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IGV4dHJhUGx1Z2luc1xuICAgICAgICAgKiBAZGVmYXVsdCAndWljb3JlLHNlbGVjdGlvbnJlZ2lvbixkcmFncmVzaXplLGFkZGltYWdlcyxwbGFjZWhvbGRlcix0YWJsZXRvb2xzLHRhYmxlcmVzaXplLGF1dG9saW5rJ1xuICAgICAgICAgKiBAd3JpdGVPbmNlXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBleHRyYVBsdWdpbnM6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiAnYWVfdWljb3JlLGFlX3NlbGVjdGlvbnJlZ2lvbixhZV9zZWxlY3Rpb25rZXlzdHJva2VzLGFlX2ltYWdlYWxpZ25tZW50LGFlX2FkZGltYWdlcyxhZV9wbGFjZWhvbGRlciwnICtcbiAgICAgICAgICAgICAgICAnYWVfdGFibGV0b29scyxhZV90YWJsZXJlc2l6ZSxhZV9hdXRvbGluayxhZV9lbWJlZCxhZV9hdXRvbGlzdCxhZV9kcmFncmVzaXplLCcgK1xuICAgICAgICAgICAgICAgICdhZV91aWJyaWRnZScsXG4gICAgICAgICAgICAgICAgLy8nYWVfdWlicmlkZ2UsYWVfcmljaGNvbWJvYnJpZGdlLGFlX3BhbmVsbWVudWJ1dHRvbmJyaWRnZSxhZV9tZW51YnJpZGdlLGFlX21lbnVidXR0b25icmlkZ2UsYWVfYnV0dG9uYnJpZGdlJyxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIG5hdGl2ZSBDS0VkaXRvciBpbnN0YW5jZS4gSGF2aW5nIHRoaXMsIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSB0aGUgZnVsbCBBUEkgb2YgQ0tFZGl0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgbmF0aXZlRWRpdG9yXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbmF0aXZlRWRpdG9yOiB7XG4gICAgICAgICAgICBnZXR0ZXI6ICdfZ2V0TmF0aXZlRWRpdG9yJyxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgY2xhc3MsIHdoaWNoIHNob3VsZCBiZSBhZGRlZCBieSBQbGFjZWhvbGRlciBwbHVnaW5cbiAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9wbGFjZWhvbGRlcn19e3svY3Jvc3NMaW5rfX1cbiAgICAgICAgICogd2hlbiBlZGl0b3IgaXMgbm90IGZvY3VzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgcGxhY2Vob2xkZXJDbGFzc1xuICAgICAgICAgKiBAZGVmYXVsdCAnYWUtcGxhY2Vob2xkZXInXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHBsYWNlaG9sZGVyQ2xhc3M6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiAnYWUtcGxhY2Vob2xkZXInLFxuICAgICAgICAgICAgd3JpdGVPbmNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcGx1Z2lucywgd2hpY2ggY29tZSBieSBkZWZhdWx0IHdpdGggQ0tFZGl0b3IsIGJ1dCB3aGljaCBhcmUgbm90IG5lZWRlZCBieSBBbGxveUVkaXRvci5cbiAgICAgICAgICogVGhlc2UgcGx1Z2lucyBhZGQgdGhlIGRlZmF1bHQgVUkgZm9yIENLZWRpdG9yLCB3aGljaCBpcyBubyBtb3JlIG5lZWRlZC4gUGxlYXNlIG5vdGUgdGhhdCBBbGxveUVkdG9yXG4gICAgICAgICAqIGNvbWVzIHdpdGggaXRzIG93biBoaWdobHkgb3B0aW1pemVkIGNvcHkgb2YgQ0tFZGl0b3IgKGp1c3QgY3VzdG9taXplZCB2aWEgdGhlaXIgb2ZmaWNpYWwgZG93bmxvYWQgcGFnZSkuXG4gICAgICAgICAqIFRoaXMgdmVyc2lvbiBkb2VzIG5vdCBjb21lIHdpdGggdGhlIHVubmVlZGVkIHBsdWdpbnMsIHNvIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IHdvbid0IGJlIG5lZWRlZC5cbiAgICAgICAgICogSG93ZXZlciwgaWYgeW91IGRlY2lkZSB0byBnbyB3aXRoIHRoZSBPT1RCIHZlcnNpb24gb2YgQ0tFZGl0b3IsIHlvdSB3aWxsIGhhdmUgdG8gcmVtb3ZlIHNvbWUgb2YgdGhlXG4gICAgICAgICAqIHBsdWdpbnMgaWYgeW91IGRlY2lkZSB0byB1c2UgQWxsb3lFZGl0b3IuIEtlZXAgaW4gbWluZCB0aGF0IHJlbW92aW5nIHRoZXNlIHBsdWdpbnMgZG9lc24ndCByZW1vdmUgdGhlbVxuICAgICAgICAgKiBlbnRpcmVseSBmcm9tIENLRWRpdG9yLiBJdCBqdXN0IHJlbW92ZXMgdGhlbSBmcm9tIGl0cyBjdXJyZW50IGluc3RhbmNlLCBpbiB3aGljaCB5b3Ugd2lsbCB1c2UgZGlmZmVyZW50XG4gICAgICAgICAqIFVJIC0gdGhvc2Ugb2YgQWxsb3lFZGl0b3IuIFlvdSB3aWxsIGJlIGZ1bGx5IGFibGUgdG8gdXNlIGJvdGggT09UQiBDS0VkaXRvciBhbmQgQWxsb3lFZGl0b3Igb24gdGhlIHNhbWVcbiAgICAgICAgICogcGFnZSFcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZW1vdmVQbHVnaW5zXG4gICAgICAgICAqIEBkZWZhdWx0ICdjb250ZXh0bWVudSx0b29sYmFyLGVsZW1lbnRzcGF0aCxyZXNpemUsbGlzdHN0eWxlLGxpbmsnXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVBsdWdpbnM6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiAnY29udGV4dG1lbnUsdG9vbGJhcixlbGVtZW50c3BhdGgscmVzaXplLGxpc3RzdHlsZSxsaW5rJyxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcnJheSBvZiBtYW51YWwgc2VsZWN0aW9uIHRyaWdnZXJzLiBUaGV5IGNhbiBiZSBjb25maWd1cmVkIHRvIG1hbnVhbGx5IHNob3cgYSBzcGVjaWZpYyBzZWxlY3Rpb24gdG9vbGJhclxuICAgICAgICAgKiBieSBmb3JjaW5nIHRoZSBzZWxlY3Rpb24gdHlwZS4gQSBzZWxlY3Rpb25LZXlzdHJva2UgaXRlbSBjb25zaXN0cyBvZiBhIGtleXMgcHJvcGVydHkgd2l0aCBhIFtDS0VkaXRvciBrZXlzdHJva2VcbiAgICAgICAgICogZGVmaW5pdGlvbl0oaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5jb25maWctY2ZnLWtleXN0cm9rZXMpIGFuZCBhIHNlbGVjdGlvbiBwcm9wZXJ0eSB3aXRoXG4gICAgICAgICAqIHRoZSBzZWxlY3Rpb24gbmFtZSB0byB0cmlnZ2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IHNlbGVjdGlvbktleXN0cm9rZXNcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uS2V5c3Ryb2tlczoge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBMYW5nLmlzQXJyYXksXG4gICAgICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAgICAgICBrZXlzOiBDS0VESVRPUi5DVFJMICsgNzYgLypMKi8sXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiAnbGluaydcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXlzOiBDS0VESVRPUi5DVFJMICsgQ0tFRElUT1IuU0hJRlQgKyA3NiAvKkwqLyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246ICdlbWJlZCdcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBOb2RlIElEIG9yIEhUTWwgbm9kZSwgd2hpY2ggQWxsb3lFZGl0b3Igc2hvdWxkIHVzZSBhcyBhbiBlZGl0YWJsZSBhcmVhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IHNyY05vZGVcbiAgICAgICAgICogQHR5cGUgU3RyaW5nIHwgTm9kZVxuICAgICAgICAgKiBAd3JpdGVPbmNlXG4gICAgICAgICAqL1xuICAgICAgICBzcmNOb2RlOiB7XG4gICAgICAgICAgICBzZXR0ZXI6ICdfdG9FbGVtZW50JyxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9vbGJhcnMgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0b29sYmFyc1xuICAgICAgICAgKi9cbiAgICAgICAgdG9vbGJhcnM6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogJ192YWxpZGF0ZVRvb2xiYXJzJyxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgYWRkOiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFsnaW1hZ2UnLCAnZW1iZWQnLCAnY2FtZXJhJywgJ2hsaW5lJywgJ3RhYmxlJ10sXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiAyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uczogU2VsZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBOb2RlIElEIG9yIEhUTWwgbm9kZSwgd2hlcmUgQWxsb3lFZGl0b3IncyBVSSBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgdWlOb2RlXG4gICAgICAgICAqIEB0eXBlIFN0cmluZyB8IE5vZGVcbiAgICAgICAgICogQHdyaXRlT25jZVxuICAgICAgICAgKi9cbiAgICAgICAgdWlOb2RlOiB7XG4gICAgICAgICAgICBzZXR0ZXI6ICdfdG9FbGVtZW50JyxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkNLRURJVE9SLmV2ZW50LmltcGxlbWVudE9uKENvcmUpO1xuXG5leHBvcnQgZGVmYXVsdCBDb3JlO1xuIiwiaW1wb3J0IENvcmUgZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCBMYW5nIGZyb20gJy4uL29vcC9sYW5nLmpzJztcblxuaW1wb3J0IEJ1dHRvbnMgZnJvbSAnLi4vY29tcG9uZW50cy9idXR0b25zJztcbmltcG9ydCBUb29sYmFycyBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2xiYXJzJztcblxuaW1wb3J0IFNlbGVjdGlvblRlc3QgZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdC5qcyc7XG5cbi8vIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBjdXJyZW50bHkgcmVnaXN0ZXJlZCBwbHVnaW5zIGluIEFsbG95RWRpdG9yLlxudmFyIEJSSURHRV9CVVRUT05TID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBBbGxveUVkaXRvci5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZWRpdGFibGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfE5vZGV9IG5vZGUgVGhlIE5vZGUgSUQgb3IgSFRNbCBub2RlLCB3aGljaCBBbGxveUVkaXRvciBzaG91bGQgdXNlIGFzIGFuIGVkaXRhYmxlIGFyZWEuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgQWxsb3lFZGl0b3IuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIGluc3RhbmNlIG9mIHt7I2Nyb3NzTGluayBcIkNvcmVcIn19e3svY3Jvc3NMaW5rfX1cbiAqL1xuY29uc3QgZWRpdGFibGUgPSBmdW5jdGlvbihub2RlLCBjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgY29uZmlnLnNyY05vZGUgPSBub2RlO1xuXG4gICAgQWxsb3lFZGl0b3IuaW1wbGVtZW50RXZlbnRUYXJnZXQoKTtcblxuICAgIHJldHVybiBuZXcgQ29yZShjb25maWcpO1xufTtcblxuLyoqXG4gKiBUaGUgZnVsbCBVUkwgZm9yIHRoZSBBbGxveUVkaXRvciBpbnN0YWxsYXRpb24gZGlyZWN0b3J5LlxuICogSXQgaXMgcG9zc2libGUgdG8gbWFudWFsbHkgcHJvdmlkZSB0aGUgYmFzZSBwYXRoIGJ5IHNldHRpbmcgYVxuICogZ2xvYmFsIHZhcmlhYmxlIG5hbWVkIGBBTExPWUVESVRPUl9CQVNFUEFUSGAuIFRoaXMgZ2xvYmFsIHZhcmlhYmxlXG4gKiBtdXN0IGJlIHNldCAqKmJlZm9yZSoqIHRoZSBlZGl0b3Igc2NyaXB0IGxvYWRpbmcuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGdldEJhc2VQYXRoXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmb3VuZCBiYXNlIHBhdGhcbiAqL1xuY29uc3QgZ2V0QmFzZVBhdGggPSBmdW5jdGlvbigpIHtcbiAgICAvLyBGaW5kIG91dCB0aGUgZWRpdG9yIGRpcmVjdG9yeSBwYXRoLCBiYXNlZCBvbiBpdHMgPHNjcmlwdD4gdGFnLlxuICAgIHZhciBwYXRoID0gd2luZG93LkFMTE9ZRURJVE9SX0JBU0VQQVRIIHx8ICcnO1xuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gc2NyaXB0c1sgaSBdLnNyYy5tYXRjaChBbGxveUVkaXRvci5yZWdleEJhc2VQYXRoKTtcblxuXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBJRSAob25seSkgdGhlIHNjcmlwdC5zcmMgc3RyaW5nIGlzIHRoZSByYXcgdmFsdWUgZW50ZXJlZCBpbiB0aGVcbiAgICAvLyBIVE1MIHNvdXJjZS4gT3RoZXIgYnJvd3NlcnMgcmV0dXJuIHRoZSBmdWxsIHJlc29sdmVkIFVSTCBpbnN0ZWFkLlxuICAgIGlmIChwYXRoLmluZGV4T2YoJzovJykgPT09IC0xICYmIHBhdGguc2xpY2UoMCwgMikgIT09ICcvLycgKSB7XG4gICAgICAgIC8vIEFic29sdXRlIHBhdGguXG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICAgICAgcGF0aCA9IGxvY2F0aW9uLmhyZWYubWF0Y2goL14uKj86XFwvXFwvW15cXC9dKi8pWzBdICsgcGF0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWxhdGl2ZSBwYXRoLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBsb2NhdGlvbi5ocmVmLm1hdGNoKC9eW15cXD9dKlxcLyg/OikvKVswXSArIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhdGgpe1xuICAgICAgICB0aHJvdyAnVGhlIEFsbG95RWRpdG9yIGluc3RhbGxhdGlvbiBwYXRoIGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGRldGVjdGVkLiBQbGVhc2Ugc2V0IHRoZSBnbG9iYWwgdmFyaWFibGUgXCJBTExPWUVESVRPUl9CQVNFUEFUSFwiIGJlZm9yZSBjcmVhdGluZyBlZGl0b3IgaW5zdGFuY2VzLic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIERldGVjdHMgYW5kIGxvYWQgdGhlIGNvcnJlc3BvbmRpbmcgbGFuZ3VhZ2UgZmlsZSBpZiBBbGxveUVkaXRvciBsYW5ndWFnZSBzdHJpbmdzIGFyZSBub3QgYWxyZWFkeSBwcmVzZW50LlxuICogVGhlIGZ1bmN0aW9uIGZpcmVzIGEge3sjY3Jvc3NMaW5rIFwiQWxsb3lFZGl0b3IvbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgbG9hZExhbmd1YWdlUmVzb3VyY2VzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBBbGxveUVkaXRvciBsb2FkcyB0aGUgbGFuZ3VhZ2UgcmVzb3VyY2UuXG4gKi9cbmNvbnN0IGxvYWRMYW5ndWFnZVJlc291cmNlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgQWxsb3lFZGl0b3IuaW1wbGVtZW50RXZlbnRUYXJnZXQoKTtcblxuICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgIGlmIChBbGxveUVkaXRvci5TdHJpbmdzKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFsbG95RWRpdG9yLm9uY2UoJ2xhbmd1YWdlUmVzb3VyY2VzTG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghQWxsb3lFZGl0b3IuX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCkge1xuICAgICAgICBBbGxveUVkaXRvci5fbGFuZ1Jlc291cmNlUmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbGFuZ3VhZ2VzID0gWydhZicsICdhcicsICdiZycsICdibicsICdicycsICdjYScsICdjcycsICdjeScsICdkYScsICdkZScsICdlbCcsICdlbi1hdScsICdlbi1jYScsICdlbi1nYicsICdlbicsICdlbycsICdlcycsICdldCcsICdldScsICdmYScsICdmaScsICdmbycsICdmci1jYScsICdmcicsICdnbCcsICdndScsICdoZScsICdoaScsICdocicsICdodScsICdpZCcsICdpcycsICdpdCcsICdqYScsICdrYScsICdrbScsICdrbycsICdrdScsICdsdCcsICdsdicsICdtaycsICdtbicsICdtcycsICduYicsICdubCcsICdubycsICdwbCcsICdwdC1icicsICdwdCcsICdybycsICdydScsICdzaScsICdzaycsICdzbCcsICdzcScsICdzci1sYXRuJywgJ3NyJywgJ3N2JywgJ3RoJywgJ3RyJywgJ3R0JywgJ3VnJywgJ3VrJywgJ3ZpJywgJ3poLWNuJywgJ3poJ107XG5cbiAgICAgICAgdmFyIHVzZXJMYW5ndWFnZSA9IG5hdmlnYXRvci5sYW5ndWFnZSB8fCBuYXZpZ2F0b3IudXNlckxhbmd1YWdlIHx8ICdlbic7XG5cbiAgICAgICAgdmFyIHBhcnRzID0gdXNlckxhbmd1YWdlLnRvTG93ZXJDYXNlKCkubWF0Y2goLyhbYS16XSspKD86LShbYS16XSspKT8vKTtcbiAgICAgICAgdmFyIGxhbmcgPSBwYXJ0c1sxXTtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHBhcnRzWzJdO1xuXG4gICAgICAgIGlmIChsYW5ndWFnZXMuaW5kZXhPZihsYW5nICsgJy0nICsgbG9jYWxlKSA+PSAwKSB7XG4gICAgICAgICAgICBsYW5nID0gbGFuZyArICctJyArIGxvY2FsZTtcbiAgICAgICAgfSBlbHNlIGlmIChsYW5ndWFnZXMuaW5kZXhPZihsYW5nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxhbmcgPSAnZW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgQ0tFRElUT1Iuc2NyaXB0TG9hZGVyLmxvYWQoQWxsb3lFZGl0b3IuZ2V0VXJsKCdsYW5nL2FsbG95LWVkaXRvci8nICsgbGFuZyArICcuanMnKSwgZnVuY3Rpb24obG9hZGVkKSB7XG4gICAgICAgICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgQWxsb3lFZGl0b3IuZmlyZSgnbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBmdWxsIFVSTCBmb3IgQWxsb3lFZGl0b3IgcmVzb3VyY2VzLiBCeSBkZWZhdWx0LCBVUkxzXG4gKiByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIGNvbnRhaW4gYSBxdWVyeXN0cmluZyBwYXJhbWV0ZXIgKFwidFwiKVxuICogc2V0IHRvIHRoZSB7QGxpbmsgQ0tFRElUT1IjdGltZXN0YW1wfSB2YWx1ZS5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZ2V0VXJsXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzb3VyY2UgVGhlIHJlc291cmNlIHdob3NlIGZ1bGwgVVJMIHdlIHdhbnQgdG8gZ2V0LlxuICogSXQgbWF5IGJlIGEgZnVsbCwgYWJzb2x1dGUsIG9yIHJlbGF0aXZlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZ1bGwgVVJMLlxuICovXG5jb25zdCBnZXRVcmwgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgIHZhciBiYXNlUGF0aCA9IEFsbG95RWRpdG9yLmdldEJhc2VQYXRoKCk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIGZ1bGwgb3IgYWJzb2x1dGUgcGF0aC5cbiAgICBpZiAocmVzb3VyY2UuaW5kZXhPZignOi8nKSA9PT0gLTEgJiYgcmVzb3VyY2UuaW5kZXhPZignLycpICE9PSAwKSB7XG4gICAgICAgIHJlc291cmNlID0gYmFzZVBhdGggKyByZXNvdXJjZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHRpbWVzdGFtcCwgZXhjZXB0IGZvciBkaXJlY3Rvcmllcy5cbiAgICBpZiAoQ0tFRElUT1IudGltZXN0YW1wICYmIHJlc291cmNlLmNoYXJBdCggcmVzb3VyY2UubGVuZ3RoIC0gMSApICE9PSAnLycgJiYgISgvWyY/XXQ9LykudGVzdChyZXNvdXJjZSkpIHtcbiAgICAgICAgcmVzb3VyY2UgKz0gKHJlc291cmNlLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArICd0PScgKyBDS0VESVRPUi50aW1lc3RhbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc291cmNlO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGV2ZW50IGZpcmluZyBhbmQgc3Vic2NyaWJpbmcgdmlhIENLRURJVE9SLmV2ZW50LlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBpbXBsZW1lbnRFdmVudFRhcmdldFxuICogQHN0YXRpY1xuICovXG5jb25zdCBpbXBsZW1lbnRFdmVudFRhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghQWxsb3lFZGl0b3IuZmlyZSAmJiAhQWxsb3lFZGl0b3Iub24pIHtcbiAgICAgICAgQ0tFRElUT1IuZXZlbnQuaW1wbGVtZW50T24oQWxsb3lFZGl0b3IpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdoaWNoIHNob3VsZCBtYXRjaCB0aGUgc2NyaXB0IHdoaWNoIGhhdmUgYmVlbiB1c2VkIHRvIGxvYWQgQWxsb3lFZGl0b3IuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAcHJvcGVydHkgcmVnZXhCYXNlUGF0aFxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgcmVnZXhCYXNlUGF0aCA9IC8oXnwuKltcXFxcXFwvXSkoPzphbGxveS1lZGl0b3JbXi9dK3xhbGxveS1lZGl0b3IpXFwuanMoPzpcXD8uKnw7LiopPyQvaTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIEFsbG95RWRpdG9yIGRldGVjdHMgdGhlIGJyb3dzZXIgbGFuZ3VhZ2UgYW5kIGxvYWRzIHRoZSBjb3JyZXNwb25kaW5nIGxhbmd1YWdlIGZpbGUuIE9uY2UgdGhpcyBldmVudFxuICogaXMgZmlyZWQsIEFsbG95RWRpdG9yLlN0cmluZ3Mgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBldmVudCBsYW5ndWFnZVJlc291cmNlc0xvYWRlZFxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgcGx1Z2luIG5hbWVzIG5lZWRlZCBmb3IgYSBnaXZlbiBwbHVnaW5cbiAqIGlmIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBvciBhbiBlbXB0eSBhcnJheS5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZ2V0QnV0dG9uc1xuICogQHBhcmFtIHtBcnJheX0gYnV0dG9ucyBBbiBhcnJheSBvZiBidXR0b25zIG9yIHBsdWdpbiBuYW1lcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGludm9rZWQgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdGVkIGJ1dHRvbiBuYW1lcy5cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgZ2V0QnV0dG9ucyA9IGZ1bmN0aW9uKGJ1dHRvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBidXR0b25zLnJlZHVjZShmdW5jdGlvbihhY2MsIHZhbCkge1xuICAgICAgICAgICAgdmFsID0gQlJJREdFX0JVVFRPTlNbdmFsXSB8fCBbdmFsXTtcbiAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHZhbCk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJ1dHRvbiBhbmQgdHJ5IHRvIGdldCBpdHMgcmVxdWlyZWQgcGx1Z2lucy5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgcmVnaXN0ZXJCcmlkZ2VCdXR0b25cbiAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b25OYW1lIFRoZSBuYW1lIG9mIHRoZSBidXR0b24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGx1Z2luTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRoYXQgcmVnaXN0ZXJzIHRoZSBidXR0b24uXG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IHJlZ2lzdGVyQnJpZGdlQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uTmFtZSwgcGx1Z2luTmFtZSkge1xuICAgIGlmICghQlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0pIHtcbiAgICAgICAgQlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBCUklER0VfQlVUVE9OU1twbHVnaW5OYW1lXS5wdXNoKGJ1dHRvbk5hbWUpO1xufTtcblxuZXhwb3J0IHtcbiAgICBCdXR0b25zLFxuICAgIGVkaXRhYmxlLFxuICAgIGdldEJhc2VQYXRoLFxuICAgIGdldEJ1dHRvbnMsXG4gICAgZ2V0VXJsLFxuICAgIGltcGxlbWVudEV2ZW50VGFyZ2V0LFxuICAgIGxvYWRMYW5ndWFnZVJlc291cmNlcyxcbiAgICByZWdpc3RlckJyaWRnZUJ1dHRvbixcbiAgICBTZWxlY3Rpb25UZXN0LFxuICAgIFRvb2xiYXJzXG59O1xuIiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcuanMnO1xuXG4vKipcbiAqIEJ1dHRvbkFjdGlvblN0eWxlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhcHBseWluZyBzdHlsZSBpbXBsZW1lbnRhdGlvbiBmb3IgYVxuICogYnV0dG9uIGJhc2VkIG9uIHRoZSBgYXBwbHlTdHlsZWAgYW5kIGByZW1vdmVTdHlsZWAgQVBJIG9mIENLRURJVE9SLlxuICpcbiAqIFRvIGV4ZWN1dGUgcHJvcGVybHksIHRoZSBjb21wb25lbnQgaGFzIHRvIGV4cG9zZSB0aGUgZm9sbG93aW5nIG1ldGhvZHMgd2hpY2ggY2FuIGJlIG9idGFpbmVkXG4gKiBvdXQgb2YgdGhlIGJveCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gbWl4aW46XG4gKiAtIGBGdW5jdGlvbmAge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGUvaXNBY3RpdmVcIn19e3svY3Jvc3NMaW5rfX0gdG8gY2hlY2sgdGhlIGFjdGl2ZSBzdGF0ZVxuICogLSBgRnVuY3Rpb25gIHt7I2Nyb3NzTGluayBcIkJ1dHRvblN0eWxlL2dldFN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IHRvIHJldHVybiB0aGUgc3R5bGUgdGhhdCBzaG91bGQgYmUgYXBwbGllZFxuICpcbiAqIEBjbGFzcyBCdXR0b25BY3Rpb25TdHlsZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBvciBhcHBsaWVzIHRoZSBjb21wb25lbnQgc3R5bGUgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkFjdGlvblN0eWxlXG4gICAgICogQG1ldGhvZCBhcHBseVN0eWxlXG4gICAgICovXG4gICAgYXBwbHlTdHlsZSgpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbih0aGlzLmlzQWN0aXZlKSAmJiBMYW5nLmlzRnVuY3Rpb24odGhpcy5nZXRTdHlsZSkpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlbW92ZVN0eWxlKHRoaXMuZ2V0U3R5bGUoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkaXRvci5hcHBseVN0eWxlKHRoaXMuZ2V0U3R5bGUoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTsiLCIvKipcbiAqIEJ1dHRvbkNvbW1hbmRBY3RpdmUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGFuIGBpc0FjdGl2ZWAgbWV0aG9kIHRvIGRldGVybWluZSBpZlxuICogYSBjb250ZXh0LWF3YXJlIGNvbW1hbmQgaXMgY3VycmVudGx5IGluIGFuIGFjdGl2ZSBzdGF0ZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjb21tYW5kIGlzIGFjdGl2ZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICAgICAqIEBtZXRob2QgaXNBY3RpdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjb21tYW5kIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICB2YXIgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKHRoaXMucHJvcHMuY29tbWFuZCk7XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmQgPyBjb21tYW5kLnN0YXRlID09PSBDS0VESVRPUi5UUklTVEFURV9PTiA6IGZhbHNlO1xuICAgIH1cbn07IiwiLyoqXG4gKiBCdXR0b25Db21tYW5kIGlzIGEgbWl4aW4gdGhhdCBleGVjdXRlcyBhIGNvbW1hbmQgdmlhIENLRURJVE9SJ3MgQVBJLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIENLRWRpdG9yIGNvbW1hbmQgYW5kIGZpcmVzIGBhY3Rpb25QZXJmb3JtZWRgIGV2ZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGRhdGEgT3B0aW9uYWwgZGF0YSB0byBiZSBwYXNzZWQgdG8gQ0tFRElUT1IncyBgZXhlY0NvbW1hbmRgIG1ldGhvZC5cbiAgICAgKiBAbWV0aG9kIGV4ZWNDb21tYW5kXG4gICAgICovXG4gICAgZXhlY0NvbW1hbmQoZGF0YSkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQodGhpcy5wcm9wcy5jb21tYW5kLCBkYXRhKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5tb2RpZmllc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbkNoYW5nZSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG59OyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcblxuLyoqXG4gKiBCdXR0b25LZXlzdHJva2UgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgYGtleXN0cm9rZWAgcHJvcCB0aGF0IGFsbG93cyBjb25maWd1cmluZ1xuICogYSBmdW5jdGlvbiBvZiB0aGUgaW5zdGFuY2UgdG8gYmUgaW52b2tlZCB1cG9uIHRoZSBrZXlzdHJva2UgYWN0aXZhdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uS2V5c3Ryb2tlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIsIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbktleXN0cm9rZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxNb3VudCkpIHtcbiAgICAgICAgICAgIHN1cGVyLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hdGl2ZUVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciBrZXlzdHJva2UgPSB0aGlzLnByb3BzLmtleXN0cm9rZTtcblxuICAgICAgICB2YXIgY29tbWFuZE5hbWUgPSBrZXlzdHJva2UubmFtZSB8fCAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKS50b1N0cmluZygpO1xuXG4gICAgICAgIHZhciBjb21tYW5kID0gbmF0aXZlRWRpdG9yLmdldENvbW1hbmQoY29tbWFuZE5hbWUpO1xuXG4gICAgICAgIGlmICghY29tbWFuZCkge1xuICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBDS0VESVRPUi5jb21tYW5kKG5hdGl2ZUVkaXRvciwge1xuICAgICAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXN0cm9rZUZuID0ga2V5c3Ryb2tlLmZuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTGFuZy5pc1N0cmluZyhrZXlzdHJva2VGbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXN0cm9rZUZuXS5jYWxsKHRoaXMsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKExhbmcuaXNGdW5jdGlvbihrZXlzdHJva2VGbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzdHJva2VGbi5jYWxsKHRoaXMsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG5hdGl2ZUVkaXRvci5hZGRDb21tYW5kKGNvbW1hbmROYW1lLCBjb21tYW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlZmF1bHRLZXlzdHJva2VDb21tYW5kID0gbmF0aXZlRWRpdG9yLmtleXN0cm9rZUhhbmRsZXIua2V5c3Ryb2tlc1trZXlzdHJva2Uua2V5c107XG5cbiAgICAgICAgbmF0aXZlRWRpdG9yLnNldEtleXN0cm9rZShrZXlzdHJva2Uua2V5cywgY29tbWFuZE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25LZXlzdHJva2VcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5zZXRLZXlzdHJva2UodGhpcy5wcm9wcy5rZXlzdHJva2Uua2V5cywgdGhpcy5fZGVmYXVsdEtleXN0cm9rZUNvbW1hbmQpO1xuICAgIH1cbn07IiwiLyoqXG4gKiBCdXR0b25DZmdQcm9wcyBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMgYSBzdHlsZSBwcm9wIGFuZCBzb21lIG1ldGhvZHMgdG8gYXBwbHkgdGhlIHJlc3VsdGluZ1xuICogc3R5bGUgYW5kIGNoZWNraW5nIGlmIGl0IGlzIHByZXNlbnQgaW4gYSBnaXZlbiBwYXRoIG9yIHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ2ZnUHJvcHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgcHJvcGVydGllcywgcGFzc2VkIHRvIHRoZSBjdXJyZW50IGNvbXBvbmVudCB3aXRoIHVzZXIncyBjb25maWd1cmF0aW9uXG4gICAgICogdmlhIGBidXR0b25DZmdgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNmZ1Byb3BzXG4gICAgICogQG1ldGhvZCBtZXJnZUJ1dHRvbkNmZ1Byb3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIHRvIGJlIG1lcmdlZCB3aXRoIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIGZvciB0aGlzXG4gICAgICogYnV0dG9uLiBJZiBub3QgcGFzc2VkLCB0aGUgdXNlciBjb25maWd1cmF0aW9uIHdpbGwgYmUgbWVyZ2VkIHdpdGggYHRoaXMucHJvcHNgXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWVyZ2VkIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBtZXJnZUJ1dHRvbkNmZ1Byb3BzKHByb3BzKSB7XG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwgdGhpcy5wcm9wcztcblxuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIGJ1dHRvbkNmZyA9IG5hdGl2ZUVkaXRvci5jb25maWcuYnV0dG9uQ2ZnIHx8IHt9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gQ0tFRElUT1IudG9vbHMubWVyZ2UocHJvcHMsIGJ1dHRvbkNmZ1snbGlua0VkaXQnXSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59OyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBCdXR0b25TdGF0ZUNsYXNzZXMgaXMgYSBtaXhpbiB0aGF0IGRlY29yYXRlcyB0aGUgZG9tRWxlbWVudCBvZiBhIGNvbXBvbmVudFxuICogd2l0aCBkaWZmZXJlbnQgQ1NTIGNsYXNzZXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogVG8gY2hlY2sgZm9yIHN0YXRlLCB0aGUgY29tcG9uZW50IGNhbiBleHBvc2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICogLSBgRnVuY3Rpb25gICoqaXNBY3RpdmUqKiB0byBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKiAtIGBGdW5jdGlvbmAgKippc0Rpc2FibGVkKiogdG8gY2hlY2sgdGhlIGRpc2FibGVkIHN0YXRlXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBzdGF0ZSBjbGFzc2VzIGFzc29jaWF0ZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudCdzIHN0YXRlLCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgcmVzdWx0cyBvZiB0aGUgaXNBY3RpdmUgYW5kIGlzRGlzYWJsZWQgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdGF0ZUNsYXNzZXNcbiAgICAgKiBAbWV0aG9kIGdldFN0YXRlQ2xhc3Nlc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgd2l0aCB0aGUgc3RhdGUgQ1NTIGNsYXNzZXMuXG4gICAgICovXG4gICAgZ2V0U3RhdGVDbGFzc2VzKCkge1xuICAgICAgICB2YXIgc3RhdGVDbGFzc2VzID0gJyc7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFjdGl2ZSBzdGF0ZVxuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHRoaXMuaXNBY3RpdmUpICYmIHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgc3RhdGVDbGFzc2VzICs9ICdhZS1idXR0b24tcHJlc3NlZCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgZGlzYWJsZWQgc3RhdGVcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbih0aGlzLmlzRGlzYWJsZWQpICYmIHRoaXMuaXNEaXNhYmxlZCgpKSB7XG4gICAgICAgICAgICBzdGF0ZUNsYXNzZXMgKz0gJyBhZS1idXR0b24tZGlzYWJsZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlQ2xhc3NlcztcbiAgICB9XG59OyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJ1xuXG4vKipcbiAqIEJ1dHRvblN0eWxlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhIHN0eWxlIHByb3AgYW5kIHNvbWUgbWV0aG9kcyB0byBhcHBseSB0aGUgcmVzdWx0aW5nXG4gKiBzdHlsZSBhbmQgY2hlY2tpbmcgaWYgaXQgaXMgcHJlc2VudCBpbiBhIGdpdmVuIHBhdGggb3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxNb3VudCkpIHtcbiAgICAgICAgICAgIHN1cGVyLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5wcm9wcy5zdHlsZTtcblxuICAgICAgICBpZiAoTGFuZy5pc1N0cmluZyhzdHlsZSkpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHN0eWxlLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1lbWJlciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuY29uZmlnO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcGFydHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgd2hpbGUgKHByb3BlcnR5ICYmIExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikgJiYgTGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWVtYmVyID0gY3VycmVudE1lbWJlcltwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyKSkge1xuICAgICAgICAgICAgICAgIHN0eWxlID0gY3VycmVudE1lbWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBmcm9tIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgQ0tFRElUT1Iuc3R5bGUgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBidXR0b24gc3R5bGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcbiAgICAgKiBAbWV0aG9kIGdldFN0eWxlXG4gICAgICogQHJldHVybiB7Q0tFRElUT1Iuc3R5bGV9IFRoZSBjdXJyZW50IHN0eWxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldFN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHN0eWxlIGlzIGFjdGl2ZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcbiAgICAgKiBAbWV0aG9kIGlzQWN0aXZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBzdHlsZSBpcyBhY3RpdmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICB2YXIgZWxlbWVudFBhdGggPSBlZGl0b3IuZWxlbWVudFBhdGgoKTtcblxuICAgICAgICByZXN1bHQgPSB0aGlzLmdldFN0eWxlKCkuY2hlY2tBY3RpdmUoZWxlbWVudFBhdGgsIGVkaXRvcik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59OyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVG9vbGJhckJ1dHRvbnMgaXMgYSBtaXhpbiB3aGljaCBwcm92aWRlcyBhIGxpc3Qgb2YgYnV0dG9ucyB3aGljaCBoYXZlIHRvIGJlXG4gKiBkaXNwbGF5ZWQgb24gdGhlIGN1cnJlbnQgdG9vbGJhciBkZXBlbmRpbmcgb24gdXNlciBwcmVmZXJlbmNlcyBhbmQgZ2l2ZW4gc3RhdGUuXG4gKlxuICogQGNsYXNzIFRvb2xiYXJCdXR0b25zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBBbmFseXplcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHRoZSBidXR0b25zIGV4Y2x1c2l2ZSBtb2RlIHZhbHVlIHRvIGZpZ3VyZSBvdXQgd2hpY2hcbiAgICAgKiBidXR0b25zIHNob3VsZCBiZSBwcmVzZW50IGluIGEgZ2l2ZW4gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhckJ1dHRvbnNcbiAgICAgKiBAbWV0aG9kIGdldFRvb2xiYXJCdXR0b25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gYnV0dG9ucyBUaGUgYnV0dG9ucyBjb3VsZCBiZSBzaG93biwgcHJpb3IgdG8gdGhlIHN0YXRlIGZpbHRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWRkaXRpb25hbFByb3BzIEFkZGl0aW9uYWwgcHJvcHMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGRvd24gdG8gdGhlIGJ1dHRvbnMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIEFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b25zIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFRvb2xiYXJCdXR0b25zKGJ1dHRvbnMsIGFkZGl0aW9uYWxQcm9wcykge1xuICAgICAgICB2YXIgYnV0dG9uUHJvcHMgPSB7fTtcblxuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIGJ1dHRvbkNmZyA9IG5hdGl2ZUVkaXRvci5jb25maWcuYnV0dG9uQ2ZnIHx8IHt9O1xuXG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oYnV0dG9ucykpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMgPSBidXR0b25zLmNhbGwodGhpcykgfHwgW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9vbGJhckJ1dHRvbnMgPSB0aGlzLmZpbHRlckV4Y2x1c2l2ZShcbiAgICAgICAgICAgICAgICBidXR0b25zLmZpbHRlcihmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbiAmJiAoQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b25dIHx8IEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChMYW5nLmlzU3RyaW5nKGJ1dHRvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvblByb3BzW2J1dHRvbl0gPSBidXR0b25DZmdbYnV0dG9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChMYW5nLmlzU3RyaW5nKGJ1dHRvbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uUHJvcHNbQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV0ua2V5XSA9IENLRURJVE9SLnRvb2xzLm1lcmdlKGJ1dHRvbkNmZ1tidXR0b25dLCBidXR0b24uY2ZnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoe1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMucHJvcHMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGJ1dHRvbi5rZXksXG4gICAgICAgICAgICAgICAgICAgIHRhYktleTogYnV0dG9uLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6ICh0aGlzLnByb3BzLnRyaWdnZXIgJiYgdGhpcy5wcm9wcy50cmlnZ2VyLnByb3BzLnRhYktleSA9PT0gYnV0dG9uLmtleSkgPyAwIDogLTEsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IHRoaXMucHJvcHMudHJpZ2dlclxuICAgICAgICAgICAgICAgIH0sIGJ1dHRvbi5rZXkpO1xuXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB0aGlzLm1lcmdlRHJvcGRvd25Qcm9wcyhwcm9wcywgYnV0dG9uLmtleSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gQ0tFRElUT1IudG9vbHMubWVyZ2UocHJvcHMsIGFkZGl0aW9uYWxQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYnV0dG9uUHJvcHNbYnV0dG9uLmtleV0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoYnV0dG9uLCBwcm9wcyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdG9vbGJhckJ1dHRvbnM7XG4gICAgfVxufTsiLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgZGlzcGxheWluZyBXaWRnZXQgQXJyb3cgYm94IG9uIHRvcCBvciBvbiBib3R0b20gb2YgdGhlIHdpZGdldFxuICogZGVwZW5kaW5nIG9uIHRoZSBwb2ludCBvZiB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0QXJyb3dCb3hcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYXJyb3cgYm94IGNsYXNzZXMgYXNzb2NpYXRlZCB0byB0aGUgY3VycmVudCBlbGVtZW50J3Mgc3RhdGUuIEl0IHJlbGllc1xuICAgICAqIG9uIHRoZSBnZXRJbnRlcmFjdGlvblBvaW50IG1ldGhvZCB0byBjYWxjdWxhdGUgdGhlIHNlbGVjdGlvbiBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0QXJyb3dCb3hcbiAgICAgKiBAbWV0aG9kIGdldEFycm93Qm94Q2xhc3Nlc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgd2l0aCB0aGUgYXJyb3cgYm94IENTUyBjbGFzc2VzLlxuICAgICAqL1xuICAgIGdldEFycm93Qm94Q2xhc3NlcygpIHtcbiAgICAgICAgdmFyIGFycm93Qm94Q2xhc3NlcyA9ICdhZS1hcnJvdy1ib3gnO1xuXG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24odGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KSAmJiB0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpLmRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00pIHtcbiAgICAgICAgICAgICAgICBhcnJvd0JveENsYXNzZXMgKz0gJyBhZS1hcnJvdy1ib3gtdG9wJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyb3dCb3hDbGFzc2VzICs9ICcgYWUtYXJyb3ctYm94LWJvdHRvbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyb3dCb3hDbGFzc2VzO1xuICAgIH1cbn07IiwiaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWFuYWdpbmcgZGlmZmVyZW50IGRyb3Bkb3ducyBpbnNpZGUgYSB3aWRnZXQuXG4gKlxuICogQGNsYXNzIFdpZGdldERyb3Bkb3duXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgICAgICBkcm9wZG93blRyaWdnZXI6IG51bGwsXG4gICAgICAgICAgICBpdGVtRHJvcGRvd246IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkcm9wZG93blRyaWdnZXI6IG51bGwsXG4gICAgICAgICAgICBpdGVtRHJvcGRvd246IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBwcm92aWRlZCBvYmplY3Qgd2l0aCB0d28gbW9yZSBwcm9wZXJ0aWVzOlxuICAgICAqIC0gZXhwYW5kZWQgLSBib29sZWFuIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGFuIHdpZGdldCBzaG91bGQgYmUgcmVuZGVyZWQgZXhjbHVzaXZlbHkuXG4gICAgICogLSB0b2dnbGVEcm9wZG93biAtIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCBieSBhbiB3aWRnZXQgaW4gb3JkZXIgdG8gb2J0YWluIGV4Y2x1c2l2ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXREcm9wZG93blxuICAgICAqIEBtZXRob2QgbWVyZ2VEcm9wZG93blByb3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgcHJvcGVydGllcyBjb250YWluZXIgd2hpY2ggc2hvdWxkIGJlIG1lcmdlZCB3aXRoIHRoZSBwcm9wZXJ0aWVzLCByZWxhdGVkXG4gICAgICogICAgdG8gZHJvcGRvd24gc3RhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1LZXkgVGhleSBrZXkgb2YgYW4gUmVhY3QgV2lkZ2V0IHdoaWNoIGNvbnRhaW5zIHRoZSBkcm9wZG93bi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIG1lcmdlRHJvcGRvd25Qcm9wcyhvYmosIGl0ZW1LZXkpIHtcbiAgICAgICAgcmV0dXJuIENLRURJVE9SLnRvb2xzLm1lcmdlKG9iaiwge1xuICAgICAgICAgICAgZXhwYW5kZWQ6IHRoaXMuc3RhdGUuaXRlbURyb3Bkb3duID09PSBpdGVtS2V5ID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgdGFiSW5kZXg6IHRoaXMuc3RhdGUuZHJvcGRvd25UcmlnZ2VyID09PSBpdGVtS2V5ID8gMCA6IC0xLFxuICAgICAgICAgICAgdG9nZ2xlRHJvcGRvd246IHRoaXMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzLCBpdGVtS2V5KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgZHJvcGRvd24gb2YgdGhlIHdpZGdldCBvciBkaXNjYXJkcyB0aGUgdG9nZ2xlZCBpdGVtIGZyb20gdGhlIHN0YXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG4gICAgICogQG1ldGhvZCB0b2dnbGVEcm9wZG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRHJvcGRvd24gVGhlIHdpZGdldCB3aGljaCByZXF1ZXN0cyB0byB0b2dnbGUgaXRzIGRyb3Bkb3duLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b2dnbGVEaXJlY3Rpb24gVXNlciBtb3ZlbWVudCBkaXJlY3Rpb24gd2hlbiB0b2dnbGVkIHZpYSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICB0b2dnbGVEcm9wZG93bihpdGVtRHJvcGRvd24sIHRvZ2dsZURpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRyb3Bkb3duVHJpZ2dlcjogaXRlbURyb3Bkb3duLFxuICAgICAgICAgICAgaXRlbURyb3Bkb3duOiBpdGVtRHJvcGRvd24gIT09IHRoaXMuc3RhdGUuaXRlbURyb3Bkb3duID8gaXRlbURyb3Bkb3duIDogbnVsbFxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb3ZlRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlRm9jdXModG9nZ2xlRGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWFuYWdpbmcgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cbiAqIFRoZSBleGNsdXNpdmUgc3RhdGUgbWVhbnMgdGhhdCBhIGJ1dHRvbiBtYXkgcmVxdWVzdCB0byBiZSB0aGUgb25seSByZW5kZXJlZFxuICogd2lkZ2V0IGluIGl0cyBwYXJlbnQgY29udGFpbmVyLiBXaWRnZXRFeGNsdXNpdmUgd2lsbCBtYW5hZ2UgdGhpcyBzdGF0ZSBieVxuICogZmlsdGVyaW5nIGFuZCBzdXBwcmVzc2luZyB0aGUgb3RoZXIgc2libGluZyB3aWRnZXRzIGZyb20gZGlzcGxheWluZy5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0RXhjbHVzaXZlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIHRoZSBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuICAgICAqIEBtZXRob2QgY2FuY2VsRXhjbHVzaXZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1FeGNsdXNpdmUgVGhlIHdpZGdldCB3aGljaCBleGNsdXNpdmUgc3RhdGUgc2hvdWxkIGJlIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGNhbmNlbEV4Y2x1c2l2ZShpdGVtRXhjbHVzaXZlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUgPT09IGl0ZW1FeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGl0ZW1FeGNsdXNpdmU6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICogQ2FsbGluZyB0aGlzLnNldFN0YXRlKCkgd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV4dFByb3BzIE9iamVjdCBjb250YWluaW5nIHRoZSBjdXJyZW50IHNldCBvZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykpIHtcbiAgICAgICAgICAgIHN1cGVyLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY2VpdmluZyBwcm9wZXJ0aWVzIG1lYW5zIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBiZWluZyByZS1yZW5kZXJlZC5cbiAgICAgICAgLy8gUmUtcmVuZGVyaW5nIGlzIHRyaWdnZXJlZCBieSBlZGl0b3JJbnRlcmFjdGlvbiwgc28gd2UgaGF2ZSB0b1xuICAgICAgICAvLyByZXNldCB0aGUgZXhjbHVzaXZlIHN0YXRlIGFuZCByZW5kZXIgdGhlIFVJIGFjY29yZGluZyB0byB0aGUgbmV3IHNlbGVjdGlvbi5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpdGVtRXhjbHVzaXZlOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgdGhlIGl0ZW1zIGFuZCByZXR1cm5zIG9ubHkgdGhvc2Ugd2l0aCBleGNsdXNpdmUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG4gICAgICogQG1ldGhvZCBmaWx0ZXJFeGNsdXNpdmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBUaGUgd2lkZ2V0cyB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheXxPYmplY3R9IFRoZSBpdGVtIHdpdGggZXhlY3V0aXZlIHN0YXRlLlxuICAgICAqL1xuICAgIGZpbHRlckV4Y2x1c2l2ZShpdGVtcykge1xuICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlID09PSBpdGVtLmtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgcHJvdmlkZWQgb2JqZWN0IHdpdGggdGhyZWUgbW9yZSBwcm9wZXJ0aWVzOlxuICAgICAqIC0gY2FuY2VsRXhjbHVzaXZlIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGEgd2lkZ2V0IGluIG9yZGVyIHRvIGNhbmNlbCBleGVjdXRpdmUgc3RhdGUuXG4gICAgICogLSByZW5kZXJFeGNsdXNpdmUgLSBib29sZWFuIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGFuIHdpZGdldCBzaG91bGQgYmUgcmVuZGVyZWQgZXhjbHVzaXZlbHkuXG4gICAgICogLSByZXF1ZXN0RXhjbHVzaXZlIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGEgd2lkZ2V0IGluIG9yZGVyIHRvIG9idGFpbiBleGNsdXNpdmUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG4gICAgICogQG1ldGhvZCBtZXJnZUV4Y2x1c2l2ZVByb3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgcHJvcGVydGllcyBjb250YWluZXIgd2hpY2ggc2hvdWxkIGJlIG1lcmdlZCB3aXRoIHRoZSBwcm9wZXJ0aWVzLCByZWxhdGVkXG4gICAgICogICAgdG8gZXhjbHVzaXZlIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtS2V5IFRoZXkga2V5IG9mIGFuIFJlYWN0IFdpZGdldCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQgZXhjbHVzaXZlbHkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICAgKi9cbiAgICBtZXJnZUV4Y2x1c2l2ZVByb3BzKG9iaiwgaXRlbUtleSkge1xuICAgICAgICByZXR1cm4gQ0tFRElUT1IudG9vbHMubWVyZ2Uob2JqLCB7XG4gICAgICAgICAgICBjYW5jZWxFeGNsdXNpdmU6IHRoaXMuY2FuY2VsRXhjbHVzaXZlLmJpbmQodGhpcywgaXRlbUtleSksXG4gICAgICAgICAgICByZW5kZXJFeGNsdXNpdmU6ICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUgPT09IGl0ZW1LZXkpLFxuICAgICAgICAgICAgcmVxdWVzdEV4Y2x1c2l2ZTogdGhpcy5yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcywgaXRlbUtleSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYW5kIHNldHMgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcbiAgICAgKiBAbWV0aG9kIHJlcXVlc3RFeGNsdXNpdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbUV4Y2x1c2l2ZSBUaGUgd2lkZ2V0IHdoaWNoIHJlcXVlc3RzIGV4Y2x1c2l2ZSBzdGF0ZS5cbiAgICAgKi9cbiAgICByZXF1ZXN0RXhjbHVzaXZlKGl0ZW1FeGNsdXNpdmUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpdGVtRXhjbHVzaXZlOiBpdGVtRXhjbHVzaXZlXG4gICAgICAgIH0pO1xuICAgIH1cbn07IiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcuanMnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDA7XG52YXIgRElSRUNUSU9OX05FWFQgPSAxO1xudmFyIERJUkVDVElPTl9QUkVWID0gLTE7XG5cbnZhciBBQ1RJT05fTk9ORSA9IDA7XG52YXIgQUNUSU9OX01PVkVfRk9DVVMgPSAxO1xudmFyIEFDVElPTl9ESVNNSVNTX0ZPQ1VTID0gMjtcblxuLyoqXG4gKiBXaWRnZXRGb2N1c01hbmFnZXIgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGtleWJvYXJkIG5hdmlnYXRpb24gaW5zaWRlIGEgd2lkZ2V0LiBUbyBkbyB0aGlzLFxuICogaXQgZXhwb3NlcyB0aGUgZm9sbG93aW5nIHByb3BzIGFuZCBtZXRob2RzOlxuICpcbiAqIEBjbGFzcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudERpZE1vdW50KSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIHVwZGF0ZXMgYXJlIGZsdXNoZWQgdG8gdGhlIERPTS5cbiAgICAgKiBSZWZyZXNoZXMgdGhlIGRlc2NlbmRhbnRzIGxpc3QuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRVcGRhdGVcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50RGlkVXBkYXRlKSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50RGlkVXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgY3VycmVudCBhY3RpdmUgZGVzY2VuZGFudC5cbiAgICAgKlxuICAgICAqIFNldmVyYWwgV2lkZ2V0cyBjYW4gYmUgbmVzdGVkIGluIGEgY29tcG9uZW50IGhpZXJhcmNoeSBieSBhdHRhY2hpbmcgdGhpcyBmb2N1cyBtZXRob2QgdG9cbiAgICAgKiB0aGUgd2lkZ2V0IERPTSBub2RlLCB0cmFuc2ZlcnJpbmcgdGhlIERPTSBmb2N1cyBjb250cm9sIHRvIHRoZSBpbm5lciBGb2N1c01hbmFnZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBmb2N1c1xuICAgICAqL1xuICAgIGZvY3VzKGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQgfHwgdGhpcy5faXNWYWxpZFRhcmdldChldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVzY2VuZGFudHMgJiYgdGhpcy5fZGVzY2VuZGFudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZURlc2NlbmRhbnRFbCA9IHRoaXMuX2Rlc2NlbmRhbnRzW3RoaXMuX2FjdGl2ZURlc2NlbmRhbnRdO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdXNlciBjbGlja3Mgd2l0aCB0aGUgbW91c2UsIHRoZSBhY3RpdmVFbGVtZW50IGlzIGFscmVhZHkgc2V0IGFuZCB0aGVyZVxuICAgICAgICAgICAgICAgIC8vIGlzIG5vIG5lZWQgdG8gZm9jdXMgaXQuIEZvY3VzaW5nIG9mIHRoZSBhY3RpdmUgZGVzY2VuZGFudCAodXN1YWxseSBzb21lIGJ1dHRvbikgaXMgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGtleWJvYXJkIG5hdmlnYXRpb24sIGJlY2F1c2UgdGhlIGZvY3VzZWQgZWxlbWVudCBtaWdodCBiZSBub3QgdGhlIGZpcnN0IGJ1dHRvbixcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhlIGRpdiBlbGVtZW50LCB3aGljaCBjb250YWlucyB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmVEZXNjZW5kYW50RWwgJiYgIXRoaXMucHJvcHMuZm9jdXNGaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kZXNjZW5kYW50cy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRGVzY2VuZGFudEVsLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUga2V5IGV2ZW50cyBvbiBhIERPTSBub2RlIHRvIGV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIG5hdmlnYXRpb24gd2hlbiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudCB0aGF0IHdhcyBkZXRlY3RlZCBvbiB0aGUgd2lkZ2V0IERPTSBub2RlLlxuICAgICAqIEBtZXRob2QgaGFuZGxlS2V5XG4gICAgICovXG4gICAgaGFuZGxlS2V5KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkVGFyZ2V0KGV2ZW50LnRhcmdldCkgJiYgdGhpcy5fZGVzY2VuZGFudHMpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLl9nZXRGb2N1c0FjdGlvbihldmVudCk7XG5cbiAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IEFDVElPTl9NT1ZFX0ZPQ1VTKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdmVGb2N1cyhhY3Rpb24uZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IEFDVElPTl9ESVNNSVNTX0ZPQ1VTKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25EaXNtaXNzKGFjdGlvbi5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBmb2N1cyBhbW9uZyBkZXNjZW5kYW50cyBpbiB0aGUgZXNwZWNpZmllZCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBtb3ZlRm9jdXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gKDEgb3IgLTEpIG9mIHRoZSBmb2N1cyBtb3ZlbWVudCBhbW9uZyBkZXNjZW5kYW50cy5cbiAgICAgKi9cbiAgICBtb3ZlRm9jdXMoZGlyZWN0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IExhbmcuaXNOdW1iZXIoZGlyZWN0aW9uKSA/IGRpcmVjdGlvbiA6IDA7XG5cbiAgICAgICAgdGhpcy5fbW92ZUZvY3VzKGRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aW9uLCBpZiBhbnksIHRoYXQgYSBrZXlib2FyZCBldmVudCBpbiB0aGUgY3VycmVudCBmb2N1cyBtYW5hZ2VyIHN0YXRlXG4gICAgICogc2hvdWxkIHByb2R1Y2UuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfZ2V0Rm9jdXNBY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGFjdGlvbiBvYmplY3Qgd2l0aCB0eXBlIGFuZCBkaXJlY3Rpb24gcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBfZ2V0Rm9jdXNBY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IEFDVElPTl9OT05FXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMua2V5cykge1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2dldEZvY3VzTW92ZURpcmVjdGlvbihldmVudCk7XG5cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24uZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGFjdGlvbi50eXBlID0gQUNUSU9OX01PVkVfRk9DVVM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXNtaXNzQWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uKGV2ZW50LCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAoZGlzbWlzc0FjdGlvbi5kaXNtaXNzKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLmRpcmVjdGlvbiA9IGRpc21pc3NBY3Rpb24uZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGFjdGlvbi50eXBlID0gQUNUSU9OX0RJU01JU1NfRk9DVVM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc21pc3MgYWN0aW9uLCBpZiBhbnksIHRoZSBmb2N1cyBtYW5hZ2VyIHNob3VsZCBleGVjdXRlIHRvIHlpZWxkIHRoZSBmb2N1cy4gVGhpc1xuICAgICAqIHdpbGwgaGFwcGVuIGluIGFueSBvZiB0aGVzZSBzY2VuYXJpb3MgaWYgYSBkaXNtaXNzIGNhbGxiYWNrIGhhcyBiZWVuIHNwZWNpZmllZDpcbiAgICAgKiAtIEEgZGlzbWlzcyBrZXkgaGFzIGJlZW4gcHJlc3NlZFxuICAgICAqIC0gSW4gYSBub24tY2lyY3VsYXIgZm9jdXMgbWFuYWdlciwgd2hlbjpcbiAgICAgKiAgICAgLSBUaGUgYWN0aXZlIGRlc2NlbmRhbnQgaXMgdGhlIGZpcnN0IG9uZSBhbmQgYSBwcmV2IGtleSBoYXMgYmVlbiBwcmVzc2VkLlxuICAgICAqICAgICAtIFRoZSBhY3RpdmUgZGVzY2VuZGFudCBpcyB0aGUgbGFzdCBvbmUgYW5kIGEgbmV4dCBrZXkgaGFzIGJlZW4gcHJlc3NlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIF9nZXRGb2N1c0Rpc21pc3NBY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZm9jdXNNb3ZlRGlyZWN0aW9uIFRoZSBmb2N1cyBtb3ZlbWVudCBkaXJlY3Rpb24gKGlmIGFueSkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIGRpc21pc3MgYWN0aW9uIHdpdGggZGlzbWlzcyBhbmQgZGlyZWN0aW9uIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgX2dldEZvY3VzRGlzbWlzc0FjdGlvbihldmVudCwgZm9jdXNNb3ZlRGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBkaXNtaXNzQWN0aW9uID0ge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBmb2N1c01vdmVEaXJlY3Rpb24sXG4gICAgICAgICAgICBkaXNtaXNzOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uRGlzbWlzcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3MpKSB7XG4gICAgICAgICAgICAgICAgZGlzbWlzc0FjdGlvbi5kaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5kaXNtaXNzTmV4dCkpIHtcbiAgICAgICAgICAgICAgICBkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpc21pc3NBY3Rpb24uZGlyZWN0aW9uID0gRElSRUNUSU9OX05FWFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMuZGlzbWlzc1ByZXYpKSB7XG4gICAgICAgICAgICAgICAgZGlzbWlzc0FjdGlvbi5kaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaXNtaXNzQWN0aW9uLmRpcmVjdGlvbiA9IERJUkVDVElPTl9QUkVWO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRpc21pc3NBY3Rpb24uZGlzbWlzcyAmJiAhdGhpcy5wcm9wcy5jaXJjdWxhciAmJiBmb2N1c01vdmVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSAoXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzTW92ZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1BSRVYgJiYgdGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBmb2N1c01vdmVEaXJlY3Rpb24gPT09IERJUkVDVElPTl9ORVhUICYmIHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPT09IHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpc21pc3NBY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlyZWN0aW9uLCBpZiBhbnksIGluIHdoaWNoIHRoZSBmb2N1cyBzaG91bGQgYmUgbW92ZWQuIEluIHByZXNlbmNlIG9mIHRoZVxuICAgICAqIHNoaWZ0IGtleSBtb2RpZmllciwgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbW92ZW1lbnQgaXMgaW52ZXJ0ZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY29tcHV0ZWQgZGlyZWN0aW9uIG9mIHRoZSBleHBlY3RlZCBmb2N1cyBtb3ZlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBESVJFQ1RJT05fTk9ORTtcblxuICAgICAgICBpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMubmV4dCkpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERJUkVDVElPTl9ORVhUO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5wcmV2KSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRElSRUNUSU9OX1BSRVY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuc2hpZktleSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uICo9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgYSBnaXZlbiBrZXlDb2RlIGlzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIGtleXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfaXNWYWxpZEtleVxuICAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBrZXlzIEEga2V5IHNldC4gQ2FuIGJlIGEgbnVtYmVyIGFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBhbGxvd2VkIGtleUNvZGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlDb2RlIEFuIGV2ZW50IGtleUNvZGUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBrZXkgaXMgdmFsaWQuXG4gICAgICovXG4gICAgX2lzVmFsaWRLZXkoa2V5Q29kZSwga2V5cykge1xuICAgICAgICByZXR1cm4gTGFuZy5pc0FycmF5KGtleXMpID8gKGtleXMuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTEpIDogKGtleUNvZGUgPT09IGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgdmFsaWQgZm9yIGZvY3VzIG1hbmFnZW1lbnQuIFVzZXIgaW5wdXQgZWxlbWVudHMgc3VjaCBhc1xuICAgICAqIGlucHV0LCBzZWxlY3Qgb3IgdGV4dGFyZWEgYXJlIGV4Y2x1ZGVkLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuICAgICAqIEBtZXRob2QgX2lzVmFsaWRLZXlcbiAgICAgKiBAcGFyYW0ge0RPTU5vZGV9IGVsZW1lbnQgQSBET00gZWxlbWVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGVsZW1lbnQgaXMgdmFsaWQuXG4gICAgICovXG4gICAgX2lzVmFsaWRUYXJnZXQoZWxlbWVudCkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHJldHVybiAodGFnTmFtZSAhPT0gJ2lucHV0JyAmJiB0YWdOYW1lICE9PSAnc2VsZWN0JyAmJiB0YWdOYW1lICE9PSAndGV4dGFyZWEnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgZm9jdXMgYW1vbmcgZGVzY2VuZGFudHMgaW4gdGhlIGVzcGVjaWZpZWQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuICAgICAqIEBtZXRob2QgX21vdmVGb2N1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiAoMSBvciAtMSkgb2YgdGhlIGZvY3VzIG1vdmVtZW50IGFtb25nIGRlc2NlbmRhbnRzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfbW92ZUZvY3VzKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgbnVtRGVzY2VuZGFudHMgPSB0aGlzLl9kZXNjZW5kYW50cy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGRlc2NlbmRhbnQgPSB0aGlzLl9kZXNjZW5kYW50c1t0aGlzLl9hY3RpdmVEZXNjZW5kYW50XTtcblxuICAgICAgICBkZXNjZW5kYW50LnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAtMSk7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlRGVzY2VuZGFudCArPSBkaXJlY3Rpb247XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2lyY3VsYXIpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcm9wZXIgbW9kdWxvIHJlc3VsdCBzaW5jZSByZW1haW5kZXIgb3BlcmF0b3IgZG9lc24ndCBiZWhhdmUgaW4gdGhlXG4gICAgICAgICAgICAvLyBzYW1lIHdheSBmb3IgbmVnYXRpdmUgbnVtYmVyc1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9ICgodGhpcy5fYWN0aXZlRGVzY2VuZGFudCAlIG51bURlc2NlbmRhbnRzKSArIG51bURlc2NlbmRhbnRzKSAlIG51bURlc2NlbmRhbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQsIG51bURlc2NlbmRhbnRzIC0gMSksIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzY2VuZGFudCA9IHRoaXMuX2Rlc2NlbmRhbnRzW3RoaXMuX2FjdGl2ZURlc2NlbmRhbnRdO1xuXG4gICAgICAgIGRlc2NlbmRhbnQuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIDApO1xuICAgICAgICBkZXNjZW5kYW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBkZXNjZW5kYW50cyBsaXN0IGJ5IGV4ZWN1dGluZyB0aGUgQ1NTIHNlbGVjdG9yIGFnYWluIGFuZCByZXNldHMgdGhlIGRlc2NlbmRhbnRzIHRhYkluZGV4LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuICAgICAqIEBtZXRob2QgX3JlZnJlc2hcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlZnJlc2goKSB7XG4gICAgICAgIHZhciBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICAgICAgaWYgKGRvbU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cyA9IGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCh0aGlzLnByb3BzLmRlc2NlbmRhbnRzKTtcblxuICAgICAgICAgICAgdmFyIHByaW9yaXR5RGVzY2VuZGFudHMgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5fZGVzY2VuZGFudHMgPSBbXTtcblxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGVzY2VuZGFudHMpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhVGFiSW5kZXggPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUYWJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eURlc2NlbmRhbnRzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzY2VuZGFudHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICBwcmlvcml0eURlc2NlbmRhbnRzID0gcHJpb3JpdHlEZXNjZW5kYW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKExhbmcudG9JbnQoYS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFiaW5kZXgnKSkgPiBMYW5nLnRvSW50KGIuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW5kYW50cyA9IHByaW9yaXR5RGVzY2VuZGFudHMuY29uY2F0KHRoaXMuX2Rlc2NlbmRhbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbmRhbnRzLnNvbWUoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsImltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHBvc2l0aW9uIHdoZXJlIGFuIFdpZGdldCBzaG91bGQgYmUgZGlzcGxheWVkIGJhc2VkIG9uIHRoZSBwb2ludFxuICogd2hlcmUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0UG9zaXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5XcmFwcGVkQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgZ3V0dGVyOiB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAxMFxuICAgICAgICB9LFxuICAgICAgICBjb25zdHJhaW5Ub1ZpZXdwb3J0OiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBzY2hlZHVsZWQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBjYW5jZWxBbmltYXRpb25cbiAgICAgKi9cbiAgICBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZUlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBpbiBwYWdlIGNvb3JkaW5hdGVzLFxuICAgICAqIHJlc3RyaWN0ZWQgdG8gZml0IHRvIGdpdmVuIHZpZXdwb3J0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBnZXRDb25zdHJhaW5lZFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgcHJvdmlkZWQgYXMgbnVtYmVyczpcbiAgICAgKiAtIGhlaWdodFxuICAgICAqIC0gbGVmdFxuICAgICAqIC0gdG9wXG4gICAgICogLSB3aWR0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3UGFuZVNpemUgT3B0aW9uYWwuIElmIG5vdCBwcm92aWRlZCwgdGhlIGN1cnJlbnQgdmlld3BvcnQgd2lsbCBiZSB1c2VkLiBTaG91bGQgY29udGFpbiBhdCBsZWFzdCB0aGVzZSBwcm9wZXJ0aWVzOlxuICAgICAqIC0gd2lkdGhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMsIHdoaWNoIHJlcHJlc2VudCB0aGUgY29uc3RyYWluZWQgcG9zaXRpb24gb2YgdGhlXG4gICAgICogZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRDb25zdHJhaW5lZFBvc2l0aW9uKGF0dHJzLCB2aWV3UGFuZVNpemUpIHtcbiAgICAgICAgdmlld1BhbmVTaXplID0gdmlld1BhbmVTaXplIHx8IG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0Vmlld1BhbmVTaXplKCk7XG5cbiAgICAgICAgdmFyIHggPSBhdHRycy5sZWZ0O1xuICAgICAgICB2YXIgeSA9IGF0dHJzLnRvcDtcblxuICAgICAgICBpZiAoYXR0cnMubGVmdCArIGF0dHJzLndpZHRoID4gdmlld1BhbmVTaXplLndpZHRoKSB7XG4gICAgICAgICAgICB4IC09IChhdHRycy5sZWZ0ICsgYXR0cnMud2lkdGggLSB2aWV3UGFuZVNpemUud2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uLCBpbiBwYWdlIGNvb3JkaW5hdGVzLCBhY2NvcmRpbmcgdG8gd2hpY2ggYSB3aWRnZXQgc2hvdWxkIGFwcGVhci5cbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLCB0aGUgd2RpZ2V0IG1heSBhcHBlYXIgYWJvdmUgb2Ygb3Igb24gYm90dG9tIG9mIHRoZSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJdCBkZXBlbmRzIG9uIHRoZSBwcm9wcyBlZGl0b3JFdmVudCB0byBhbmFseXplIHRoZSBmb2xsb3dpbmcgdXNlci1pbnRlcmFjdGlvbiBwYXJhbWV0ZXJzOlxuICAgICAqIC0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbVxuICAgICAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogLSB7TnVtYmVyfSBwb3MgQ29udGFpbnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3NpdGlvbiwgY29uc2lkZXJlZCBhcyBtb3N0IGFwcHJvcHJpYXRlLlxuICAgICAqIFRoaXMgbWF5IGJlIHRoZSBwb2ludCB3aGVyZSB0aGUgdXNlciByZWxlYXNlZCB0aGUgbW91c2UsIG9yIGp1c3QgdGhlIGJlZ2lubmluZyBvciB0aGUgZW5kIG9mXG4gICAgICogdGhlIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQG1ldGhvZCBnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBPYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIGRpcmVjdGlvbiwgeCwgeSwgd2hlcmUgeCBhbmQgeSBhcmUgaW4gcGFnZSBjb29yZGluYXRlcyBhbmQgZGlyZWN0aW9uIGNhbiBiZSBvbmUgb2YgdGhlc2U6XG4gICAgICogQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Agb3IgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cbiAgICAgKi9cbiAgICBnZXRJbnRlcmFjdGlvblBvaW50KCkge1xuICAgICAgICB2YXIgZXZlbnRQYXlsb2FkID0gdGhpcy5wcm9wcy5lZGl0b3JFdmVudCA/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YSA6IG51bGw7XG5cbiAgICAgICAgaWYgKCFldmVudFBheWxvYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3Rpb25EYXRhID0gZXZlbnRQYXlsb2FkLnNlbGVjdGlvbkRhdGE7XG5cbiAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnRQYXlsb2FkLm5hdGl2ZUV2ZW50O1xuXG4gICAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgICAgICB4OiBldmVudFBheWxvYWQubmF0aXZlRXZlbnQucGFnZVgsXG4gICAgICAgICAgICB5OiBzZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3BcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZGlyZWN0aW9uO1xuXG4gICAgICAgIHZhciBlbmRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZW5kUmVjdDtcblxuICAgICAgICB2YXIgc3RhcnRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uc3RhcnRSZWN0O1xuXG4gICAgICAgIGlmIChlbmRSZWN0ICYmIHN0YXJ0UmVjdCAmJiBzdGFydFJlY3QudG9wID09PSBlbmRSZWN0LnRvcCkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDtcbiAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgcG9pbnQgd2hlcmUgdXNlciByZWxlYXNlZCB0aGUgbW91c2UsIHNob3cgVG9vbGJhciBhdCB0aGlzIHBvaW50XG4gICAgICAgIC8vIG90aGVyd2lzZSBzaG93IGl0IG9uIHRoZSBtaWRkbGUgb2YgdGhlIHNlbGVjdGlvbi5cblxuICAgICAgICBpZiAocG9zLnggJiYgcG9zLnkpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLl9nZXRYUG9pbnQoc2VsZWN0aW9uRGF0YSwgcG9zLngpO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCkge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbihwb3MueSwgc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHBvcy55LCB0aGlzLl9nZXRZUG9pbnQoc2VsZWN0aW9uRGF0YSwgbmF0aXZlRXZlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5sZWZ0ICsgc2VsZWN0aW9uRGF0YS5yZWdpb24ud2lkdGggLyAyO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSkge1xuXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuX2dldFlQb2ludChzZWxlY3Rpb25EYXRhLCBuYXRpdmVFdmVudCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIFdpZGdldC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQG1ldGhvZCBfZ2V0WFBvaW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50WCBUaGUgWCBjb29yZGluYXRlIHJlY2VpdmVkIGZyb20gdGhlIG5hdGl2ZSBldmVudCAobW91c2V1cCkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGlvbkRhdGEgVGhlIGRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGFzIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uRGF0YTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBYIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgX2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBldmVudFgpIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IHNlbGVjdGlvbkRhdGEucmVnaW9uO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gcmVnaW9uLnN0YXJ0UmVjdCA/IHJlZ2lvbi5zdGFydFJlY3QubGVmdCA6IHJlZ2lvbi5sZWZ0O1xuICAgICAgICB2YXIgcmlnaHQgPSByZWdpb24uZW5kUmVjdCA/IHJlZ2lvbi5lbmRSZWN0LnJpZ2h0IDogcmVnaW9uLnJpZ2h0O1xuXG4gICAgICAgIHZhciB4O1xuXG4gICAgICAgIGlmIChsZWZ0IDwgZXZlbnRYICYmIHJpZ2h0ID4gZXZlbnRYKSB7XG4gICAgICAgICAgICB4ID0gZXZlbnRYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlZnREaXN0ID0gTWF0aC5hYnMobGVmdCAtIGV2ZW50WCk7XG4gICAgICAgICAgICB2YXIgcmlnaHREaXN0ID0gTWF0aC5hYnMocmlnaHQgLSBldmVudFgpO1xuXG4gICAgICAgICAgICBpZiAobGVmdERpc3QgPCByaWdodERpc3QpIHsgLy8gdXNlciByYWlzZWQgdGhlIG1vdXNlIG9uIGxlZnQgb24gdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHggPSBsZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgV2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEludGVyYWN0aW9uUG9pbnRcbiAgICAgKiBAbWV0aG9kIF9nZXRZUG9pbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmF0aXZlRXZlbnQgVGhlIGRhdGEgYWJvdXQgZXZlbnQgaXMgZmlyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjYWxjdWxhdGVkIFkgcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBfZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KSB7XG4gICAgICAgIHZhciB5ID0gMDtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uRGF0YSAmJiBuYXRpdmVFdmVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRUYXJnZXQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobmF0aXZlRXZlbnQudGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRUYXJnZXQuJCAmJiBlbGVtZW50VGFyZ2V0LmdldFN0eWxlKCdvdmVyZmxvdycpID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICB5ID0gbmF0aXZlRXZlbnQudGFyZ2V0Lm9mZnNldFRvcCArIG5hdGl2ZUV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgV2lkZ2V0IHRha2luZyBpbiBjb25zaWRlcmF0aW9uIHRoZVxuICAgICAqIHt7I2Nyb3NzTGluayBcIldpZGdldFBvc2l0aW9uL2d1dHRlcjphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX0gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgIGdldFdpZGdldFhZUG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBUaGUgbGVmdCBvZmZzZXQgaW4gcGFnZSBjb29yZGluYXRlcyB3aGVyZSBUb29sYmFyIHNob3VsZCBiZSBzaG93bi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRoZSB0b3Agb2Zmc2V0IGluIHBhZ2UgY29vcmRpbmF0ZXMgd2hlcmUgVG9vbGJhciBzaG91bGQgYmUgc2hvd24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIE1heSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgKiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCBvciBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aXRoIGxlZnQgYW5kIHRvcCBvZmZzZXRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0V2lkZ2V0WFlQb2ludChsZWZ0LCB0b3AsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIHZhciBndXR0ZXIgPSB0aGlzLnByb3BzLmd1dHRlcjtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSB8fCBkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCAtIGd1dHRlci5sZWZ0IC0gKGRvbU5vZGUub2Zmc2V0V2lkdGggLyAyKTtcblxuICAgICAgICAgICAgdG9wID0gKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00pID8gKHRvcCArIGd1dHRlci50b3ApIDpcbiAgICAgICAgICAgICAgICAodG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQgLSBndXR0ZXIudG9wKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFQgfHxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1JJR0hUX1RPX0xFRlQpIHtcblxuICAgICAgICAgICAgbGVmdCA9IChkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9MRUZUX1RPX1JJR0hUKSA/XG4gICAgICAgICAgICAgICAgKGxlZnQgKyBndXR0ZXIubGVmdCArIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMikgOlxuICAgICAgICAgICAgICAgIChsZWZ0IC0gMyAqIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMiAtIGd1dHRlci5sZWZ0KTtcblxuICAgICAgICAgICAgdG9wID0gdG9wIC0gZ3V0dGVyLnRvcCAtIChkb21Ob2RlLm9mZnNldEhlaWdodCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsZWZ0LCB0b3BdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBpc1Zpc2libGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNWaXNpYmxlKCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGlmIChkb21Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuaGFzQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSB3aWRnZXQgZnJvbSBhIHN0YXJ0aW5nIHBvaW50IHRvIGEgZGVzdGluYXRpb24gcG9pbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cbiAgICAgKiBAbWV0aG9kIG1vdmVUb1BvaW50XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzdGFydFBvaW50IFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIG1vdmVtZW50LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZW5kUG9pbnQgVGhlIGRlc3RpbmF0aW9uIHBvaW50IGZvciB0aGUgbW92ZW1lbnQuXG4gICAgICovXG4gICAgbW92ZVRvUG9pbnQoc3RhcnRQb2ludCwgZW5kUG9pbnQpIHtcbiAgICAgICAgdmFyIGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpO1xuXG4gICAgICAgIGRvbUVsZW1lbnQuc2V0U3R5bGVzKHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YXJ0UG9pbnRbMF0gKyAncHgnLFxuICAgICAgICAgICAgdG9wOiBzdGFydFBvaW50WzFdICsgJ3B4JyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWxsb3ktZWRpdG9yLWludmlzaWJsZScpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50LmFkZENsYXNzKCdhZS10b29sYmFyLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQuYWRkQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG4gICAgICAgICAgICBkb21FbGVtZW50LnNldFN0eWxlcyh7XG4gICAgICAgICAgICAgICAgbGVmdDogZW5kUG9pbnRbMF0gKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcDogZW5kUG9pbnRbMV0gKyAncHgnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgd2lkZ2V0IHdpdGggdGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cbiAgICAgKiBAbWV0aG9kIHNob3dcbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUoKSAmJiBkb21Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb25Qb2ludCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsWCxcbiAgICAgICAgICAgICAgICAgICAgZmluYWxZLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsWCxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFk7XG5cbiAgICAgICAgICAgICAgICBmaW5hbFggPSBpbml0aWFsWCA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgnbGVmdCcpKTtcbiAgICAgICAgICAgICAgICBmaW5hbFkgPSBpbml0aWFsWSA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgndG9wJykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuY29uc3RyYWluVG9WaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5nZXRDb25zdHJhaW5lZFBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VGbG9hdChkb21Ob2RlLm9mZnNldEhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmaW5hbFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGZpbmFsWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KGRvbU5vZGUub2Zmc2V0V2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsWCA9IHJlcy54O1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFkgPSByZXMueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25Qb2ludC5kaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxZID0gdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b207XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFkgPSB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1BvaW50KFtpbml0aWFsWCwgaW5pdGlhbFldLCBbZmluYWxYLCBmaW5hbFldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHdpZGdldCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBpbnRlcmFjdGlvbiBwb2ludC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuICAgICAqIEBtZXRob2QgdXBkYXRlUG9zaXRpb25cbiAgICAgKi9cbiAgICB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgICAgdmFyIGludGVyYWN0aW9uUG9pbnQgPSB0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKTtcblxuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGlmIChpbnRlcmFjdGlvblBvaW50ICYmIGRvbU5vZGUpIHtcbiAgICAgICAgICAgIHZhciB4eSA9IHRoaXMuZ2V0V2lkZ2V0WFlQb2ludChpbnRlcmFjdGlvblBvaW50LngsIGludGVyYWN0aW9uUG9pbnQueSwgaW50ZXJhY3Rpb25Qb2ludC5kaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSkuc2V0U3R5bGVzKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB4eVswXSArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wOiB4eVsxXSArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYW4gYW5pbWF0aW9uIGZyYW1lLCBpZiBwb3NzaWJsZSwgdG8gc2ltdWxhdGUgYW4gYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBfYW5pbWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2NoZWR1bGVkIGZyYW1lLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYW5pbWF0ZShjYWxsYmFjaykge1xuICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWVJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Cb2xkIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHN0eWxpbmcgYW4gc2VsZWN0aW9uIHdpdGggc3Ryb25nIChib2xkKSBzdHlsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQm9sZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkJvbGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5ib2xkfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1ib2xkXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYm9sZH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1ib2xkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJvbGRcbiAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkJvbGQua2V5ID0gJ2JvbGQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkJvbGRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkJvbGQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdib2xkJyxcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdleGVjQ29tbWFuZCcsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA2NiAvKkIqL1xuICAgIH0sXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX2JvbGQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbktleXN0cm9rZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbkJvbGRcbikpKSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNhbWVyYUltYWdlIGNsYXNzIHRha2VzIHBob3RvIGZyb20gY2FtZXJhIGFuZCBpbnNlcnRzIGl0IHRvIHRoZSBjb250ZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25DYW1lcmFJbWFnZVxuICovXG5jbGFzcyBCdXR0b25DYW1lcmFJbWFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgdGhlIHRha2UgcGhvdG8gYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzLnJlZnMuYnV0dG9uVGFrZVBob3RvKS5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmVhbS5zdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtLnN0b3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RyZWFtLmdldFZpZGVvVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBnZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWE7XG5cbiAgICAgICAgZ2V0VXNlck1lZGlhLmNhbGwobmF2aWdhdG9yLCB7XG4gICAgICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgICB9LCB0aGlzLl9oYW5kbGVTdHJlYW1TdWNjZXNzLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVN0cmVhbUVycm9yLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNhbWVyYVwiPlxuICAgICAgICAgICAgICAgIDx2aWRlbyByZWY9XCJ2aWRlb0NvbnRhaW5lclwiPlZpZGVvIHN0cmVhbSBub3QgYXZhaWxhYmxlLjwvdmlkZW8+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJhZS1jYW1lcmEtc2hvb3RcIiBvbkNsaWNrPXt0aGlzLnRha2VQaG90by5iaW5kKHRoaXMpfSByZWY9XCJidXR0b25UYWtlUGhvdG9cIj5UYWtlIHBob3RvPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGNhbnZhcyBjbGFzc05hbWU9XCJhZS1jYW1lcmEtY2FudmFzXCIgcmVmPVwiY2FudmFzQ29udGFpbmVyXCI+PC9jYW52YXM+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBwaG90byBmcm9tIHRoZSB2aWRlbyBzdHJlYW0gYW5kIGluc2VydHMgaW4gaW50byBlZGl0b3IncyBjb250ZW50LlxuICAgICAqXG4gICAgICogQGZpcmVzIEJ1dHRvbkNhbWVyYUltYWdlI2ltYWdlQ2FtZXJhQWRkXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCB0YWtlUGhvdG9cbiAgICAgKi9cbiAgICB0YWtlUGhvdG8oKSB7XG4gICAgICAgIHZhciB2aWRlb0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLnZpZGVvQ29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl92aWRlb0hlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5wcm9wcy52aWRlb1dpZHRoO1xuXG4gICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgICAgIGNhbnZhc0VsLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvRWwsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgaW1nVVJMID0gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcblxuICAgICAgICAgICAgdmFyIGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoJzxpbWcgc3JjPVwiJyArIGltZ1VSTCArICdcIj4nKTtcblxuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnaW1hZ2VDYW1lcmFBZGQnLCBlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdmlkZW8gc3RyZWFtIGNhcHR1cmluZyBmYWlsdXJlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCBfaGFuZGxlU3RyZWFtRXJyb3JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlcnJvciBUaGUgZmlyZWQgZXZlbnQgaW4gY2FzZSBvZiBlcnJvci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZVN0cmVhbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHdpbmRvdy5hbGVydCgnQW4gZXJyb3Igb2NjdXJyZWQhICcgKyBlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHN0cmVhbWluZyB2aWRlbyBpbiB0aGUgdmlkZW8gZWxlbWVudCBhbmQgc2V0cyB3aWR0aC9oZWlnaHQgdG8gdGhlIHZpZGVvXG4gICAgICogYW5kIGNhbnZhcyBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICAgICAqIEBtZXRob2QgX2hhbmRsZVN0cmVhbVN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtIFRoZSB2aWRlbyBzdHJlYW1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZVN0cmVhbVN1Y2Nlc3Moc3RyZWFtKSB7XG4gICAgICAgIHZhciB2aWRlb0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLnZpZGVvQ29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB2aWRlb0VsLnZpZGVvSGVpZ2h0IC8gKHZpZGVvRWwudmlkZW9XaWR0aC90aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMucHJvcHMudmlkZW9XaWR0aCAvICg0LzMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWRlb0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuICAgICAgICAgICAgdmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgICAgICBjYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5wcm9wcy52aWRlb1dpZHRoKTtcbiAgICAgICAgICAgIGNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcblxuICAgICAgICAgICAgdGhpcy5fdmlkZW9IZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcblxuICAgICAgICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgICAgICAgICAgdmlkZW9FbC5tb3pTcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb0VsLnNyYyA9ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlkZW9FbC5wbGF5KCk7XG5cbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmJ1dHRvblRha2VQaG90bykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIHRha2VuIGZyb20gdGhlIGNhbWVyYSBhbmQgYWRkZWQgYXMgYW4gZWxlbWVudCB0byB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQGV2ZW50IEJ1dHRvbkNhbWVyYUltYWdlI2ltYWdlQ2FtZXJhQWRkXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnQgaW4gZWRpdG9yLlxuICAgICAqL1xufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGNhbWVyYUltYWdlXG4gKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uQ2FtZXJhSW1hZ2Uua2V5ID0gJ2NhbWVyYUltYWdlJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqL1xuQnV0dG9uQ2FtZXJhSW1hZ2UuZGVmYXVsdFByb3BzID0ge1xuICAgIHZpZGVvV2lkdGg6IDMyMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ2FtZXJhSW1hZ2U7XG4iLCJpbXBvcnQgQnV0dG9uQ2FtZXJhSW1hZ2UgZnJvbSAnLi9idXR0b24tY2FtZXJhLWltYWdlLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25DYW1lcmEgY2xhc3MgcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IHdheXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGUuXG4gKiAtIEV4Y2x1c2l2ZTogUmVuZGVycyBCdXR0b25DYW1lcmFJbWFnZSBpbiBvcmRlciB0byB0YWtlIHBob3RvIGZyb20gdGhlIGNhbWVyYS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ2FtZXJhXG4gKi9cbmNsYXNzIEJ1dHRvbkNhbWVyYSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEJ1dHRvbkNhbWVyYUltYWdlIHsuLi50aGlzLnByb3BzfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9ICEobmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fFxuICAgICAgICAgICAgICAgIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhICYmIGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnKSB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWEpO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkaXNhYmxlZCA/IEFsbG95RWRpdG9yLlN0cmluZ3MuY2FtZXJhRGlzYWJsZWQgOiBBbGxveUVkaXRvci5TdHJpbmdzLmNhbWVyYTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e2xhYmVsfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24taW1hZ2UtY2FtZXJhXCIgZGlzYWJsZWQ9e2Rpc2FibGVkfSBvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUuYmluZChCdXR0b25DYW1lcmEua2V5KX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtsYWJlbH0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tY2FtZXJhXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBjYW1lcmFcbiAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uQ2FtZXJhLmtleSA9ICdjYW1lcmEnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25DYW1lcmE7XG4iLCJpbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQ29kZSBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgcHJlYCBlbGVtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db2RlXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25Db2RlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29kZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tY29kZVwiIG9uQ2xpY2s9e3RoaXMuYXBwbHlTdHlsZS5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1jb2RlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGNvZGVcbiAqIEBtZW1iZXJvZiBCdXR0b25Db2RlXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkNvZGUua2V5ID0gJ2NvZGUnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkNvZGVcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkNvZGUuZGVmYXVsdFByb3BzID0ge1xuICAgIHN0eWxlOiB7XG4gICAgICAgIGVsZW1lbnQ6ICdwcmUnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQWN0aW9uU3R5bGUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25Db2RlXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db21tYW5kTGlzdEl0ZW0gY2xhc3MgaXMgYSBVSSBjbGFzcyB0aGF0IHJlbmRlcnMgYSBCdXR0b25Db21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlXG4gKiBhIGxpc3QgYXMgYW4gaXRlbSwgd2l0aCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYmVoYXZpb3VyLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZExpc3RJdGVtXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuZGVzY3JpcHRpb259IGNsYXNzTmFtZT17dGhpcy5fZ2V0Q2xhc3NOYW1lKCl9IG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9Pnt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufTwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWUgb2YgV2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuICAgICAqIEBtZXRob2QgX2dldENsYXNzTmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBXaWRnZXQuXG4gICAgICovXG4gICAgX2dldENsYXNzTmFtZSgpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmljb24pIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSAnIGFlLWljb24tJyArIHRoaXMucHJvcHMuaWNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25Db21tYW5kTGlzdEl0ZW0ua2V5ID0gJ2J1dHRvbkNvbW1hbmRMaXN0SXRlbSc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZExpc3RJdGVtXG4pOyIsImltcG9ydCBCdXR0b25Db21tYW5kTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNvbW1hbmRzTGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzaG93aW5nIGEgbGlzdCBvZiBjb21tYW5kcyB0aGF0IGNhbiBiZVxuICogZXhlY3V0ZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ29tbWFuZHNMaXN0XG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uQ29tbWFuZHNMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogRm9jdXNlcyBvbiB0aGUgbGlzdCBub2RlIHRvIGFsbG93IGtleWJvYXJkIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcykuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1kcm9wZG93biBhZS1hcnJvdy1ib3ggYWUtYXJyb3ctYm94LXRvcC1sZWZ0XCIgb25Gb2N1cz17dGhpcy5mb2N1cy5iaW5kKHRoaXMpfSBvbktleURvd249e3RoaXMuaGFuZGxlS2V5LmJpbmQodGhpcyl9IHRhYkluZGV4PVwiMFwiPlxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJhZS1saXN0Ym94XCIgaWQ9e3RoaXMucHJvcHMubGlzdElkfSByb2xlPVwibGlzdGJveFwiPlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyQWN0aW9ucyh0aGlzLnByb3BzLmNvbW1hbmRzKX1cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBpbnN0YW5jZXMgb2YgQnV0dG9uQ29tbWFuZExpc3RJdGVtIHdpdGggdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSByb3cgYWN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kc0xpc3RcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJBY3Rpb25zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZW5kZXJlZCBpbnN0YW5jZXMgb2YgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGNsYXNzXG4gICAgICovXG4gICAgX3JlbmRlckFjdGlvbnMoY29tbWFuZHMpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgICAgICB2YXIgaXRlbXM7XG5cbiAgICAgICAgaWYgKGNvbW1hbmRzICYmIGNvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMgPSBjb21tYW5kcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW0uY29tbWFuZH0gcm9sZT1cIm9wdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSBjb21tYW5kPXtpdGVtLmNvbW1hbmR9IGRlc2NyaXB0aW9uPXt0eXBlb2YgaXRlbS5sYWJlbCA9PT0gJ3N0cmluZycgPyBpdGVtLmxhYmVsIDogaXRlbS5sYWJlbCgpfSBlZGl0b3I9e2VkaXRvcn0gLz5cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJ1dHRvbkNvbW1hbmRzTGlzdFxuICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25Db21tYW5kc0xpc3Qua2V5ID0gJ2J1dHRvbkNvbW1hbmRzTGlzdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25Db21tYW5kc0xpc3QuZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvbkNvbW1hbmRzTGlzdFxuKTsiLCJpbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRHJvcGRvd24gY2xhc3MgcHJvdmlkZXMgbWFya3VwIGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uIGJlaGF2aW91ciB0byBhIGRyb3Bkb3duXG4gKiBvcGVuZWQgZnJvbSBhIGJ1dHRvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRHJvcGRvd25cbiAqL1xuY2xhc3MgQnV0dG9uRHJvcGRvd24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Ecm9wZG93blxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1kcm9wZG93biBhZS1hcnJvdy1ib3ggYWUtYXJyb3ctYm94LXRvcC1sZWZ0XCIgb25Gb2N1cz17dGhpcy5mb2N1cy5iaW5kKHRoaXMpfSBvbktleURvd249e3RoaXMuaGFuZGxlS2V5LmJpbmQodGhpcyl9IHRhYkluZGV4PVwiMFwiPlxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJhZS1saXN0Ym94XCIgcm9sZT1cImxpc3Rib3hcIj5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGRyb3Bkb3duIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGRyb3Bkb3duXG4gKiBAbWVtYmVyb2YgQnV0dG9uRHJvcGRvd25cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uRHJvcGRvd24ua2V5ID0gJ2Ryb3Bkb3duJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25Ecm9wZG93blxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqL1xuQnV0dG9uRHJvcGRvd24uZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvbkRyb3Bkb3duXG4pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgS0VZX0VOVEVSID0gMTM7XG52YXIgS0VZX0VTQyA9IDI3O1xuXG4vKipcbiAqIFRoZSBCdXR0b25FbWJlZEVkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYW4gZW1iZWQgbGluayBpbiBhIGRvY3VtZW50LlxuICogUHJvdmlkZXMgVUkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGFuIGVtYmVkIGxpbmsuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkVtYmVkRWRpdFxuICovXG5jbGFzcyBCdXR0b25FbWJlZEVkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLmxpbmtJbnB1dCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogRm9jdXNlcyBvbiB0aGUgbGluayBpbnB1dCB0byBpbW1lZGlhdGVseSBhbGxvdyBlZGl0aW5nLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgY29tcG9uZW50XG4gICAgICogaXMgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gcHJldmVudCBhZ2dyZXNzaXZlIGZvY3VzIHN0ZWFsaW5nLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlIHx8IHRoaXMucHJvcHMubWFudWFsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZSBiZWZvcmUgZm9jdXNpbmcgdG8gYXZvaWQgdW5kZXNpcmVkXG4gICAgICAgICAgICAvLyBzY3JvbGxzIG9uIHRoZSBwYWdlXG4gICAgICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fZm9jdXNMaW5rSW5wdXQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5fZm9jdXNMaW5rSW5wdXQuYmluZCh0aGlzKSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhpcy5zdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIGdldEluaXRpYWxTdGF0ZVxuICAgICAqL1xuICAgIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciBlbWJlZDtcblxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbWJlZCA9IHNlbGVjdGVkRWxlbWVudC5maW5kT25lKCdbZGF0YS13aWRnZXQ9XCJhZV9lbWJlZFwiXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhyZWYgPSBlbWJlZCA/IGVtYmVkLmdldEF0dHJpYnV0ZSgnZGF0YS1hZS1lbWJlZC11cmwnKSA6ICcnO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbWJlZCxcbiAgICAgICAgICAgIGluaXRpYWxMaW5rOiB7XG4gICAgICAgICAgICAgICAgaHJlZjogaHJlZlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmtIcmVmOiBocmVmXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY2xlYXJMaW5rU3R5bGUgPSB7XG4gICAgICAgICAgICBvcGFjaXR5OiB0aGlzLnN0YXRlLmxpbmtIcmVmID8gMSA6IDBcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmRlbGV0ZUVtYmVkfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24tZW1iZWQtcmVtb3ZlXCIgZGlzYWJsZWQ9eyF0aGlzLnN0YXRlLmVsZW1lbnR9IG9uQ2xpY2s9e3RoaXMuX3JlbW92ZUVtYmVkLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVFbWJlZH0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYmluXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHh4bFwiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lPVwiYWUtaW5wdXRcIiBvbkNoYW5nZT17dGhpcy5faGFuZGxlTGlua0hyZWZDaGFuZ2UuYmluZCh0aGlzKX0gb25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3duLmJpbmQodGhpcyl9IHBsYWNlaG9sZGVyPXtBbGxveUVkaXRvci5TdHJpbmdzLmVkaXRMaW5rfSByZWY9e3RoaXMubGlua0lucHV0fSB0eXBlPVwidGV4dFwiIHZhbHVlPXt0aGlzLnN0YXRlLmxpbmtIcmVmfT48L2lucHV0PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJJbnB1dH0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uIGFlLWljb24tcmVtb3ZlXCIgb25DbGljaz17dGhpcy5fY2xlYXJMaW5rLmJpbmQodGhpcyl9IHN0eWxlPXtjbGVhckxpbmtTdHlsZX0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJ9PjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkaXNhYmxlZD17IXRoaXMuX2lzVmFsaWRTdGF0ZSgpfSBvbkNsaWNrPXt0aGlzLl9lbWJlZExpbmsuYmluZCh0aGlzKX0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tb2tcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGxpbmsgaW5wdXQuIFRoaXMgb25seSBjaGFuZ2VzIHRoZSBjb21wb25lbnQgaW50ZXJuYWwgc3RhdGUsIGJ1dCBkb2VzIG5vdFxuICAgICAqIGFmZmVjdCB0aGUgbGluayBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIE9ubHkgdGhlIF9yZW1vdmVMaW5rIGFuZCBfdXBkYXRlTGluayBtZXRob2RzXG4gICAgICogYXJlIHRyYW5zbGF0ZWQgdG8gdGhlIGVkaXRvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgX2NsZWFyTGlua1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2xlYXJMaW5rKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGxpbmtIcmVmOiAnJ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZW1iZWRVcmwgY29tbWFuZCB0byB0cmFuc2Zvcm0gdGhlIGxpbmsgaW50byBhbiBlbWJlZCBtZWRpYSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIF9lbWJlZExpbmtcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2VtYmVkTGluaygpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgbmF0aXZlRWRpdG9yLmV4ZWNDb21tYW5kKCdlbWJlZFVybCcsIHtcbiAgICAgICAgICAgIHVybDogdGhpcy5zdGF0ZS5saW5rSHJlZlxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG4gICAgICAgIC8vIGluc2lkZSBhbm90aGVyIGluIGV4Y2x1c2l2ZSBtb2RlIChzdWNoIGlzIHRoZSBjYXNlIG9mIHRoZSBsaW5rIGJ1dHRvbilcbiAgICAgICAgdGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSB1c2VyIGN1cnNvciBvbiB0aGUgd2lkZ2V0J3MgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBfZm9jdXNMaW5rSW5wdXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ZvY3VzTGlua0lucHV0KCkge1xuICAgICAgICB0aGlzLmxpbmtJbnB1dC5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuICAgICAqIC0gRW50ZXI6IENyZWF0ZXMvdXBkYXRlcyB0aGUgbGluay5cbiAgICAgKiAtIEVzY2FwZTogRGlzY2FyZHMgdGhlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRMaW5rKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcbiAgICAgICAgICAgIC8vIGluc2lkZSBhbm90aGVyIGluIGV4Y2x1c2l2ZSBtb2RlIChzdWNoIGlzIHRoZSBjYXNlIG9mIHRoZSBsaW5rIGJ1dHRvbilcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cbiAgICAgICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCBzdGF0ZSB3aGVuIHRoZSBsaW5rIGlucHV0IGNoYW5nZXMgb24gdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVMaW5rSHJlZkNoYW5nZVxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVMaW5rSHJlZkNoYW5nZShldmVudCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGxpbmtIcmVmOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCBsaW5rIHN0YXRlIGlzIHZhbGlkIHNvIHRoZSB1c2VyIGNhbiBzYXZlIHRoZSBsaW5rLiBBIHZhbGlkIHN0YXRlXG4gICAgICogbWVhbnMgdGhhdCB3ZSBoYXZlIGEgbm9uLWVtcHR5IGhyZWYgdGhhdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBvcmlnaW5hbCBvbmUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBfaXNWYWxpZFN0YXRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHN0YXRlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBfaXNWYWxpZFN0YXRlKCkge1xuICAgICAgICB2YXIgdmFsaWRTdGF0ZSA9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxpbmtIcmVmICYmIChcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmxpbmtIcmVmICE9PSB0aGlzLnN0YXRlLmluaXRpYWxMaW5rLmhyZWZcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZW1iZWQgaW4gdGhlIGVkaXRvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgX3JlbW92ZUVtYmVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVFbWJlZCgpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgdmFyIGVtYmVkV3JhcHBlciA9IHRoaXMuc3RhdGUuZWxlbWVudC5nZXRBc2NlbmRhbnQoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQ2xhc3MoJ2NrZV93aWRnZXRfd3JhcHBlcicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbWJlZFdyYXBwZXIucmVtb3ZlKCk7XG5cbiAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBlbWJlZEVkaXRcbiAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uRW1iZWRFZGl0LmtleSA9ICdlbWJlZEVkaXQnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25FbWJlZEVkaXQ7XG4iLCJpbXBvcnQgQnV0dG9uRW1iZWRFZGl0IGZyb20gJy4vYnV0dG9uLWVtYmVkLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25LZXlzdHJva2UgZnJvbSAnLi4vYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkVtYmVkIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGFuIGVtYmVkIGxpbmsgaW4gYSBkb2N1bWVudC5cbiAqIEJ1dHRvbkVtYmVkIHJlbmRlcnMgaW4gdHdvIGRpZmZlcmVudCBtb2RlczpcbiAqXG4gKiAtIE5vcm1hbDogSnVzdCBhIGJ1dHRvbiB0aGF0IGFsbG93cyB0byBzd2l0Y2ggdG8gdGhlIGVkaXRpb24gbW9kZVxuICogLSBFeGNsdXNpdmU6IFRoZSBCdXR0b25FbWJlZEVkaXQgVUkgd2l0aCBhbGwgdGhlIGxpbmsgZWRpdGlvbiBjb250cm9scy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRW1iZWRcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICovXG5jbGFzcyBCdXR0b25FbWJlZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8QnV0dG9uRW1iZWRFZGl0IHsuLi50aGlzLnByb3BzfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmxpbmt9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIGRhdGEtdHlwZT1cImJ1dHRvbi1lbWJlZFwiIG9uQ2xpY2s9e3RoaXMuX3JlcXVlc3RFeGNsdXNpdmUuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmxpbmt9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFkZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyB0aGUgbGluayBidXR0b24gdG8gYmUgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gYWxsb3cgdGhlIGVtYmVkZGluZyBvZiBhIGxpbmsuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRcbiAgICAgKiBAbWV0aG9kIF9yZXF1ZXN0RXhjbHVzaXZlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZXF1ZXN0RXhjbHVzaXZlKCkge1xuICAgICAgICB0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUoQnV0dG9uRW1iZWQua2V5KTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgZW1iZWRcbiAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25FbWJlZCAua2V5ID0gJ2VtYmVkJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uRW1iZWQuZGVmYXVsdFByb3BzID0ge1xuICAgIGtleXN0cm9rZToge1xuICAgICAgICBmbjogJ19yZXF1ZXN0RXhjbHVzaXZlJyxcbiAgICAgICAga2V5czogQ0tFRElUT1IuQ1RSTCArIENLRURJVE9SLlNISUZUICsgNzYgLypMKi9cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25LZXlzdHJva2UoXG4gICAgQnV0dG9uRW1iZWRcbik7IiwiaW1wb3J0IEJ1dHRvbkFjdGlvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWFjdGlvbi1zdHlsZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkgxIGNsYXNzIHByb3ZpZGVzIHdyYXBzIGEgc2VsZWN0aW9uIGluIGBoMWAgZWxlbWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSDFcbiAqIEB1c2VzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkgxIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSDFcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmgxfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1oMVwiIG9uQ2xpY2s9e3RoaXMuYXBwbHlTdHlsZS5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDF9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24taDFcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaDFcbiAqIEBtZW1iZXJvZiBCdXR0b25IMVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25IMS5rZXkgPSAnaDEnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkgxXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25IMS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgc3R5bGU6IHtcbiAgICAgICAgZWxlbWVudDogJ2gxJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uSDFcbikpKTsiLCJpbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSDIgY2xhc3MgcHJvdmlkZXMgd3JhcHMgYSBzZWxlY3Rpb24gaW4gYGgyYCBlbGVtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25IMlxuICogQHVzZXMgQnV0dG9uQWN0aW9uU3R5bGVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uSDIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25IMlxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDJ9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWgyXCIgb25DbGljaz17dGhpcy5hcHBseVN0eWxlLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5oMn0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1oMlwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBoMlxuICogQG1lbWJlcm9mIEJ1dHRvbkgyXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkgyLmtleSA9ICdoMic7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSDJcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkgyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBzdHlsZToge1xuICAgICAgICBlbGVtZW50OiAnaDInXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQWN0aW9uU3R5bGUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25IMlxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkhsaW5lIGNsYXNzIHByb3ZpZGVzIGluc2VydHMgaG9yaXpvbnRhbCBsaW5lLlxuICpcbiAqIEBjbGFzcyBCdXR0b25IbGluZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uSGxpbmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25IbGluZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmhvcml6b250YWxydWxlfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24taGxpbmVcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5ob3Jpem9udGFscnVsZX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1zZXBhcmF0b3JcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaGxpbmVcbiAqIEBtZW1iZXJvZiBCdXR0b25IbGluZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25IbGluZS5rZXkgPSAnaGxpbmUnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkhsaW5lXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25IbGluZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2hvcml6b250YWxydWxlJyxcbiAgICBzdHlsZToge1xuICAgICAgICBlbGVtZW50OiAnaHInXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uSGxpbmVcbikpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYW4gaW1hZ2UgaW4gdGhlIGNlbnRlci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduQ2VudGVyXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24taW1hZ2UtYWxpZ24tY2VudGVyXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXJ9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYWxpZ24tY2VudGVyXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGltYWdlQ2VudGVyXG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25JbWFnZUFsaWduQ2VudGVyLmtleSA9ICdpbWFnZUNlbnRlcic7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSW1hZ2VBbGlnbkNlbnRlci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2p1c3RpZnljZW50ZXInXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbkNvbW1hbmRBY3RpdmUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgICAgICBCdXR0b25JbWFnZUFsaWduQ2VudGVyXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSW1hZ2VBbGlnbkxlZnQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYW4gaW1hZ2Ugb24gbGVmdC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW1hZ2VBbGlnbkxlZnRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbWFnZUFsaWduTGVmdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25MZWZ0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkxlZnR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlLWFsaWduLWxlZnRcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkxlZnR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYWxpZ24tbGVmdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBpbWFnZUxlZnRcbiAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduTGVmdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25JbWFnZUFsaWduTGVmdC5rZXkgPSAnaW1hZ2VMZWZ0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduTGVmdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSW1hZ2VBbGlnbkxlZnQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdqdXN0aWZ5bGVmdCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvbkltYWdlQWxpZ25MZWZ0XG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsaWduaW5nIGFuIGltYWdlIG9uIHJpZ2h0LlxuICpcbiAqIEBjbGFzcyBCdXR0b25JbWFnZUFsaWduUmlnaHRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbWFnZUFsaWduUmlnaHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduUmlnaHRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25SaWdodH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hbGlnbi1yaWdodFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBpbWFnZVJpZ2h0XG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkltYWdlQWxpZ25SaWdodC5rZXkgPSAnaW1hZ2VSaWdodCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25JbWFnZUFsaWduUmlnaHQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdqdXN0aWZ5cmlnaHQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbkNvbW1hbmRBY3RpdmUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgICAgICBCdXR0b25JbWFnZUFsaWduUmlnaHRcbikpKTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlIGNsYXNzIGluc2VydHMgYW4gaW1hZ2UgdG8gdGhlIGNvbnRlbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlXG4gKi9cbmNsYXNzIEJ1dHRvbkltYWdlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuZmlsZUlucHV0ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBpbnB1dFN5bGUgPSB7ZGlzcGxheTogJ25vbmUnfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaW1hZ2V9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZVwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmltYWdlfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1pbWFnZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgICAgIDxpbnB1dCBhY2NlcHQ9XCJpbWFnZS8qXCIgb25DaGFuZ2U9e3RoaXMuX29uSW5wdXRDaGFuZ2UuYmluZCh0aGlzKX0gcmVmPXt0aGlzLmZpbGVJbnB1dH0gc3R5bGU9e2lucHV0U3lsZX0gdHlwZT1cImZpbGVcIi8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZXMgY2xpY2sgb24gdGhlIGlucHV0IGVsZW1lbnQuIFRoaXMgd2lsbCBvcGVuIGJyb3dzZXIncyBuYXRpdmUgZmlsZSBvcGVuIGRpYWxvZy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuICAgICAqIEBtZXRob2QgaGFuZGxlQ2xpY2tcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgcmVjZWl2ZWQgY2xpY2sgZXZlbnQgb24gdGhlIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBoYW5kbGVDbGljaygpIHtcbiAgICAgICAgdGhpcy5maWxlSW5wdXQuY3VycmVudC5jbGljaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uIGlucHV0IGNoYW5nZSwgcmVhZHMgdGhlIGNob3NlbiBmaWxlIGFuZCBmaXJlcyBhbiBldmVudCBgYmVmb3JlSW1hZ2VBZGRgIHdpdGggdGhlIGltYWdlIHdoaWNoIHdpbGwgYmUgYWRkZWRcbiAgICAgKiB0byB0aGUgY29udGVudC4gVGhlIGltYWdlIGZpbGUgd2lsbCBiZSBwYXNzZWQgaW4gdGhlIGBpbWFnZUZpbGVzYCBwcm9wZXJ0eS5cbiAgICAgKiBJZiBhbnkgb2YgdGhlIGxpc3RlbmVycyByZXR1cm5zIGBmYWxzZWAgb3IgY2FuY2VscyB0aGUgZXZlbnQsIHRoZSBpbWFnZSB3b24ndCBiZSBhZGRlZCB0byB0aGUgY29udGVudC5cbiAgICAgKiBPdGhlcndpc2UsIGFuIGV2ZW50IGBpbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBpbnNlcnRlZCBlbGVtZW50IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuXG4gICAgICogVGhlIHBhc3NlZCBwYXJhbXMgd2lsbCBiZTpcbiAgICAgKiAtIGBlbGAgLSB0aGUgY3JlYXRlZCBpbWcgZWxlbWVudFxuICAgICAqIC0gYGZpbGVgIC0gdGhlIG9yaWdpbmFsIGltYWdlIGZpbGUgZnJvbSB0aGUgaW5wdXQgZWxlbWVudFxuICAgICAqXG4gICAgICogQGZpcmVzIEJ1dHRvbkltYWdlI2JlZm9yZUltYWdlQWRkXG4gICAgICogQGZpcmVzIEJ1dHRvbkltYWdlI2ltYWdlQWRkXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlXG4gICAgICogQG1ldGhvZCBfb25JbnB1dENoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfb25JbnB1dENoYW5nZSgpIHtcbiAgICAgICAgdmFyIGlucHV0RWwgPSB0aGlzLmZpbGVJbnB1dC5jdXJyZW50O1xuXG4gICAgICAgIC8vIE9uIElFMTEgdGhlIGZ1bmN0aW9uIG1pZ2h0IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFycmF5IG9mXG4gICAgICAgIC8vIGZpbGVzLiBJbiBzdWNoIGEgY2FzZSwgbm8gYWN0aW9ucyB3aWxsIGJlIHRha2VuLlxuICAgICAgICBpZiAoIWlucHV0RWwuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgdmFyIGZpbGUgPSBpbnB1dEVsLmZpbGVzWzBdO1xuXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBlZGl0b3IuZmlyZSgnYmVmb3JlSW1hZ2VBZGQnLCB7XG4gICAgICAgICAgICAgICAgaW1hZ2VGaWxlczogZmlsZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKCc8aW1nIHNyYz1cIicgKyBldmVudC50YXJnZXQucmVzdWx0ICsgJ1wiPicpO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlXG4gICAgICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2ltYWdlQWRkJywgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuXG4gICAgICAgIGlucHV0RWwudmFsdWUgPSAnJztcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW1hZ2VcbiAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25JbWFnZS5rZXkgPSAnaW1hZ2UnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25JbWFnZTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkluZGVudEJsb2NrIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGluZGVudGluZyB0aGUgc2VsZWN0ZWQgYmxvY2tzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25JbmRlbnRCbG9ja1xuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkluZGVudEJsb2NrIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSW5kZW50QmxvY2tcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmluZGVudH0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24taW5kZW50LWJsb2NrXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaW5kZW50fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWluZGVudC1ibG9ja1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBpbmRlbnRCbG9ja1xuICogQG1lbWJlcm9mIEJ1dHRvbkluZGVudEJsb2NrXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkluZGVudEJsb2NrLmtleSA9ICdpbmRlbnRCbG9jayc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSW5kZW50QmxvY2tcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkluZGVudEJsb2NrLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnaW5kZW50J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uSW5kZW50QmxvY2tcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25LZXlzdHJva2UgZnJvbSAnLi4vYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSXRhbGljIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHN0eWxpbmcgYW4gc2VsZWN0aW9uIHdpdGggaXRhbGljIChlbSkgc3R5bGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkl0YWxpY1xuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkl0YWxpYyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaXRhbGljfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1pdGFsaWNcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pdGFsaWN9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24taXRhbGljXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGl0YWxpY1xuICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25JdGFsaWMua2V5ID0gJ2l0YWxpYyc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSXRhbGljXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25JdGFsaWMuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdpdGFsaWMnLFxuICAgIGtleXN0cm9rZToge1xuICAgICAgICBmbjogJ2V4ZWNDb21tYW5kJyxcbiAgICAgICAga2V5czogQ0tFRElUT1IuQ1RSTCArIDczIC8qSSovXG4gICAgfSxcbiAgICBzdHlsZTogJ2NvcmVTdHlsZXNfaXRhbGljJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25LZXlzdHJva2UoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25JdGFsaWNcbikpKSk7IiwiaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4vYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc2hvd2luZyBhIGxpc3Qgb2ZcbiAqIGl0ZW1zIHRoYXQgY2FuIGJlIHNlbGVjdGVkIGZvciB0aGUgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICghbmV4dFByb3BzLnRlcm0gfHwgbmV4dFByb3BzLnRlcm0gIT09IHRoaXMucHJvcHMudGVybSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuXG4gICAgICAgICAgICBpZiAobmV4dFByb3BzLnRlcm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl91cGRhdGVJdGVtcywgdGhpcy5wcm9wcy5kZWxheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0UHJvcHMuYXV0b2NvbXBsZXRlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5mb2N1cywgMCk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnNldEF1dG9jb21wbGV0ZVN0YXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuZXhwYW5kZWQgfHwgIXRoaXMuc3RhdGUuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8QnV0dG9uRHJvcGRvd24+XG4gICAgICAgICAgICAgICAge3RoaXMuX3JlbmRlckF1dG9jb21wbGV0ZUl0ZW1zKHRoaXMuc3RhdGUuaXRlbXMpfVxuICAgICAgICAgICAgPC9CdXR0b25Ecm9wZG93bj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgYmVmb3JlIHJlbmRlcmluZyB3aGVuIG5ldyBwcm9wcyBvciBzdGF0ZSBhcmUgYmVpbmcgcmVjZWl2ZWQuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyIG9yIHdoZW4gZm9yY2VVcGRhdGUgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICAgICAqIEBtZXRob2QgIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzIGFuZCBzdGF0ZSB3aWxsIG5vdFxuICAgICAqIHJlcXVpcmUgYSBjb21wb25lbnQgdXBkYXRlLlxuICAgICAqL1xuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV4dFByb3BzLmV4cGFuZGVkICE9PSB0aGlzLnByb3BzLmV4cGFuZGVkIHx8IG5leHRQcm9wcy50ZXJtICE9PSB0aGlzLnByb3BzLnRlcm0gfHwgbmV4dFN0YXRlLml0ZW1zICE9PSB0aGlzLnN0YXRlLml0ZW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzZXQgb2YgbGlzdCBpdGVtcyBmb3IgdGhlIHByb3ZpZGVkIGl0ZW1zXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJBdXRvY29tcGxldGVJdGVtc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIExpc3Qgb2YgYXV0b2NvbXBsZXRlIGl0ZW1zIHRvIHJlbmRlclxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmVuZGVyZWQgbGlzdCBpdGVtIGluc3RhbmNlc1xuICAgICAqL1xuICAgIF9yZW5kZXJBdXRvY29tcGxldGVJdGVtcyhpdGVtcykge1xuICAgICAgICBpdGVtcyA9IGl0ZW1zIHx8IFtdO1xuXG4gICAgICAgIHZhciBoYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2sgPSB0aGlzLnByb3BzLmhhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljaztcblxuICAgICAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLnRlcm0gPT09IGl0ZW0udXJsID8gJ2FlLXRvb2xiYXItZWxlbWVudCBhY3RpdmUnIDogJ2FlLXRvb2xiYXItZWxlbWVudCc7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGxpIGtleT17aXRlbS51cmx9IHJvbGU9XCJvcHRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gb25DbGljaz17aGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrfSBkYXRhLXZhbHVlPXtpdGVtLnVybH0+e2l0ZW0udGl0bGV9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBkYXRhIGFjY29yZGluZyB0byB7dGhpcy5wcm9wcy50ZXJtfSBhbmQgY2FsbHMgc2V0U3RhdGUoKSB3aXRoIHRoZSByZXR1cm5lZCBkYXRhXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVJdGVtc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlSXRlbXMoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnRlcm0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMucHJvcHMuZGF0YSh0aGlzLnByb3BzLnRlcm0pKTtcblxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAhaW5zdGFuY2UucHJvcHMuZXhwYW5kZWQgJiYgaW5zdGFuY2UucHJvcHMudG9nZ2xlRHJvcGRvd24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBidXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0LmtleSA9ICdidXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjaXJjdWxhcjogZmFsc2UsXG4gICAgZGF0YTogW10sXG4gICAgZGVsYXk6IDEwMCxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4pOyIsImltcG9ydCBCdXR0b25DZmdQcm9wcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1wcm9wcy5qcyc7XG5pbXBvcnQgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgZnJvbSAnLi9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtUYXJnZXRFZGl0IGZyb20gJy4vYnV0dG9uLWxpbmstdGFyZ2V0LWVkaXQuanN4JztcbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBXaWRnZXREcm9wZG93biBmcm9tICcuLi9iYXNlL3dpZGdldC1kcm9wZG93bi5qcyc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rRWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIGxpbmsgaW4gYSBkb2N1bWVudC5cbiAqIFByb3ZpZGVzIFVJIGZvciBjcmVhdGluZywgZWRpdGluZyBhbmQgcmVtb3ZpbmcgYSBsaW5rLlxuICpcbiAqIEBjbGFzcyBCdXR0b25MaW5rRWRpdFxuICogQHVzZXMgQnV0dG9uQ2ZnUHJvcHNcbiAqIEB1c2VzIFdpZGdldERyb3Bkb3duXG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uTGlua0VkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLmxpbmtJbnB1dCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5fZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIGNvbXBvbmVudFxuICAgICAqIGlzIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIHByZXZlbnQgYWdncmVzc2l2ZSBmb2N1cyBzdGVhbGluZy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlIHx8IHRoaXMucHJvcHMubWFudWFsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZSBiZWZvcmUgZm9jdXNpbmcgdG8gYXZvaWQgdW5kZXNpcmVkXG4gICAgICAgICAgICAvLyBzY3JvbGxzIG9uIHRoZSBwYWdlXG4gICAgICAgICAgICB0aGlzLl9mb2N1c0xpbmtJbnB1dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuX2dldEluaXRpYWxTdGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHRhcmdldFNlbGVjdG9yID0ge1xuICAgICAgICAgICAgYWxsb3dlZFRhcmdldHM6IHRoaXMucHJvcHMuYWxsb3dlZFRhcmdldHMsXG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMucHJvcHMuZWRpdG9yLFxuICAgICAgICAgICAgaGFuZGxlTGlua1RhcmdldENoYW5nZTogdGhpcy5faGFuZGxlTGlua1RhcmdldENoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc2VsZWN0ZWRUYXJnZXQ6IHRoaXMuc3RhdGUubGlua1RhcmdldCB8fCBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXREZWZhdWx0XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0U2VsZWN0b3IgPSB0aGlzLm1lcmdlRHJvcGRvd25Qcm9wcyh0YXJnZXRTZWxlY3RvciwgQnV0dG9uTGlua1RhcmdldEVkaXQua2V5KTtcblxuICAgICAgICB2YXIgYXV0b2NvbXBsZXRlRHJvcGRvd247XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGF0YSkge1xuICAgICAgICAgICAgdmFyIGRhdGFGbiA9IHRoaXMucHJvcHMuZGF0YTtcblxuICAgICAgICAgICAgaWYgKCFMYW5nLmlzRnVuY3Rpb24oZGF0YUZuKSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMucHJvcHMuZGF0YTtcblxuICAgICAgICAgICAgICAgIGRhdGFGbiA9ICgpID0+IGl0ZW1zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBhdXRvY29tcGxldGVTZWxlY3RlZDogdGhpcy5zdGF0ZS5hdXRvY29tcGxldGVTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhRm4sXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLnByb3BzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBoYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2s6IHRoaXMuX2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayxcbiAgICAgICAgICAgICAgICBvbkRpc21pc3M6IHRoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24sXG4gICAgICAgICAgICAgICAgc2V0QXV0b2NvbXBsZXRlU3RhdGU6IHRoaXMuX3NldEF1dG9jb21wbGV0ZVN0YXRlLFxuICAgICAgICAgICAgICAgIHRlcm06IHRoaXMuc3RhdGUubGlua0hyZWZcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMgPSB0aGlzLm1lcmdlRHJvcGRvd25Qcm9wcyhhdXRvY29tcGxldGVEcm9wZG93blByb3BzLCBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdC5rZXkpO1xuXG4gICAgICAgICAgICBhdXRvY29tcGxldGVEcm9wZG93biA9IDxCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCB7Li4uYXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wc30gLz47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnV0dG9uQ2xlYXJMaW5rO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmxpbmtIcmVmKSB7XG4gICAgICAgICAgICBidXR0b25DbGVhckxpbmsgPSA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJJbnB1dH0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uIGFlLWljb24tcmVtb3ZlXCIgb25DbGljaz17dGhpcy5fY2xlYXJMaW5rLmJpbmQodGhpcyl9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFyfT48L2J1dHRvbj47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGxhY2Vob2xkZXJQcm9wID0ge307XG5cbiAgICAgICAgaWYgKCFDS0VESVRPUi5lbnYuaWUgJiYgQWxsb3lFZGl0b3IuU3RyaW5ncykge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXJQcm9wLnBsYWNlaG9sZGVyID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5lZGl0TGluaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1lZGl0LWxpbmtcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MucmVtb3ZlTGlua30gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGlzYWJsZWQ9eyF0aGlzLnN0YXRlLmVsZW1lbnR9IG9uQ2xpY2s9e3RoaXMuX3JlbW92ZUxpbmsuYmluZCh0aGlzKX0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MucmVtb3ZlfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi11bmxpbmtcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgeHhsXCI+XG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLnNob3dUYXJnZXRTZWxlY3RvciAmJiA8QnV0dG9uTGlua1RhcmdldEVkaXQgey4uLnRhcmdldFNlbGVjdG9yfSAvPn1cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzc05hbWU9XCJhZS1pbnB1dFwiIG9uQ2hhbmdlPXt0aGlzLl9oYW5kbGVMaW5rSHJlZkNoYW5nZS5iaW5kKHRoaXMpfSBvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd24uYmluZCh0aGlzKX0geyAuLi5wbGFjZWhvbGRlclByb3AgfSByZWY9e3RoaXMubGlua0lucHV0fSB0eXBlPVwidGV4dFwiIHZhbHVlPXt0aGlzLnN0YXRlLmxpbmtIcmVmfT48L2lucHV0PlxuICAgICAgICAgICAgICAgICAgICAgICAge2F1dG9jb21wbGV0ZURyb3Bkb3dufVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbkNsZWFyTGlua31cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGlzYWJsZWQ9eyF0aGlzLl9pc1ZhbGlkU3RhdGUoKX0gb25DbGljaz17dGhpcy5fdXBkYXRlTGluay5iaW5kKHRoaXMpfSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1va1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoaXMuc3RhdGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9nZXRJbml0aWFsU3RhdGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9nZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHtlZGl0b3IsIGRlZmF1bHRMaW5rVGFyZ2V0fSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgbGluayA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpKS5nZXRGcm9tU2VsZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IGhyZWYgPSBsaW5rID8gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSA6ICcnO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsaW5rID8gbGluay5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpIDogZGVmYXVsdExpbmtUYXJnZXQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZVNlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGxpbmssXG4gICAgICAgICAgICBpbml0aWFsTGluazoge1xuICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rSHJlZjogaHJlZixcbiAgICAgICAgICAgIGxpbmtUYXJnZXQ6IHRhcmdldFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgbGluayBpbnB1dC4gVGhpcyBvbmx5IGNoYW5nZXMgdGhlIGNvbXBvbmVudCBpbnRlcm5hbCBzdGF0ZSwgYnV0IGRvZXMgbm90XG4gICAgICogYWZmZWN0IHRoZSBsaW5rIGVsZW1lbnQgb2YgdGhlIGVkaXRvci4gT25seSB0aGUgX3JlbW92ZUxpbmsgYW5kIF91cGRhdGVMaW5rIG1ldGhvZHNcbiAgICAgKiBhcmUgdHJhbnNsYXRlZCB0byB0aGUgZWRpdG9yIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9jbGVhckxpbmtcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NsZWFyTGluaygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsaW5rSHJlZjogJydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSB1c2VyIGN1cnNvciBvbiB0aGUgd2lkZ2V0J3MgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9mb2N1c0xpbmtJbnB1dFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZm9jdXNMaW5rSW5wdXQoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGZvY3VzTGlua0VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5saW5rSW5wdXQuY3VycmVudC5mb2N1cygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZvY3VzTGlua0VsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZm9jdXNMaW5rRWwsIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuICAgICAqIC0gRW50ZXI6IENyZWF0ZXMvdXBkYXRlcyB0aGUgbGluay5cbiAgICAgKiAtIEVzY2FwZTogRGlzY2FyZHMgdGhlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVLZXlEb3duXG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGtleWJvYXJkIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxpbmsoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlU2VsZWN0ZWQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICAgICAgbmV3IENLRURJVE9SLkxpbmsoZWRpdG9yKS5hZHZhbmNlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGUgbGluayBpbnB1dCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVMaW5rSHJlZkNoYW5nZVxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVMaW5rSHJlZkNoYW5nZShldmVudCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGxpbmtIcmVmOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGUgbGluayB0YXJnZXQgY2hhbmdlcyBvbiB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlTGlua1RhcmdldENoYW5nZVxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjbGljayBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpdGVtRHJvcGRvd246IG51bGwsXG4gICAgICAgICAgICBsaW5rVGFyZ2V0OiBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiBhbiBhdXRvY29tcGxldGUgbGluayByZXN1bHQgaXMgc2VsZWN0ZWQgYnkgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICAgICAqIEBtZXRob2QgX2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGlja1xuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjbGljayBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayhldmVudCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGl0ZW1Ecm9wZG93bjogbnVsbCxcbiAgICAgICAgICAgIGxpbmtIcmVmOiBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSBjdXJyZW50IGxpbmsgc3RhdGUgaXMgdmFsaWQgc28gdGhlIHVzZXIgY2FuIHNhdmUgdGhlIGxpbmsuIEEgdmFsaWQgc3RhdGVcbiAgICAgKiBtZWFucyB0aGF0IHdlIGhhdmUgYSBub24tZW1wdHkgaHJlZiBhbmQgdGhhdCBlaXRoZXIgdGhhdCBvciB0aGUgbGluayB0YXJnZXQgYXJlIGRpZmZlcmVudFxuICAgICAqIGZyb20gdGhlIG9yaWdpbmFsIGxpbmsuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9pc1ZhbGlkU3RhdGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIF9pc1ZhbGlkU3RhdGUoKSB7XG4gICAgICAgIHZhciB2YWxpZFN0YXRlID1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUubGlua0hyZWYgJiYgKFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUubGlua0hyZWYgIT09IHRoaXMuc3RhdGUuaW5pdGlhbExpbmsuaHJlZiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUubGlua1RhcmdldCAhPT0gdGhpcy5zdGF0ZS5pbml0aWFsTGluay50YXJnZXRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGluayBpbiB0aGUgZWRpdG9yIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9yZW1vdmVMaW5rXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVMaW5rKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcik7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBib29rbWFya3MgPSBzZWxlY3Rpb24uY3JlYXRlQm9va21hcmtzKCk7XG5cbiAgICAgICAgbGlua1V0aWxzLnJlbW92ZSh0aGlzLnN0YXRlLmVsZW1lbnQsIHsgYWR2YW5jZTogdHJ1ZSB9KTtcblxuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0Qm9va21hcmtzKGJvb2ttYXJrcyk7XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuICAgICAgICAvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG4gICAgICAgIHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cbiAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhdXRvY29tcGxldGVTZWxlY3RlZCBzdGF0ZSB0byBmb2N1cyBhbmQgc2VsZWN0IGF1dG9jb21wbGV0ZcK0cyBkcm9wZG93blxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfc2V0QXV0b2NvbXBsZXRlU3RhdGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldEF1dG9jb21wbGV0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlU2VsZWN0ZWQ6IHN0YXRlLnNlbGVjdGVkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxpbmsgaW4gdGhlIGVkaXRvciBlbGVtZW50LiBJZiB0aGUgZWxlbWVudCBkaWRuJ3QgZXhpc3QgcHJldmlvdXNseSwgaXQgd2lsbFxuICAgICAqIGNyZWF0ZSBhIG5ldyA8YT4gZWxlbWVudCB3aXRoIHRoZSBocmVmIHNwZWNpZmllZCBpbiB0aGUgbGluayBpbnB1dC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICAgICAqIEBtZXRob2QgX3VwZGF0ZUxpbmtcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUxpbmsoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgbGlua1V0aWxzID0gbmV3IENLRURJVE9SLkxpbmsoZWRpdG9yLCB7YXBwZW5kUHJvdG9jb2w6IHRoaXMucHJvcHMuYXBwZW5kUHJvdG9jb2x9KTtcbiAgICAgICAgdmFyIGxpbmtBdHRycyA9IHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5zdGF0ZS5saW5rVGFyZ2V0XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb2RpZnlTZWxlY3Rpb24gPSB7IGFkdmFuY2U6IHRydWUgfTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5saW5rSHJlZikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGxpbmtBdHRycy5ocmVmID0gdGhpcy5zdGF0ZS5saW5rSHJlZjtcblxuICAgICAgICAgICAgICAgIGxpbmtVdGlscy51cGRhdGUobGlua0F0dHJzLCB0aGlzLnN0YXRlLmVsZW1lbnQsIG1vZGlmeVNlbGVjdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmtVdGlscy5jcmVhdGUodGhpcy5zdGF0ZS5saW5rSHJlZiwgbGlua0F0dHJzLCBtb2RpZnlTZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG4gICAgICAgIC8vIGluc2lkZSBhbm90aGVyIGluIGV4Y2x1c2l2ZSBtb2RlIChzdWNoIGlzIHRoZSBjYXNlIG9mIHRoZSBsaW5rIGJ1dHRvbilcbiAgICAgICAgdGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgbGlua0VkaXRcbiAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25MaW5rRWRpdC5rZXkgPSAnbGlua0VkaXQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25MaW5rRWRpdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgYXBwZW5kUHJvdG9jb2w6IHRydWUsXG4gICAgYXV0b2NvbXBsZXRlVXJsOiAnJyxcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBjdXN0b21JbmRleFN0YXJ0OiB0cnVlLFxuICAgIGRlZmF1bHRMaW5rVGFyZ2V0OiAnJyxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfSxcbiAgICBzaG93VGFyZ2V0U2VsZWN0b3I6IHRydWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNmZ1Byb3BzKFxuICAgIFdpZGdldERyb3Bkb3duKFxuICAgIFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICAgICAgQnV0dG9uTGlua0VkaXRcbikpKTtcbiIsImltcG9ydCBCdXR0b25UYXJnZXRMaXN0IGZyb20gJy4vYnV0dG9uLXRhcmdldC1saXN0LmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rVGFyZ2V0RWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjaGFuZ2luZyB0aGUgdGFyZ2V0IG9mIGEgbGlua1xuICogaW4gdGhlIGRvY3VtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuICovXG5jbGFzcyBCdXR0b25MaW5rVGFyZ2V0RWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtUYXJnZXRFZGl0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlID0gdGhpcy5wcm9wcy5oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlO1xuICAgICAgICB2YXIgYWxsb3dlZExpbmtUYXJnZXRzID0gdGhpcy5wcm9wcy5hbGxvd2VkVGFyZ2V0cztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rLXRhcmdldCBhZS1jb250YWluZXItZHJvcGRvd24gYWUtY29udGFpbmVyLWRyb3Bkb3duLW1lZGl1bSBhZS1oYXMtZHJvcGRvd25cIiB0YWJJbmRleD1cIjBcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9IGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXR9IGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiIG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzKX0gcm9sZT1cImNvbWJvYm94XCIgdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXt0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0fT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi1zZWxlY3RlZC1pdGVtXCI+e3RoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hcnJvd1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuZXhwYW5kZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uVGFyZ2V0TGlzdCBlZGl0b3I9e3RoaXMucHJvcHMuZWRpdG9yfSBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259IGFsbG93ZWRMaW5rVGFyZ2V0cz17YWxsb3dlZExpbmtUYXJnZXRzfSBoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlPXtoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlfSBzZWxlY3RlZFRhcmdldD17dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldH0vPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgYmVmb3JlIHJlbmRlcmluZyB3aGVuIG5ldyBwcm9wcyBvciBzdGF0ZSBhcmUgYmVpbmcgcmVjZWl2ZWQuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyIG9yIHdoZW4gZm9yY2VVcGRhdGUgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuICAgICAqIEBtZXRob2QgIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzIGFuZCBzdGF0ZSB3aWxsIG5vdFxuICAgICAqIHJlcXVpcmUgYSBjb21wb25lbnQgdXBkYXRlLlxuICAgICAqL1xuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQcm9wcy5leHBhbmRlZCAhPT0gdGhpcy5wcm9wcy5leHBhbmRlZCB8fCBuZXh0UHJvcHMuc2VsZWN0ZWRUYXJnZXQgIT09IHRoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGxpbmtUYXJnZXRFZGl0XG4gKiBAbWVtYmVyb2YgQnV0dG9uTGlua1RhcmdldEVkaXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uTGlua1RhcmdldEVkaXQua2V5ID0gJ2xpbmtUYXJnZXRFZGl0JztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uTGlua1RhcmdldEVkaXQ7XG4iLCJpbXBvcnQgQnV0dG9uQ2ZnUHJvcHMgZnJvbSAnLi4vYmFzZS9idXR0b24tcHJvcHMuanMnO1xuaW1wb3J0IEJ1dHRvbkxpbmtFZGl0IGZyb20gJy4vYnV0dG9uLWxpbmstZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkxpbmsgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYSBsaW5rIGluIGEgZG9jdW1lbnQuIEJ1dHRvbkxpbmtcbiAqIHJlbmRlcnMgaW4gdHdvIGRpZmZlcmVudCBtb2RlczpcbiAqXG4gKiAtIE5vcm1hbDogSnVzdCBhIGJ1dHRvbiB0aGF0IGFsbG93cyB0byBzd2l0Y2ggdG8gdGhlIGVkaXRpb24gbW9kZVxuICogLSBFeGNsdXNpdmU6IFRoZSBCdXR0b25MaW5rRWRpdCBVSSB3aXRoIGFsbCB0aGUgbGluayBlZGl0aW9uIGNvbnRyb2xzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25MaW5rXG4gKiBAdXNlcyBCdXR0b25DZmdQcm9wc1xuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uTGluayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgbGluay5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG4gICAgICogQG1ldGhvZCBpc0FjdGl2ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHNlbGVjdGlvbiBpcyBpbnNpZGUgYSBsaW5rLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiAobmV3IENLRURJVE9SLkxpbmsodGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKSkuZ2V0RnJvbVNlbGVjdGlvbigpICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gdGhpcy5tZXJnZUJ1dHRvbkNmZ1Byb3BzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEJ1dHRvbkxpbmtFZGl0IHsuLi5wcm9wc30gLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tbGlua1wiIG9uQ2xpY2s9e3RoaXMuX3JlcXVlc3RFeGNsdXNpdmUuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmxpbmt9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWxpbmtcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgdGhlIGxpbmsgYnV0dG9uIHRvIGJlIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhIGxpbmsuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuICAgICAqIEBtZXRob2QgX3JlcXVlc3RFeGNsdXNpdmVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlcXVlc3RFeGNsdXNpdmUoKSB7XG4gICAgICAgIHRoaXMucHJvcHMucmVxdWVzdEV4Y2x1c2l2ZShCdXR0b25MaW5rLmtleSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGxpbmtcbiAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkxpbmsua2V5ID0gJ2xpbmsnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICAgIGtleXN0cm9rZToge1xuICAgICAgICBmbjogJ19yZXF1ZXN0RXhjbHVzaXZlJyxcbiAgICAgICAga2V5czogQ0tFRElUT1IuQ1RSTCArIDc2IC8qTCovXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ2ZnUHJvcHMoXG4gICAgQnV0dG9uS2V5c3Ryb2tlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uTGlua1xuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25PcmRlcmVkTGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBvcmRlcmVkIGxpc3RzIGluIGFuIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uT3JkZXJlZExpc3RcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uT3JkZXJlZExpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25PcmRlcmVkTGlzdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MubnVtYmVyZWRsaXN0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1vbFwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLm51bWJlcmVkbGlzdH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1udW1iZXJlZC1saXN0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IG9sXG4gKiBAbWVtYmVyb2YgQnV0dG9uT3JkZXJlZExpc3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uT3JkZXJlZExpc3Qua2V5ID0gJ29sJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25PcmRlcmVkTGlzdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uT3JkZXJlZExpc3QuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdudW1iZXJlZGxpc3QnLFxuICAgIHN0eWxlOiB7XG4gICAgICAgIGVsZW1lbnQ6ICdvbCdcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uT3JkZXJlZExpc3RcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25PdXRkZW50QmxvY2sgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igb3V0ZGVudGluZyBibG9ja3MuXG4gKlxuICogQGNsYXNzIEJ1dHRvbk91dGRlbnRCbG9ja1xuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbk91dGRlbnRCbG9jayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbk91dGRlbnRCbG9ja1xuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Mub3V0ZGVudH0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tb3V0ZGVudC1ibG9ja1wiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLm91dGRlbnR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tb3V0ZGVudC1ibG9ja1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBpbmRlbnRCbG9ja1xuICogQG1lbWJlcm9mIEJ1dHRvbk91dGRlbnRCbG9ja1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25PdXRkZW50QmxvY2sua2V5ID0gJ291dGRlbnRCbG9jayc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uT3V0ZGVudEJsb2NrXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25PdXRkZW50QmxvY2suZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdvdXRkZW50J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uT3V0ZGVudEJsb2NrXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0Jztcbi8qKlxuICogVGhlIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhIHBhcmFncmFwaCBvbiBsZWZ0LlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdH0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnRcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkxlZnR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYWxpZ24tbGVmdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBwYXJhZ3JhcGhMZWZ0XG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblBhcmFncmFwaEFsaWduTGVmdC5rZXkgPSAncGFyYWdyYXBoTGVmdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdqdXN0aWZ5bGVmdCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdFxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsaWduaW5nIGEgcGFyYWdyYXBoIG9uIHJpZ2h0LlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1yaWdodFwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYWxpZ24tcmlnaHRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgcGFyYWdyYXBoUmlnaHRcbiAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQua2V5ID0gJ3BhcmFncmFwaFJpZ2h0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnanVzdGlmeXJpZ2h0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblBhcmFncmFwaENlbnRlciBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjZW50ZXJpbmcgYSBwYXJhZ3JhcGguXG4gKlxuICogQGNsYXNzIEJ1dHRvblBhcmFncmFwaENlbnRlclxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaENlbnRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaENlbnRlclxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXJ9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXBhcmFncmFwaC1jZW50ZXJcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hbGlnbi1jZW50ZXJcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgcGFyYWdyYXBoQ2VudGVyXG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQ2VudGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblBhcmFncmFwaENlbnRlci5rZXkgPSAncGFyYWdyYXBoQ2VudGVyJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvblBhcmFncmFwaENlbnRlci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2p1c3RpZnljZW50ZXInXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbkNvbW1hbmRBY3RpdmUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgICAgICBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGp1c3RmeWluZyBhIHBhcmFncmFwaC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaEp1c3RpZnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkp1c3RpZnl9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXBhcmFncmFwaC1qdXN0aWZ5XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25KdXN0aWZ5fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLWp1c3RpZmllZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBwYXJhZ3JhcGhKdXN0aWZ5XG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25QYXJhZ3JhcGhKdXN0aWZ5LmtleSA9ICdwYXJhZ3JhcGhKdXN0aWZ5JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25QYXJhZ3JhcGhKdXN0aWZ5LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnanVzdGlmeWJsb2NrJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeVxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25RdW90ZSBjbGFzcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgYmxvY2txdW90ZWAgZWxlbWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUXVvdGVcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uUXVvdGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25RdW90ZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MucXVvdGV9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXF1b3RlXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MucXVvdGV9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tcXVvdGVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgcXVvdGVcbiAqIEBtZW1iZXJvZiBCdXR0b25RdW90ZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25RdW90ZS5rZXkgPSAncXVvdGUnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblF1b3RlXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25RdW90ZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2Jsb2NrcXVvdGUnLFxuICAgIHN0eWxlOiB7XG4gICAgICAgIGVsZW1lbnQ6ICdibG9ja3F1b3RlJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25RdW90ZVxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUmVtb3ZlRm9ybWF0IGNsYXNzIHJlbW92ZXMgc3R5bGUgZm9ybWF0dGluZy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUmVtb3ZlRm9ybWF0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKi9cbmNsYXNzIEJ1dHRvblJlbW92ZUZvcm1hdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZWZvcm1hdH0gY2xhc3NOYW1lPSdhZS1idXR0b24nIGRhdGEtdHlwZT1cImJ1dHRvbi1yZW1vdmVmb3JtYXRcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVmb3JtYXR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tcmVtb3ZlZm9ybWF0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHJlbW92ZUZvcm1hdFxuICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25SZW1vdmVGb3JtYXQua2V5ID0gJ3JlbW92ZUZvcm1hdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUmVtb3ZlRm9ybWF0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25SZW1vdmVGb3JtYXQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdyZW1vdmVGb3JtYXQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvblJlbW92ZUZvcm1hdFxuKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3RyaWtlIGNsYXNzIHN0eWxlcyBhIHNlbGVjdGlvbiB3aXRoIHN0cmlrZSBzdHlsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3RyaWtlXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblN0cmlrZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2VcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0cmlrZX0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tc3RyaWtlXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3RyaWtlfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXN0cmlrZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBzdHJpa2VcbiAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU3RyaWtlLmtleSA9ICdzdHJpa2UnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblN0cmlrZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uU3RyaWtlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnc3RyaWtlJyxcbiAgICBzdHlsZTogJ2NvcmVTdHlsZXNfc3RyaWtlJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvblN0cmlrZVxuKSkpOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGNsYXNzIHByb3ZpZGVzIHRoZSBoZWFkZXIgb2YgYW4gbGlzdCBvZiBzdHlsZSBpdGVtcy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXJcbiAqL1xuY2xhc3MgQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25zU3R5bGVzTGlzdEhlYWRlclxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zdHlsZXMgJiYgdGhpcy5wcm9wcy5zdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWxpc3QtaGVhZGVyXCI+e3RoaXMucHJvcHMubmFtZX08L3NwYW4+XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHByZXZpZXdpbmcgYSBzdHlsZSBkZWZpbml0aW9uXG4gKiBpbnNpZGUgYSBsaXN0IGFuZCBhcHBseWluZyBpdCB0byB0aGUgY3VycmVudCBlZGl0b3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuICovXG5jbGFzcyBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8bGkgcm9sZT1cIm9wdGlvblwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCIgb25DbGljaz17dGhpcy5fcmVtb3ZlU3R5bGVzLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fT57QWxsb3lFZGl0b3IuU3RyaW5ncy5ub3JtYWx9PC9idXR0b24+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGlubGluZSBzdHlsZXMgYW5kIGNvbmZpZ3VyZWQgYmxvY2sgZWxlbWVudHMgYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcbiAgICAgKiBAbWV0aG9kIF9yZW1vdmVTdHlsZXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlbW92ZVN0eWxlcygpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdyZW1vdmVGb3JtYXQnKTtcblxuICAgICAgICB0aGlzLnByb3BzLnJlbW92ZUJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKGJsb2NrSXRlbSkge1xuICAgICAgICAgICAgdmFyIGJsb2NrU3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoe2VsZW1lbnQ6IGJsb2NrSXRlbX0pO1xuXG4gICAgICAgICAgICBlZGl0b3IucmVtb3ZlU3R5bGUoYmxvY2tTdHlsZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgYnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcbiAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZS5rZXkgPSAnYnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgcmVtb3ZlQmxvY2tzOiBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ3ByZSddXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZTtcbiIsImltcG9ydCBCdXR0b25BY3Rpb25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1hY3Rpb24tc3R5bGUuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0eWxlc0xpc3RJdGVtIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHByZXZpZXdpbmcgYSBzdHlsZSBkZWZpbml0aW9uXG4gKiBpbnNpZGUgYSBsaXN0IGFuZCBhcHBseWluZyBpdCB0byB0aGUgY3VycmVudCBlZGl0b3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZXNMaXN0SXRlbVxuICogQHVzZXMgQnV0dG9uQWN0aW9uU3R5bGVcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIsIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtXG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIC8vIFN0eWxlcyB3aXRoIHdpbGRjYXJkIGVsZW1lbnQgKCopIGdlbmVyYXRlIGFuIGVtcHR5IHRhZyBpbiB0aGVpciBwcmV2aWV3IDwgY2xhc3M9XCJjdXN0b20tY2xhc3NcIiAvPi5cbiAgICAgICAgLy8gV2UgZGVmYXVsdCB0byBlbGVtZW50IHNwYW4gYW5kIHJlbW92ZSB0aGUgbWFyZ2lucyB0byBvYnRhaW4gYSBtb3JlIGNvbnNpc3RlbnQgc2V0IG9mIHByZXZpZXdzLlxuICAgICAgICB2YXIgc3R5bGVDZmcgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiAnc3BhbicsXG4gICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzdHlsZUNmZyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHN0eWxlQ2ZnLCB0aGlzLnByb3BzLnN0eWxlKTtcblxuICAgICAgICB0aGlzLl9wcmV2aWV3ID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ2ZnKS5idWlsZFByZXZpZXcodGhpcy5wcm9wcy5uYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgZGFuZ2Vyb3VzZWx5U2V0SW5udGVySFRNTCBzaW5jZSB3ZSdyZSBub3QgaW4gY29udHJvbCBvZiB0aGUgc3R5bGVcbiAgICAgICAgLy8gcHJldmlldyB0aGF0IGlzIGdlbmVyYXRlZCBieSBDS0VkaXRvci5cbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMubmFtZSA9PT0gdGhpcy5wcm9wcy5hY3RpdmVTdHlsZSA/ICdhZS10b29sYmFyLWVsZW1lbnQgYWN0aXZlJyA6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDogdGhpcy5fcHJldmlld319IG9uQ2xpY2s9e3RoaXMuX29uQ2xpY2suYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9PjwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGl0ZW0gc3R5bGUgdG8gdGhlIGVkaXRvciBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cbiAgICAgKiBAbWV0aG9kIF9vbkNsaWNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9vbkNsaWNrKCkge1xuICAgICAgICAvLyBUeXBpY2FsbHksIHdlIHdhbnQgdGhlIHN0eWxlIHRvIGJlIHRoZSBvbmx5IG9uZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgc29cbiAgICAgICAgLy8gd2UgZXhlY3V0ZSB0aGUgJ3JlbW92ZUZvcm1hdCcgY29tbWFuZCBmaXJzdC4gTm90ZSB0aGF0IGJsb2NrIHN0eWxlcyB3b24ndCBiZSBjbGVhbmVkLlxuICAgICAgICAvLyBIb3dldmVyLCB0aGlzIGlzIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBlZGl0b3JzIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGZlYXR1cmUuXG4gICAgICAgIHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuZXhlY0NvbW1hbmQoJ3JlbW92ZUZvcm1hdCcpO1xuXG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBidXR0b25TdHlsZXNMaXN0SXRlbVxuICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblN0eWxlc0xpc3RJdGVtLmtleSA9ICdidXR0b25TdHlsZXNMaXN0SXRlbSc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25TdHlsZXNMaXN0SXRlbVxuKSk7IiwiaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4vYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaXRlbS5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCc7XG5pbXBvcnQgQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaGVhZGVyLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXNMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHNob3dpbmcgYSBsaXN0IG9mIHN0eWxlcyB0aGF0IGNhbiBiZVxuICogYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZXNMaXN0XG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uU3R5bGVzTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgb24gdGhlIGxpc3Qgbm9kZSB0byBhbGxvdyBrZXlib2FyZCBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB2YXIgYmxvY2tTdHlsZXMgPSBbXTtcbiAgICAgICAgdmFyIGlubGluZVN0eWxlcyA9IFtdO1xuICAgICAgICB2YXIgb2JqZWN0U3R5bGVzID0gW107XG5cbiAgICAgICAgdGhpcy5wcm9wcy5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoaXRlbS5zdHlsZSk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS50eXBlID09PSBDS0VESVRPUi5TVFlMRV9CTE9DSykge1xuICAgICAgICAgICAgICAgIGJsb2NrU3R5bGVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLnR5cGUgPT09IENLRURJVE9SLlNUWUxFX0lOTElORSkge1xuICAgICAgICAgICAgICAgIGlubGluZVN0eWxlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS50eXBlID09PSBDS0VESVRPUi5TVFlMRV9PQkpFQ1QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RTdHlsZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYmxvY2tTdHlsZXMgPSBibG9ja1N0eWxlcztcbiAgICAgICAgdGhpcy5faW5saW5lU3R5bGVzID0gaW5saW5lU3R5bGVzO1xuICAgICAgICB0aGlzLl9vYmplY3RTdHlsZXMgPSBvYmplY3RTdHlsZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciByZW1vdmVTdHlsZXNJdGVtO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNob3dSZW1vdmVTdHlsZXNJdGVtKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZXNJdGVtID0gPEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGVkaXRvcj17dGhpcy5wcm9wcy5lZGl0b3J9IG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEJ1dHRvbkRyb3Bkb3duIHsuLi50aGlzLnByb3BzfT5cbiAgICAgICAgICAgICAgICB7cmVtb3ZlU3R5bGVzSXRlbX1cblxuICAgICAgICAgICAgICAgIDxCdXR0b25zU3R5bGVzTGlzdEhlYWRlciBuYW1lPXtBbGxveUVkaXRvci5TdHJpbmdzLmJsb2NrU3R5bGVzfSBzdHlsZXM9e3RoaXMuX2Jsb2NrU3R5bGVzfSAvPlxuICAgICAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJTdHlsZXNJdGVtcyh0aGlzLl9ibG9ja1N0eWxlcyl9XG5cbiAgICAgICAgICAgICAgICA8QnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIgbmFtZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbmxpbmVTdHlsZXN9IHN0eWxlcz17dGhpcy5faW5saW5lU3R5bGVzfSAvPlxuICAgICAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJTdHlsZXNJdGVtcyh0aGlzLl9pbmxpbmVTdHlsZXMpfVxuXG4gICAgICAgICAgICAgICAgPEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIG5hbWU9e0FsbG95RWRpdG9yLlN0cmluZ3Mub2JqZWN0U3R5bGVzfSBzdHlsZXM9e3RoaXMuX29iamVjdFN0eWxlc30gLz5cbiAgICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyU3R5bGVzSXRlbXModGhpcy5fb2JqZWN0U3R5bGVzKX1cbiAgICAgICAgICAgIDwvQnV0dG9uRHJvcGRvd24+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBpbnN0YW5jZXMgb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gd2l0aCB0aGUgcHJldmlldyBvZiB0aGUgY29ycmVzcG9uZGVudCBibG9jaywgaW5saW5lIG9yIG9iamVjdCBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuICAgICAqIEBtZXRob2QgX3JlbmRlclN0eWxlc0l0ZW1zXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3R5bGVzIExpc3Qgb2Ygc3R5bGVzIGZvciB3aGljaCBwcmV2aWV3IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXl9IFJlbmRlcmVkIGluc3RhbmNlcyBvZiBCdXR0b25TdHlsZXNMaXN0SXRlbSBjbGFzc1xuICAgICAqL1xuICAgIF9yZW5kZXJTdHlsZXNJdGVtcyhzdHlsZXMpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgICAgICB2YXIgaXRlbXM7XG5cbiAgICAgICAgaWYgKHN0eWxlcyAmJiBzdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtcyA9IHN0eWxlcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW0ubmFtZX0gcm9sZT1cIm9wdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblN0eWxlc0xpc3RJdGVtIGFjdGl2ZVN0eWxlPXt0aGlzLnByb3BzLmFjdGl2ZVN0eWxlfSBlZGl0b3I9e2VkaXRvcn0gbmFtZT17aXRlbS5uYW1lfSBzdHlsZT17aXRlbS5zdHlsZX0gLz5cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBkZWZhdWx0IGJ1dHRvblN0eWxlc0xpc3RcbiAqL1xuQnV0dG9uU3R5bGVzTGlzdC5rZXkgPSAnYnV0dG9uU3R5bGVzTGlzdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uU3R5bGVzTGlzdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY2lyY3VsYXI6IGZhbHNlLFxuICAgIGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG4gICAga2V5czoge1xuICAgICAgICBkaXNtaXNzOiBbMjddLFxuICAgICAgICBkaXNtaXNzTmV4dDogWzM5XSxcbiAgICAgICAgZGlzbWlzc1ByZXY6IFszN10sXG4gICAgICAgIG5leHQ6IFs0MF0sXG4gICAgICAgIHByZXY6IFszOF1cbiAgICB9LFxuICAgIHNob3dSZW1vdmVTdHlsZXNJdGVtOiB0cnVlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoXG4gICAgQnV0dG9uU3R5bGVzTGlzdFxuKTsiLCJpbXBvcnQgQnV0dG9uU3R5bGVzTGlzdCBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3R5bGVzIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHN0eWxpbmcgYSBzZWxlY3Rpb24gd2l0aCBhIGxpc3Qgb2ZcbiAqIGNvbmZpZ3VyYWJsZSBhbmQgY3VzdG9taXphYmxlIHN0eWxlcy4gVGhlIGFsbG93ZWQgc3R5bGVzIGZvbGxvdyBDS0VESVRPUi5TdHlsZSBjb25maWd1cmF0aW9uXG4gKiAoaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5zdHlsZSlcbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVzXG4gKi9cbmNsYXNzIEJ1dHRvblN0eWxlcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc1xuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgYWN0aXZlU3R5bGUgPSBBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbDtcblxuICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5fZ2V0U3R5bGVzKCk7XG5cbiAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlU3R5bGUgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdmFyIGJ1dHRvblN0eWxlc0xpc3Q7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvblN0eWxlc0xpc3QgPSA8QnV0dG9uU3R5bGVzTGlzdCBhY3RpdmVTdHlsZT17YWN0aXZlU3R5bGV9IGVkaXRvcj17dGhpcy5wcm9wcy5lZGl0b3J9IG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0gc2hvd1JlbW92ZVN0eWxlc0l0ZW09e3RoaXMucHJvcHMuc2hvd1JlbW92ZVN0eWxlc0l0ZW19IHN0eWxlcz17c3R5bGVzfSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93biBhZS1oYXMtZHJvcGRvd25cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9IGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzICsgJyAnICsgYWN0aXZlU3R5bGV9IGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiIG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzKX0gcm9sZT1cImNvbWJvYm94XCIgdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0eWxlcyArICcgJyArIGFjdGl2ZVN0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi1zZWxlY3RlZC1pdGVtXCI+e2FjdGl2ZVN0eWxlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYXJyb3dcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHtidXR0b25TdHlsZXNMaXN0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzXG4gICAgICogQG1ldGhvZCBfY2hlY2tBY3RpdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVDb25maWcgU3R5bGUgZGVmaW5pdGlvbiBhcyBwZXIgaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5zdHlsZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBzdHlsZSBpcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBfY2hlY2tBY3RpdmUoc3R5bGVDb25maWcpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgLy8gU3R5bGVzIHdpdGggd2lsZGNhcmQgZWxlbWVudCAoKikgd29uJ3QgYmUgY29uc2lkZXJlZCBhY3RpdmUgYnkgQ0tFZGl0b3IuIERlZmF1bHRpbmdcbiAgICAgICAgLy8gdG8gYSAnc3BhbicgZWxlbWVudCB3b3JrcyBmb3IgbW9zdCBvZiB0aG9zZSBjYXNlcyB3aXRoIG5vIGRlZmluZWQgZWxlbWVudC5cbiAgICAgICAgc3R5bGVDb25maWcgPSBDS0VESVRPUi50b29scy5tZXJnZSh7ZWxlbWVudDogJ3NwYW4nfSwgc3R5bGVDb25maWcpO1xuXG4gICAgICAgIHZhciBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZyk7XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlLmNoZWNrQWN0aXZlKG5hdGl2ZUVkaXRvci5lbGVtZW50UGF0aCgpLCBuYXRpdmVFZGl0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3R5bGVzLiBFYWNoIHN0eWxlIGNvbnNpc3RzIGZyb20gdHdvIHByb3BlcnRpZXM6XG4gICAgICogLSBuYW1lIC0gdGhlIHN0eWxlIG5hbWUsIGZvciBleGFtcGxlIFwiaDFcIlxuICAgICAqIC0gc3R5bGUgLSBhbiBvYmplY3Qgd2l0aCBvbmUgcHJvcGVydHksIGNhbGxlZCBgZWxlbWVudGAgd2hpY2ggdmFsdWVcbiAgICAgKiByZXByZXNlbnRzIHRoZSBzdHlsZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzXG4gICAgICogQG1ldGhvZCBfZ2V0U3R5bGVzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5PG9iamVjdD59IEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgc3R5bGVzLlxuICAgICAqL1xuICAgIF9nZXRTdHlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnN0eWxlcyB8fCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5oMSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiAnaDEnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmgyLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdoMidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuZm9ybWF0dGVkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdwcmUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmNpdGUsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogJ2NpdGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmNvZGUsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogJ2NvZGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBzdHlsZXNcbiAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU3R5bGVzLmtleSA9ICdzdHlsZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25TdHlsZXM7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN1YnNjcmlwdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhcHBseWluZyBzdWJzY3JpcHQgc3R5bGUgdG8gYSB0ZXh0IHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3Vic2NyaXB0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblN1YnNjcmlwdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN1YnNjcmlwdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3Vic2NyaXB0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1zdWJzY3JpcHRcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdWJzY3JpcHR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tc3Vic2NyaXB0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHN1YnNjcmlwdFxuICogQG1lbWJlcm9mIEJ1dHRvblN1YnNjcmlwdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25TdWJzY3JpcHQua2V5ID0gJ3N1YnNjcmlwdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3Vic2NyaXB0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25TdWJzY3JpcHQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdzdWJzY3JpcHQnLFxuICAgIHN0eWxlOiAnY29yZVN0eWxlc19zdWJzY3JpcHQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uU3Vic2NyaXB0XG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN1cGVyc2NyaXB0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFwcGx5aW5nIHN1cGVyc2NyaXB0IHN0eWxlIHRvIGEgdGV4dCBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN1cGVyc2NyaXB0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblN1cGVyc2NyaXB0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3VwZXJzY3JpcHRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1cGVyc2NyaXB0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1zdXBlcnNjcmlwdFwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1cGVyc2NyaXB0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXN1cGVyc2NyaXB0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHN1cGVyc2NyaXB0XG4gKiBAbWVtYmVyb2YgQnV0dG9uU3VwZXJzY3JpcHRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU3VwZXJzY3JpcHQua2V5ID0gJ3N1cGVyc2NyaXB0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25TdXBlcnNjcmlwdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uU3VwZXJzY3JpcHQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdzdXBlcnNjcmlwdCcsXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX3N1cGVyc2NyaXB0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvblN1cGVyc2NyaXB0XG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmRzTGlzdCBmcm9tICcuL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZUNlbGwgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgY2VsbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlQ2VsbFxuICovXG5jbGFzcyBCdXR0b25UYWJsZUNlbGwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNlbGxcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGJ1dHRvbkNvbW1hbmRzTGlzdDtcbiAgICAgICAgdmFyIGJ1dHRvbkNvbW1hbmRzTGlzdElkO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlQ2VsbC5rZXkgKyAnTGlzdCc7XG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3QgPSA8QnV0dG9uQ29tbWFuZHNMaXN0IGNvbW1hbmRzPXt0aGlzLl9nZXRDb21tYW5kcygpfSBlZGl0b3I9e3RoaXMucHJvcHMuZWRpdG9yfSBsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfSBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH0gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsfSBhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1jZWxsXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHtidXR0b25Db21tYW5kc0xpc3R9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcbiAgICAgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNlbGxcbiAgICAgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuICAgICAqL1xuICAgIF9nZXRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjZWxsSW5zZXJ0QmVmb3JlJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsSW5zZXJ0QmVmb3JlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjZWxsSW5zZXJ0QWZ0ZXInLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxJbnNlcnRBZnRlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2VsbERlbGV0ZScsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbERlbGV0ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2VsbE1lcmdlJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsTWVyZ2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NlbGxNZXJnZURvd24nLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxNZXJnZURvd25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NlbGxNZXJnZVJpZ2h0JyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsTWVyZ2VSaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2VsbEhvcml6b250YWxTcGxpdCcsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbFNwbGl0SG9yaXpvbnRhbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2VsbFZlcnRpY2FsU3BsaXQnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxTcGxpdFZlcnRpY2FsXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHRhYmxlQ2VsbFxuICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ2VsbFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25UYWJsZUNlbGwua2V5ID0gJ3RhYmxlQ2VsbCc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlQ2VsbDsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlQ29sdW1uIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gd29yayB3aXRoIHRhYmxlIGNvbHVtbnMuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlQ29sdW1uXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlQ29sdW1uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDb2x1bW5cbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGJ1dHRvbkNvbW1hbmRzTGlzdCxcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdElkO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlQ29sdW1uLmtleSArICdMaXN0JztcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdCA9IDxCdXR0b25Db21tYW5kc0xpc3QgY29tbWFuZHM9e3RoaXMuX2dldENvbW1hbmRzKCl9IGVkaXRvcj17dGhpcy5wcm9wcy5lZGl0b3J9IGxpc3RJZD17YnV0dG9uQ29tbWFuZHNMaXN0SWR9IG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfSBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbn0gYXJpYS1vd25zPXtidXR0b25Db21tYW5kc0xpc3RJZH0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgb25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMpfSByb2xlPVwibGlzdGJveFwiIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW59PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWNvbHVtblwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICB7YnV0dG9uQ29tbWFuZHNMaXN0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG4gICAgICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDb2x1bW5cbiAgICAgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuICAgICAqL1xuICAgIF9nZXRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb2x1bW5JbnNlcnRCZWZvcmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbkluc2VydEJlZm9yZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY29sdW1uSW5zZXJ0QWZ0ZXInLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbkluc2VydEFmdGVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb2x1bW5EZWxldGUnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbkRlbGV0ZVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB0YWJsZUNvbHVtblxuICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ29sdW1uXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblRhYmxlQ29sdW1uLmtleSA9ICd0YWJsZUNvbHVtbic7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlQ29sdW1uOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIEtFWV9FTlRFUiA9IDEzO1xudmFyIEtFWV9FU0MgPSAyNztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVFZGl0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgdGFibGUgaW4gYSBkb2N1bWVudC5cbiAqIFByb3ZpZGVzIFVJIGZvciBjcmVhdGluZyBhIHRhYmxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUVkaXRcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVFZGl0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuICAgICAqIEBtZXRob2QgZ2V0SW5pdGlhbFN0YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMucm93c1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmNvbHNSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbHM6IDMsXG4gICAgICAgICAgICByb3dzOiAzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCAobm90IG9uIHRoZSBzZXJ2ZXIpLFxuICAgICAqIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBGb2N1c2VzIG9uIHRoZSBsaW5rIGlucHV0IHRvIGltbWVkaWF0ZWx5IGFsbG93IGVkaXRpbmcuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnJvd3NSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0YWJsZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVUYWJsZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlVGFibGUoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgdGFibGVVdGlscyA9IG5ldyBDS0VESVRPUi5UYWJsZShlZGl0b3IpO1xuXG4gICAgICAgIHRhYmxlVXRpbHMuY3JlYXRlKHtcbiAgICAgICAgICAgIGF0dHJzOiB0aGlzLnByb3BzLnRhYmxlQXR0cmlidXRlcyxcbiAgICAgICAgICAgIGNvbHM6IHRoaXMuc3RhdGUuY29scyxcbiAgICAgICAgICAgIHJvd3M6IHRoaXMuc3RhdGUucm93c1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgY2hhbmdlIGluIGlucHV0IHZhbHVlLiBTZXRzIHRoZSBwcm92aWRlZCB2YWx1ZSBmcm9tIHRoZSB1c2VyIGJhY2sgdG8gdGhlIGlucHV0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuICAgICAqIEBtZXRob2QgX2hhbmRsZUNoYW5nZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0IHdoaWNoIHZhbHVlIHNob3VsZCBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBwcm92aWRlZCBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZUNoYW5nZShpbnB1dE5hbWUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuICAgICAgICBzdGF0ZVtpbnB1dE5hbWVdID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vbml0b3JzIGtleSBpbnRlcmFjdGlvbiBpbnNpZGUgdGhlIGlucHV0IGVsZW1lbnQgdG8gcmVzcG9uZCB0byB0aGUga2V5czpcbiAgICAgKiAtIEVudGVyOiBDcmVhdGVzIHRoZSB0YWJsZS5cbiAgICAgKiAtIEVzY2FwZTogRGlzY2FyZHMgdGhlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlVGFibGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciByb3dzSWQgPSB0aW1lICsgJ3Jvd3MnO1xuICAgICAgICB2YXIgY29sc0lkID0gdGltZSArICdjb2xzJztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC10YWJsZVwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPXtyb3dzSWR9PntBbGxveUVkaXRvci5TdHJpbmdzLnJvd3N9PC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1pbnB1dCBzbWFsbFwiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lPVwiYWUtaW5wdXRcIiBpZD17cm93c0lkfSBvbkNoYW5nZT17dGhpcy5faGFuZGxlQ2hhbmdlLmJpbmQodGhpcywgJ3Jvd3MnKX0gbWluPVwiMVwiIG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpfSBwbGFjZWhvbGRlcj1cIlJvd3NcIiByZWY9e3RoaXMucm93c1JlZn0gdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0aGlzLnN0YXRlLnJvd3N9PjwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17Y29sc0lkfT57QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5zfTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgc21hbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzTmFtZT1cImFlLWlucHV0XCIgaWQ9e2NvbHNJZH0gb25DaGFuZ2U9e3RoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMsICdjb2xzJyl9IG1pbj1cIjFcIiBvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd24uYmluZCh0aGlzKX0gcGxhY2Vob2xkZXI9XCJDb2x1bXNcIiByZWY9e3RoaXMuY29sc1JlZn0gdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0aGlzLnN0YXRlLmNvbHN9PjwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9XCJDb25maXJtXCIgY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgb25DbGljaz17dGhpcy5fY3JlYXRlVGFibGUuYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tb2tcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdGFibGVFZGl0XG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblRhYmxlRWRpdC5rZXkgPSAndGFibGVFZGl0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKi9cbkJ1dHRvblRhYmxlRWRpdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdGFibGVBdHRyaWJ1dGVzOiB7XG4gICAgICAgIGJvcmRlcjogMSxcbiAgICAgICAgY2VsbFBhZGRpbmc6IDAsXG4gICAgICAgIGNlbGxTcGFjaW5nOiAwLFxuICAgICAgICBzdHlsZTogJ3dpZHRoOiAxMDAlJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlRWRpdDtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVIZWFkaW5nIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gd29yayB3aXRoIHRhYmxlIGhlYWRpbmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlSGVhZGluZ1xuICovXG5jbGFzcyBCdXR0b25UYWJsZUhlYWRpbmcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUhlYWRpbmdcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGJ1dHRvbkNvbW1hbmRzTGlzdDtcbiAgICAgICAgdmFyIGJ1dHRvbkNvbW1hbmRzTGlzdElkO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlSGVhZGluZy5rZXkgKyAnTGlzdCc7XG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3QgPSA8QnV0dG9uQ29tbWFuZHNMaXN0IGNvbW1hbmRzPXt0aGlzLl9nZXRDb21tYW5kcygpfSBlZGl0b3I9e3RoaXMucHJvcHMuZWRpdG9yfSBsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfSBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGl2ZUhlYWRpbmcgPSBuZXcgQ0tFRElUT1IuVGFibGUodGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKSkuZ2V0SGVhZGluZygpO1xuICAgICAgICB2YXIgYWN0aXZlSGVhZGluZ0ludHJvID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5oZWFkZXJzICsgJzonO1xuICAgICAgICB2YXIgYWN0aXZlSGVhZGluZ0xhYmVsID0gQWxsb3lFZGl0b3IuU3RyaW5nc1snaGVhZGVycycgKyBhY3RpdmVIZWFkaW5nXTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24teGwgYWUtaGFzLWRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfSBhcmlhLWxhYmVsPVwiXCIgY2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCIgb25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMpfSByb2xlPVwiY29tYm9ib3hcIiB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9XCJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi1zZWxlY3RlZC1pdGVtXCI+e2FjdGl2ZUhlYWRpbmdJbnRyb30gPHN0cm9uZz57YWN0aXZlSGVhZGluZ0xhYmVsfTwvc3Ryb25nPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYXJyb3dcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHtidXR0b25Db21tYW5kc0xpc3R9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcbiAgICAgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUhlYWRpbmdcbiAgICAgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuICAgICAqL1xuICAgIF9nZXRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd0YWJsZUhlYWRpbmdOb25lJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5oZWFkZXJzTm9uZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAndGFibGVIZWFkaW5nUm93JyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5oZWFkZXJzUm93XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd0YWJsZUhlYWRpbmdDb2x1bW4nLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNDb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3RhYmxlSGVhZGluZ0JvdGgnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNCb3RoXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHRhYmxlUm93XG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVIZWFkaW5nXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblRhYmxlSGVhZGluZy5rZXkgPSAndGFibGVIZWFkaW5nJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVIZWFkaW5nOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlUmVtb3ZlIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHJlbW92aW5nIGEgdGFibGVcbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVSZW1vdmVcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVSZW1vdmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmRlbGV0ZVRhYmxlfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24tdGFibGUtcmVtb3ZlXCIgb25DbGljaz17dGhpcy5fcmVtb3ZlVGFibGUuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmRlbGV0ZVRhYmxlfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWJpblwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHRhYmxlIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuICAgICAqIEBtZXRob2QgX3JlbW92ZVRhYmxlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVUYWJsZSgpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciB0YWJsZVV0aWxzID0gbmV3IENLRURJVE9SLlRhYmxlKGVkaXRvcik7XG5cbiAgICAgICAgdGFibGVVdGlscy5yZW1vdmUoKTtcblxuICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHRhYmxlUmVtb3ZlXG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSZW1vdmVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVGFibGVSZW1vdmUua2V5ID0gJ3RhYmxlUmVtb3ZlJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVSZW1vdmU7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmRzTGlzdCBmcm9tICcuL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZVJvdyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHdvcmsgd2l0aCB0YWJsZSByb3dzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZVJvd1xuICovXG5jbGFzcyBCdXR0b25UYWJsZVJvdyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlUm93XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBidXR0b25Db21tYW5kc0xpc3Q7XG4gICAgICAgIHZhciBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZVJvdy5rZXkgKyAnTGlzdCc7XG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3QgPSA8QnV0dG9uQ29tbWFuZHNMaXN0IGNvbW1hbmRzPXt0aGlzLl9nZXRDb21tYW5kcygpfSBlZGl0b3I9e3RoaXMucHJvcHMuZWRpdG9yfSBsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfSBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH0gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5yb3d9IGFyaWEtb3ducz17YnV0dG9uQ29tbWFuZHNMaXN0SWR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzKX0gcm9sZT1cImNvbWJvYm94XCIgdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnJvd30+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tcm93XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHtidXR0b25Db21tYW5kc0xpc3R9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcbiAgICAgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJvd1xuICAgICAqIEBtZXRob2QgX2dldENvbW1hbmRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG4gICAgICovXG4gICAgX2dldENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jb21tYW5kcyB8fCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3Jvd0luc2VydEJlZm9yZScsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3Mucm93SW5zZXJ0QmVmb3JlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdyb3dJbnNlcnRBZnRlcicsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3Mucm93SW5zZXJ0QWZ0ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3Jvd0RlbGV0ZScsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3Mucm93RGVsZXRlXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHRhYmxlUm93XG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSb3dcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVGFibGVSb3cua2V5ID0gJ3RhYmxlUm93JztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVSb3c7IiwiaW1wb3J0IEJ1dHRvblRhYmxlRWRpdCBmcm9tICcuL2J1dHRvbi10YWJsZS1lZGl0LmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIHRhYmxlIGluIGEgZG9jdW1lbnQuIEJ1dHRvblRhYmxlXG4gKiByZW5kZXJzIGluIHR3byBkaWZmZXJlbnQgbW9kZXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGVcbiAqIC0gRXhjbHVzaXZlOiBUaGUgQnV0dG9uVGFibGVFZGl0IFVJIHdpdGggYWxsIHRoZSB0YWJsZSBlZGl0aW9uIGNvbnRyb2xzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZVxuICovXG5jbGFzcyBCdXR0b25UYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8QnV0dG9uVGFibGVFZGl0IHsuLi50aGlzLnByb3BzfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnRhYmxlfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24tdGFibGVcIiBvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmV9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy50YWJsZX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tdGFibGVcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHRhYmxlXG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVGFibGUua2V5ID0gJ3RhYmxlJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGU7IiwiaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4vYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYXJnZXRMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRoZSB0YXJnZXQgb2YgYSBsaW5rXG4gKiBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhcmdldExpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25UYXJnZXRMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3RcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3RcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGxpc3RUYXJnZXRzID0gdGhpcy5fcmVuZGVyTGlzdFRhcmdldHMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEJ1dHRvbkRyb3Bkb3duIHsuLi50aGlzLnByb3BzfT5cbiAgICAgICAgICAgICAgICB7bGlzdFRhcmdldHN9XG4gICAgICAgICAgICA8L0J1dHRvbkRyb3Bkb3duPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRoZSBhbGxvd2VkIGxpbmsgdGFyZ2V0IGl0ZW1zLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3RcbiAgICAgKiBAbWV0aG9kIF9nZXRBbGxvd2VkVGFyZ2V0SXRlbXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBhbGxvd2VkIHRhcmdldCBpdGVtcy5cbiAgICAgKi9cbiAgICBfZ2V0QWxsb3dlZFRhcmdldEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5hbGxvd2VkTGlua1RhcmdldHMgfHwgW3tcbiAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXREZWZhdWx0LFxuICAgICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXRTZWxmLFxuICAgICAgICAgICAgdmFsdWU6ICdfc2VsZidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MubGlua1RhcmdldEJsYW5rLFxuICAgICAgICAgICAgdmFsdWU6ICdfYmxhbmsnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXRQYXJlbnQsXG4gICAgICAgICAgICB2YWx1ZTogJ19wYXJlbnQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXRUb3AsXG4gICAgICAgICAgICB2YWx1ZTogJ190b3AnXG4gICAgICAgIH1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGFsbG93ZWQgbGluayB0YXJnZXQgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuICAgICAqIEBtZXRob2QgX3JlbmRlckxpc3RUYXJnZXRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgcmVuZGVyZWQgbGluayBpdGVtc1xuICAgICAqL1xuICAgIF9yZW5kZXJMaXN0VGFyZ2V0cygpIHtcbiAgICAgICAgdmFyIHRhcmdldHMgPSB0aGlzLl9nZXRBbGxvd2VkVGFyZ2V0SXRlbXMoKTtcblxuICAgICAgICB2YXIgaGFuZGxlTGlua1RhcmdldENoYW5nZSA9IHRoaXMucHJvcHMuaGFuZGxlTGlua1RhcmdldENoYW5nZTtcblxuICAgICAgICB0YXJnZXRzID0gdGFyZ2V0cy5tYXAoZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldCA9PT0gdGFyZ2V0LnZhbHVlID8gJ2FlLXRvb2xiYXItZWxlbWVudCBhY3RpdmUnIDogJ2FlLXRvb2xiYXItZWxlbWVudCc7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGxpIGtleT17dGFyZ2V0LnZhbHVlfSByb2xlPVwib3B0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGRhdGEtdmFsdWU9e3RhcmdldC52YWx1ZX0gb25DbGljaz17aGFuZGxlTGlua1RhcmdldENoYW5nZX0+e3RhcmdldC5sYWJlbH08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0cztcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgbGlua1RhcmdldEVkaXRcbiAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblRhcmdldExpc3Qua2V5ID0gJ3RhcmdldExpc3QnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3RcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKi9cbkJ1dHRvblRhcmdldExpc3QuZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG4gICAga2V5czoge1xuICAgICAgICBkaXNtaXNzOiBbMjddLFxuICAgICAgICBkaXNtaXNzTmV4dDogWzM5XSxcbiAgICAgICAgZGlzbWlzc1ByZXY6IFszN10sXG4gICAgICAgIG5leHQ6IFs0MF0sXG4gICAgICAgIHByZXY6IFszOF1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoXG4gICAgQnV0dG9uVGFyZ2V0TGlzdFxuKTsiLCJpbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVHdpdHRlciBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhIGxpbmsgd2hpY2hcbiAqIGFsbG93cyBwZW9wbGUgdG8gdHdlZXQgcGFydCBvZiB0aGUgY29udGVudCBpbiB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Ud2l0dGVyXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uVHdpdHRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciByZW1vdmVzIHRoZSB0d2l0dGVyIGxpbmsgb24gdGhlIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Ud2l0dGVyXG4gICAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgICAqL1xuICAgIGhhbmRsZUNsaWNrKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICB2YXIgbGlua1V0aWxzID0gbmV3IENLRURJVE9SLkxpbmsoZWRpdG9yKTtcblxuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICBsaW5rVXRpbHMucmVtb3ZlKGxpbmtVdGlscy5nZXRGcm9tU2VsZWN0aW9uKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlua1V0aWxzLmNyZWF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRIcmVmKCksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnYWUtdHdpdHRlci1saW5rJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6ICdfYmxhbmsnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBsaW5rIHRoYXQgcG9pbnRzIHRvIHR3aXR0ZXIuY29tL2ludGVudC90d2VldC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Ud2l0dGVyXG4gICAgICogQG1ldGhvZCBpc0FjdGl2ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHNlbGVjdGlvbiBpcyBpbnNpZGUgYSB0d2l0dGVyIGxpbmssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgdmFyIGxpbmsgPSBuZXcgQ0tFRElUT1IuTGluayh0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpKS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIChsaW5rICYmIChsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpLmluZGV4T2YoJ3R3aXR0ZXIuY29tL2ludGVudC90d2VldCcpICE9PSAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Ud2l0dGVyXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy50d2l0dGVyfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tdHdpdHRlclwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnR3aXR0ZXJ9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tdHdpdHRlclwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgYXBwcm9wcmlhdGUgdHdpdHRlciB1cmwgYmFzZWQgb24gdGhlIHNlbGVjdGVkIHRleHQgYW5kIHRoZSBjb25maWd1cmF0aW9uXG4gICAgICogb3B0aW9ucyByZWNlaXZlZCB2aWEgcHJvcHMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuICAgICAqIEBtZXRob2QgX2dldEhyZWZcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBBIHZhbGlkIHR3aXR0ZXIgdXJsIHdpdGggdGhlIHNlbGVjdGVkIHRleHQgYW5kIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgX2dldEhyZWYoKSB7XG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRUZXh0ID0gbmF0aXZlRWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFNlbGVjdGVkVGV4dCgpO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy5wcm9wcy51cmw7XG4gICAgICAgIHZhciB2aWEgPSB0aGlzLnByb3BzLnZpYTtcbiAgICAgICAgdmFyIHR3aXR0ZXJIcmVmID0gJ2h0dHBzOi8vdHdpdHRlci5jb20vaW50ZW50L3R3ZWV0P3RleHQ9JyArIHNlbGVjdGVkVGV4dDtcblxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB0d2l0dGVySHJlZiArPSAnJnVybD0nICsgdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZpYSkge1xuICAgICAgICAgICAgdHdpdHRlckhyZWYgKz0gJyZ2aWE9JyArIHZpYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0d2l0dGVySHJlZjtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdHdpdHRlclxuICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVHdpdHRlci5rZXkgPSAndHdpdHRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25Ud2l0dGVyXG4pOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Vbm9yZGVyZWRsaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIHVub3JkZXJlZCBsaXN0cyBpbiBhbiBlZGl0b3IuXG4gKlxuICogQGNsYXNzIEJ1dHRvblVub3JkZXJlZGxpc3RcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uVW5vcmRlcmVkbGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblVub3JkZXJlZGxpc3RcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmJ1bGxldGVkbGlzdH0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tdWxcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5idWxsZXRlZGxpc3R9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYnVsbGV0ZWQtbGlzdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB1bFxuICogQG1lbWJlcm9mIEJ1dHRvblVub3JkZXJlZGxpc3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVW5vcmRlcmVkbGlzdC5rZXkgPSAndWwnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblVub3JkZXJlZGxpc3RcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvblVub3JkZXJlZGxpc3QuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdidWxsZXRlZGxpc3QnLFxuICAgIHN0eWxlOiB7XG4gICAgICAgIGVsZW1lbnQ6ICd1bCdcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uVW5vcmRlcmVkbGlzdFxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25VbmRlcmxpbmUgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgdW5kZXJseWluZyBhIHRleHQgc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25VbmRlcmxpbmVcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25VbmRlcmxpbmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnR7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblVuZGVybGluZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MudW5kZXJsaW5lfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi11bmRlcmxpbmVcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy51bmRlcmxpbmV9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tdW5kZXJsaW5lXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHVuZGVybGluZVxuICogQG1lbWJlcm9mIEJ1dHRvblVuZGVybGluZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25VbmRlcmxpbmUua2V5ID0gJ3VuZGVybGluZSc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uVW5kZXJsaW5lXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25VbmRlcmxpbmUuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICd1bmRlcmxpbmUnLFxuICAgIGtleXN0cm9rZToge1xuICAgICAgICBmbjogJ2V4ZWNDb21tYW5kJyxcbiAgICAgICAga2V5czogQ0tFRElUT1IuQ1RSTCArIDg1IC8qVSovXG4gICAgfSxcbiAgICBzdHlsZTogJ2NvcmVTdHlsZXNfdW5kZXJsaW5lJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25LZXlzdHJva2UoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25VbmRlcmxpbmVcbikpKSk7IiwiaW1wb3J0IEJ1dHRvbkJvbGQgZnJvbSAnLi9idXR0b24tYm9sZC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNhbWVyYUltYWdlIGZyb20gJy4vYnV0dG9uLWNhbWVyYS1pbWFnZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNhbWVyYSBmcm9tICcuL2J1dHRvbi1jYW1lcmEuanN4JztcbmltcG9ydCBCdXR0b25Db2RlIGZyb20gJy4vYnV0dG9uLWNvZGUuanN4JztcbmltcG9ydCBCdXR0b25Db21tYW5kTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4vYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgQnV0dG9uRW1iZWRFZGl0IGZyb20gJy4vYnV0dG9uLWVtYmVkLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25FbWJlZCBmcm9tICcuL2J1dHRvbi1lbWJlZC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkgxIGZyb20gJy4vYnV0dG9uLWgxLmpzeCc7XG5pbXBvcnQgQnV0dG9uSDIgZnJvbSAnLi9idXR0b24taDIuanN4JztcbmltcG9ydCBCdXR0b25IbGluZSBmcm9tICcuL2J1dHRvbi1obGluZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkltYWdlQWxpZ25DZW50ZXIgZnJvbSAnLi9idXR0b24taW1hZ2UtYWxpZ24tY2VudGVyLmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2VBbGlnbkxlZnQgZnJvbSAnLi9idXR0b24taW1hZ2UtYWxpZ24tbGVmdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkltYWdlQWxpZ25SaWdodCBmcm9tICcuL2J1dHRvbi1pbWFnZS1hbGlnbi1yaWdodC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkltYWdlIGZyb20gJy4vYnV0dG9uLWltYWdlLmpzeCc7XG5pbXBvcnQgQnV0dG9uSW5kZW50QmxvY2sgZnJvbSAnLi9idXR0b24taW5kZW50LWJsb2NrLmpzeCc7XG5pbXBvcnQgQnV0dG9uSXRhbGljIGZyb20gJy4vYnV0dG9uLWl0YWxpYy5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IGZyb20gJy4vYnV0dG9uLWxpbmstYXV0b2NvbXBsZXRlLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25MaW5rVGFyZ2V0RWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLXRhcmdldC1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uTGluayBmcm9tICcuL2J1dHRvbi1saW5rLmpzeCc7XG5pbXBvcnQgQnV0dG9uT2wgZnJvbSAnLi9idXR0b24tb2wuanN4JztcbmltcG9ydCBCdXR0b25PdXRkZW50QmxvY2sgZnJvbSAnLi9idXR0b24tb3V0ZGVudC1ibG9jay5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tbGVmdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQgZnJvbSAnLi9idXR0b24tcGFyYWdyYXBoLWFsaWduLXJpZ2h0LmpzeCc7XG5pbXBvcnQgQnV0dG9uUGFyYWdyYXBoQ2VudGVyIGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1jZW50ZXIuanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5IGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1qdXN0aWZ5LmpzeCc7XG5pbXBvcnQgQnV0dG9uUXVvdGUgZnJvbSAnLi9idXR0b24tcXVvdGUuanN4JztcbmltcG9ydCBCdXR0b25SZW1vdmVGb3JtYXQgZnJvbSAnLi9idXR0b24tcmVtb3ZlLWZvcm1hdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0cmlrZSBmcm9tICcuL2J1dHRvbi1zdHJpa2UuanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SGVhZGVyIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWhlYWRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaXRlbS5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3QgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXMgZnJvbSAnLi9idXR0b24tc3R5bGVzLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3Vic2NyaXB0IGZyb20gJy4vYnV0dG9uLXN1YnNjcmlwdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblN1cGVyc2NyaXB0IGZyb20gJy4vYnV0dG9uLXN1cGVyc2NyaXB0LmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVDZWxsIGZyb20gJy4vYnV0dG9uLXRhYmxlLWNlbGwuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZUNvbHVtbiBmcm9tICcuL2J1dHRvbi10YWJsZS1jb2x1bW4uanN4JztcbmltcG9ydCBCdXR0b25UYWJsZUVkaXQgZnJvbSAnLi9idXR0b24tdGFibGUtZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlSGVhZGluZyBmcm9tICcuL2J1dHRvbi10YWJsZS1oZWFkaW5nLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVSZW1vdmUgZnJvbSAnLi9idXR0b24tdGFibGUtcmVtb3ZlLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVSb3cgZnJvbSAnLi9idXR0b24tdGFibGUtcm93LmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGUgZnJvbSAnLi9idXR0b24tdGFibGUuanN4JztcbmltcG9ydCBCdXR0b25UYXJnZXRMaXN0IGZyb20gJy4vYnV0dG9uLXRhcmdldC1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uVHdpdHRlciBmcm9tICcuL2J1dHRvbi10d2l0dGVyLmpzeCc7XG5pbXBvcnQgQnV0dG9uVWwgZnJvbSAnLi9idXR0b24tdWwuanN4JztcbmltcG9ydCBCdXR0b25VbmRlcmxpbmUgZnJvbSAnLi9idXR0b24tdW5kZXJsaW5lLmpzeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBbQnV0dG9uQm9sZC5rZXldOiBCdXR0b25Cb2xkLFxuICAgIFtCdXR0b25DYW1lcmFJbWFnZS5rZXldOiBCdXR0b25DYW1lcmFJbWFnZSxcbiAgICBbQnV0dG9uQ2FtZXJhLmtleV06IEJ1dHRvbkNhbWVyYSxcbiAgICBbQnV0dG9uQ29kZS5rZXldOiBCdXR0b25Db2RlLFxuICAgIFtCdXR0b25Db21tYW5kTGlzdEl0ZW0ua2V5XTogQnV0dG9uQ29tbWFuZExpc3RJdGVtLFxuICAgIFtCdXR0b25Db21tYW5kc0xpc3Qua2V5XTogQnV0dG9uQ29tbWFuZHNMaXN0LFxuICAgIFtCdXR0b25Ecm9wZG93bi5rZXldOiBCdXR0b25Ecm9wZG93bixcbiAgICBbQnV0dG9uRW1iZWRFZGl0LmtleV06IEJ1dHRvbkVtYmVkRWRpdCxcbiAgICBbQnV0dG9uRW1iZWQua2V5XTogQnV0dG9uRW1iZWQsXG4gICAgW0J1dHRvbkgxLmtleV06IEJ1dHRvbkgxLFxuICAgIFtCdXR0b25IMi5rZXldOiBCdXR0b25IMixcbiAgICBbQnV0dG9uSGxpbmUua2V5XTogQnV0dG9uSGxpbmUsXG4gICAgW0J1dHRvbkltYWdlQWxpZ25DZW50ZXIua2V5XTogQnV0dG9uSW1hZ2VBbGlnbkNlbnRlcixcbiAgICBbQnV0dG9uSW1hZ2VBbGlnbkxlZnQua2V5XTogQnV0dG9uSW1hZ2VBbGlnbkxlZnQsXG4gICAgW0J1dHRvbkltYWdlQWxpZ25SaWdodC5rZXldOiBCdXR0b25JbWFnZUFsaWduUmlnaHQsXG4gICAgW0J1dHRvbkltYWdlLmtleV06IEJ1dHRvbkltYWdlLFxuICAgIFtCdXR0b25JbmRlbnRCbG9jay5rZXldOiBCdXR0b25JbmRlbnRCbG9jayxcbiAgICBbQnV0dG9uSXRhbGljLmtleV06IEJ1dHRvbkl0YWxpYyxcbiAgICBbQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qua2V5XTogQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QsXG4gICAgW0J1dHRvbkxpbmtFZGl0LmtleV06IEJ1dHRvbkxpbmtFZGl0LFxuICAgIFtCdXR0b25MaW5rVGFyZ2V0RWRpdC5rZXldOiBCdXR0b25MaW5rVGFyZ2V0RWRpdCxcbiAgICBbQnV0dG9uTGluay5rZXldOiBCdXR0b25MaW5rLFxuICAgIFtCdXR0b25PbC5rZXldOiBCdXR0b25PbCxcbiAgICBbQnV0dG9uT3V0ZGVudEJsb2NrLmtleV06IEJ1dHRvbk91dGRlbnRCbG9jayxcbiAgICBbQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0LmtleV06IEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCxcbiAgICBbQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodC5rZXldOiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0LFxuICAgIFtCdXR0b25QYXJhZ3JhcGhDZW50ZXIua2V5XTogQnV0dG9uUGFyYWdyYXBoQ2VudGVyLFxuICAgIFtCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5LmtleV06IEJ1dHRvblBhcmFncmFwaEp1c3RpZnksXG4gICAgW0J1dHRvblF1b3RlLmtleV06IEJ1dHRvblF1b3RlLFxuICAgIFtCdXR0b25SZW1vdmVGb3JtYXQua2V5XTogQnV0dG9uUmVtb3ZlRm9ybWF0LFxuICAgIFtCdXR0b25TdHJpa2Uua2V5XTogQnV0dG9uU3RyaWtlLFxuICAgIFtCdXR0b25TdHlsZXNMaXN0SGVhZGVyLmtleV06IEJ1dHRvblN0eWxlc0xpc3RIZWFkZXIsXG4gICAgW0J1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLmtleV06IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLFxuICAgIFtCdXR0b25TdHlsZXNMaXN0SXRlbS5rZXldOiBCdXR0b25TdHlsZXNMaXN0SXRlbSxcbiAgICBbQnV0dG9uU3R5bGVzTGlzdC5rZXldOiBCdXR0b25TdHlsZXNMaXN0LFxuICAgIFtCdXR0b25TdHlsZXMua2V5XTogQnV0dG9uU3R5bGVzLFxuICAgIFtCdXR0b25TdWJzY3JpcHQua2V5XTogQnV0dG9uU3Vic2NyaXB0LFxuICAgIFtCdXR0b25TdXBlcnNjcmlwdC5rZXldOiBCdXR0b25TdXBlcnNjcmlwdCxcbiAgICBbQnV0dG9uVGFibGVDZWxsLmtleV06IEJ1dHRvblRhYmxlQ2VsbCxcbiAgICBbQnV0dG9uVGFibGVDb2x1bW4ua2V5XTogQnV0dG9uVGFibGVDb2x1bW4sXG4gICAgW0J1dHRvblRhYmxlRWRpdC5rZXldOiBCdXR0b25UYWJsZUVkaXQsXG4gICAgW0J1dHRvblRhYmxlSGVhZGluZy5rZXldOiBCdXR0b25UYWJsZUhlYWRpbmcsXG4gICAgW0J1dHRvblRhYmxlUmVtb3ZlLmtleV06IEJ1dHRvblRhYmxlUmVtb3ZlLFxuICAgIFtCdXR0b25UYWJsZVJvdy5rZXldOiBCdXR0b25UYWJsZVJvdyxcbiAgICBbQnV0dG9uVGFibGUua2V5XTogQnV0dG9uVGFibGUsXG4gICAgW0J1dHRvblRhcmdldExpc3Qua2V5XTogQnV0dG9uVGFyZ2V0TGlzdCxcbiAgICBbQnV0dG9uVHdpdHRlci5rZXldOiBCdXR0b25Ud2l0dGVyLFxuICAgIFtCdXR0b25VbC5rZXldOiBCdXR0b25VbCxcbiAgICBbQnV0dG9uVW5kZXJsaW5lLmtleV06IEJ1dHRvblVuZGVybGluZVxufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBXaWRnZXRFeGNsdXNpdmUgZnJvbSAnLi9iYXNlL3dpZGdldC1leGNsdXNpdmUuanMnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuXG4vKipcbiAqIFRoZSBtYWluIGVkaXRvciBVSSBjbGFzcyBtYW5hZ2VzIGEgaGllcmFyY2h5IG9mIHdpZGdldHMgKHRvb2xiYXJzIGFuZCBidXR0b25zKS5cbiAqXG4gKiBAY2xhc3MgVUlcbiAqIEB1c2VzIFdpZGdldEV4Y2x1c2l2ZVxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIFVJIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhpZGRlbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICBlZGl0b3Iub24oJ2VkaXRvckludGVyYWN0aW9uJywgdGhpcy5fb25FZGl0b3JJbnRlcmFjdGlvbiwgdGhpcyk7XG4gICAgICAgIGVkaXRvci5vbignYWN0aW9uUGVyZm9ybWVkJywgdGhpcy5fb25BY3Rpb25QZXJmb3JtZWQsIHRoaXMpO1xuICAgICAgICBlZGl0b3Iub24oJ2tleScsIHRoaXMuX29uRWRpdG9yS2V5LCB0aGlzKTtcblxuICAgICAgICAvLyBTZXQgdXAgZXZlbnRzIGZvciBoaWRpbmcgdGhlIFVJIHdoZW4gdXNlciBzdG9wcyBpbnRlcmFjdGluZyB3aXRoIHRoZSBlZGl0b3IuXG4gICAgICAgIC8vIFRoaXMgbWF5IGhhcHBlbiB3aGVuIGhlIGp1c3QgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGVkaXRvci4gSG93ZXZlcixcbiAgICAgICAgLy8gdGhpcyBkb2VzIG5vdCBpbmNsdWRlIGEgc2l0dWF0aW9uIHdoZW4gaGUgY2xpY2tzIG9uIHNvbWUgYnV0dG9uLCBwYXJ0IG9mXG4gICAgICAgIC8vIGVkaXRvcidzIFVJLlxuXG4gICAgICAgIC8vIEl0IGlzIG5vdCBlYXN5IHRvIGRlYm91bmNlIF9zZXRVSUhpZGRlbiBvbiBtb3VzZWRvd24sIGJlY2F1c2UgaWYgd2VcbiAgICAgICAgLy8gZGVib3VuY2UgaXQsIHdoZW4gdGhlIGhhbmRsZXIgaXMgYmVpbmcgaW52b2tlZCwgdGhlIHRhcmdldCBtaWdodCBiZSBubyBtb3JlIHBhcnRcbiAgICAgICAgLy8gb2YgdGhlIGVkaXRvcidzIFVJIC0gb25BY3Rpb25QZXJmb3JtZWQgY2F1c2VzIHJlLXJlbmRlci5cbiAgICAgICAgdGhpcy5fbW91c2Vkb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFVJSGlkZGVuKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9rZXlEb3duTGlzdGVuZXIgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VUlIaWRkZW4oZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICAgIH0sIHRoaXMucHJvcHMuZXZlbnRzRGVsYXksIHRoaXMpO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleURvd25MaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQncyB1cGRhdGVzIGFyZSBmbHVzaGVkIHRvIHRoZSBET00uXG4gICAgICogRmlyZXMgYGFyaWFVcGRhdGVgIGV2ZW50IHBhc3NpbmcgQVJJQSByZWxhdGVkIG1lc3NhZ2VzLlxuICAgICAqIEZpcmVzIGBlZGl0b3JVcGRhdGVgIGV2ZW50IHBhc3NpbmcgdGhlIHByZXZpb3VzIGFuZCBjdXJyZW50IHByb3BlcnRpZXMgYW5kIHN0YXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRVcGRhdGVcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGUgKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHZhciBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgaWYgKGRvbU5vZGUpIHtcbiAgICAgICAgICAgIGVkaXRvci5maXJlKCdhcmlhVXBkYXRlJywge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuX2dldEF2YWlsYWJsZVRvb2xiYXJzTWVzc2FnZShkb21Ob2RlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IuZmlyZSgnZWRpdG9yVXBkYXRlJywge1xuICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICBwcmV2U3RhdGU6IHByZXZTdGF0ZSxcbiAgICAgICAgICAgIHByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2dldEFyaWFVcGRhdGVUZW1wbGF0ZShhcmlhVXBkYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdKSB7XG4gICAgICAgICAgICB0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdID0gbmV3IENLRURJVE9SLnRlbXBsYXRlKHRoaXMuX2dldEFyaWFVcGRhdGVzKClbYXJpYVVwZGF0ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FyaWFVcGRhdGVUZW1wbGF0ZXNbYXJpYVVwZGF0ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGVzIGZvciBBUklBIG1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX2dldEFyaWFVcGRhdGVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBUklBIHJlbGF0ZXMgbWVzc2FnZXMuIERlZmF1bHQ6XG4gICAgICoge1xuICAgICAqICAgICAgbm9Ub29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVOb1Rvb2xiYXIsXG4gICAgICogICAgICBvbmVUb29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVPbmVUb29sYmFyLFxuICAgICAqICAgICAgbWFueVRvb2xiYXJzOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVNYW55VG9vbGJhcnNcbiAgICAgKiAgfVxuICAgICAqL1xuICAgIF9nZXRBcmlhVXBkYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuYXJpYVVwZGF0ZXMgfHwge1xuICAgICAgICAgICAgbm9Ub29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVOb1Rvb2xiYXIsXG4gICAgICAgICAgICBvbmVUb29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVPbmVUb29sYmFyLFxuICAgICAgICAgICAgbWFueVRvb2xiYXJzOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVNYW55VG9vbGJhcnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEFSSUEgbWVzc2FnZSB3aGljaCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGF2YWlsYWJsZSB0b29sYmFycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgX2dldEF2YWlsYWJsZVRvb2xiYXJzTWVzc2FnZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBkb21Ob2RlIFRoZSBET00gbm9kZSBmcm9tIHdoaWNoIHRoZSBhdmFpbGFibGUgdG9vbGJhcnMgd2lsbCBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgQVJJQSBtZXNzYWdlIGZvciB0aGUgbnVtYmVyIG9mIGF2YWlsYWJsZSB0b29sYmFyc1xuICAgICAqL1xuICAgIF9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2UoZG9tTm9kZSkge1xuICAgICAgICB2YXIgdG9vbGJhcnNOb2RlTGlzdCA9IGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sYmFyXCJdJyk7XG5cbiAgICAgICAgaWYgKCF0b29sYmFyc05vZGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFyaWFVcGRhdGVzKCkubm9Ub29sYmFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRvb2xiYXJOYW1lcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRvb2xiYXJzTm9kZUxpc3QpLm1hcChmdW5jdGlvbih0b29sYmFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xiYXIuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGFyaWFVcGRhdGUgPSB0b29sYmFyTmFtZXMubGVuZ3RoID09PSAxID8gJ29uZVRvb2xiYXInIDogJ21hbnlUb29sYmFycyc7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBcmlhVXBkYXRlVGVtcGxhdGUoYXJpYVVwZGF0ZSkub3V0cHV0KHtcbiAgICAgICAgICAgICAgICB0b29sYmFyczogdG9vbGJhck5hbWVzLmpvaW4oJywnKS5yZXBsYWNlKC8sKFteLF0qKSQvLCAnIGFuZCAnICsgJyQxJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5fbW91c2Vkb3duTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9rZXlEb3duTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleURvd25MaXN0ZW5lci5kZXRhY2goKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlEb3duTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgZWRpdG9yLiBUaGlzIG1heSBpbmNsdWRlIHNldmVyYWwgdG9vbGJhcnMgYW5kIGJ1dHRvbnMuXG4gICAgICogVGhlIGVkaXRvcidzIFVJIGFsc28gdGFrZXMgY2FyZSBvZiByZW5kZXJpbmcgdGhlIGl0ZW1zIGluIGV4Y2x1c2l2ZSBtb2RlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9vbGJhcnMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BzLnRvb2xiYXJzKS5tYXAoZnVuY3Rpb24odG9vbGJhcikge1xuICAgICAgICAgICAgcmV0dXJuIEFsbG95RWRpdG9yLlRvb2xiYXJzW3Rvb2xiYXJdIHx8IHdpbmRvd1t0b29sYmFyXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdG9vbGJhcnMgPSB0aGlzLmZpbHRlckV4Y2x1c2l2ZSh0b29sYmFycykubWFwKGZ1bmN0aW9uKHRvb2xiYXIpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMubWVyZ2VFeGNsdXNpdmVQcm9wcyh7XG4gICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLnByb3BzLnRvb2xiYXJzW3Rvb2xiYXIua2V5XSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMucHJvcHMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGVkaXRvckV2ZW50OiB0aGlzLnN0YXRlLmVkaXRvckV2ZW50LFxuICAgICAgICAgICAgICAgIGtleTogdG9vbGJhci5rZXksXG4gICAgICAgICAgICAgICAgb25EaXNtaXNzOiB0aGlzLl9vbkRpc21pc3NUb29sYmFyRm9jdXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRGF0YTogdGhpcy5zdGF0ZS5zZWxlY3Rpb25EYXRhXG4gICAgICAgICAgICB9LCB0b29sYmFyLmtleSk7XG5cbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRvb2xiYXIsIHByb3BzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS10b29sYmFyc1wiIG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgICAge3Rvb2xiYXJzfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuZXIgdG8gdGhlIGVkaXRvcidzIGBhY3Rpb25QZXJmb3JtZWRgIGV2ZW50LiBTZXRzIHN0YXRlIGFuZCByZWRyYXdzIHRoZSBVSSBvZiB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX29uQWN0aW9uUGVyZm9ybWVkXG4gICAgICogQHBhcmFtIHtTeW50ZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnRcbiAgICAgKi9cbiAgICBfb25BY3Rpb25QZXJmb3JtZWQoZXZlbnQpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpdGVtRXhjbHVzaXZlOiBudWxsLFxuICAgICAgICAgICAgc2VsZWN0aW9uRGF0YTogZWRpdG9yLmdldFNlbGVjdGlvbkRhdGEoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlZCB3aGVuIGEgZGlzbWlzcyBrZXkgaXMgcHJlc3NlZCBvdmVyIGEgdG9vbGJhciB0byByZXR1cm4gdGhlIGZvY3VzIHRvIHRoZSBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfb25EaXNtaXNzVG9vbGJhckZvY3VzXG4gICAgICovXG4gICAgX29uRGlzbWlzc1Rvb2xiYXJGb2N1cygpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuZXIgdG8gdGhlIGVkaXRvcidzIGB1c2VySW50ZXJhY3Rpb25gIGV2ZW50LiBSZXRyaWV2ZXMgdGhlIGRhdGEgYWJvdXQgdGhlIHVzZXIgc2VsZWN0aW9uIGFuZFxuICAgICAqIHByb3ZpZGVzIGl0IHZpYSBjb21wb25lbnQncyBzdGF0ZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9vbkVkaXRvckludGVyYWN0aW9uXG4gICAgICogQHBhcmFtIHtTeW50ZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnRcbiAgICAgKi9cbiAgICBfb25FZGl0b3JJbnRlcmFjdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGVkaXRvckV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgICBpdGVtRXhjbHVzaXZlOiBudWxsLFxuICAgICAgICAgICAgc2VsZWN0aW9uRGF0YTogZXZlbnQuZGF0YS5zZWxlY3Rpb25EYXRhXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgb24gdGhlIGFjdGl2ZSB0b29sYmFyIHdoZW4gdGhlIGNvbWJpbmF0aW9uIEFMVCtGMTAgaXMgcHJlc3NlZCBpbnNpZGUgdGhlIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9vbkVkaXRvcktleVxuICAgICAqL1xuICAgIF9vbkVkaXRvcktleShldmVudCkge1xuICAgICAgICB2YXIgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLmRvbUV2ZW50LiQ7XG5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmFsdEtleSAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSAxMjEpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgdGFyZ2V0IHdpdGggd2hpY2ggdGhlIHVzZXIgaW50ZXJhY3RlZCBpcyBwYXJ0IG9mIGVkaXRvcidzIFVJIG9yIGl0IGlzXG4gICAgICogdGhlIGVkaXRhYmxlIGFyZWEuIElmIG5vbmUgb2YgdGhlc2UsIHNldHMgdGhlIHN0YXRlIG9mIGVkaXRvcidzIFVJIHRvIGJlIGhpZGRlbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9zZXRVSUhpZGRlblxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gdGFyZ2V0IFRoZSBET00gZWxlbWVudCB3aXRoIHdoaWNoIHVzZXIgaW50ZXJhY3RlZCBsYXN0bHkuXG4gICAgICovXG4gICAgX3NldFVJSGlkZGVuKHRhcmdldCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGlmIChkb21Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgZWRpdGFibGUgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpLmVkaXRhYmxlKCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IG5ldyBDS0VESVRPUi5kb20ubm9kZSh0YXJnZXQpO1xuXG4gICAgICAgICAgICBpZiAoIWVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gKGVkaXRhYmxlLiQgPT09IHRhcmdldCkgfHwgZWRpdGFibGUuY29udGFpbnModGFyZ2V0Tm9kZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKSkuY29udGFpbnModGFyZ2V0Tm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgVUlcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cblVJLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBkZXNjZW5kYW50czogJ1tjbGFzc149YWUtdG9vbGJhci1dJyxcbiAgICBldmVudHNEZWxheTogMCxcbiAgICBrZXlzOiB7XG4gICAgICAgIG5leHQ6IDlcbiAgICB9XG59O1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gY29tcG9uZW50IHVwZGF0ZXMgYW5kIHdoZW4gaXQgaXMgcmVuZGVyZWQgaW4gdGhlIERPTS5cbiAqIFRoZSBwYXlsb2FkIGNvbnNpc3RzIGZyb20gYSBgbWVzc2FnZWAgcHJvcGVydHkgY29udGFpbmluZyB0aGUgQVJJQSBtZXNzYWdlLlxuICpcbiAqIEBldmVudCBhcmlhVXBkYXRlXG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGNvbXBvbmVudCB1cGRhdGVzLiBUaGUgcGF5bG9hZCBjb25zaXN0cyBmcm9tIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKiAtIHByZXZQcm9wcyAtIFRoZSBwcmV2aW91cyBwcm9wZXJ0aWVzIG9mIHRoZSBjb21wb25lbnRcbiAqIC0gcHJldlN0YXRlIC0gVGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBjb21wb25lbnRcbiAqIC0gcHJvcHMgLSBUaGUgY3VycmVudCBwcm9wZXJ0aWVzIG9mIHRoZSBjb21wb25lbnRcbiAqIC0gc3RhdGUgLSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQGV2ZW50IGFyaWFVcGRhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRFeGNsdXNpdmUoXG4gICAgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgICAgICBVSVxuKSk7IiwiaW1wb3J0IFRvb2xiYXJBZGQgZnJvbSAnLi90b29sYmFyLWFkZC5qc3gnO1xuaW1wb3J0IFRvb2xiYXJTdHlsZXMgZnJvbSAnLi90b29sYmFyLXN0eWxlcy5qc3gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgW1Rvb2xiYXJBZGQua2V5XTogVG9vbGJhckFkZCxcbiAgICBbVG9vbGJhclN0eWxlcy5rZXldOiBUb29sYmFyU3R5bGVzXG59OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBUb29sYmFyQnV0dG9ucyBmcm9tICcuLi9iYXNlL3Rvb2xiYXItYnV0dG9ucy5qcyc7XG5pbXBvcnQgV2lkZ2V0QXJyb3dCb3ggZnJvbSAnLi4vYmFzZS93aWRnZXQtYXJyb3ctYm94LmpzJztcbmltcG9ydCBXaWRnZXREcm9wZG93biBmcm9tICcuLi9iYXNlL3dpZGdldC1kcm9wZG93bi5qcyc7XG5pbXBvcnQgV2lkZ2V0RXhjbHVzaXZlIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWV4Y2x1c2l2ZS5qcyc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuaW1wb3J0IFdpZGdldFBvc2l0aW9uIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LXBvc2l0aW9uLmpzJztcblxudmFyIFBPU0lUSU9OX0xFRlQgPSAxO1xudmFyIFBPU0lUSU9OX1JJR0hUID0gMjtcblxuLyoqXG4gKiBUaGUgVG9vbGJhckFkZCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhZGRpbmcgY29udGVudCB0byB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBUb29sYmFyQWRkXG4gKiBAdXNlcyBUb29sYmFyQnV0dG9uc1xuICogQHVzZXMgV2lkZ2V0QXJyb3dCb3hcbiAqIEB1c2VzIFdpZGdldERyb3Bkb3duXG4gKiBAdXNlcyBXaWRnZXRFeGNsdXNpdmVcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICogQHVzZXMgV2lkZ2V0UG9zaXRpb25cbiAqL1xuY2xhc3MgVG9vbGJhckFkZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQgKG5vdCBvbiB0aGUgc2VydmVyKSxcbiAgICAgKiBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQncyB1cGRhdGVzIGFyZSBmbHVzaGVkIHRvIHRoZSBET00uXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2UHJvcHMgVGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3RhdGUgQ29tcG9uZW50J3MgcHJldmlvdXMgc3RhdGUuXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgLy8gSW4gY2FzZSBvZiBleGNsdXNpdmUgcmVuZGVyaW5nLCBmb2N1cyB0aGUgZmlyc3QgZGVzY2VuZGFudCAoYnV0dG9uKVxuICAgICAgICAvLyBzbyB0aGUgdXNlciB3aWxsIGJlIGFibGUgdG8gc3RhcnQgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYnV0dG9ucyBpbW1lZGlhdGVseS5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIGJ1dHRvbnMgZm9yIGFkZGluZyBjb250ZW50IG9yIGhpZGVzIHRoZSB0b29sYmFyXG4gICAgICogaWYgdXNlciBpbnRlcmFjdGVkIHdpdGggYSBub24tZWRpdGFibGUgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy8gU29tZSBvcGVyYXRpb25zIHN1Y2ggYXMgYHJlcXVlc3RFeGNsdXNpdmVgIG1heSBmb3JjZSBlZGl0b3IgdG8gYmx1ciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGludmFsaWRhdGUgdGhlIGBwcm9wcy5lZGl0b3JFdmVudGAgc3RvcmVkIHZhbHVlLCB3aXRob3V0IGNhdXNpbmcgYSBgcHJvcHNgIGNoYW5nZS5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBlZGl0b3IgaXMgZW1wdHksIGBhZV9wbGFjZWhvbGRlcmAgcGx1Z2luIHdpbGwgcmVtb3ZlXG4gICAgICAgIC8vIHRoZSB0YXJnZXQgZnJvbSB0aGUgRE9NIGFuZCB3aWxsIHByZXZlbnQgYGFkZGAgdG9vbGJhciBmcm9tIHJlbmRlcmluZy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQgc2hvdWxkIGJlIHNhZmUgdG8gYXNzdW1lIHRoYXQgaWYgeW91IGhhdmUgYmVlbiBhYmxlIHRvIHJlbmRlciB0aGUgdG9vbGJhclxuICAgICAgICAvLyBhbmQgcmVxdWVzdCB0aGUgZXhjbHVzaXZlIG1vZGUsIHRoZW4gcmVuZGVyaW5nIG1pZ2h0IGJlIGtlcHQgdW50aWwgdGhlIGV4Y2x1c2l2ZSBtb2RlIGlzIGxlZnQuXG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5lZGl0b3JFdmVudCAmJlxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YS5uYXRpdmVFdmVudC50YXJnZXQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5wcm9wcy5lZGl0b3JFdmVudC5kYXRhLm5hdGl2ZUV2ZW50LnRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuX2dldEJ1dHRvbnMoKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuX2dldFRvb2xiYXJDbGFzc05hbWUoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFkZH0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGRhdGEtdGFiaW5kZXg9e3RoaXMucHJvcHMuY29uZmlnLnRhYkluZGV4IHx8IDB9IG9uRm9jdXM9e3RoaXMuZm9jdXMuYmluZCh0aGlzKX0gb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleS5iaW5kKHRoaXMpfSByb2xlPVwidG9vbGJhclwiIHRhYkluZGV4PVwiLTFcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgICAgICB7YnV0dG9uc31cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGJ1dHRvbnMgdGhhdCB3aWxsIGV2ZW50dWFsbHkgcmVuZGVyIHRvIEhUTUwuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICAgICAqIEBtZXRob2QgX2dldEJ1dHRvbnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgYnV0dG9ucyB3aGljaCBoYXZlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIF9nZXRCdXR0b25zKCkge1xuICAgICAgICB2YXIgYnV0dG9ucztcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMgPSB0aGlzLmdldFRvb2xiYXJCdXR0b25zKHRoaXMucHJvcHMuY29uZmlnLmJ1dHRvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YSAmJiB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEucmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9ucyA9IChcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFkZH0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uIGFlLWJ1dHRvbi1hZGRcIiBvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUuYmluZCh0aGlzLCBUb29sYmFyQWRkLmtleSl9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFkZH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFkZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidXR0b25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIHRvb2xiYXIgaW4gY2FzZSBvZiBib3RoIGV4Y2x1c2l2ZSBhbmQgbm9ybWFsIG1vZGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICAgICAqIEBtZXRob2QgX2dldFRvb2xiYXJDbGFzc05hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY2xhc3MgbmFtZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIF9nZXRUb29sYmFyQ2xhc3NOYW1lKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtdG9vbGJhci1hZGQnO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgY3NzQ2xhc3MgPSAnYWUtdG9vbGJhciAnICsgdGhpcy5nZXRBcnJvd0JveENsYXNzZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjc3NDbGFzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCBzZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbGJhciBpbiBleGNsdXNpdmUgb3Igbm9ybWFsIG1vZGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICAgICAqIEBtZXRob2QgX3VwZGF0ZVBvc2l0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZ2lvbjtcblxuICAgICAgICAvLyBJZiBjb21wb25lbnQgaXMgbm90IG1vdW50ZWQsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgaWYgKCFSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEucmVnaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBkb21FbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVjdCA9IHJlZ2lvbi5zdGFydFJlY3QgfHwgcmVnaW9uO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50UmVjdCA9IG5hdGl2ZUVkaXRvci5lZGl0YWJsZSgpLmdldENsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wcm9wcy5jb25maWcucG9zaXRpb24gfHwgdGhpcy5wcm9wcy5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gUE9TSVRJT05fTEVGVCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gY2xpZW50UmVjdC5sZWZ0IC0gZG9tTm9kZS5vZmZzZXRXaWR0aCAtIHRoaXMucHJvcHMuZ3V0dGVyRXhjbHVzaXZlLmxlZnQgKyAncHgnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSBjbGllbnRSZWN0LnJpZ2h0ICsgdGhpcy5wcm9wcy5ndXR0ZXJFeGNsdXNpdmUubGVmdCArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS5sZWZ0ID0gb2Zmc2V0TGVmdDtcblxuICAgICAgICAgICAgICAgIGRvbU5vZGUuc3R5bGUudG9wID0gTWF0aC5mbG9vcigocmVnaW9uLmJvdHRvbSArIHJlZ2lvbi50b3ApIC8gMikgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUVkaXRvci5lbGVtZW50LmdldFN0eWxlKCdvdmVyZmxvdycpICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS50b3AgPSBNYXRoLmZsb29yKHJlZ2lvbi50b3AgLSBkb21Ob2RlLm9mZnNldEhlaWdodC8yICsgc3RhcnRSZWN0LmhlaWdodC8yKSArICdweCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS50b3AgPSBNYXRoLmZsb29yKCBuYXRpdmVFZGl0b3IuZWxlbWVudC4kLm9mZnNldFRvcCArIChzdGFydFJlY3QuaGVpZ2h0IC8gMikgLSAoZG9tTm9kZS5vZmZzZXRIZWlnaHQgLyAyKSApICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb21Ob2RlLnN0eWxlLm9wYWNpdHkgPSAxO1xuXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWUtYXJyb3ctYm94Jyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGFkZFxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuVG9vbGJhckFkZC5rZXkgPSAnYWRkJztcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBjb25zdGFudCBmb3IgcG9zaXRpb25pbmcgdGhlIFRvb2xiYXIgb24gbGVmdCBvZiB0aGUgZWRpdGFibGUgYXJlYS5cbiAqXG4gKiBAZGVmYXVsdCAxXG4gKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGxlZnRcbiAqIEBzdGF0aWNcbiAqL1xuVG9vbGJhckFkZC5sZWZ0ID0gUE9TSVRJT05fTEVGVDtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBjb25zdGFudCBmb3IgcG9zaXRpb25pbmcgdGhlIFRvb2xiYXIgb24gcmlnaHQgb2YgdGhlIGVkaXRhYmxlIGFyZWEuXG4gKlxuICogQGRlZmF1bHQgMlxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByaWdodFxuICogQHN0YXRpY1xuICovXG5Ub29sYmFyQWRkLnJpZ2h0ID0gUE9TSVRJT05fUklHSFQ7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuVG9vbGJhckFkZC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgZGVzY2VuZGFudHM6ICcuYWUtYnV0dG9uJyxcbiAgICBndXR0ZXJFeGNsdXNpdmU6IHtcbiAgICAgICAgbGVmdDogMTAsXG4gICAgICAgIHRvcDogMFxuICAgIH0sXG4gICAga2V5czoge1xuICAgICAgICBkaXNtaXNzOiBbMjddLFxuICAgICAgICBuZXh0OiBbMzksIDQwXSxcbiAgICAgICAgcHJldjogWzM3LCAzOF1cbiAgICB9LFxuICAgIHBvc2l0aW9uOiBQT1NJVElPTl9MRUZUXG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRBcnJvd0JveChcbiAgICBXaWRnZXREcm9wZG93bihcbiAgICBXaWRnZXRFeGNsdXNpdmUoXG4gICAgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIFdpZGdldFBvc2l0aW9uKFxuICAgIFRvb2xiYXJCdXR0b25zKFxuICAgICAgICBUb29sYmFyQWRkXG4pKSkpKSk7IiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFRvb2xiYXJCdXR0b25zIGZyb20gJy4uL2Jhc2UvdG9vbGJhci1idXR0b25zLmpzJztcbmltcG9ydCBXaWRnZXRBcnJvd0JveCBmcm9tICcuLi9iYXNlL3dpZGdldC1hcnJvdy1ib3guanMnO1xuaW1wb3J0IFdpZGdldERyb3Bkb3duIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duLmpzJztcbmltcG9ydCBXaWRnZXRFeGNsdXNpdmUgZnJvbSAnLi4vYmFzZS93aWRnZXQtZXhjbHVzaXZlLmpzJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyc7XG5pbXBvcnQgV2lkZ2V0UG9zaXRpb24gZnJvbSAnLi4vYmFzZS93aWRnZXQtcG9zaXRpb24uanMnO1xuXG4vKipcbiAqIFRoZSBUb29sYmFyU3R5bGVzIGNsYXNzIGhvc3RzIHRoZSBidXR0b25zIGZvciBzdHlsaW5nIGEgdGV4dCBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIFRvb2xiYXJTdHlsZXNcbiAqIEB1c2VzIFRvb2xiYXJCdXR0b25zXG4gKiBAdXNlcyBXaWRnZXRBcnJvd0JveFxuICogQHVzZXMgV2lkZ2V0RHJvcGRvd25cbiAqIEB1c2VzIFdpZGdldEV4Y2x1c2l2ZVxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKiBAdXNlcyBXaWRnZXRQb3NpdGlvblxuICovXG5jbGFzcyBUb29sYmFyU3R5bGVzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50e1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCAobm90IG9uIHRoZSBzZXJ2ZXIpLFxuICAgICAqIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIHVwZGF0ZXMgYXJlIGZsdXNoZWQgdG8gdGhlIERPTS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZQcm9wcyBUaGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCdzIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdGF0ZSBDb21wb25lbnQncyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIGJ1dHRvbnMgZm9yIGFkZGluZyBjb250ZW50IG9yIGhpZGVzIHRoZSB0b29sYmFyXG4gICAgICogaWYgdXNlciBpbnRlcmFjdGVkIHdpdGggYSBub24tZWRpdGFibGUgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLl9nZXRDdXJyZW50U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBnZXRBcnJvd0JveENsYXNzZXNGbiA9IHRoaXMuX2dldFNlbGVjdGlvbkZ1bmN0aW9uKGN1cnJlbnRTZWxlY3Rpb24uZ2V0QXJyb3dCb3hDbGFzc2VzKTtcbiAgICAgICAgICAgIHZhciBhcnJvd0JveENsYXNzZXM7XG5cbiAgICAgICAgICAgIGlmIChnZXRBcnJvd0JveENsYXNzZXNGbikge1xuICAgICAgICAgICAgICAgIGFycm93Qm94Q2xhc3NlcyA9IGdldEFycm93Qm94Q2xhc3Nlc0ZuKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycm93Qm94Q2xhc3NlcyA9IHRoaXMuZ2V0QXJyb3dCb3hDbGFzc2VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjc3NDbGFzc2VzID0gJ2FlLXRvb2xiYXItc3R5bGVzICcgKyBhcnJvd0JveENsYXNzZXM7XG5cbiAgICAgICAgICAgIHZhciBidXR0b25zID0gdGhpcy5nZXRUb29sYmFyQnV0dG9ucyhcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtYW51YWxTZWxlY3Rpb246IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQgPyB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGEubWFudWFsU2VsZWN0aW9uIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uVHlwZTogY3VycmVudFNlbGVjdGlvbi5uYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXN9IGRhdGEtdGFiaW5kZXg9e3RoaXMucHJvcHMuY29uZmlnLnRhYkluZGV4IHx8IDB9IG9uRm9jdXM9e3RoaXMuZm9jdXMuYmluZCh0aGlzKX0gb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleS5iaW5kKHRoaXMpfSByb2xlPVwidG9vbGJhclwiIHRhYkluZGV4PVwiLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtidXR0b25zfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIGZ1bmN0aW9uIGZyb20gU3RyaW5nLiBJdCBjb252ZXJ0cyBhIGZ1bGx5IHF1YWxpZmllZCBzdHJpbmcgaW50byB0aGUgbWFwcGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiAgICAgKiBAbWV0aG9kIF9nZXRTZWxlY3Rpb25GdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBzZWxlY3Rpb25GbiBBIGZ1bmN0aW9uLCBvciBhIGZ1bGx5IHF1YWxpZmllZCBzdHJpbmcgcG9pbnRpbmcgdG8gdGhlIGRlc2lyZWQgb25lIChlLmcuICdBbGxveUVkaXRvci5TZWxlY3Rpb25UZXN0LmltYWdlJykuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbWFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIF9nZXRTZWxlY3Rpb25GdW5jdGlvbihzZWxlY3Rpb25Gbikge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRnVuY3Rpb247XG5cbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzZWxlY3Rpb25GbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbkZ1bmN0aW9uID0gc2VsZWN0aW9uRm47XG5cbiAgICAgICAgfSBlbHNlIGlmIChMYW5nLmlzU3RyaW5nKHNlbGVjdGlvbkZuKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gc2VsZWN0aW9uRm4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWVtYmVyID0gd2luZG93O1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcGFydHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgd2hpbGUgKHByb3BlcnR5ICYmIExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikgJiYgTGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWVtYmVyID0gY3VycmVudE1lbWJlcltwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKGN1cnJlbnRNZW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRnVuY3Rpb24gPSBjdXJyZW50TWVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkZ1bmN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5emVzIHRoZSBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24gYW5kIHJldHVybnMgdGhlIHNlbGVjdGlvbiBjb25maWd1cmF0aW9uIHRoYXQgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gICAgICogQG1ldGhvZCBfZ2V0Q3VycmVudFNlbGVjdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtYXRjaGVkIHNlbGVjdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIF9nZXRDdXJyZW50U2VsZWN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnRQYXlsb2FkID0gdGhpcy5wcm9wcy5lZGl0b3JFdmVudCA/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YSA6IG51bGw7XG4gICAgICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKGV2ZW50UGF5bG9hZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5jb25maWcuc2VsZWN0aW9ucy5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdEZuID0gdGhpcy5fZ2V0U2VsZWN0aW9uRnVuY3Rpb24oaXRlbS50ZXN0KTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRlc3RGbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmVudFBheWxvYWQubWFudWFsU2VsZWN0aW9uID09PSBpdGVtLm5hbWUgfHzCoHRlc3RGbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBldmVudFBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMucHJvcHMuZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVQb3NpdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIC8vIElmIGNvbXBvbmVudCBpcyBub3QgbW91bnRlZCwgdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAoIVJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuX2dldEN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyBJZiBjdXJyZW50IHNlbGVjdGlvbiBoYXMgYSBmdW5jdGlvbiBjYWxsZWQgYHNldFBvc2l0aW9uYCwgY2FsbCBpdFxuICAgICAgICAvLyBhbmQgY2hlY2sgdGhlIHJldHVybmVkIHZhbHVlLiBJZiBmYWxzZSwgZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb25pbmcgbG9naWMuXG4gICAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2V0UG9zaXRpb25GbiA9IHRoaXMuX2dldFNlbGVjdGlvbkZ1bmN0aW9uKGN1cnJlbnRTZWxlY3Rpb24uc2V0UG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoc2V0UG9zaXRpb25Gbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldFBvc2l0aW9uRm4uY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5wcm9wcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvckV2ZW50OiB0aGlzLnByb3BzLmVkaXRvckV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25EYXRhOiB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5Ub29sYmFyU3R5bGVzLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS1pbnB1dCwgLmFlLWJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIC5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgbmV4dDogWzM5LCA0MF0sXG4gICAgICAgIHByZXY6IFszNywgMzhdXG4gICAgfVxufTtcblxuLyoqXG4qIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuKlxuKiBAZGVmYXVsdCBzdHlsZXNcbiogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuKiBAc3RhdGljXG4qL1xuVG9vbGJhclN0eWxlcy5rZXkgPSAnc3R5bGVzJztcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0QXJyb3dCb3goXG4gICAgV2lkZ2V0RHJvcGRvd24oXG4gICAgV2lkZ2V0RXhjbHVzaXZlKFxuICAgIFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICBXaWRnZXRQb3NpdGlvbihcbiAgICBUb29sYmFyQnV0dG9ucyhcbiAgICAgICAgVG9vbGJhclN0eWxlc1xuKSkpKSkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3VpYnJpZGdlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGV4dGVuZHMgQ0tFRElUT1IudWkuYWRkIGZ1bmN0aW9uIHNvIGFuIGFkZCBoYW5kbGVyIGNhbiBiZSBzcGVjaWZpZWRcbiAgICAgKiBvbiB0b3Agb2YgdGhlIG9yaWdpbmFsIG9uZXMuIEl0IGJyaWRnZXMgdGhlIGNhbGxzIHRvIGFkZCBjb21wb25lbnRzIHZpYTpcbiAgICAgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgdHlwZSwgZGVmaW5pdGlvbilcbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3VpYnJpZGdlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3VpYnJpZGdlJywge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGJlZm9yZUluaXRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsVUlBZGRGbiA9IGVkaXRvci51aS5hZGQ7XG5cbiAgICAgICAgICAgIGVkaXRvci51aS5hZGQgPSBmdW5jdGlvbihuYW1lLCB0eXBlLCBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxVSUFkZEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHlwZUhhbmRsZXIgPSB0aGlzLl8uaGFuZGxlcnNbdHlwZV07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZUhhbmRsZXIgJiYgdHlwZUhhbmRsZXIuYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVIYW5kbGVyLmFkZChuYW1lLCBkZWZpbml0aW9uLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgICAgICBBbGxveUVkaXRvci5yZWdpc3RlckJyaWRnZUJ1dHRvbihuYW1lLCBlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18ucGx1Z2luLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn0oKSk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIERlYm91bmNlIHV0aWwgZnVuY3Rpb24uIElmIGEgZnVuY3Rpb24gZXhlY3V0aW9uIGlzIGV4cGVuc2l2ZSwgaXQgbWlnaHQgYmUgZGVib3VuY2VkLiBUaGlzIG1lYW5zXG4gICAgICogdGhhdCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHNvbWUgYW1vdW50IG9mIHRpbWUgYWZ0ZXIgaXRzIGxhc3QgY2FsbC4gRm9yIGV4YW1wbGUsIGlmIHdlIGF0dGFjaCBhXG4gICAgICogYSBmdW5jdGlvbiBvbiBzY3JvbGwgZXZlbnQsIGl0IG1pZ2h0IGJlIGNhbGxlZCBodW5kcmVkcyB0aW1lcyBwZXIgc2Vjb25kLiBJbiB0aGlzIGNhc2UgaXQgbWF5IGJlXG4gICAgICogZGVib3VuY2VkIHdpdGgsIGxldCdzIHNheSAxMDBtcy4gVGhlIHJlYWwgZXhlY3V0aW9uIG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBoYXBwZW4gMTAwbXMgYWZ0ZXIgbGFzdFxuICAgICAqIHNjcm9sbCBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICAgICAqIEBtZXRob2QgZGVib3VuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB3aGljaCBoYXMgdG8gYmUgY2FsbGVkIGFmdGVyIGdpdmVuIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgVGltZW91dCBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBjb250ZXh0IGluIHdoaWNoIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZC4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbC5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgQ0tFRElUT1IudG9vbHMuZGVib3VuY2UgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZSB8fCBmdW5jdGlvbihjYWxsYmFjaywgdGltZW91dCwgY29udGV4dCwgYXJncykge1xuICAgICAgICB2YXIgZGVib3VuY2VIYW5kbGU7XG5cbiAgICAgICAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhbGxDb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VIYW5kbGUpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0YXJ0SW5kZXggPSAwOyBzdGFydEluZGV4IDwgbGVuOyArK3N0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcmd1bWVudHNbc3RhcnRJbmRleF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FsbEFyZ3MgPSByZXN1bHQuY29uY2F0KGFyZ3MgfHwgW10pO1xuXG4gICAgICAgICAgICBkZWJvdW5jZUhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoY2FsbENvbnRleHQsIGNhbGxBcmdzKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbGxGbi5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZUhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGNhbGxGbjtcbiAgICB9O1xufSgpKTsiLCJpbXBvcnQgZGVib3VuY2UgZnJvbSAnLi9kZWJvdW5jZSc7XG5pbXBvcnQgbGluayBmcm9tICcuL2xpbmsnO1xuaW1wb3J0IHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zJztcbmltcG9ydCBzZWxlY3Rpb25SZWdpb24gZnJvbSAnLi9zZWxlY3Rpb24tcmVnaW9uJztcbmltcG9ydCB0YWJsZSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB0b29scyBmcm9tICcuL3Rvb2xzJztcbmltcG9ydCB1aWNvcmUgZnJvbSAnLi91aWNvcmUnO1xuXG5leHBvcnQge1xuICAgIGRlYm91bmNlLFxuICAgIGxpbmssXG4gICAgcGx1Z2lucyxcbiAgICBzZWxlY3Rpb25SZWdpb24sXG4gICAgdGFibGUsXG4gICAgdG9vbHMsXG4gICAgdWljb3JlXG59OyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkVHRVhfQk9PS01BUktfU0NIRU1FID0gL14jLiovaTtcbiAgICB2YXIgUkVHRVhfRU1BSUxfU0NIRU1FID0gL15bYS16MC05XFx1MDQzMC1cXHUwNDRGXFwuXy1dK0AvaTtcbiAgICB2YXIgUkVHRVhfVVJJX1NDSEVNRSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKilcXDp8XlxcLy9pO1xuXG4gICAgLyoqXG4gICAgICogTGluayBjbGFzcyB1dGlsaXR5LiBQcm92aWRlcyBtZXRob2RzIGZvciBjcmVhdGUsIGRlbGV0ZSBhbmQgdXBkYXRlIGxpbmtzLlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLkxpbmtcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaW5rKGVkaXRvciwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5hcHBlbmRQcm90b2NvbCA9IGNvbmZpZyAmJiBjb25maWcuYXBwZW5kUHJvdG9jb2wgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIExpbmsucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogTGluayxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWR2YW5jZXMgdGhlIGVkaXRvciBzZWxlY3Rpb24gdG8gdGhlIG5leHQgYXZhaWxhYmxlIHBvc2l0aW9uIGFmdGVyIGFcbiAgICAgICAgICogZ2l2ZW4gbGluayBvciB0aGUgb25lIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG4gICAgICAgICAqIEBtZXRob2QgYWR2YW5jZVNlbGVjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBsaW5rIFRoZSBsaW5rIGVsZW1lbnQgd2hpY2ggbGluayBzdHlsZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICovXG4gICAgICAgIGFkdmFuY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmsgPSBsaW5rIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UubW92ZVRvRWxlbWVudEVkaXRFbmQobGluayk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSByYW5nZS5nZXROZXh0RWRpdGFibGVOb2RlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUgJiYgIXRoaXMuX2VkaXRvci5lbGVtZW50LmVxdWFscyhuZXh0Tm9kZS5nZXRDb21tb25BbmNlc3RvcihsaW5rKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdoaXRlc3BhY2UgPSAvXFxzLy5leGVjKG5leHROb2RlLmdldFRleHQoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHdoaXRlc3BhY2UgPyB3aGl0ZXNwYWNlLmluZGV4ICsgMSA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobmV4dE5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChuZXh0Tm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RSYW5nZXMoW3JhbmdlXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIGxpbmsgd2l0aCBnaXZlbiBVUkkgYXMgaHJlZi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBBIGNvbmZpZyBvYmplY3Qgd2l0aCBsaW5rIGF0dHJpYnV0ZXMuIFRoZXNlIG1pZ2h0IGJlIGFyYml0cmFyeSBET00gYXR0cmlidXRlcy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGlmeVNlbGVjdGlvbiBBIGNvbmZpZyBvYmplY3Qgd2l0aCBhbiBhZHZhbmNlIGF0dHJpYnV0ZSB0byBpbmRpY2F0ZSBpZiB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb3ZlZCBhZnRlciB0aGUgbGluayBjcmVhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFVSSSBUaGUgVVJJIG9mIHRoZSBsaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihVUkksIGF0dHJzLCBtb2RpZnlTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKVswXTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbmV3IENLRURJVE9SLmRvbS50ZXh0KFVSSSwgdGhpcy5fZWRpdG9yLmRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVVJJID0gdGhpcy5fZ2V0Q29tcGxldGVVUkkoVVJJKTtcblxuICAgICAgICAgICAgdmFyIGxpbmtBdHRycyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHtcbiAgICAgICAgICAgICAgICAnZGF0YS1ja2Utc2F2ZWQtaHJlZic6IFVSSSxcbiAgICAgICAgICAgICAgICBocmVmOiBVUklcbiAgICAgICAgICAgIH0sIGF0dHJzKTtcblxuICAgICAgICAgICAgdmFyIHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBsaW5rQXR0cnMsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogJ2EnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3R5bGUudHlwZSA9IENLRURJVE9SLlNUWUxFX0lOTElORTtcbiAgICAgICAgICAgIHN0eWxlLmFwcGx5VG9SYW5nZShyYW5nZSwgdGhpcy5fZWRpdG9yKTtcblxuICAgICAgICAgICAgaWYgKG1vZGlmeVNlbGVjdGlvbiAmJiBtb2RpZnlTZWxlY3Rpb24uYWR2YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGEgbGluayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG4gICAgICAgICAqIEBtZXRob2QgZ2V0RnJvbVNlbGVjdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gVGhlIHJldHJpZXZlZCBsaW5rIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RnJvbVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50ICYmIHNlbGVjdGVkRWxlbWVudC5pcygnYScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkRWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlcygpWzBdO1xuXG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zaHJpbmsoQ0tFRElUT1IuU0hSSU5LX1RFWFQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRvci5lbGVtZW50UGF0aChyYW5nZS5nZXRDb21tb25BbmNlc3RvcigpKS5jb250YWlucygnYScsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIGxpbmsgZnJvbSB0aGUgZWRpdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gbGluayBUaGUgbGluayBlbGVtZW50IHdoaWNoIGxpbmsgc3R5bGUgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RpZnlTZWxlY3Rpb24gQSBjb25maWcgb2JqZWN0IHdpdGggYW4gYWR2YW5jZSBhdHRyaWJ1dGUgdG8gaW5kaWNhdGUgaWYgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgbW92ZWQgYWZ0ZXIgdGhlIGxpbmsgY3JlYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGxpbmssIG1vZGlmeVNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcblxuICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZ5U2VsZWN0aW9uICYmIG1vZGlmeVNlbGVjdGlvbi5hZHZhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmsucmVtb3ZlKGVkaXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c1JlbW92ZUVsZW1lbnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdhJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQ0tFRElUT1IuU1RZTEVfSU5MSU5FXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyAncmVtb3ZlU3R5bGUoKScgcmVtb3ZlcyB0aGUgc3R5bGUgZnJvbSB0aGUgZWRpdG9yJ3MgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gIFdlIG5lZWQgdG8gZm9yY2UgdGhlIHNlbGVjdGlvbiB0byBiZSB0aGUgd2hvbGUgbGluayBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gIHRvIHJlbW92ZSBpdCBwcm9wZXJseS5cblxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEVsZW1lbnQoc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTdHlsZShzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGhyZWYgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gbGluayBUaGUgbGluayBlbGVtZW50IHdoaWNoIGhyZWYgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgdG8gdXBkYXRlIG9yIHJlbW92ZS4gQXR0cmlidXRlcyB3aXRoIG51bGwgdmFsdWVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGlmeVNlbGVjdGlvbiBBIGNvbmZpZyBvYmplY3Qgd2l0aCBhbiBhZHZhbmNlIGF0dHJpYnV0ZSB0byBpbmRpY2F0ZSBpZiB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb3ZlZCBhZnRlciB0aGUgbGluayBjcmVhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oYXR0cnMsIGxpbmssIG1vZGlmeVNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gIHRoaXM7XG5cbiAgICAgICAgICAgIGxpbmsgPSBsaW5rIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciB1cmkgPSBpbnN0YW5jZS5fZ2V0Q29tcGxldGVVUkkoYXR0cnMpO1xuXG4gICAgICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY2tlLXNhdmVkLWhyZWYnOiB1cmksXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHVyaVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXR0cnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZUF0dHJzID0gW107XG5cbiAgICAgICAgICAgICAgICB2YXIgc2V0QXR0cnMgPSB7fTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnNba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXR0cnMucHVzaCgnZGF0YS1ja2Utc2F2ZWQtaHJlZicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVBdHRycy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnaHJlZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJpID0gaW5zdGFuY2UuX2dldENvbXBsZXRlVVJJKGF0dHJzW2tleV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXR0cnNbJ2RhdGEtY2tlLXNhdmVkLWhyZWYnXSA9IHVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyc1trZXldID0gdXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyc1trZXldID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGluay5yZW1vdmVBdHRyaWJ1dGVzKHJlbW92ZUF0dHJzKTtcbiAgICAgICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZXMoc2V0QXR0cnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kaWZ5U2VsZWN0aW9uICYmIG1vZGlmeVNlbGVjdGlvbi5hZHZhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU2VsZWN0aW9uKGxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIFVSSSBiZWdpbnMgd2l0aCBhICcjJyBzeW1ib2wgdG8gZGV0ZXJtaW5lIGlmIGl0J3MgYW4gb24gcGFnZSBib29rbWFyay5cbiAgICAgICAgICogSWYgaXQgZG9lc24ndCwgaXQgdGhlbiBjaGVja3MgaWYgdGhlIFVSSSBoYXMgYW4gJ0AnIHN5bWJvbC4gSWYgaXQgZG9lcyBhbmQgdGhlIFVSSVxuICAgICAgICAgKiBsb29rcyBsaWtlIGFuIGVtYWlsIGFuZCBkb2Vzbid0IGhhdmUgJ21haWx0bzonLCAnbWFpbHRvOicgaXMgYWRkZWQgdG8gdGhlIFVSSS5cbiAgICAgICAgICogSWYgaXQgZG9lc24ndCBhbmQgdGhlIFVSSSBkb2Vzbid0IGhhdmUgYSBzY2hlbWUsIHRoZSBkZWZhdWx0ICdodHRwJyBzY2hlbWUgd2l0aFxuICAgICAgICAgKiBoaWVyYXJjaGljYWwgcGF0aCAnLy8nIGlzIGFkZGVkIHRvIHRoZSBVUkkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIF9nZXRDb21wbGV0ZVVSSVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gVVJJIFRoZSBVUkkgb2YgdGhlIGxpbmsuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgVVJJIHVwZGF0ZWQgd2l0aCB0aGUgcHJvdG9jb2wuXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0Q29tcGxldGVVUkk6IGZ1bmN0aW9uKFVSSSkge1xuICAgICAgICAgICAgaWYgKFJFR0VYX0JPT0tNQVJLX1NDSEVNRS50ZXN0KFVSSSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVVJJO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChSRUdFWF9FTUFJTF9TQ0hFTUUudGVzdChVUkkpKSB7XG4gICAgICAgICAgICAgICAgVVJJID0gJ21haWx0bzonICsgVVJJO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghUkVHRVhfVVJJX1NDSEVNRS50ZXN0KFVSSSkpIHtcbiAgICAgICAgICAgICAgICBVUkkgPSB0aGlzLmFwcGVuZFByb3RvY29sID8gJ2h0dHA6Ly8nICsgVVJJIDogVVJJO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gVVJJO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENLRURJVE9SLkxpbmsgPSBDS0VESVRPUi5MaW5rIHx8IExpbms7XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBXcmFwcyBlYWNoIG9mIHRoZSBwbHVnaW4gbGlmZWN5Y2xlIG1ldGhvZHMgaW4gYSBjbG9zdXJlIHRoYXQgd2lsbFxuICAgIC8vIHNldCB1cCB0aGUgZWRpdG9yLl9fcHJvY2Vzc2luZ1BsdWdpbl9fIHZhcmlhYmxlIHNvIGl0IGNhbiBiZSBnbG9iYWxseVxuICAgIC8vIGFjY2Vzc2VkIGV4cG9zaW5nIHRoZSBwbHVnaW4gYmVpbmcgcHJvY2Vzc2VkIGFuZCB0aGUgbGlmZWN5Y2xlIHBoYXNlXG4gICAgLy8gaW4gd2hpY2ggaXQgaXMgaGFwcGVuaW5nXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge09iamVjdH0gcGx1Z2luIFRoZSBwbHVnaW4gdG8gd3JhcCBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHZhciB3cmFwUGx1Z2luTGlmZWN5Y2xlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgIHZhciBtZXRob2RzID0gWydiZWZvcmVJbml0JywgJ2luaXQnLCAnYWZ0ZXJJbml0J107XG5cbiAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW5bbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5bbWV0aG9kTmFtZV0gPSBDS0VESVRPUi50b29scy5vdmVycmlkZShwbHVnaW5bbWV0aG9kTmFtZV0sIGZ1bmN0aW9uKG9yaWdpbmFsUGx1Z2luTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhhc2U6IG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW46IHBsdWdpblxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5fX3Byb2Nlc3NpbmdQbHVnaW5fXyA9IHBheWxvYWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUGx1Z2luTWV0aG9kLmNhbGwodGhpcywgZWRpdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLl9fcHJvY2Vzc2luZ1BsdWdpbl9fID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEZpbHRlcnMgdGhlIHJlcXVpcmVzIG9iamVjdCB0byByZW1vdmUgdW53YW50ZWQgZGVwZW5kZW5jaWVzLiBBdCB0aGlzIHBvaW50XG4gICAgLy8gb25seSAndG9vbGJhcicgaGFzIGJlZW4gaWRlbnRpZmllZCwgYnV0IG1vcmUgY2FuIGFwcGVhci4gQW4gdW53YW50ZWQgcGx1Z2luXG4gICAgLy8gZGVwZW5kZW5jeSBpcyBvbmUgdGhhdCBwcmV2ZW50cyBhIG5lY2Vzc2FyeSBwbHVnaW4gZnJvbSBiZWluZyByZW1vdmVkXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSByZXF1aXJlcyBUaGUgcmVxdWlyZXMgb2JqZWN0XG4gICAgLy8gQHJldHVybiB7c3RyaW5nfSBUaGUgZmlsdGVyZWQgcmVxdWlyZXMgb2JqZWN0XG4gICAgdmFyIGZpbHRlclVud2FudGVkRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24ocmVxdWlyZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcXVpcmVzID0gcmVxdWlyZXMuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1aXJlcy5maWx0ZXIoZnVuY3Rpb24ocmVxdWlyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUgIT09ICd0b29sYmFyJztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENLRURJVE9SLnBsdWdpbnMgY2xhc3MgdXRpbGl0eSB3aGljaCBhZGRzIGFkZGl0aW9uYWwgbWV0aG9kcyB0byB0aG9zZSBvZiBDS0VkaXRvci5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgQ0tFRElUT1IucGx1Z2lucy5sb2FkIG1ldGhvZCBzbyB3ZSBjYW4gZXh0ZW5kIHRoZSBsaWZlY3ljbGUgbWV0aG9kcyBvZlxuICAgICAqIHRoZSBsb2FkZWQgcGx1Z2lucyB0byBhZGQgc29tZSBtZXRhaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBsdWdpbiBiZWluZyBwcm9jZXNzZWRcbiAgICAgKlxuXHQgKiBAcGFyYW0ge1N0cmluZy9BcnJheX0gbmFtZXMgVGhlIG5hbWUgb2YgdGhlIHJlc291cmNlIHRvIGxvYWQuIEl0IG1heSBiZSBhXG5cdCAqIHN0cmluZyB3aXRoIGEgc2luZ2xlIHJlc291cmNlIG5hbWUsIG9yIGFuIGFycmF5IHdpdGggc2V2ZXJhbCBuYW1lcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhbGwgcmVzb3VyY2VzXG5cdCAqIGFyZSBsb2FkZWQuIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgbG9hZGVkIG5hbWVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgb2JqZWN0IHRvIGJlIHVzZWQgZm9yIHRoZSBjYWxsYmFjayBjYWxsLlxuICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zXG4gICAgICogQG1ldGhvZCBsb2FkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIENLRURJVE9SLnBsdWdpbnMubG9hZCA9IENLRURJVE9SLnRvb2xzLm92ZXJyaWRlKENLRURJVE9SLnBsdWdpbnMubG9hZCwgZnVuY3Rpb24ocGx1Z2luc0xvYWQpe1xuICAgICAgICAvLyBXcmFwIG9yaWdpbmFsIGxvYWQgZnVuY3Rpb24gc28gd2UgY2FuIHRyYW5zZm9ybSB0aGUgcGx1Z2luIGlucHV0IHBhcmFtZXRlclxuICAgICAgICAvLyBiZWZvcmUgcGFzc2luZyBpdCBkb3duIHRvIHRoZSBvcmlnaW5hbCBjYWxsYmFja1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZXMsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICAgICAgcGx1Z2luc0xvYWQuY2FsbCh0aGlzLCBuYW1lcywgZnVuY3Rpb24ocGx1Z2lucykge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbk5hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnJlcXVpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnJlcXVpcmVzID0gZmlsdGVyVW53YW50ZWREZXBlbmRlbmNpZXMocGx1Z2luLnJlcXVpcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcFBsdWdpbkxpZmVjeWNsZShwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlLCBwbHVnaW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn0oKSk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfc2VsZWN0aW9ucmVnaW9uJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NID0gMDtcbiAgICBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCA9IDE7XG4gICAgQ0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFQgPSAyO1xuICAgIENLRURJVE9SLlNFTEVDVElPTl9SSUdIVF9UT19MRUZUID0gMztcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGlvblJlZ2lvbiB1dGlsaXR5IGNsYXNzIHdoaWNoIHByb3ZpZGVzIG1ldGFkYXRhIGFib3V0IHRoZSBzZWxlY3Rpb24uIFRoZSBtZXRhZGF0YSBtYXkgYmUgdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICAgKiByZWN0YW5nbGVzLCBjYXJldCByZWdpb24sIGV0Yy4gKipUaGlzIGNsYXNzIGlzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIHN0YW5kYWxvbmUuIEl0cyBmdW5jdGlvbnMgd2lsbFxuICAgICAqIGJlIG1lcmdlZCBpbnRvIGVhY2ggZWRpdG9yIGluc3RhbmNlLCBzbyB0aGUgZGV2ZWxvcGVyIG1heSB1c2UgdGhlbSBkaXJlY3RseSB2aWEgdGhlIGVkaXRvciwgd2l0aG91dCBtYWtpbmdcbiAgICAgKiBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzKiouXG4gICAgICpcbiAgICAgKiBAY2xhc3MgU2VsZWN0aW9uUmVnaW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uUmVnaW9uKCkge31cblxuICAgIFNlbGVjdGlvblJlZ2lvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb25SZWdpb24sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgc2VsZWN0aW9uIGZyb20gdHdvIHBvaW50cyBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVNlbGVjdGlvbkZyb21Qb2ludFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNlbGVjdGlvbkZyb21Qb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2UoeCwgeSwgeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgc2VsZWN0aW9uIGZyb20gcmFuZ2UuIEEgcmFuZ2UgY29uc2lzdHMgZnJvbSB0d28gcG9pbnRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlU2VsZWN0aW9uRnJvbVJhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFggWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0WSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kWCBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFkgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2U6IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZKSB7XG4gICAgICAgICAgICB2YXIgZW5kO1xuICAgICAgICAgICAgdmFyIGVuZENvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBlbmRPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgcmFuZ2U7XG4gICAgICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChlbmRYLCBlbmRZKTtcblxuICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnQub2Zmc2V0Tm9kZTtcbiAgICAgICAgICAgICAgICBlbmRDb250YWluZXIgPSBlbmQub2Zmc2V0Tm9kZTtcblxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCA9IGVuZC5vZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoZW5kWCwgZW5kWSk7XG5cbiAgICAgICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IHN0YXJ0LnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGVuZC5zdGFydENvbnRhaW5lcjtcblxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnQuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gZW5kLnN0YXJ0T2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiBkb2N1bWVudC5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChuZXcgQ0tFRElUT1IuZG9tLm5vZGUoc3RhcnRDb250YWluZXIpLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5ldyBDS0VESVRPUi5kb20ubm9kZShlbmRDb250YWluZXIpLCBlbmRPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb24oKS5zZWxlY3RSYW5nZXMoW3JhbmdlXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnVubG9jaygpO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVUb1BvaW50KHN0YXJ0WCwgc3RhcnRZKTtcblxuICAgICAgICAgICAgICAgIHZhciBlbmRSYW5nZSA9IHJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIGVuZFJhbmdlLm1vdmVUb1BvaW50KGVuZFgsIGVuZFkpO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvRW5kJywgZW5kUmFuZ2UpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb24oKS5sb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlZ2lvbiBvZiB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgY2FyZXQuIFRoZSBwb2ludHMgYXJlIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Q2FyZXRSZWdpb25cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogLSBib3R0b21cbiAgICAgICAgICogLSBsZWZ0XG4gICAgICAgICAqIC0gcmlnaHRcbiAgICAgICAgICogLSB0b3BcbiAgICAgICAgICovXG4gICAgICAgIGdldENhcmV0UmVnaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgcmVnaW9uID0ge1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGJvb2ttYXJrcyA9IHNlbGVjdGlvbi5jcmVhdGVCb29rbWFya3MoKTtcblxuICAgICAgICAgICAgaWYgKCFib29rbWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJvb2ttYXJrTm9kZUVsID0gYm9va21hcmtzWzBdLnN0YXJ0Tm9kZS4kO1xuXG4gICAgICAgICAgICBib29rbWFya05vZGVFbC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG5cbiAgICAgICAgICAgIHJlZ2lvbiA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChib29rbWFya05vZGVFbCkuZ2V0Q2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBib29rbWFya05vZGVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJvb2ttYXJrTm9kZUVsKTtcblxuICAgICAgICAgICAgdmFyIHNjcm9sbFBvcyA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgcmVnaW9uLmJvdHRvbSA9IHNjcm9sbFBvcy55ICsgcmVnaW9uLmJvdHRvbTtcbiAgICAgICAgICAgIHJlZ2lvbi5sZWZ0ID0gc2Nyb2xsUG9zLnggKyByZWdpb24ubGVmdDtcbiAgICAgICAgICAgIHJlZ2lvbi5yaWdodCA9IHNjcm9sbFBvcy54ICsgcmVnaW9uLnJpZ2h0O1xuICAgICAgICAgICAgcmVnaW9uLnRvcCA9IHNjcm9sbFBvcy55ICsgcmVnaW9uLnRvcDtcblxuICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBkYXRhIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2VsZWN0aW9uRGF0YVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGRhdGE6XG4gICAgICAgICAqIC0gZWxlbWVudCAtIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWxlbWVudCwgaWYgYW55XG4gICAgICAgICAqIC0gdGV4dCAtIFRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAqIC0gcmVnaW9uIC0gVGhlIGRhdGEsIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uUmVnaW9uOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VsZWN0aW9uRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uZ2V0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgdGV4dDogc2VsZWN0aW9uLmdldFNlbGVjdGVkVGV4dCgpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXN1bHQucmVnaW9uID0gdGhpcy5nZXRTZWxlY3Rpb25SZWdpb24oc2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVnaW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQG1ldGhvZCBnZXRTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIG9iamVjdCB3aGljaCBpcyBiZWluZyByZXR1cm5lZCBmcm9tXG4gICAgICAgICAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldENsaWVudFJlY3RzUmVnaW9uOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fSB3aXRoIHRocmVlIG1vcmUgcHJvcGVydGllczpcbiAgICAgICAgICogLSBkaXJlY3Rpb24gLSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIENhbiBiZSBvbmUgb2YgdGhlc2U6XG4gICAgICAgICAqICAgMS4gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cbiAgICAgICAgICogICAyLiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUFxuICAgICAgICAgKiAtIGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHNlbGVjdGlvbiByZWdpb25cbiAgICAgICAgICogLSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIHJlZ2lvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VsZWN0aW9uUmVnaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZWdpb24gPSB0aGlzLmdldENsaWVudFJlY3RzUmVnaW9uKCk7XG5cbiAgICAgICAgICAgIHJlZ2lvbi5kaXJlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbkRpcmVjdGlvbigpO1xuXG4gICAgICAgICAgICByZWdpb24uaGVpZ2h0ID0gcmVnaW9uLmJvdHRvbSAtIHJlZ2lvbi50b3A7XG4gICAgICAgICAgICByZWdpb24ud2lkdGggPSByZWdpb24ucmlnaHQgLSByZWdpb24ubGVmdDtcblxuICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBlbXB0eSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAbWV0aG9kIGlzU2VsZWN0aW9uRW1wdHlcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBlbXB0eSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNTZWxlY3Rpb25FbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgcmV0dXJuIChzZWxlY3Rpb24uZ2V0VHlwZSgpID09PSBDS0VESVRPUi5TRUxFQ1RJT05fTk9ORSkgfHxcbiAgICAgICAgICAgICAgICAoKHJhbmdlcyA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKSkgJiYgcmFuZ2VzLmxlbmd0aCA9PT0gMSAmJiByYW5nZXNbMF0uY29sbGFwc2VkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBvYmplY3Qgd2l0aCBkYXRhIGFib3V0IHRoZSBbY2xpZW50IHJlY3RhbmdsZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50LmdldENsaWVudFJlY3RzKSBvZiB0aGUgc2VsZWN0aW9uLFxuICAgICAgICAgKiBub3JtYWxpemVkIGFjcm9zcyBicm93c2VzLiBBbGwgb2Zmc2V0cyBiZWxvdyBhcmUgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQG1ldGhvZCBnZXRDbGllbnRSZWN0c1JlZ2lvblxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBkYXRhOlxuICAgICAgICAgKiAtIGJvdHRvbSAtIGJvdHRvbSBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG4gICAgICAgICAqIC0gbGVmdCAtIGxlZnQgb2Zmc2V0IG9mIGFsbCBjbGllbnQgcmVjdGFuZ2xlc1xuICAgICAgICAgKiAtIHJpZ2h0IC0gcmlnaHQgb2Zmc2V0IG9mIGFsbCBjbGllbnQgcmVjdGFuZ2xlc1xuICAgICAgICAgKiAtIHRvcCAtIHRvcCBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG4gICAgICAgICAqIC0gc3RhcnRSZWN0IC0gQW4gT2JqZWN0LCB3aGljaCBjb250YWlucyB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uOlxuICAgICAgICAgKiAgICAgKyBib3R0b20gLSBib3R0b20gb2Zmc2V0XG4gICAgICAgICAqICAgICArIGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgICAgKiAgICAgKyBsZWZ0IC0gbGVmdCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuICAgICAgICAgKiAgICAgKyByaWdodCAtIHJpZ2h0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqICAgICArIHRvcCAtIHRvcCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuICAgICAgICAgKiAgICAgKyB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAqIC0gZW5kUmVjdCAtIEFuIE9iamVjdCwgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbjpcbiAgICAgICAgICogICAgICsgYm90dG9tIC0gYm90dG9tIG9mZnNldFxuICAgICAgICAgKiAgICAgKyBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICogICAgICsgbGVmdCAtIGxlZnQgb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICogICAgICsgcmlnaHQgLSByaWdodCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuICAgICAgICAgKiAgICAgKyB0b3AgLSB0b3Agb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICogICAgICsgd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgc2VsZWN0aW9uLCB0aGUgb2JqZWN0cyB3aWxsIGJlIGZpbGxlZCB3aXRoIDAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDbGllbnRSZWN0c1JlZ2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBuYXRpdmVTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZ2V0TmF0aXZlKCk7XG5cbiAgICAgICAgICAgIHZhciBkZWZhdWx0UmVjdCA9IHtcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmVnaW9uID0ge1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICBlbmRSZWN0OiBkZWZhdWx0UmVjdCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBzdGFydFJlY3Q6IGRlZmF1bHRSZWN0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIW5hdGl2ZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBib3R0b20gPSAwO1xuICAgICAgICAgICAgdmFyIGNsaWVudFJlY3RzO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciByYW5nZUNvdW50O1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHRvcCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBpZiAobmF0aXZlU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50UmVjdHMgPSBuYXRpdmVTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZUNvdW50ID0gbmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQ7XG4gICAgICAgICAgICAgICAgY2xpZW50UmVjdHMgPSAobmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSA/IG5hdGl2ZVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCkgOiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IHRoaXMuZ2V0Q2FyZXRSZWdpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGNsaWVudFJlY3RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2xpZW50UmVjdHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubGVmdCA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpdGVtLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yaWdodCA+IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IGl0ZW0ucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b3AgPCB0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGl0ZW0udG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uYm90dG9tID4gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBpdGVtLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxQb3MgPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyh3aW5kb3cpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICByZWdpb24uYm90dG9tID0gc2Nyb2xsUG9zLnkgKyBib3R0b207XG4gICAgICAgICAgICAgICAgcmVnaW9uLmxlZnQgPSBzY3JvbGxQb3MueCArIGxlZnQ7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnJpZ2h0ID0gc2Nyb2xsUG9zLnggKyByaWdodDtcbiAgICAgICAgICAgICAgICByZWdpb24udG9wID0gc2Nyb2xsUG9zLnkgKyB0b3A7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFJlY3QgPSBjbGllbnRSZWN0c1swXTtcblxuICAgICAgICAgICAgICAgICAgICByZWdpb24uZW5kUmVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc2Nyb2xsUG9zLnkgKyBlbmRSZWN0LmJvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZW5kUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzY3JvbGxQb3MueCArIGVuZFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzY3JvbGxQb3MueCArIGVuZFJlY3QucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHNjcm9sbFBvcy55ICsgZW5kUmVjdC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZW5kUmVjdC53aWR0aFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5zdGFydFJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHNjcm9sbFBvcy55ICsgc3RhcnRSZWN0LmJvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogc3RhcnRSZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNjcm9sbFBvcy54ICsgc3RhcnRSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2Nyb2xsUG9zLnggKyBzdGFydFJlY3QucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHNjcm9sbFBvcy55ICsgc3RhcnRSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzdGFydFJlY3Qud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWdpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIFRoZSBkaXJlY3Rpb24gaXMgZnJvbSB0b3AgdG8gYm90dG9tIG9yIGZyb20gYm90dG9tIHRvIHRvcC5cbiAgICAgICAgICogRm9yIElFIDwgOSBpdCBpcyBub3QgcG9zc2libGUsIHNvIHRoZSBkaXJlY3Rpb24gZm9yIHRoZXNlIGJyb3dzZXJzIHdpbGwgYmUgYWx3YXlzIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAbWV0aG9kIGdldFNlbGVjdGlvbkRpcmVjdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgYSBudW1iZXIgd2hpY2ggcmVwcmVzZW50cyBzZWxlY3Rpb24gZGlyZWN0aW9uLiBJdCBtaWdodCBiZSBvbmUgb2YgdGhlc2U6XG4gICAgICAgICAqIC0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT007XG4gICAgICAgICAqIC0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxlY3Rpb25EaXJlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgbmF0aXZlU2VsZWN0aW9uID0gc2VsZWN0aW9uLmdldE5hdGl2ZSgpO1xuXG4gICAgICAgICAgICBpZiAoIW5hdGl2ZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmNob3JOb2RlO1xuXG4gICAgICAgICAgICBpZiAoKGFuY2hvck5vZGUgPSBuYXRpdmVTZWxlY3Rpb24uYW5jaG9yTm9kZSkgJiYgYW5jaG9yTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGFuY2hvck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmF0aXZlU2VsZWN0aW9uLmZvY3VzTm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uICYmIG5hdGl2ZVNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPiBuYXRpdmVTZWxlY3Rpb24uZm9jdXNPZmZzZXQgfHwgcG9zaXRpb24gPT09IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX3NlbGVjdGlvbnJlZ2lvbicsIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyLFxuICAgICAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eTtcblxuICAgICAgICAgICAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgICAgICAgICAgICAgIGZvciAoYXR0ciBpbiBTZWxlY3Rpb25SZWdpb24ucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKFNlbGVjdGlvblJlZ2lvbi5wcm90b3R5cGUsIGF0dHIpICYmIHR5cGVvZiBlZGl0b3JbYXR0cl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JbYXR0cl0gPSBTZWxlY3Rpb25SZWdpb24ucHJvdG90eXBlW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn0oKSk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBJRV9OT05fRElSRUNUTFlfRURJVEFCTEVfRUxFTUVOVCA9IHtcbiAgICAgICAgJ3RhYmxlJzogMSxcbiAgICAgICAgJ2NvbCc6IDEsXG4gICAgICAgICdjb2xncm91cCc6IDEsXG4gICAgICAgICd0Ym9keSc6IDEsXG4gICAgICAgICd0ZCc6IDEsXG4gICAgICAgICd0Zm9vdCc6IDEsXG4gICAgICAgICd0aCc6IDEsXG4gICAgICAgICd0aGVhZCc6IDEsXG4gICAgICAgICd0cic6IDFcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFibGUgY2xhc3MgdXRpbGl0eS4gUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRlLCBkZWxldGUgYW5kIHVwZGF0ZSB0YWJsZXMuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IuVGFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFRhYmxlKGVkaXRvcikge1xuICAgICAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG4gICAgfVxuXG4gICAgVGFibGUuSEVBRElOR19CT1RIID0gJ0JvdGgnO1xuICAgIFRhYmxlLkhFQURJTkdfQ09MID0gJ0NvbHVtbic7XG4gICAgVGFibGUuSEVBRElOR19OT05FID0gJ05vbmUnO1xuICAgIFRhYmxlLkhFQURJTkdfUk9XID0gJ1Jvdyc7XG5cbiAgICBUYWJsZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBUYWJsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGFibGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY3JlYXRlZCB0YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgICAgICB2YXIgdGFibGUgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHzCoHt9O1xuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcm93cyBhbmQgY29scy5cbiAgICAgICAgICAgIHZhciB0Ym9keSA9IHRhYmxlLmFwcGVuZCh0aGlzLl9jcmVhdGVFbGVtZW50KCd0Ym9keScpKTtcbiAgICAgICAgICAgIHZhciByb3dzID0gY29uZmlnLnJvd3MgfHwgMTtcbiAgICAgICAgICAgIHZhciBjb2xzID0gY29uZmlnLmNvbHMgfHwgMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gdGJvZHkuYXBwZW5kKHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3RyJykpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gcm93LmFwcGVuZCh0aGlzLl9jcmVhdGVFbGVtZW50KCd0ZCcpKTtcblxuICAgICAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZEJvZ3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXModGFibGUsIGNvbmZpZy5hdHRycyk7XG4gICAgICAgICAgICB0aGlzLnNldEhlYWRpbmcodGFibGUsIGNvbmZpZy5oZWFkaW5nKTtcblxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSB0YWJsZSBlbGVtZW50IGlmIHdlJ3JlIGNyZWF0aW5nIG9uZS5cbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KHRhYmxlKTtcblxuICAgICAgICAgICAgdmFyIGZpcnN0Q2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3NbMF0uY2VsbHNbMF0pO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlVG9Qb3NpdGlvbihmaXJzdENlbGwsIENLRURJVE9SLlBPU0lUSU9OX0FGVEVSX1NUQVJUKTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIHRhYmxlIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG4gICAgICAgICAqIEBtZXRob2QgZ2V0RnJvbVNlbGVjdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gVGhlIHJldHJpZXZlZCB0YWJsZSBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEZyb21TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRhYmxlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmIHNlbGVjdGVkLmlzKCd0YWJsZScpKSB7XG4gICAgICAgICAgICAgICAgdGFibGUgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZWJraXQgY291bGQgcmVwb3J0IHRoZSBmb2xsb3dpbmcgcmFuZ2Ugb24gY2VsbCBzZWxlY3Rpb24gKCM0OTQ4KTpcbiAgICAgICAgICAgICAgICAgICAgLy8gPHRhYmxlPjx0cj48dGQ+WyZuYnNwOzwvdGQ+PC90cj48L3RhYmxlPl1cblxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ0tFRElUT1IuZW52LndlYmtpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzWzBdLnNocmluayhDS0VESVRPUi5OT0RFX0VMRU1FTlQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFibGUgPSB0aGlzLl9lZGl0b3IuZWxlbWVudFBhdGgocmFuZ2VzWzBdLmdldENvbW1vbkFuY2VzdG9yKHRydWUpKS5jb250YWlucygndGFibGUnLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YWJsZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdGFibGUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgZWRpdGFibGUuIFRoaXMgbWV0aG9kXG4gICAgICAgICAqIHdvcmthcm91bmRzIGEgbGltaXRhdGlvbiBvZiBJRSB3aGVyZSBmb3Igc29tZSBlbGVtZW50cyAobGlrZSB0YWJsZSksXG4gICAgICAgICAqIGBpc0NvbnRlbnRFZGl0YWJsZWAgcmV0dXJucyBhbHdheXMgZmFsc2UuIFRoaXMgaXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBzdXBwb3J0XG4gICAgICAgICAqIGBjb250ZW50ZWRpdGFibGVgIG9uIHN1Y2ggZWxlbWVudHMuIEhvd2V2ZXIsIGRlc3BpdGUgc3VjaCBlbGVtZW50c1xuICAgICAgICAgKiBjYW5ub3QgYmUgc2V0IGFzIGNvbnRlbnQgZWRpdGFibGUgZGlyZWN0bHksIGEgY29udGVudCBlZGl0YWJsZSBTUEFOLFxuICAgICAgICAgKiBvciBESVYgZWxlbWVudCBjYW4gYmUgcGxhY2VkIGluc2lkZSB0aGUgaW5kaXZpZHVhbCB0YWJsZSBjZWxscy5cbiAgICAgICAgICogU2VlIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc4MzclMjh2PVZTLjg1JTI5LmFzcHhcbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuICAgICAgICAgKiBAbWV0aG9kIGlzRWRpdGFibGVcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIHRhYmxlIGVsZW1lbnQgdG8gdGVzdCBpZiBlZGl0YWJsZVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNFZGl0YWJsZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoIUNLRURJVE9SLmVudi5pZSB8fCAhZWwuaXMoSUVfTk9OX0RJUkVDVExZX0VESVRBQkxFX0VMRU1FTlQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFlbC5pc1JlYWRPbmx5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpICE9PSAnZmFsc2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFZGl0YWJsZShlbC5nZXRQYXJlbnQoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgd2hpY2ggaGVhZGluZyBzdHlsZSBpcyBzZXQgZm9yIHRoZSBnaXZlbiB0YWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuICAgICAgICAgKiBAbWV0aG9kIGdldEhlYWRpbmdcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIHRvIGdhdGhlciB0aGUgaGVhZGluZyBmcm9tLiBJZiBudWxsLCBpdCB3aWxsIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgaGVhZGluZyBvZiB0aGUgdGFibGUuIEV4cGVjdGVkIHZhbHVlcyBhcmUgYENLRURJVE9SLlRhYmxlLk5PTkVgLCBgQ0tFRElUT1IuVGFibGUuUk9XYCwgYENLRURJVE9SLlRhYmxlLkNPTGAgYW5kIGBDS0VESVRPUi5UYWJsZS5CT1RIYC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEhlYWRpbmc6IGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgICAgICAgICB0YWJsZSA9IHRhYmxlIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb3dIZWFkaW5nU2V0dGluZ3MgPSB0YWJsZS4kLnRIZWFkICE9PSBudWxsO1xuXG4gICAgICAgICAgICB2YXIgY29sSGVhZGluZ1NldHRpbmdzID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIG9mIHRoZSBmaXJzdCBjZWxscyBpbiBldmVyeSByb3cgYXJlIFRIXG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0YWJsZS4kLnJvd3MubGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIC8vIElmIGp1c3Qgb25lIGNlbGwgaXNuJ3QgYSBUSCB0aGVuIGl0IGlzbid0IGEgaGVhZGVyIGNvbHVtblxuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGFibGUuJC5yb3dzW3Jvd10uY2VsbHNbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2VsbCAmJiBjZWxsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sSGVhZGluZ1NldHRpbmdzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhlYWRpbmdTZXR0aW5ncyA9IFRhYmxlLkhFQURJTkdfTk9ORTtcblxuICAgICAgICAgICAgaWYgKHJvd0hlYWRpbmdTZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIGhlYWRpbmdTZXR0aW5ncyA9IFRhYmxlLkhFQURJTkdfUk9XO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sSGVhZGluZ1NldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGluZ1NldHRpbmdzID0gKGhlYWRpbmdTZXR0aW5ncyA9PT0gVGFibGUuSEVBRElOR19ST1cgPyBUYWJsZS5IRUFESU5HX0JPVEggOiBUYWJsZS5IRUFESU5HX0NPTCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoZWFkaW5nU2V0dGluZ3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSB0YWJsZSBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIGVsZW1lbnQgd2hpY2ggdGFibGUgc3R5bGUgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuXG4gICAgICAgICAgICBpZiAodGFibGUpIHtcbiAgICAgICAgICAgICAgICB0YWJsZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFibGUgPSBlZGl0b3IuZWxlbWVudFBhdGgoKS5jb250YWlucygndGFibGUnLCAxKTtcblxuICAgICAgICAgICAgICAgIGlmICh0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFibGUncyBwYXJlbnQgaGFzIG9ubHkgb25lIGNoaWxkIHJlbW92ZSBpdCBhcyB3ZWxsICh1bmxlc3MgaXQncyBhIHRhYmxlIGNlbGwsIG9yIHRoZSBlZGl0YWJsZSBlbGVtZW50KSAoIzU0MTYsICM2Mjg5LCAjMTIxMTApXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0YWJsZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5nZXRDaGlsZENvdW50KCkgPT09IDEgJiYgIXBhcmVudC5pcygndGQnLCAndGgnKSAmJiAhcGFyZW50LmVxdWFscyhlZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVUb1Bvc2l0aW9uKHRhYmxlLCBDS0VESVRPUi5QT1NJVElPTl9CRUZPUkVfU1RBUlQpO1xuICAgICAgICAgICAgICAgICAgICB0YWJsZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NpZ25zIHByb3ZpZGVkIGF0dHJpYnV0ZXMgdG8gYSB0YWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuICAgICAgICAgKiBAbWV0aG9kIHNldEF0dHJpYnV0ZXNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhYmxlIFRoZSB0YWJsZSB0byB3aGljaCB0aGUgYXR0cmlidXRlcyBzaG91bGQgYmUgYXNzaWduZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBhdHRyaWJ1dGVzIHdoaWNoIGhhdmUgdG8gYmUgYXNzaWduZWQgdG8gdGhlIHRhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRBdHRyaWJ1dGVzOiBmdW5jdGlvbih0YWJsZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYXBwcm9wcmlhdGUgdGFibGUgaGVhZGluZyBzdHlsZSB0byBhIHRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG4gICAgICAgICAqIEBtZXRob2Qgc2V0SGVhZGluZ1xuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSB0YWJsZSBUaGUgdGFibGUgZWxlbWVudCB0byB3aGljaCB0aGUgaGVhZGluZyBzaG91bGQgYmUgc2V0LiBJZiBudWxsLCBpdCB3aWxsIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGhlYWRpbmcgVGhlIHRhYmxlIGhlYWRpbmcgdG8gYmUgc2V0LiBBY2NlcHRlZCB2YWx1ZXMgYXJlOiBgQ0tFRElUT1IuVGFibGUuTk9ORWAsIGBDS0VESVRPUi5UYWJsZS5ST1dgLCBgQ0tFRElUT1IuVGFibGUuQ09MYCBhbmQgYENLRURJVE9SLlRhYmxlLkJPVEhgLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0SGVhZGluZzogZnVuY3Rpb24odGFibGUsIGhlYWRpbmcpIHtcbiAgICAgICAgICAgIHRhYmxlID0gdGFibGUgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciBpLCBuZXdDZWxsO1xuICAgICAgICAgICAgdmFyIHRhYmxlSGVhZDtcbiAgICAgICAgICAgIHZhciB0YWJsZUJvZHkgPSB0YWJsZS5nZXRFbGVtZW50c0J5VGFnKCd0Ym9keScpLmdldEl0ZW0oMCk7XG5cbiAgICAgICAgICAgIHZhciB0YWJsZUhlYWRpbmcgPSB0aGlzLmdldEhlYWRpbmcodGFibGUpO1xuICAgICAgICAgICAgdmFyIGhhZENvbEhlYWRpbmcgPSAodGFibGVIZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0NPTCB8fCB0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USCk7XG5cbiAgICAgICAgICAgIHZhciBuZWVkQ29sSGVhZGluZyA9IGhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQ09MIHx8IGhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USDtcbiAgICAgICAgICAgIHZhciBuZWVkUm93SGVhZGluZyA9IGhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfUk9XIHx8IGhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USDtcblxuICAgICAgICAgICAgLy8gSWYgd2UgbmVlZCByb3cgaGVhZGluZyBhbmQgZG9uJ3QgaGF2ZSBhIDx0aGVhZD4gZWxlbWVudCB5ZXQsIG1vdmUgdGhlXG4gICAgICAgICAgICAvLyBmaXJzdCByb3cgb2YgdGhlIHRhYmxlIHRvIHRoZSBoZWFkIGFuZCBjb252ZXJ0IHRoZSBub2RlcyB0byA8dGg+IG9uZXMuXG4gICAgICAgICAgICBpZiAoIXRhYmxlLiQudEhlYWQgJiYgbmVlZFJvd0hlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVGaXJzdFJvdyA9IHRhYmxlQm9keS5nZXRFbGVtZW50c0J5VGFnKCd0cicpLmdldEl0ZW0oMCk7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlRmlyc3RSb3dDaGlsZENvdW50ID0gdGFibGVGaXJzdFJvdy5nZXRDaGlsZENvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgVEQgdG8gVEg6XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRhYmxlRmlyc3RSb3dDaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0YWJsZUZpcnN0Um93LmdldENoaWxkKGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgYm9va21hcmsgbm9kZXMuICgjNjE1NSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwudHlwZSA9PT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UICYmICFjZWxsLmRhdGEoJ2NrZS1ib29rbWFyaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnJlbmFtZU5vZGUoJ3RoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnNldEF0dHJpYnV0ZSgnc2NvcGUnLCAnY29sJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YWJsZUhlYWQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KHRhYmxlLiQuY3JlYXRlVEhlYWQoKSk7XG4gICAgICAgICAgICAgICAgdGFibGVIZWFkLmFwcGVuZCh0YWJsZUZpcnN0Um93LnJlbW92ZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgbmVlZCByb3cgaGVhZGluZyBhbmQgd2UgaGF2ZSBhIDx0aGVhZD4gZWxlbWVudCwgbW92ZSB0aGVcbiAgICAgICAgICAgIC8vIHJvdyBvdXQgb2YgdGhlcmUgYW5kIGludG8gdGhlIDx0Ym9keT4gZWxlbWVudC5cbiAgICAgICAgICAgIGlmICh0YWJsZS4kLnRIZWFkICE9PSBudWxsICYmICFuZWVkUm93SGVhZGluZykge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHJvdyBvdXQgb2YgdGhlIFRIZWFkIGFuZCBwdXQgaXQgaW4gdGhlIFRCb2R5OlxuICAgICAgICAgICAgICAgIHRhYmxlSGVhZCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQodGFibGUuJC50SGVhZCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNGaXJzdFJvdyA9IHRhYmxlQm9keS5nZXRGaXJzdCgpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhYmxlSGVhZC5nZXRDaGlsZENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdGaXJzdFJvdyA9IHRhYmxlSGVhZC5nZXRGaXJzdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Rmlyc3RSb3dDaGlsZENvdW50ID0gbmV3Rmlyc3RSb3cuZ2V0Q2hpbGRDb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdGaXJzdFJvd0NoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbCA9IG5ld0ZpcnN0Um93LmdldENoaWxkKGkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q2VsbC50eXBlID09PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLnJlbmFtZU5vZGUoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoJ3Njb3BlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBuZXdGaXJzdFJvdy5pbnNlcnRCZWZvcmUocHJldmlvdXNGaXJzdFJvdyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFibGVIZWFkLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YWJsZUhlYWRpbmcgPSB0aGlzLmdldEhlYWRpbmcodGFibGUpO1xuICAgICAgICAgICAgdmFyIGhhc0NvbEhlYWRpbmcgPSAodGFibGVIZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0NPTCB8fCB0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USCk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIG5lZWQgY29sdW1uIGhlYWRpbmcgYW5kIHRoZSB0YWJsZSBkb2Vzbid0IGhhdmUgaXQsIGNvbnZlcnQgZXZlcnkgZmlyc3QgY2VsbCBpblxuICAgICAgICAgICAgLy8gZXZlcnkgcm93IGludG8gYSBgPHRoIHNjb3BlPVwicm93XCI+YCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKCFoYXNDb2xIZWFkaW5nICYmIG5lZWRDb2xIZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRhYmxlLiQucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFibGUuJC5yb3dzW2ldLmNlbGxzWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC5yb3dzW2ldLmNlbGxzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwucmVuYW1lTm9kZSgndGgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwuc2V0QXR0cmlidXRlKCdzY29wZScsICdyb3cnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgbmVlZCBjb2x1bW4gaGVhZGluZyBidXQgdGhlIHRhYmxlIGhhcyBpdCwgY29udmVydCBldmVyeSBmaXJzdCBjZWxsIGluIGV2ZXJ5XG4gICAgICAgICAgICAvLyByb3cgYmFjayBpbnRvIGEgYDx0ZD5gIGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAoaGFkQ29sSGVhZGluZyAmJiAhbmVlZENvbEhlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFibGUuJC5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC5yb3dzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocm93LmdldFBhcmVudCgpLmdldE5hbWUoKSA9PT0gJ3Rib2R5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChyb3cuJC5jZWxsc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLnJlbmFtZU5vZGUoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLnJlbW92ZUF0dHJpYnV0ZSgnc2NvcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCB1c2luZyB0aGUgcGFzc2VkIHRhZyBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1ldGhvZCBfY3JlYXRlRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgdGFnIG5hbWUgZnJvbSB3aGljaCBhbiBlbGVtZW50IHNob3VsZCBiZSBjcmVhdGVkXG4gICAgICAgICAqIEByZXR1cm4ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBJbnN0YW5jZSBvZiBDS0VESVRPUiBET00gZWxlbWVudCBjbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgX2NyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobmFtZSwgdGhpcy5fZWRpdG9yLmRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDS0VESVRPUi5vbignaW5zdGFuY2VSZWFkeScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBoZWFkaW5nQ29tbWFuZHMgPSBbVGFibGUuSEVBRElOR19OT05FLCBUYWJsZS5IRUFESU5HX1JPVywgVGFibGUuSEVBRElOR19DT0wsIFRhYmxlLkhFQURJTkdfQk9USF07XG5cbiAgICAgICAgdmFyIHRhYmxlVXRpbHMgPSBuZXcgVGFibGUoZXZlbnQuZWRpdG9yKTtcblxuICAgICAgICBoZWFkaW5nQ29tbWFuZHMuZm9yRWFjaChmdW5jdGlvbihoZWFkaW5nKSB7XG4gICAgICAgICAgICBldmVudC5lZGl0b3IuYWRkQ29tbWFuZCgndGFibGVIZWFkaW5nJyArIGhlYWRpbmcsIHtcbiAgICAgICAgICAgICAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVVdGlscy5zZXRIZWFkaW5nKG51bGwsIGhlYWRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIENLRURJVE9SLlRhYmxlID0gQ0tFRElUT1IuVGFibGUgfHwgVGFibGU7XG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIENLRURJVE9SLnRvb2xzIGNsYXNzIHV0aWxpdHkgd2hpY2ggYWRkcyBhZGRpdGlvbmFsIG1ldGhvZHMgdG8gdGhvc2Ugb2YgQ0tFZGl0b3IuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IudG9vbHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVxdWVzdCB1c2luZyB0aGUgSlNPTlAgdGVjaG5pcXVlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENLRURJVE9SLnRvb2xzXG4gICAgICogQG1ldGhvZCBqc29ucFxuICAgICAqIEBwYXJhbSB7Q0tFRElUT1IudGVtcGxhdGV9IHVybFRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBvZiB0aGUgVVJMIHRvIGJlIHJlcXVlc3RlZC4gQWxsIHByb3BlcnRpZXMgcGFzc2VkIGluIGB1cmxQYXJhbXNgIGNhbiBiZSB1c2VkLCBwbHVzIGEgYHtjYWxsYmFja31gLCB3aGljaCByZXByZXNlbnQgYSBKU09OUCBjYWxsYmFjaywgbXVzdCBiZSBkZWZpbmVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGluIGNhc2Ugb2Ygc3VjY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXJsUGFyYW1zIFBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBgdXJsVGVtcGxhdGVgLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqICAtIGlkOiB0aGUgdHJhbnNhY3Rpb24gSURcbiAgICAgKiAgLSBhIGBjYW5jZWwoKWAgbWV0aG9kXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIENLRURJVE9SLnRvb2xzLmpzb25wID0gZnVuY3Rpb24odXJsVGVtcGxhdGUsIHVybFBhcmFtcywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrS2V5ID0gQ0tFRElUT1IudG9vbHMuZ2V0TmV4dE51bWJlcigpO1xuXG4gICAgICAgIHVybFBhcmFtcyA9IHVybFBhcmFtcyB8fCB7fTtcbiAgICAgICAgdXJsUGFyYW1zLmNhbGxiYWNrID0gJ0NLRURJVE9SLl8uanNvbnBDYWxsYmFja3NbJyArIGNhbGxiYWNrS2V5ICsgJ10nO1xuXG4gICAgICAgIGlmICghQ0tFRElUT1IuXy5qc29ucENhbGxiYWNrcykge1xuICAgICAgICAgICAgQ0tFRElUT1IuXy5qc29ucENhbGxiYWNrcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgQ0tFRElUT1IuXy5qc29ucENhbGxiYWNrc1tjYWxsYmFja0tleV0gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjbGVhblVwKCk7XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2NyaXB0RWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCB1cmxUZW1wbGF0ZS5vdXRwdXQodXJsUGFyYW1zKSk7XG4gICAgICAgIHNjcmlwdEVsZW1lbnQub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhblVwKCk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBjbGVhblVwKCkge1xuICAgICAgICAgICAgaWYgKHNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzW2NhbGxiYWNrS2V5XTtcbiAgICAgICAgICAgICAgICBzY3JpcHRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIENLRURJVE9SLmRvY3VtZW50LmdldEJvZHkoKS5hcHBlbmQoc2NyaXB0RWxlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbmNlbDogY2xlYW5VcCxcbiAgICAgICAgICAgIGlkOiBjYWxsYmFja0tleVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgcHJvcGVydGllcyBvZiBhbGwgdGhlIHN1cHBsaWVkXG4gICAgICogb2JqZWN0cy4gVGhlIHByb3BlcnRpZXMgZnJvbSBsYXRlciBvYmplY3RzIHdpbGwgb3ZlcndyaXRlIHRob3NlIGluIGVhcmxpZXJcbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogUGFzc2luZyBpbiBhIHNpbmdsZSBvYmplY3Qgd2lsbCBjcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgaXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAgICAgKiBAbWV0aG9kIG1lcmdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMqIE9uZSBvciBtb3JlIG9iamVjdHMgdG8gbWVyZ2UuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBtZXJnZWQgb2JqZWN0LlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBDS0VESVRPUi50b29scy5tZXJnZSA9IENLRURJVE9SLnRvb2xzLm1lcmdlIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlcyBldmVudCBvbiBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENLRURJVE9SLnRvb2xzXG4gICAgICogQG1ldGhvZCBzaW11bGF0ZVxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBvbiB3aGljaCB0aGUgZXZlbnQgc2hvdWQgYmUgc2ltdWFsdGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgd2hpY2ggaGF2ZSB0byBiZSBzaW11bGF0ZWQuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIENLRURJVE9SLnRvb2xzLnNpbXVsYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgICAgIGV2ZW50SW5zdGFuY2UuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudEluc3RhbmNlKTtcbiAgICB9O1xufSgpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV91aWNvcmUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVUlDb3JlIGNsYXNzIHdoaWNoIHdpbGwgaGFuZGxlIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggdGhlIGVkaXRvci4gVGhlc2UgaW50ZXJhY3Rpb25zXG4gICAgICogbWlnaHQgYmUgdHJpZ2dlcmVkIHZpYSBtb3VzZSwga2V5Ym9hcmQgb3IgdG91Y2ggZGV2aWNlcy4gVGhlIGNsYXNzIGZpbGwgZmlyZSBhbiBldmVudCB2aWFcbiAgICAgKiBDS0VkaXRvcidzIGV2ZW50IHN5c3RlbSAtIFwiZWRpdG9ySW50ZXJhY3Rpb25cIi4gVGhlIFVJIG1heSBsaXN0ZW4gdG8gdGhpcyBldmVudCBhbmRcbiAgICAgKiBleGVjdXRlIHNvbWUgYWN0aW9ucyAtIGZvciBleGFtcGxlIHRvIHNob3cvaGlkZSB0b29sYmFycy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQgaWYgdXNlciBwcmVzc2VzIHRoZSBFc2Mga2V5LCAnZWRpdG9ySW50ZXJhY3Rpb24nIGV2ZW50IHdvbid0IGJlIGZpcmVkLiBIb3dldmVyLCB0aGlzIGJlaGF2aW91ciBjYW4gYmUgY2hhbmdlZFxuICAgICAqIGJ5IHNldHRpbmcge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV91aWNvcmUvYWxsb3dFc2M6YXR0cmlidXRlXCJ9fXt7L2Nyb3NzTGlua319IGNvbmZpZyBwcm9wZXJ0eSBpbiBlZGl0b3IncyBjb25maWd1cmF0aW9uIHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgYWVfdWljb3JlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHVzZXIgaW50ZXJhY3RzIHNvbWVob3cgd2l0aCB0aGUgYnJvd3Nlci4gVGhpcyBtYXkgYmUgY2xpY2tpbmcgd2l0aCB0aGUgbW91c2UsIHByZXNzaW5nIGtleWJvYXJkIGJ1dHRvbixcbiAgICAgKiBvciB0b3VjaGluZyBzY3JlZW4uIFRoaXMgZXZlbiB3aWxsIGJlIG5vdCBmaXJlZCBhZnRlciBlYWNoIGludGVyYWN0aW9uLiBJdCB3aWxsIGJlIGRlYm91bmNlZC4gQnkgZGVmYXVsdCB0aGUgdGltZW91dFxuICAgICAqIGlzIDUwbXMuIFRoaXMgdmFsdWUgY2FuIGJlIG92ZXJ3cml0dGVuIHZpYSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3VpY29yZS90aW1lb3V0OmF0dHJpYnV0ZVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIHByb3BlcnR5IG9mIGVkaXRvcidzIGNvbmZpZ3VyYXRpb24sIGxpa2U6IGVkaXRvci5jb25maWcudWljb3JlLnRpbWVvdXQgPSAxMDBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBhZV91aWNvcmVcbiAgICAgKiBAZXZlbnQgYWVfdWljb3JlI2VkaXRvckludGVyYWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAtIG5hdGl2ZUV2ZW50IC0gVGhlIGV2ZW50IGFzIHJlY2VpdmVkIGZyb20gQ0tFZGl0b3IuXG4gICAgICogLSBzZWxlY3Rpb25EYXRhIC0gVGhlIGRhdGEsIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uRGF0YTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGJ5IFVJIGVsZW1lbnRzIGxpa2UgVG9vbGJhcnMgb3IgQnV0dG9ucyB3aGVuIHRoZWlyIHN0YXRlIGNoYW5nZXMuIFRoZSBsaXN0ZW5lciB1cGRhdGVzIHRoZSBsaXZlIHJlZ2lvbiB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGFlX3VpY29yZVxuICAgICAqIEBldmVudCBhZV91aWNvcmUjYXJpYVVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogLSBtZXNzYWdlIC0gVGhlIHByb3ZpZGVkIG1lc3NhZ2UgZnJvbSB0aGUgVUkgZWxlbWVudC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgZWRpdG9yIHdpbGwgc3RpbGwgZmlyZSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3VpY29yZS9lZGl0b3JJbnRlcmFjdGlvbjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCxcbiAgICAgKiBpZiB1c2VyIHByZXNzZXMgRXNjIGtleS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBhZV91aWNvcmVcbiAgICAgKiBAYXR0cmlidXRlIGFsbG93RXNjXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGRlZmF1bHQgdGltZW91dCBhZnRlciB3aGljaCB0aGUge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV91aWNvcmUvZWRpdG9ySW50ZXJhY3Rpb246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcbiAgICAgKiB3aWxsIGJlIGZpcmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGFlX3VpY29yZVxuICAgICAqIEBhdHRyaWJ1dGUgdGltZW91dFxuICAgICAqIEBkZWZhdWx0IDUwIChtcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cblxuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKFxuICAgICAgICAnYWVfdWljb3JlJywge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplciBsaWZlY3ljbGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBVSUNvcmUgcGx1Z2luLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBhZV91aWNvcmVcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBDS0VkaXRvciBpbnN0YW5jZS5cbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyaWFTdGF0ZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFyaWFFbGVtZW50ID0gdGhpcy5fY3JlYXRlQXJpYUVsZW1lbnQoZWRpdG9yLmlkKTtcblxuICAgICAgICAgICAgICAgIHZhciB1aVRhc2tzVGltZW91dCA9IGVkaXRvci5jb25maWcudWljb3JlID8gZWRpdG9yLmNvbmZpZy51aWNvcmUudGltZW91dCA6IDUwO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZVVJID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmlhU3RhdGUgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm5hbWUgIT09ICdrZXl1cCcgfHwgZXZlbnQuZGF0YS4kLmtleUNvZGUgIT09IDI3IHx8IGVkaXRvci5jb25maWcuYWxsb3dFc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZmlyZSgnZWRpdG9ySW50ZXJhY3Rpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnQuZGF0YS4kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRGF0YTogc2VsZWN0aW9uRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVpVGFza3NUaW1lb3V0XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVBcmlhID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmlhRWxlbWVudC5pbm5lckhUTUwgPSBhcmlhU3RhdGUuam9pbignLiAnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdWlUYXNrc1RpbWVvdXRcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU1vdXNlTGVhdmUgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZVVJTm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWUtdWknKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFlVUlOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZVVJTm9kZXNbaV0uY29udGFpbnMoZXZlbnQuZGF0YS4kLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVUkoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1aVRhc2tzVGltZW91dFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ2FyaWFVcGRhdGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGVBcmlhIGlzIGRlYm91bmNlZCBmdW5jdGlvbiwgc28gaWYgaXQgaXMgYmVpbmcgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCBpdCB3aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGNhbmNlbGVkIHVudGlsIHNvbWUgdGltZSBwYXNzZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGF0IHJlYXNvbiBoZXJlIHdlIGV4cGxpY2l0bHkgYXBwZW5kIHRoZSBjdXJyZW50IG1lc3NhZ2UgdG8gdGhlIGxpc3Qgb2YgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNhbGwgaGFuZGxlQXJpYS4gU2luY2UgaXQgaXMgZGVib3VuY2VkLCB3aGVuIHNvbWUgdGltZW91dCBwYXNzZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCB0aGUgbWVzc2FnZXMgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBsaXZlIHJlZ2lvbiBhbmQgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxuXG4gICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZS5wdXNoKGV2ZW50LmRhdGEubWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQXJpYSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvY3VzSGFuZGxlciA9IGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAnZm9jdXMnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzSGFuZGxlci5yZW1vdmVMaXN0ZW5lcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2tleXVwJywgaGFuZGxlVUkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdtb3VzZXVwJywgaGFuZGxlVUkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdtb3VzZWxlYXZlJywgaGFuZGxlTW91c2VMZWF2ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVVJKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBhcmlhRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFyaWFFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVVSS5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhbmQgYXBwbGllcyBhbiBIVE1MIGVsZW1lbnQgdG8gdGhlIGJvZHkgb2YgdGhlIGRvY3VtZW50IHdoaWNoIHdpbGwgY29udGFpbiBBUklBIG1lc3NhZ2VzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBhZV91aWNvcmVcbiAgICAgICAgICAgICAqIEBtZXRob2QgX2NyZWF0ZUFyaWFFbGVtZW50XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIHByb3ZpZGVkIGlkIG9mIHRoZSBlbGVtZW50LiBJdCB3aWxsIGJlIHVzZWQgYXMgcHJlZml4IGZvciB0aGUgZmluYWwgZWxlbWVudCBJZC5cbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgY3JlYXRlZCBhbmQgYXBwbGllZCB0byBET00gZWxlbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2NyZWF0ZUFyaWFFbGVtZW50OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgICAgICBzdGF0dXNFbGVtZW50LmNsYXNzTmFtZSA9ICdhZS1zci1vbmx5JztcblxuICAgICAgICAgICAgICAgIHN0YXR1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgICAgICAgICAgc3RhdHVzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnc3RhdHVzJyk7XG4gICAgICAgICAgICAgICAgc3RhdHVzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQgKyAnTGl2ZVJlZ2lvbicpO1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0dXNFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn0oKSk7IiwiaW1wb3J0IExhbmcgZnJvbSAnLi9sYW5nLmpzJztcblxuLyoqXG4gKiBBdHRyaWJ1dGUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGNsYXNzIEF0dHJpYnV0ZVxuICogQGNvbnN0cnVjdG9yXG4qL1xuZnVuY3Rpb24gQXR0cmlidXRlKGNvbmZpZykge1xuICAgIHRoaXMuX19jb25maWdfXyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLl9fQVRUUlNfXyA9IHt9O1xufVxuXG5BdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBBdHRyaWJ1dGUsXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtBbnl9IFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICB2YXIgY3VycmVudEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLkFUVFJTW2F0dHJdO1xuXG4gICAgICAgIGlmICghY3VycmVudEF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZChhdHRyKSkge1xuICAgICAgICAgICAgdGhpcy5faW5pdChhdHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJWYWx1ZSA9IHRoaXMuX19BVFRSU19fW2F0dHJdO1xuXG4gICAgICAgIGlmIChjdXJyZW50QXR0ci5nZXR0ZXIpIHtcbiAgICAgICAgICAgIGN1clZhbHVlID0gdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIuZ2V0dGVyLCBjdXJWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VyVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNldC5cbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIHNob3VsZCBiZSBzZXQgdG8gdGhlIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBjdXJyZW50QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuQVRUUlNbYXR0cl07XG5cbiAgICAgICAgaWYgKCFjdXJyZW50QXR0cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKGF0dHIpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0KGF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEF0dHIud3JpdGVPbmNlICYmIHRoaXMuX2lzSW5pdGlhbGl6ZWQoYXR0cikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50QXR0ci52YWxpZGF0b3IgJiYgIXRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnZhbGlkYXRvciwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEF0dHIuc2V0dGVyKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnNldHRlciwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX0FUVFJTX19bYXR0cl0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIHByb3ZpZGVkIHBhcmFtIGFzIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKiBJZiBwYXJhbSBwcm92aWRlZCBhcyBzdHJpbmcsIGEgY29ycmVzcG9uZGluZyBmdW5jdGlvbiBpbiB0aGlzIG9iamVjdCB3aWxsXG4gICAgICogYmUgY2FsbGVkLiBJZiBwcm92aWRlZCBwYXJhbSBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGRpcmVjdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcbiAgICAgKiBAbWV0aG9kIF9jYWxsU3RyaW5nT3JGdW5jdGlvblxuICAgICAqIEBwYXJhbSAge0FueXxBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHdoaWNoIHdpbGwgYmUgcHJvdmlkZWQgdG8gdGhlIGNhbGxlZCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xGdW5jdGlvbn0gc3RyaW5nT3JGdW5jdGlvbiBUaGUgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIGNhbGxlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBbnl9IFRoZSByZXR1cm5lZCB2YWx1ZSBmcm9tIHRoZSBjYWxsZWQgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfY2FsbFN0cmluZ09yRnVuY3Rpb246IGZ1bmN0aW9uKHN0cmluZ09yRnVuY3Rpb24sIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgaWYgKCFMYW5nLmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbYXJnc107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTGFuZy5pc1N0cmluZyhzdHJpbmdPckZ1bmN0aW9uKSAmJiBMYW5nLmlzRnVuY3Rpb24odGhpc1tzdHJpbmdPckZ1bmN0aW9uXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXNbc3RyaW5nT3JGdW5jdGlvbl0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoTGFuZy5pc0Z1bmN0aW9uKHN0cmluZ09yRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdHJpbmdPckZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXR0cmlidXRlLiBTZXRzIGl0cyBkZWZhdWx0IHZhbHVlIGRlcGVuZGluZyBvbiB0aGUgZmxhZ3Mgb2YgdGhlXG4gICAgICogYXR0cmlidXRlIGFuZCB0aGUgcGFzc2VkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcbiAgICAgKiBAbWV0aG9kIF9pbml0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB3aGljaCBoYXZlIHRvIGJlIGluaXRpYWxpemVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5BVFRSU1thdHRyXTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBkZWZhdWx0IHZhbHVlIG9yIHBhc3NlZCBvbmUgdmlhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgIHZhciBoYXNEZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VycmVudEF0dHIsICd2YWx1ZScpO1xuICAgICAgICB2YXIgaGFzUGFzc2VkVmFsdWVWaWFDb25maWcgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX2NvbmZpZ19fLCBhdHRyKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyB2YWx1ZUZuLCBzZXQgdGhlIHZhbHVlIHRvIGJlIHRoZSByZXN1bHQgb2YgaW52b2NhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIGlmIChjdXJyZW50QXR0ci52YWx1ZUZuKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnZhbHVlRm4sIHZhbHVlKTtcblxuICAgICAgICAgICAgdGhpcy5fX0FUVFJTX19bYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGlmIHRoZSBhdHRyaWJ1dGUgaGFzIHJlYWRPbmx5IGZsYWcsIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBhdHRyaWJ1dGUsXG4gICAgICAgIC8vIHJlZ2FyZGxlc3MgaWYgdGhlcmUgaXMgdmFsdWUgb3Igbm90XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRBdHRyLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgaWYgdGhlIGF0dHJpYnV0ZSBoYXMgd3JpdGVPbmNlIHZhbHVlLCBzZXQgaXQgZnJvbSB0aGUgcGFzc2VkIGNvbmZpZ3VyYXRpb24gb3IgZnJvbSB0aGVcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZSwgaW4gdGhpcyBvcmRlci4gT3RoZXJ3aXNlLCByZXR1cm4gbWlzZXJhYmxlLlxuICAgICAgICBlbHNlIGlmIChjdXJyZW50QXR0ci53cml0ZU9uY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX2NvbmZpZ19fW2F0dHJdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgdHdvIGNhc2VzIGJlbG93IGFyZSBlYXN5IC0gc2V0IHRoZSB2YWx1ZSB0byBiZSBmcm9tIHRoZSBwYXNzZWQgY29uZmlnIG9yXG4gICAgICAgIC8vIGZyb20gdGhlIGRlZmF1bHQgdmFsdWUsIGluIHRoaXMgb3JkZXIuXG4gICAgICAgIGVsc2UgaWYgKGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX19jb25maWdfX1thdHRyXTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY3VycmVudEF0dHIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyB2YWxpZGF0b3IsIGFuZCB1c2VyIHBhc3NlZCBjb25maWcgb2JqZWN0IC0gY2hlY2sgdGhlIHJldHVybmVkIHZhbHVlLlxuICAgICAgICAvLyBJZiBpdCBpcyBmYWxzZSwgdGhlbiBzZXQgYXMgaW5pdGlhbCB2YWx1ZSB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgdmFsdWUsIGp1c3QgcmV0dXJuLlxuICAgICAgICBpZiAoY3VycmVudEF0dHIudmFsaWRhdG9yICYmIGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnICYmICF0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci52YWxpZGF0b3IsIHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY3VycmVudEF0dHIudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIHNldHRlciBhbmQgdXNlciBwYXNzZWQgY29uZmlnIG9iamVjdCAtIHBhc3MgdGhlIHZhbHVlIHRob3VnaHQgdGhlIHNldHRlci5cbiAgICAgICAgLy8gVGhlIHZhbHVlIG1pZ2h0IGJlIG9uZSBmcm9tIGRlZmF1bHRGbiwgZGVmYXVsdCB2YWx1ZSBvciBwcm92aWRlZCBmcm9tIHRoZSBjb25maWcuXG4gICAgICAgIGlmIChjdXJyZW50QXR0ci5zZXR0ZXIgJiYgaGFzUGFzc2VkVmFsdWVWaWFDb25maWcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIuc2V0dGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbGx5LCBzZXQgdGhlIHZhbHVlIGFzIGluaXRpYWwgdmFsdWUgdG8gdGhlIHN0b3JhZ2Ugd2l0aCB2YWx1ZXMuXG4gICAgICAgIHRoaXMuX19BVFRSU19fW2F0dHJdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbiBhdHRyaWJ1dGUgaXMgaW5pdGlhbGl6ZWQuIEFuIGF0dHJpYnV0ZSBpcyBjb25zaWRlcmVkIGFzIGluaXRpYWxpemVkXG4gICAgICogd2hlbiB0aGVyZSBpcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGlzIG5hbWUgaW4gdGhlIGxvY2FsIGNvbGxlY3Rpb24gb2YgYXR0cmlidXRlIHZhbHVlc1xuICAgICAqIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcbiAgICAgKiBAbWV0aG9kIF9pc0luaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZSB3aGljaCBzaG91bGQgYmUgY2hlY2tlZCBpZiBpdCBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBhdHRyaWJ1dGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBfaXNJbml0aWFsaXplZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX19BVFRSU19fLCBhdHRyKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBdHRyaWJ1dGU7IiwiaW1wb3J0IEF0dHJpYnV0ZSBmcm9tICcuL2F0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgTGFuZyBmcm9tICcuL2xhbmcuanMnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuL29vcC5qcyc7XG5cbi8qKlxuICogUXVpY2sgYW5kIGRpcnR5IGltcGwgb2YgQmFzZSBjbGFzcy5cbiAqXG4gKiBAY2xhc3MgQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJhc2UoY29uZmlnKSB7XG4gICAgQmFzZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY29uZmlnKTtcblxuICAgIHRoaXMuaW5pdChjb25maWcpO1xufVxuXG5leHRlbmQoQmFzZSwgQXR0cmlidXRlLCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGBpbml0aWFsaXplcmAgbWV0aG9kIG9mIGVhY2ggY2xhc3Mgd2hpY2ggZXh0ZW5kcyBCYXNlIHN0YXJ0aW5nIGZyb20gdGhlIHBhcmVudCB0byB0aGUgY2hpbGQuXG4gICAgICogV2lsbCBwYXNzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB0byBlYWNoIGluaXRpYWxpemVyIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCYXNlXG4gICAgICogQG1ldGhvZCBpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9jYWxsQ2hhaW4oJ2luaXRpYWxpemVyJywgY29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGBkZXN0cnVjdG9yYCBtZXRob2Qgb2YgZWFjaCBjbGFzcyB3aGljaCBleHRlbmRzIEJhc2Ugc3RhcnRpbmcgZnJvbSB0aGUgcGFyZW50IHRvIHRoZSBjaGlsZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCYXNlXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NhbGxDaGFpbignZGVzdHJ1Y3RvcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBhIG1ldGhvZCBvZiBlYWNoIGNsYXNzLCB3aGljaCBpcyBiZWluZyBwcmVzZW50IGluIHRoZSBoaWVyYXJjaHkgc3RhcnRpbmcgZnJvbSBwYXJlbnQgdG8gdGhlIGNoaWxkLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJhc2VcbiAgICAgKiBAbWV0aG9kIF9jYWxsQ2hhaW5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggdGhlIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3YXQgIFRoZSBtZXRob2QsIHdoaWNoIHNob3VsZCBiZSBpbnZva2VkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jYWxsQ2hhaW46IGZ1bmN0aW9uKHdhdCwgYXJncykge1xuICAgICAgICB2YXIgYXJyID0gW107XG5cbiAgICAgICAgdmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIHdoaWxlIChjdG9yKSB7XG4gICAgICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKGN0b3IucHJvdG90eXBlW3dhdF0pKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goY3Rvci5wcm90b3R5cGVbd2F0XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0b3IgPSBjdG9yLnN1cGVyY2xhc3MgPyBjdG9yLnN1cGVyY2xhc3MuY29uc3RydWN0b3IgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyID0gYXJyLnJldmVyc2UoKTtcblxuICAgICAgICBhcmdzID0gTGFuZy5pc0FycmF5KGFyZ3MpID8gYXJncyA6IFthcmdzXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcnJbaV07XG5cbiAgICAgICAgICAgIGl0ZW0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZTsiLCIvKipcbiAqIFByb3ZpZGVzIGNvcmUgbGFuZ3VhZ2UgdXRpbGl0aWVzLlxuICpcbiAqIEBjbGFzcyBMYW5nXG4gKi9cbmNvbnN0IExhbmcgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCBpc0FycmF5XG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGlzQXJyYXk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGJvb2xlYW4uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgaXNCb29sZWFuXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGJvb2xlYW4sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCBpc0Z1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdmdW5jdGlvbic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgTlVMTC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCBpc051bGxcbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgTlVMTCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpc051bGw6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgaXNOdW1iZXJcbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGlzTnVtYmVyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgaXNPYmplY3RcbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGlzT2JqZWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcgfHwgTGFuZy5pc0Z1bmN0aW9uKHZhbHVlKSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIGlzU3RyaW5nXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGlzU3RyaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzdXBwbGllciB0byB0aGUgcmVjZWl2ZXIuXG4gICAgICogVGhlIGZ1bmN0aW9uIHdpbGwgYWRkIGFsbCBwcm9wZXJ0aWVzLCBub3Qgb25seSB0aGVzZSBvd25lZCBieSB0aGUgc3VwcGxpZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgbWl4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY2VpdmVyIFRoZSBvYmplY3Qgd2hpY2ggd2lsbCByZWNlaXZlIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN1cHBsaWVyIFRoZSBvYmplY3Qgd2hpY2ggcHJvdmlkZXMgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtb2RpZmllZCByZWNlaXZlci5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbWl4OiBmdW5jdGlvbihyZWNlaXZlciwgc3VwcGxpZXIpIHtcbiAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3VwcGxpZXIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHN1cHBsaWVyLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJba2V5XSA9IHN1cHBsaWVyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdmFsdWUgdG8gSW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCB0b0ludFxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjb252ZXJ0ZWQgdG8gSW50ZWdlci5cbiAgICAgKiBAcmV0dXJuIHtJbnRlZ2VyfSBUaGUgY29udmVydGVkIHZhbHVlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0b0ludDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTGFuZzsiLCJpbXBvcnQgTGFuZyBmcm9tICcuL2xhbmcnO1xuXG4vKipcbiAqIFNldHMgdGhlIHByb3RvdHlwZSwgY29uc3RydWN0b3IgYW5kIHN1cGVyY2xhc3MgcHJvcGVydGllcyB0byBzdXBwb3J0IGFuIGluaGVyaXRhbmNlIHN0cmF0ZWd5XG4gKiB0aGF0IGNhbiBjaGFpbiBjb25zdHJ1Y3RvcnMgYW5kIG1ldGhvZHMuIFN0YXRpYyBtZW1iZXJzIHdpbGwgbm90IGJlIGluaGVyaXRlZC5cbiAqXG4gKiBAbWVtYmVyb2YgT09QXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVjZWl2ZXIgVGhlIGNsYXNzIHdoaWNoIHdpbGwgZXh0ZW5kIGFub3RoZXIgY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBwbGllciBUaGUgY2xhc3Mgd2hpY2ggd2lsbCBwcm92aWRlIHRoZSBwcm9wZXJ0aWVzIHRoZSBjaGlsZCBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1Byb3BzIFByb3RvdHlwZSBwcm9wZXJ0aWVzIHRvIGFkZC9vdmVycmlkZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0aWNQcm9wcyBTdGF0aWMgcHJvcGVydGllcyB0byBhZGQvb3ZlcndyaXRlLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBleHRlbmRlZCBjbGFzcy5cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgZXh0ZW5kID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN1cHBsaWVyLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmICghc3VwcGxpZXIgfHwgIXJlY2VpdmVyKSB7XG4gICAgICAgIHRocm93ICdleHRlbmQgZmFpbGVkLCB2ZXJpZnkgZGVwZW5kZW5jaWVzJztcbiAgICB9XG5cbiAgICB2YXIgc3VwcGxpZXJQcm90byA9IHN1cHBsaWVyLnByb3RvdHlwZSwgcmVjZWl2ZXJQcm90byA9IE9iamVjdC5jcmVhdGUoc3VwcGxpZXJQcm90byk7XG4gICAgcmVjZWl2ZXIucHJvdG90eXBlID0gcmVjZWl2ZXJQcm90bztcblxuICAgIHJlY2VpdmVyUHJvdG8uY29uc3RydWN0b3IgPSByZWNlaXZlcjtcbiAgICByZWNlaXZlci5zdXBlcmNsYXNzID0gc3VwcGxpZXJQcm90bztcblxuICAgIC8vIGFzc2lnbiBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxuICAgIGlmIChzdXBwbGllciAhPT0gT2JqZWN0ICYmIHN1cHBsaWVyUHJvdG8uY29uc3RydWN0b3IgPT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgc3VwcGxpZXJQcm90by5jb25zdHJ1Y3RvciA9IHN1cHBsaWVyO1xuICAgIH1cblxuICAgIC8vIGFkZCBwcm90b3R5cGUgb3ZlcnJpZGVzXG4gICAgaWYgKHByb3RvUHJvcHMpIHtcbiAgICAgICAgTGFuZy5taXgocmVjZWl2ZXJQcm90bywgcHJvdG9Qcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIG9iamVjdCBvdmVycmlkZXNcbiAgICBpZiAoc3RhdGljUHJvcHMpIHtcbiAgICAgICAgTGFuZy5taXgocmVjZWl2ZXIsIHN0YXRpY1Byb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWl2ZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHRlbmQ7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBpc0lFID0gQ0tFRElUT1IuZW52LmllO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9hZGRpbWFnZXMnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFsbG93cyBEcmFnJkRyb3Agb2YgaW1hZ2VzIGRpcmVjdGx5IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuIFRoZSBpbWFnZSB3aWxsIGJlIGVuY29kZWRcbiAgICAgKiBhcyBEYXRhIFVSSS4gQW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGxpc3Qgb2YgZHJvcHBlZCBpbWFnZXMuIElmIGFueSBvZiB0aGUgbGlzdGVuZXJzXG4gICAgICogcmV0dXJucyBgZmFsc2VgIG9yIGNhbmNlbHMgdGhlIGV2ZW50LCB0aGUgaW1hZ2VzIHdvbid0IGJlIGFkZGVkIHRvIHRoZSBjb250ZW50LiBPdGhlcndpc2UsXG4gICAgICogYW4gZXZlbnQgYGltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGluc2VydGVkIGVsZW1lbnQgaW50byB0aGUgZWRpdGFibGUgYXJlYS5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYmVmb3JlIGFkZGluZyBpbWFnZXMgdG8gdGhlIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNiZWZvcmVJbWFnZUFkZFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGltYWdlRmlsZXMgQXJyYXkgb2YgaW1hZ2UgZmlsZXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYW4gaW1hZ2UgaXMgYmVpbmcgYWRkZWQgdG8gdGhlIGVkaXRvciBzdWNjZXNzZnVsbHkuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMjaW1hZ2VBZGRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBUaGUgY3JlYXRlZCBpbWFnZSB3aXRoIHNyYyBhcyBEYXRhIFVSSVxuICAgICAqIEBwYXJhbSB7RmlsZX0gZmlsZSBUaGUgaW1hZ2UgZmlsZVxuICAgICAqL1xuXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoXG4gICAgICAgICdhZV9hZGRpbWFnZXMnLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgYSAnZHJhZ2VudGVyJywgJ2RyYWdvdmVyJywgJ2Ryb3AnIGFuZCBgcGFzdGVgIGV2ZW50cyBvbiB0aGUgZWRpdGluZyBhcmVhLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAnZHJhZ2VudGVyJywgdGhpcy5fb25EcmFnRW50ZXIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAnZHJhZ292ZXInLCB0aGlzLl9vbkRyYWdPdmVyLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2Ryb3AnLCB0aGlzLl9vbkRyYWdEcm9wLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ3Bhc3RlJywgdGhpcy5fb25QYXN0ZSwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWNjZXB0cyBhbiBhcnJheSBvZiBkcm9wcGVkIGZpbGVzIHRvIHRoZSBlZGl0b3IuIFRoZW4sIGl0IGZpbHRlcnMgdGhlIGltYWdlcyBhbmQgc2VuZHMgdGhlbSBmb3IgZnVydGhlclxuICAgICAgICAgICAgICogcHJvY2Vzc2luZyB0byB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcy9fcHJvY2Vzc0ZpbGU6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGZpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzI2JlZm9yZUltYWdlQWRkXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBfaGFuZGxlRmlsZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbGVzIEFycmF5IG9mIGRyb3BwZWQgZmlsZXMuIE9ubHkgdGhlIGltYWdlcyBmcm9tIHRoaXMgbGlzdCB3aWxsIGJlIHByb2Nlc3NlZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9oYW5kbGVGaWxlczogZnVuY3Rpb24oZmlsZXMsIGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlO1xuICAgICAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlRmlsZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWxlID0gZmlsZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUudHlwZS5pbmRleE9mKCdpbWFnZScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZWRpdG9yLmZpcmUoJ2JlZm9yZUltYWdlQWRkJywge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUZpbGVzOiBpbWFnZUZpbGVzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYWdlRmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBpbWFnZUZpbGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzRmlsZShmaWxlLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGRyYWcgZHJvcCBldmVudC4gVGhlIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgc2VsZWN0aW9uIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAqIHBvaW50IGFuZCB3aWxsIHNlbmQgYSBsaXN0IG9mIGZpbGVzIHRvIGJlIHByb2Nlc3NlZCB0b1xuICAgICAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMvX2hhbmRsZUZpbGVzOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgX29uRHJhZ0Ryb3BcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBldmVudCBkcmFnZHJvcCBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfb25EcmFnRHJvcDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cbiAgICAgICAgICAgICAgICBuZXcgQ0tFRElUT1IuZG9tLmV2ZW50KG5hdGl2ZUV2ZW50KS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yLmNyZWF0ZVNlbGVjdGlvbkZyb21Qb2ludChuYXRpdmVFdmVudC5jbGllbnRYLCBuYXRpdmVFdmVudC5jbGllbnRZKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZpbGVzKG5hdGl2ZUV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcywgZWRpdG9yKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGFuZGxlcyBkcmFnIGVudGVyIGV2ZW50LiBJbiBjYXNlIG9mIElFLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJldmVudCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgX29uRHJhZ0VudGVyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RPTSBldmVudH0gZXZlbnQgZHJhZ2VudGVyIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbkRyYWdFbnRlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJRSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2ZW50RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGFuZGxlcyBkcmFnIG92ZXIgZXZlbnQuIEluIGNhc2Ugb2YgSUUsIHRoaXMgZnVuY3Rpb24gd2lsbCBwcmV2ZW50IHRoZSBldmVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBfb25EcmFnT3ZlclxuICAgICAgICAgICAgICogQHBhcmFtIHtET00gZXZlbnR9IGV2ZW50IGRyYWdvdmVyIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbkRyYWdPdmVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0lFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHBhc3RlZCBkYXRhIGlzIGltYWdlIGFuZCBwYXNzZXMgaXQgdG9cbiAgICAgICAgICAgICAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzL19wcm9jZXNzRmlsZTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0gZm9yIHByb2Nlc3NpbmcuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgX29uUGFzdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBldmVudCBBIGBwYXN0ZWAgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3JcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX29uUGFzdGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS4kICYmIGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhICYmIGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhLml0ZW1zICYmIGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhc3RlZERhdGEgPSBldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtc1swXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzdGVkRGF0YS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUZpbGUgPSBwYXN0ZWREYXRhLmdldEFzRmlsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzRmlsZShpbWFnZUZpbGUsIGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcmV2ZW50cyBhIG5hdGl2ZSBldmVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBfcHJldmVudEV2ZW50XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RPTSBldmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3ByZXZlbnRFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBDS0VESVRPUi5kb20uZXZlbnQoZXZlbnQuZGF0YS4kKTtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb2Nlc3NlcyBhbiBpbWFnZSBmaWxlLiBUaGUgZnVuY3Rpb24gY3JlYXRlcyBhbiBpbWcgZWxlbWVudCBhbmQgc2V0cyBhcyBzb3VyY2VcbiAgICAgICAgICAgICAqIGEgRGF0YSBVUkksIHRoZW4gZmlyZXMgYW4gJ2ltYWdlQWRkJyBldmVudCB2aWEgQ0tFZGl0b3IncyBldmVudCBzeXN0ZW0uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGZpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzI2ltYWdlQWRkXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBfcHJldmVudEV2ZW50XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RPTSBldmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3Byb2Nlc3NGaWxlOiBmdW5jdGlvbihmaWxlLCBlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW4gPSByZWFkZXIucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKCc8aW1nIHNyYz1cIicgKyBiaW4gKyAnXCI+Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2ltYWdlQWRkJywgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn0oKSk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfYXV0b2xpbmsnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZXMgdGhlIGF1dG8gVVJMIGRldGVjdGlvbiBmZWF0dXJlIGluIElFLCB0aGVpciBsYWNrcyBmdW5jdGlvbmFsaXR5OlxuICAgIC8vIFRoZXkgY29udmVydCB0aGUgbGlua3Mgb25seSBvbiBzcGFjZS4gV2UgZG8gb24gc3BhY2UsIGNvbW1hLCBzZW1pY29sb24gYW5kIEVudGVyLlxuICAgIGlmICgvTVNJRSAoW147XSopfFRyaWRlbnQuKjsgcnY6KFswLTkuXSspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdBdXRvVXJsRGV0ZWN0JywgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgS0VZX0JBQ0sgPSA4O1xuXG4gICAgdmFyIEtFWV9DT01NQSA9IDE4ODtcblxuICAgIHZhciBLRVlfRU5URVIgPSAxMztcblxuICAgIHZhciBLRVlfU0VNSUNPTE9OID0gMTg2O1xuXG4gICAgdmFyIEtFWV9TUEFDRSA9IDMyO1xuXG4gICAgdmFyIERFTElNSVRFUlMgPSBbS0VZX0NPTU1BLCBLRVlfRU5URVIsIEtFWV9TRU1JQ09MT04sIEtFWV9TUEFDRV07XG5cbiAgICB2YXIgUkVHRVhfTEFTVF9XT1JEID0gL1teXFxzXSsvbWc7XG5cbiAgICB2YXIgUkVHRVhfVVJMID0gLyhodHRwcz9cXDpcXC9cXC98d3d3XFwuKSgtXFwuKT8oW14oXFxzLz9cXC4jLSldK1xcLj8pKyhcXGJcXC9bXlxcc10qKT8kL2k7XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgbGlua3Mgd2hlbiB1c2VyIHR5cGVzIHRleHQgd2hpY2ggbG9va3MgbGlrZSBVUkwuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKFxuICAgICAgICAnYWVfYXV0b2xpbmsnLCB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyB0aGUgYGtleXVwYCBldmVudCBvbiB0aGUgZWRpdGluZyBhcmVhLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdrZXl1cCcsIHRoaXMuX29uS2V5VXAsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgbGFzdCB3b3JkIGludHJvZHVjZWQgYnkgdGhlIHVzZXIuIFJlYWRzIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAqIGNhcmV0IHBvc2l0aW9uIGJhY2t3YXJkcyB1bnRpbCBpdCBmaW5kcyB0aGUgZmlyc3Qgd2hpdGUgc3BhY2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAgICAgICAgICogQG1ldGhvZCBfZ2V0TGFzdFdvcmRcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGxhc3Qgd29yZCBpbnRyb2R1Y2VkIGJ5IHVzZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2dldExhc3RXb3JkOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNUZXh0ID0gJyc7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBwcmVzc2VkIEVudGVyLCBzbyB3ZSBoYXZlIHRvIGxvb2sgb24gdGhlIHByZXZpb3VzIG5vZGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIuZ2V0UHJldmlvdXMoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIG5vZGUgaXMgYSBTUEFDRSwgKGl0IGRvZXMgbm90IGhhdmUgJ2dldExhc3QnIG1ldGhvZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgaXQgYW5kIGZpbmQgdGhlIHByZXZpb3VzIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcmV2aW91c05vZGUuZ2V0TGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHByZXZpb3VzTm9kZS5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSBwcmV2aW91c05vZGUuZ2V0TGFzdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIsIHRoZSBsYXN0IGNoaWxkIG5vZGUgbWF5IGJlIGEgPEJSPlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHdoaWNoIGRvZXMgbm90IGhhdmUgJ2dldFRleHQnIG1ldGhvZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBpZ25vcmUgaXQgYW5kIGZpbmQgdGhlIHByZXZpb3VzIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxhc3RDaGlsZCAmJiAhbGFzdENoaWxkLmdldFRleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGlsZCA9IGxhc3RDaGlsZC5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxhc3RDaGlsZCBpcyBhbHJlYWR5IGEgbGlua1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLiQuaHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Q29udGFpbmVyID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUZXh0ID0gbGFzdENoaWxkID8gbGFzdENoaWxkLmdldFRleHQoKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gcHJldmlvdXNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBjaGFyYWN0ZXIgaXMgdGhlIGRlbGltaXRlciwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVGV4dCA9IHRoaXMuX3N0YXJ0Q29udGFpbmVyLmdldFRleHQoKS5zdWJzdHJpbmcoMCwgb2Zmc2V0IC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdFdvcmQgPSAnJztcblxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHByZXZpb3VzVGV4dC5tYXRjaChSRUdFWF9MQVNUX1dPUkQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RXb3JkID0gbWF0Y2gucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RXb3JkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGxpbmsgaXMgYSB2YWxpZCBVUkwuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAgICAgICAgICogQG1ldGhvZCBpc1ZhbGlkVVJMXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluayBUaGUgbGluayB3ZSB3YW50IHRvIGtub3cgaWYgaXQgaXMgYSB2YWxpZCBVUkxcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgbGluayBpcyBhIHZhbGlkIFVSTCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9pc1ZhbGlkVVJMOiBmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJFR0VYX1VSTC50ZXN0KGxpbmspO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0ZW5zIHRvIHRoZSBga2V5ZG93bmAgZXZlbnQgYW5kIGlmIHRoZSBrZXljb2RlIGlzIGBCYWNrc3BhY2VgLCByZW1vdmVzIHRoZSBwcmV2aW91c2x5XG4gICAgICAgICAgICAgKiBjcmVhdGVkIGxpbmsuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAgICAgICAgICogQG1ldGhvZCBfb25LZXlEb3duXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50RmFjYWRlfSBldmVudCBFdmVudEZhY2FkZSBvYmplY3RcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX29uS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgZWRpdGFibGUucmVtb3ZlTGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IEtFWV9CQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGluayhlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2NrTGluayA9IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExpc3RlbnMgdG8gdGhlIGBFbnRlcmAgYW5kIGBTcGFjZWAga2V5IGV2ZW50cyBpbiBvcmRlciB0byBjaGVjayBpZiB0aGUgbGFzdCB3b3JkXG4gICAgICAgICAgICAgKiBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyIHNob3VsZCBiZSByZXBsYWNlZCBieSBhIGxpbmsgZWxlbWVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9vbktleVVwXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50RmFjYWRlfSBldmVudCBFdmVudEZhY2FkZSBvYmplY3RcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX29uS2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKERFTElNSVRFUlMuaW5kZXhPZih0aGlzLl9jdXJyZW50S2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0V29yZCA9IHRoaXMuX2dldExhc3RXb3JkKGVkaXRvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRVUkwobGFzdFdvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBsYWNlQ29udGVudEJ5TGluayhlZGl0b3IsIGxhc3RXb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwbGFjZXMgY29udGVudCBieSBhIGxpbmsgZWxlbWVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZmlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGluayNhdXRvbGlua0FkZFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAgICAgICAgICogQG1ldGhvZCBfcmVwbGFjZUNvbnRlbnRCeUxpbmtcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50IFRoZSB0ZXh0IHRoYXQgaGFzIHRvIGJlIHJlcGxhY2VkIGJ5IGFuIGxpbmsgZWxlbWVudFxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcmVwbGFjZUNvbnRlbnRCeUxpbms6IGZ1bmN0aW9uKGVkaXRvciwgY29udGVudCkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuZ2V0KHRoaXMuX3N0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBjb250ZW50LCBzbyBDS0VESVRPUi5MaW5rIGNhbiBwcm9wZXJseSByZXBsYWNlIGl0XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0IC0gY29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNrTGluayA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcik7XG4gICAgICAgICAgICAgICAgY2tMaW5rLmNyZWF0ZShjb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ja0xpbmsgPSBja0xpbms7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGlua05vZGUgPSBja0xpbmsuZ2V0RnJvbVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdhdXRvbGlua0FkZCcsIGxpbmtOb2RlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvS2V5RXZlbnQoZWRpdG9yKTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdyByYW5nZSBpcyBvbiB0aGUgbGluayBhbmQgaXQgaXMgc2VsZWN0ZWQuIFdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gZm9jdXMgdG8gdGhlIGNhcmV0IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNlciBwcmVzc2VkIGBFbnRlcmAsIGdldCB0aGUgbmV4dCBlZGl0YWJsZSBub2RlIGF0IHBvc2l0aW9uIDAsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCB0aGUgY3Vyc29yIGF0IHRoZSBuZXh0IGNoYXJhY3RlciBvZiB0aGUgbGluayAodGhlIHdoaXRlIHNwYWNlKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50S2V5Q29kZSA9PT0gS0VZX0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0RWRpdGFibGVOb2RlID0gcmFuZ2UuZ2V0TmV4dEVkaXRhYmxlTm9kZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5leHRFZGl0YWJsZU5vZGUsIDApO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobmV4dEVkaXRhYmxlTm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHROb2RlID0gcmFuZ2UuZ2V0TmV4dE5vZGUoKTtcblxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChuZXh0Tm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChuZXh0Tm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZpcmVkIHdoZW4gYSBVUkwgaXMgZGV0ZWN0ZWQgaW4gdGV4dCBhbmQgY29udmVydGVkIHRvIGEgbGluay5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGluayNhdXRvbGlua0FkZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIE5vZGUgb2YgdGhlIGNyZWF0ZWQgbGluay5cbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZXMgdGhlIGNyZWF0ZWQgbGluayBlbGVtZW50LCBhbmQgcmVwbGFjZXMgaXQgYnkgaXRzIHRleHQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAgICAgICAgICogQG1ldGhvZCBfcmVtb3ZlTGlua1xuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcmVtb3ZlTGluazogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuICAgICAgICAgICAgICAgIHZhciBjYXJldE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBsaW5rLCBzbyBDS0VESVRPUi5MaW5rIGNhbiBwcm9wZXJseSByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICB2YXIgbGlua05vZGUgPSB0aGlzLl9zdGFydENvbnRhaW5lci5nZXROZXh0KCkgfHwgdGhpcy5fc3RhcnRDb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3UmFuZ2UgPSBlZGl0b3IuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChsaW5rTm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kQWZ0ZXIobGlua05vZGUpO1xuICAgICAgICAgICAgICAgIG5ld1JhbmdlLnNlbGVjdCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2tMaW5rLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZvY3VzIHRvIHRoZSBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChyYW5nZS5zdGFydENvbnRhaW5lciwgY2FyZXRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjYXJldE9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3Vic2NyaWJlIHRvIGEga2V5IGV2ZW50IG9mIHRoZSBlZGl0YWJsZSBhcmlhLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3N1YnNjcmliZVRvS2V5RXZlbnRcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3N1YnNjcmliZVRvS2V5RXZlbnQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBwcmlvcml0eSBvZiBrZXlkb3duIGxpc3RlbmVyIC0gMSBtZWFucyB0aGUgaGlnaGVzdCBwcmlvcml0eS5cbiAgICAgICAgICAgICAgICAvLyBJbiBDaHJvbWUgb24gcHJlc3NpbmcgYEVudGVyYCB0aGUgbGlzdGVuZXIgaXMgbm90IGJlaW5nIGludm9rZWQuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly9kZXYuY2tlZGl0b3IuY29tL3RpY2tldC8xMTg2MSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2F1dG9saXN0JykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBLRVlfQkFDSyA9IDg7XG5cbiAgICB2YXIgS0VZX1NQQUNFID0gMzI7XG5cbiAgICB2YXIgREVGQVVMVF9DT05GSUcgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlZ2V4OiAvXlxcKiQvLFxuICAgICAgICAgICAgdHlwZTogJ2J1bGxldGVkbGlzdCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmVnZXg6IC9eMVxcLiQvLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlcmVkbGlzdCdcbiAgICAgICAgfVxuICAgIF07XG5cblx0LyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIG9yZGVyZWQvdW5vcmRlcmVkIGxpc3Qgd2hlbiB1c2VyIHR5cGVzIHRleHQgd2hpY2ggbG9va3MgbGlrZSBhIGxpc3QuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKFxuICAgICAgICAnYWVfYXV0b2xpc3QnLCB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS2VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyB0aGUgYGtleWRvd25gIGV2ZW50IG9uIHRoZSBjb250ZW50IGVkaXRpbmcgYXJlYS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgZm9yIHByZXNzaW5nIHRoZSBgQmFja3NwYWNlYCBrZXkgaW4gb3JkZXIgdG8gdW5kbyB0aGUgbGlzdCBjcmVhdGlvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG9cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICBlZGl0YWJsZS5yZW1vdmVMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2NoZWNrRm9yQmFja3NwYWNlQW5kVW5kbyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gS0VZX0JBQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCd1bmRvJyk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5pbnNlcnRIdG1sKGV2ZW50Lmxpc3RlbmVyRGF0YS5idWxsZXQgKyAnJm5ic3A7Jyk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrcyBjdXJyZW50IGxpbmUgdG8gZmluZCBtYXRjaCB3aXRoIE1BVENIRVMgb2JqZWN0IHRvIGNyZWF0ZSBPTCBvciBVTC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9jaGVja0xpbmVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZWRpdG9yfSBFZGl0b3Igb2JqZWN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gUmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGRldGVjdGVkIGxpc3QgY29uZmlnIGlmIGFueVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfZ2V0TGlzdENvbmZpZzogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZ1JlZ2V4ID0gZWRpdG9yLmNvbmZpZy5hdXRvbGlzdCB8fCBERUZBVUxUX0NPTkZJRztcblxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29udGFpbmVyID0gcmFuZ2UuZW5kQ29udGFpbmVyLmdldFRleHQoKTtcblxuICAgICAgICAgICAgICAgIHZhciBidWxsZXQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZygwLCByYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRleHRDb250YWluZXIuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0T2Zmc2V0LCB0ZXh0Q29udGFpbmVyLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4TGVuID0gY29uZmlnUmVnZXgubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgdmFyIGF1dG9saXN0Q2ZnID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICghYXV0b2xpc3RDZmcgJiYgcmVnZXhMZW4gPiBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXhJdGVtID0gY29uZmlnUmVnZXhbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleEl0ZW0ucmVnZXgudGVzdChidWxsZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvbGlzdENmZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWxsZXQ6IGJ1bGxldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJlZ2V4SXRlbS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9saXN0Q2ZnO1xuICAgICAgICAgICAgfSxcblxuXHRcdFx0LyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgbGlzdCB3aXRoIGRpZmZlcmVudCB0eXBlczogQnVsbGV0ZWQgb3IgTnVtYmVyZWQgbGlzdFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3RcbiAgICAgICAgICAgICAqIEBtZXRob2QgX2NyZWF0ZUxpc3RcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0Q29uZmlnIE9iamVjdCB0aGF0IGNvbnRhaW5zIGJ1bGxldCwgdGV4dCBhbmQgdHlwZSBmb3IgY3JlYXRpbmcgdGhlIGxpc3RcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcblx0XHRcdCAqL1xuICAgICAgICAgICAgX2NyZWF0ZUxpc3Q6IGZ1bmN0aW9uKGxpc3RDb25maWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gbGlzdENvbmZpZy5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgICAgICByYW5nZS5lbmRDb250YWluZXIuc2V0VGV4dChsaXN0Q29uZmlnLnRleHQpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZChsaXN0Q29uZmlnLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8ga2V5ZG93biBpbiBvcmRlciB0byBjaGVjayBpZiB0aGUgbmV4dCBrZXkgcHJlc3MgaXMgYEJhY2tzcGFjZWAuXG4gICAgICAgICAgICAgICAgLy8gSWYgc28sIHRoZSBjcmVhdGlvbiBvZiB0aGUgbGlzdCB3aWxsIGJlIGRpc2NhcmRlZC5cbiAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2tleWRvd24nLCB0aGlzLl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8sIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldDogbGlzdENvbmZpZy5idWxsZXRcbiAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIH0sXG5cblx0XHRcdC8qKlxuICAgICAgICAgICAgICogTGlzdGVucyB0byB0aGUgYFNwYWNlYCBrZXkgZXZlbnRzIHRvIGNoZWNrIGlmIHRoZSBsYXN0IHdvcmRcbiAgICAgICAgICAgICAqIGludHJvZHVjZWQgYnkgdGhlIHVzZXIgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgbGlzdCAoT0wgb3IgVUwpXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuICAgICAgICAgICAgICogQG1ldGhvZCBfb25LZXlEb3duXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX29uS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gS0VZX1NQQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0Q29uZmlnID0gdGhpcy5fZ2V0TGlzdENvbmZpZyhldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTGlzdChsaXN0Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXHQpO1xufSgpKTsiLCIvKipcbiAqIENLRWRpdG9yIHBsdWdpbjogRHJhZ2FibGUgaW1hZ2UgcmVzaXppbmdcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zc3R1ci9jay1kcmFncmVzaXplXG4gKiAtIFNob3dzIHNlbWktdHJhbnNwYXJlbnQgb3ZlcmxheSB3aGlsZSByZXNpemluZ1xuICogLSBFbmZvcmNlcyBBc3BlY3QgUmF0aW8gKHVubGVzcyBob2xkaW5nIHNoaWZ0KVxuICogLSBTbmFwIHRvIHNpemUgb2Ygb3RoZXIgaW1hZ2VzIGluIGVkaXRvclxuICogLSBFc2NhcGUgd2hpbGUgZHJhZ2dpbmcgY2FuY2VscyByZXNpemVcbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfZHJhZ3Jlc2l6ZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgSU1BR0VfSEFORExFUyA9IHtcbiAgICAgICAgYm90aDogWyd0bCcsICd0bScsICd0cicsICdsbScsICdybScsICdibCcsICdibScsICdiciddLFxuICAgICAgICBoZWlnaHQ6IFsndGwnLCAndG0nLCAndHInLCAnYmwnLCAnYm0nLCAnYnInXSxcbiAgICAgICAgc2NhbGU6IFsndGwnLCAndHInLCAnYmwnLCAnYnInXSxcbiAgICAgICAgd2lkdGg6IFsndGwnLCAndHInLCAnbG0nLCAncm0nLCAnYmwnLCAnYnInXSxcbiAgICB9O1xuXG4gICAgdmFyIFBPU0lUSU9OX0VMRU1FTlRfRk4gPSB7XG4gICAgICAgIGJsOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCAtMyArIGxlZnQsIGJveC5oZWlnaHQgLSA0ICsgdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgYm06IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIE1hdGgucm91bmQoYm94LndpZHRoIC8gMikgLSAzICsgbGVmdCwgYm94LmhlaWdodCAtIDQgKyB0b3ApO1xuICAgICAgICB9LFxuICAgICAgICBicjogZnVuY3Rpb24oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50KGhhbmRsZSwgYm94LndpZHRoIC0gNCArIGxlZnQsIGJveC5oZWlnaHQgLSA0ICsgdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG06IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIC0zICsgbGVmdCwgTWF0aC5yb3VuZChib3guaGVpZ2h0IC8gMikgLSAzICsgdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGw6IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGxlZnQgLSAzLCB0b3AgLSAzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG06IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIE1hdGgucm91bmQoYm94LndpZHRoIC8gMikgLSAzICsgbGVmdCwgLTMgKyB0b3ApO1xuICAgICAgICB9LFxuICAgICAgICB0cjogZnVuY3Rpb24oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50KGhhbmRsZSwgYm94LndpZHRoIC0gNCArIGxlZnQsIC0zICsgdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm06IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCBNYXRoLnJvdW5kKGJveC5oZWlnaHQgLyAyKSAtIDMgKyB0b3ApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBJTUFHRV9TTkFQX1RPX1NJWkUgPSA3O1xuXG4gICAgdmFyIGlzRmlyZWZveCA9ICgnTW96QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKTtcblxuICAgIHZhciBpc1dlYktpdCA9ICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKTtcblxuICAgIHZhciBlbmFibGVQbHVnaW4gPSBpc1dlYktpdCB8fCBpc0ZpcmVmb3g7XG5cbiAgICBpZiAoZW5hYmxlUGx1Z2luKSB7XG4gICAgICAgIC8vIENTUyBpcyBhZGRlZCBpbiBhIGNvbXByZXNzZWQgZm9ybVxuICAgICAgICBDS0VESVRPUi5hZGRDc3MoJ2ltZzo6c2VsZWN0aW9ue2NvbG9yOnJnYmEoMCwwLDAsMCl9aW1nLmNraW1ncnN6e291dGxpbmU6MXB4IGRhc2hlZCAjMDAwfSNja2ltZ3Jzentwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowO2N1cnNvcjpkZWZhdWx0O3otaW5kZXg6MTAwMDF9I2NraW1ncnN6IHNwYW57ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDowO2hlaWdodDowO2JhY2tncm91bmQtc2l6ZToxMDAlIDEwMCU7b3BhY2l0eTouNjU7b3V0bGluZToxcHggZGFzaGVkICMwMDB9I2NraW1ncnN6IGl7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt3aWR0aDo1cHg7aGVpZ2h0OjVweDtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjMDAwfSNja2ltZ3JzeiBpLmFjdGl2ZSwjY2tpbWdyc3ogaTpob3ZlcntiYWNrZ3JvdW5kOiMwMDB9I2NraW1ncnN6IGkuYnIsI2NraW1ncnN6IGkudGx7Y3Vyc29yOm53c2UtcmVzaXplfSNja2ltZ3JzeiBpLmJtLCNja2ltZ3JzeiBpLnRte2N1cnNvcjpucy1yZXNpemV9I2NraW1ncnN6IGkuYmwsI2NraW1ncnN6IGkudHJ7Y3Vyc29yOm5lc3ctcmVzaXplfSNja2ltZ3JzeiBpLmxtLCNja2ltZ3JzeiBpLnJte2N1cnNvcjpldy1yZXNpemV9Ym9keS5kcmFnZ2luZy1icixib2R5LmRyYWdnaW5nLWJyICosYm9keS5kcmFnZ2luZy10bCxib2R5LmRyYWdnaW5nLXRsICp7Y3Vyc29yOm53c2UtcmVzaXplIWltcG9ydGFudH1ib2R5LmRyYWdnaW5nLWJtLGJvZHkuZHJhZ2dpbmctYm0gKixib2R5LmRyYWdnaW5nLXRtLGJvZHkuZHJhZ2dpbmctdG0gKntjdXJzb3I6bnMtcmVzaXplIWltcG9ydGFudH1ib2R5LmRyYWdnaW5nLWJsLGJvZHkuZHJhZ2dpbmctYmwgKixib2R5LmRyYWdnaW5nLXRyLGJvZHkuZHJhZ2dpbmctdHIgKntjdXJzb3I6bmVzdy1yZXNpemUhaW1wb3J0YW50fWJvZHkuZHJhZ2dpbmctbG0sYm9keS5kcmFnZ2luZy1sbSAqLGJvZHkuZHJhZ2dpbmctcm0sYm9keS5kcmFnZ2luZy1ybSAqe2N1cnNvcjpldy1yZXNpemUhaW1wb3J0YW50fScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW5cbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfZHJhZ3Jlc2l6ZScsIHtcbiAgICAgICAgb25Mb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghZW5hYmxlUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgIGlmICghZW5hYmxlUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIGluaXQoZWRpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpbml0KGVkaXRvcikge1xuICAgICAgICB2YXIgd2luZG93ID0gZWRpdG9yLndpbmRvdy4kLFxuICAgICAgICAgICAgZG9jdW1lbnQgPSBlZGl0b3IuZG9jdW1lbnQuJDtcblxuICAgICAgICBpZiAoaXNGaXJlZm94KSB7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIHRoZSBuYXRpdmUgaW1hZ2UgcmVzaXppbmdcbiAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdlbmFibGVPYmplY3RSZXNpemluZycsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc25hcFRvU2l6ZSA9ICh0eXBlb2YgSU1BR0VfU05BUF9UT19TSVpFID09PSAndW5kZWZpbmVkJykgPyBudWxsIDogSU1BR0VfU05BUF9UT19TSVpFO1xuXG4gICAgICAgIGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSA9IGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSB8fCAnYm90aCc7XG5cbiAgICAgICAgdmFyIHJlc2l6ZXIgPSBuZXcgUmVzaXplcihlZGl0b3IsIHtcbiAgICAgICAgICAgIGltYWdlU2NhbGVSZXNpemU6IGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSxcbiAgICAgICAgICAgIHNuYXBUb1NpemU6IHNuYXBUb1NpemVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1vdXNlRG93bkxpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHJlc2l6ZXIuaXNIYW5kbGUoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplci5pbml0RHJhZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZURvd25MaXN0ZW5lciwgZmFsc2UpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uKSByZXR1cm47XG4gICAgICAgICAgICAvLyBJZiBhbiBlbGVtZW50IGlzIHNlbGVjdGVkIGFuZCB0aGF0IGVsZW1lbnQgaXMgYW4gSU1HXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmdldFR5cGUoKSAhPT0gQ0tFRElUT1IuU0VMRUNUSU9OX05PTkUgJiYgc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpLmlzKCdpbWcnKSkge1xuICAgICAgICAgICAgICAgIC8vIEFuZCB3ZSdyZSBub3QgcmlnaHQgb3IgbWlkZGxlIGNsaWNraW5nIG9uIHRoZSBpbWFnZVxuICAgICAgICAgICAgICAgIGlmICghd2luZG93LmV2ZW50IHx8ICF3aW5kb3cuZXZlbnQuYnV0dG9uIHx8IHdpbmRvdy5ldmVudC5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplci5zaG93KHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKS4kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLm9uKCdzZWxlY3Rpb25DaGFuZ2UnLCBzZWxlY3Rpb25DaGFuZ2UpO1xuXG4gICAgICAgIGVkaXRvci5vbignZ2V0RGF0YScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gZS5kYXRhLmRhdGFWYWx1ZSB8fCAnJztcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLzxkaXYgaWQ9XCJja2ltZ3JzelwiKFtcXHNcXFNdKj8pPFxcL2Rpdj4vaSwgJycpO1xuICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXFxiKGNraW1ncnN6KVxcYi9nLCAnJyk7XG4gICAgICAgICAgICBlLmRhdGEuZGF0YVZhbHVlID0gaHRtbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdiZWZvcmVVbmRvSW1hZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaGFuZGxlcyBiZWZvcmUgdW5kbyBpbWFnZXMgYXJlIHNhdmVkXG4gICAgICAgICAgICByZXNpemVyLmhpZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdhZnRlclVuZG9JbWFnZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgaGFuZGxlcyBhZnRlciB1bmRvIGltYWdlcyBhcmUgc2F2ZWRcbiAgICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlZGl0b3Iub24oJ2JsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaGFuZGxlcyB3aGVuIGVkaXRvciBsb3NlcyBmb2N1c1xuICAgICAgICAgICAgcmVzaXplci5oaWRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVkaXRvci5vbignYmVmb3JlTW9kZVVubG9hZCcsIGZ1bmN0aW9uIHNlbGYoKSB7XG4gICAgICAgICAgICBlZGl0b3IucmVtb3ZlTGlzdGVuZXIoJ2JlZm9yZU1vZGVVbmxvYWQnLCBzZWxmKTtcbiAgICAgICAgICAgIHJlc2l6ZXIuaGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlZGl0b3Iub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXNpemVFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NraW1ncnN6Jyk7XG5cbiAgICAgICAgICAgIGlmIChyZXNpemVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzaXplRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRmlyZWZveCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdlbmFibGVPYmplY3RSZXNpemluZycsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duTGlzdGVuZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGlvbiB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyByZXNpemVkXG4gICAgICAgIHZhciByZXNpemVUaW1lb3V0O1xuICAgICAgICBlZGl0b3Iud2luZG93Lm9uKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENhbmNlbCBhbnkgcmVzaXplIHdhaXRpbmcgdG8gaGFwcGVuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZW91dCk7XG4gICAgICAgICAgICAvLyBEZWxheSByZXNpemUgdG8gXCJkZWJvdW5jZVwiXG4gICAgICAgICAgICByZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dChzZWxlY3Rpb25DaGFuZ2UsIDUwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVzaXplcihlZGl0b3IsIGNmZykge1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy53aW5kb3cgPSBlZGl0b3Iud2luZG93LiQ7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBlZGl0b3IuZG9jdW1lbnQuJDtcbiAgICAgICAgdGhpcy5jZmcgPSBjZmcgfHwge307XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIFJlc2l6ZXIucHJvdG90eXBlID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5pZCA9ICdja2ltZ3Jzeic7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnByZXZpZXcpO1xuXG4gICAgICAgICAgICB2YXIgaGFuZGxlcyA9IHRoaXMuaGFuZGxlcyA9IHt9O1xuXG4gICAgICAgICAgICBJTUFHRV9IQU5ETEVTW3RoaXMuY2ZnLmltYWdlU2NhbGVSZXNpemVdLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlc1toYW5kbGVOYW1lXSA9IGluc3RhbmNlLmhhbmRsZXNbaGFuZGxlTmFtZV0gPSBpbnN0YW5jZS5jcmVhdGVIYW5kbGUoaGFuZGxlTmFtZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBoYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhhbmRsZXNbbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVIYW5kbGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNIYW5kbGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcyA9IHRoaXMuaGFuZGxlcztcbiAgICAgICAgICAgIGZvciAodmFyIG4gaW4gaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVzW25dID09PSBlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5jZmcuc25hcFRvU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3RoZXJJbWFnZXMgPSB0b0FycmF5KHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm90aGVySW1hZ2VzLnNwbGljZSh0aGlzLm90aGVySW1hZ2VzLmluZGV4T2YoZWwpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLmJveCA9IGdldEJvdW5kaW5nQm94KHRoaXMud2luZG93LCBlbCk7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQodGhpcy5jb250YWluZXIsIGJveC5sZWZ0LCBib3gudG9wKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2NraW1ncnN6Jyk7XG4gICAgICAgICAgICB0aGlzLnNob3dIYW5kbGVzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGNsYXNzIGZyb20gYWxsIGltZy5ja2ltZ3JzelxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdja2ltZ3JzeicpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2NraW1ncnN6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhpZGVIYW5kbGVzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbml0RHJhZzogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy9yaWdodC1jbGljayBvciBtaWRkbGUtY2xpY2tcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzaXplciA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZHJhZyA9IG5ldyBEcmFnRXZlbnQodGhpcy53aW5kb3csIHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICAgICAgZHJhZy5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplci5zaG93UHJldmlldygpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzaXplci5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRyYWcub25EcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplci5jYWxjdWxhdGVTaXplKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIudXBkYXRlUHJldmlldygpO1xuICAgICAgICAgICAgICAgIHZhciBib3ggPSByZXNpemVyLnByZXZpZXdCb3g7XG4gICAgICAgICAgICAgICAgcmVzaXplci51cGRhdGVIYW5kbGVzKGJveCwgYm94LmxlZnQsIGJveC50b3ApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRyYWcub25SZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplci5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzaXplci5oaWRlUHJldmlldygpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuZWRpdG9yLmdldFNlbGVjdGlvbigpLnVubG9jaygpO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgYW4gdW5kbyBzbmFwc2hvdCBiZWZvcmUgdGhlIGltYWdlIGlzIHBlcm1hbmVudGx5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICByZXNpemVyLmVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkcmFnLm9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNpemVyLnJlc2l6ZUNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBhbm90aGVyIHNuYXBzaG90IGFmdGVyIHRoZSBpbWFnZSBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgcmVzaXplci5lZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZHJhZy5zdGFydChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlSGFuZGxlczogZnVuY3Rpb24oYm94LCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgICAgICAgICB0b3AgPSB0b3AgfHwgMDtcbiAgICAgICAgICAgIHZhciBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBoYW5kbGUgaW4gaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIFBPU0lUSU9OX0VMRU1FTlRfRk5baGFuZGxlXShoYW5kbGVzW2hhbmRsZV0sIGxlZnQsIHRvcCwgYm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hvd0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXModGhpcy5ib3gpO1xuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBoYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlc1tuXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGlkZUhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBuIGluIGhhbmRsZXMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVzW25dLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dQcmV2aWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIHRoaXMuZWwuc3JjICsgJ1wiKSc7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVNpemUoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldygpO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVQcmV2aWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLnByZXZpZXdCb3g7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQodGhpcy5wcmV2aWV3LCBib3gubGVmdCwgYm94LnRvcCk7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuc3R5bGUud2lkdGggPSB0aGlzLnByZXZpZXdCb3gud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnN0eWxlLmhlaWdodCA9IHRoaXMucHJldmlld0JveC5oZWlnaHQgKyAncHgnO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlUHJldmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdCb3godGhpcy53aW5kb3csIHRoaXMucHJldmlldyk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYm94LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm94LmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjdWxhdGVTaXplOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gdGhpcy5wcmV2aWV3Qm94ID0ge1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmJveC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYm94LmhlaWdodFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBhdHRyID0gZGF0YS50YXJnZXQuY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZigncicpKSB7XG4gICAgICAgICAgICAgICAgYm94LndpZHRoID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LndpZHRoICsgZGF0YS5kZWx0YS54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh+YXR0ci5pbmRleE9mKCdiJykpIHtcbiAgICAgICAgICAgICAgICBib3guaGVpZ2h0ID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LmhlaWdodCArIGRhdGEuZGVsdGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZignbCcpKSB7XG4gICAgICAgICAgICAgICAgYm94LndpZHRoID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LndpZHRoIC0gZGF0YS5kZWx0YS54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh+YXR0ci5pbmRleE9mKCd0JykpIHtcbiAgICAgICAgICAgICAgICBib3guaGVpZ2h0ID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LmhlaWdodCAtIGRhdGEuZGVsdGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIGRyYWdnaW5nIGNvcm5lciwgZW5mb3JjZSBhc3BlY3QgcmF0aW8gKHVubGVzcyBzaGlmdCBrZXkgaXMgYmVpbmcgaGVsZClcbiAgICAgICAgICAgIGlmIChhdHRyLmluZGV4T2YoJ20nKSA8IDAgJiYgIWRhdGEua2V5cy5zaGlmdCkge1xuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHRoaXMuYm94LndpZHRoIC8gdGhpcy5ib3guaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChib3gud2lkdGggLyBib3guaGVpZ2h0ID4gcmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgYm94LmhlaWdodCA9IE1hdGgucm91bmQoYm94LndpZHRoIC8gcmF0aW8pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJveC53aWR0aCA9IE1hdGgucm91bmQoYm94LmhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbmFwVG9TaXplID0gdGhpcy5jZmcuc25hcFRvU2l6ZTtcblxuICAgICAgICAgICAgaWYgKHNuYXBUb1NpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJzID0gdGhpcy5vdGhlckltYWdlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgb3RoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGJveC53aWR0aCAtIG90aGVyLndpZHRoKSA8PSBzbmFwVG9TaXplICYmIE1hdGguYWJzKGJveC5oZWlnaHQgLSBvdGhlci5oZWlnaHQpIDw9IHNuYXBUb1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveC53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94LmhlaWdodCA9IG90aGVyLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JlY2FsY3VsYXRlIGxlZnQgb3IgdG9wIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZignbCcpKSB7XG4gICAgICAgICAgICAgICAgYm94LmxlZnQgPSB0aGlzLmJveC53aWR0aCAtIGJveC53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh+YXR0ci5pbmRleE9mKCd0JykpIHtcbiAgICAgICAgICAgICAgICBib3gudG9wID0gdGhpcy5ib3guaGVpZ2h0IC0gYm94LmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzaXplQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzaXplRWxlbWVudC5jYWxsKHRoaXMsIHRoaXMuZWwsIHRoaXMucmVzdWx0LndpZHRoLCB0aGlzLnJlc3VsdC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIERyYWdFdmVudCh3aW5kb3csIGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgICAgbW91c2Vtb3ZlOiBiaW5kKHRoaXMubW91c2Vtb3ZlLCB0aGlzKSxcbiAgICAgICAgICAgIGtleWRvd246IGJpbmQodGhpcy5rZXlkb3duLCB0aGlzKSxcbiAgICAgICAgICAgIG1vdXNldXA6IGJpbmQodGhpcy5tb3VzZXVwLCB0aGlzKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIERyYWdFdmVudC5wcm90b3R5cGUgPSB7XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuYXR0ciA9IGUudGFyZ2V0LmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGUpO1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBldmVudHMubW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudHMua2V5ZG93biwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRzLm1vdXNldXAsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdkcmFnZ2luZy0nICsgdGhpcy5hdHRyKTtcbiAgICAgICAgICAgIHRoaXMub25TdGFydCAmJiB0aGlzLm9uU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSB7XG4gICAgICAgICAgICAgICAgeDogZS5jbGllbnRYIC0gdGhpcy5zdGFydFBvcy54LFxuICAgICAgICAgICAgICAgIHk6IGUuY2xpZW50WSAtIHRoaXMuc3RhcnRQb3MueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IHtcbiAgICAgICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICBjdHJsOiBlLmN0cmxLZXksXG4gICAgICAgICAgICAgICAgYWx0OiBlLmFsdEtleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShlKTtcbiAgICAgICAgICAgIHRoaXMub25EcmFnICYmIHRoaXMub25EcmFnKCk7XG4gICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vbW91c2UgYnV0dG9uIHJlbGVhc2VkIG91dHNpZGUgd2luZG93OyBtb3VzZXVwIHdhc24ndCBmaXJlZCAoQ2hyb21lKVxuICAgICAgICAgICAgICAgIHRoaXMubW91c2V1cChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAga2V5ZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy9lc2NhcGUga2V5IGNhbmNlbHMgZHJhZ2dpbmdcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNldXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGUpO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUgJiYgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdnaW5nLScgKyB0aGlzLmF0dHIpO1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBldmVudHMubW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudHMua2V5ZG93biwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRzLm1vdXNldXAsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMub25SZWxlYXNlICYmIHRoaXMub25SZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9oZWxwZXIgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGgsXG4gICAgICAgICAgICBhcnIgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG4gICAgICAgIGlmIChmbi5iaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZChjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkVsZW1lbnQoZWwsIGxlZnQsIHRvcCkge1xuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gU3RyaW5nKGxlZnQpICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUudG9wID0gU3RyaW5nKHRvcCkgKyAncHgnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGltYWdlU2NhbGVSZXNpemUgPSB0aGlzLmVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZTtcbiAgICAgICAgaWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdib3RoJykge1xuICAgICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBTdHJpbmcod2lkdGgpICsgJ3B4JztcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IFN0cmluZyhoZWlnaHQpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbWFnZVNjYWxlUmVzaXplID09PSAnd2lkdGgnIHx8IGltYWdlU2NhbGVSZXNpemUgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gU3RyaW5nKHdpZHRoKSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IFN0cmluZyhoZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3god2luZG93LCBlbCkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG4iLCIvKipcbiAqIENLRWRpdG9yIHBsdWdpbjogSW1hZ2UyXG4gKiAtIFNob3cgZ3JpcHBlciB0byByZXNpemUgaW1hZ2VzIG9uIElFXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9kcmFncmVzaXplX2llJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbGlnbm1lbnRzT2JqID0ge1xuICAgICAgICBjZW50ZXI6IDEsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAyXG4gICAgfTtcblxuICAgIC8qXG4gICAgICogU2V0IGN1cnNvciBjc3MgZGVwZW5kIG9uIGltYWdlU2NhbGVSZXNpemUgY29uZmlnXG4gICAgICoqL1xuXG4gICAgdmFyIGN1cnNvciA9IHtcbiAgICAgICAgYm90aDogJ253c2UtcmVzaXplJyxcbiAgICAgICAgaGVpZ2h0OiAnbnMtcmVzaXplJyxcbiAgICAgICAgc2NhbGU6ICdud3NlLXJlc2l6ZScsXG4gICAgICAgIHdpZHRoOiAnZXctcmVzaXplJyxcbiAgICB9O1xuXG4gICAgdmFyIHJlZ2V4UGVyY2VudCA9IC9eXFxzKihcXGQrXFwlKVxccyokL2k7XG5cbiAgICB2YXIgdGVtcGxhdGUgPSAnPGltZyBhbHQ9XCJcIiBzcmM9XCJcIiAvPic7XG5cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfZHJhZ3Jlc2l6ZV9pZScsIHtcbiAgICAgICAgaGlkcGk6IHRydWUsXG5cbiAgICAgICAgaWNvbnM6ICdpbWFnZScsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIGltYWdlID0gd2lkZ2V0RGVmKGVkaXRvcik7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSB3aWRnZXQuXG4gICAgICAgICAgICBlZGl0b3Iud2lkZ2V0cy5hZGQoJ2ltYWdlJywgaW1hZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQ0tFRElUT1IuYWRkQ3NzKFxuICAgICAgICAgICAgICAgICcuY2tlX2ltYWdlX3Jlc2l6ZXJfbndzZS1yZXNpemV7JyArXG4gICAgICAgICAgICAgICAgJ2N1cnNvcjogbndzZS1yZXNpemU7JyArXG4gICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAnLmNrZV9pbWFnZV9yZXNpemVyX25zLXJlc2l6ZXsnICtcbiAgICAgICAgICAgICAgICAnY3Vyc29yOiBucy1yZXNpemU7JyArXG4gICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAnLmNrZV9pbWFnZV9yZXNpemVyX253c2UtcmVzaXpleycgK1xuICAgICAgICAgICAgICAgICdjdXJzb3I6IG53c2UtcmVzaXplOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplcl9ldy1yZXNpemV7JyArXG4gICAgICAgICAgICAgICAgJ2N1cnNvcjogZXctcmVzaXplOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2Vfbm9jYXB0aW9ueycgK1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gcmVtb3ZlIHVud2FudGVkIHNwYWNlIHNvIHJlc2l6ZVxuICAgICAgICAgICAgICAgIC8vIHdyYXBwZXIgaXMgZGlzcGxheWVkIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICdsaW5lLWhlaWdodDowJyArXG4gICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAnLmNrZV9pbWFnZV9yZXNpemVyeycgK1xuICAgICAgICAgICAgICAgICdkaXNwbGF5Om5vbmU7JyArXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uOmFic29sdXRlOycgK1xuICAgICAgICAgICAgICAgICd3aWR0aDoxMHB4OycgK1xuICAgICAgICAgICAgICAgICdoZWlnaHQ6MTBweDsnICtcbiAgICAgICAgICAgICAgICAnYm90dG9tOi01cHg7JyArXG4gICAgICAgICAgICAgICAgJ3JpZ2h0Oi01cHg7JyArXG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmQ6IzAwMDsnICtcbiAgICAgICAgICAgICAgICAnb3V0bGluZToxcHggc29saWQgI2ZmZjsnICtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRyYWcgaGFuZGxlciBmcm9tIGJlaW5nIG1pc3BsYWNlZCAoIzExMjA3KS5cbiAgICAgICAgICAgICAgICAnbGluZS1oZWlnaHQ6MDsnICtcbiAgICAgICAgICAgICAgICAnY3Vyc29yOm53c2UtcmVzaXplOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplcl93cmFwcGVyeycgK1xuICAgICAgICAgICAgICAgICdwb3NpdGlvbjpyZWxhdGl2ZTsnICtcbiAgICAgICAgICAgICAgICAnZGlzcGxheTppbmxpbmUtYmxvY2s7JyArXG4gICAgICAgICAgICAgICAgJ2xpbmUtaGVpZ2h0OjA7JyArXG4gICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAnLmNrZV93aWRnZXRfd3JhcHBlcjpob3ZlciAuY2tlX2ltYWdlX3Jlc2l6ZXIsJyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplci5ja2VfaW1hZ2VfcmVzaXppbmd7JyArXG4gICAgICAgICAgICAgICAgJ2Rpc3BsYXk6YmxvY2snICtcbiAgICAgICAgICAgICAgICAnfSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVxdWlyZXM6ICd3aWRnZXQnXG4gICAgfSk7XG5cbiAgICAvLyBXaWdldCBzdGF0ZXMgKGZvcm1zKSBkZXBlbmRpbmcgb24gYWxpZ25tZW50IGFuZCBjb25maWd1cmF0aW9uLlxuICAgIC8vXG4gICAgLy8gTm9uLWNhcHRpb25lZCB3aWRnZXQgKGlubGluZSBzdHlsZXMpXG4gICAgLy8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgIC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdPiAgIOKUgjxpbWcgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnSAvPiAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPHAgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8cCBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4g4pSCICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCICAgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdPiAg4pSCPGltZyBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnSAvPiAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgLy9cbiAgICAvLyBOb24tY2FwdGlvbmVkIHdpZGdldCAoY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXMgZGVmaW5lZClcbiAgICAvLyBcdFx04pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgLy8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIGNsYXNzPeKAnWxlZnTigJ0+ICAgICAgICAg4pSCPGltZyBjbGFzcz3igJ1sZWZ04oCdIC8+ICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8cCBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxwIGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgY2xhc3M94oCdcmlnaHTigJ0+ICAgICAgICDilII8aW1nIGNsYXNzPeKAnXJpZ2h04oCdIC8+ICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAvL1xuICAgIC8vIENhcHRpb25lZCB3aWRnZXQgKGlubGluZSBzdHlsZXMpXG4gICAgLy8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgIC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0+ICAgICAgICAgICAg4pSCPGZpZ3VyZSBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdIC8+ICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPiAgICAg4pSCPGRpdiBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4gICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgc3R5bGU94oCdZGlzcGxheTppbmxpbmUtYmxvY2vigJ0gLz7ilIIgPGZpZ3VyZSBzdHlsZT3igJ1kaXNwbGF5OmlubGluZS1ibG9ja+KAnSAvPuKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0+ICAgICAgICAgICDilII8ZmlndXJlIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdIC8+ICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAvL1xuICAgIC8vIENhcHRpb25lZCB3aWRnZXQgKGNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzIGRlZmluZWQpXG4gICAgLy8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgIC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIGNsYXNzPeKAnWxlZnTigJ0+ICAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSBjbGFzcz3igJ1sZWZ04oCdIC8+ICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyIGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICAgICAg4pSCPGRpdiBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIGNsYXNzPeKAnXJpZ2h04oCdPiAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSBjbGFzcz3igJ1yaWdodOKAnSAvPiAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cbiAgICAvLyBAcmV0dXJucyB7T2JqZWN0fVxuICAgIGZ1bmN0aW9uIHdpZGdldERlZihlZGl0b3IpIHtcbiAgICAgICAgZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplID0gZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplIHx8ICdib3RoJztcblxuICAgICAgICBlZGl0b3Iub24oJ2ltYWdlQWRkJywgZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgICAgICAgICAgZWRpdG9yLndpZGdldHMuaW5pdE9uKGltYWdlRGF0YS5kYXRhLmVsLCAnaW1hZ2UnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuICAgICAgICB2YXIgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWxwZXJzID0gQ0tFRElUT1IucGx1Z2lucy5pbWFnZTI7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLnBhcnRzLmltYWdlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdhbHQnKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2FwdGlvbjogISF0aGlzLnBhcnRzLmNhcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9jayByYXRpbyBpcyBvbiBieSBkZWZhdWx0ICgjMTA4MzMpLlxuICAgICAgICAgICAgICAgICAgICBsb2NrOiB0aGlzLnJlYWR5ID8gaGVscGVycy5jaGVja0hhc05hdHVyYWxSYXRpbyhpbWFnZSkgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzcmM6IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJydcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgdXNlZCAnYScgaW4gd2lkZ2V0I3BhcnRzIGRlZmluaXRpb24sIGl0IGNvdWxkIGhhcHBlbiB0aGF0XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0ZWQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHdpZGdldC5wYXJ0cyNjYXB0aW9uLiBTaW5jZSB0aGVyZSdzIG5vIGNsZXZlclxuICAgICAgICAgICAgICAgIC8vIHdheSB0byBzb2x2ZSBpdCB3aXRoIENTUyBzZWxlY3RvcnMsIGl0J3MgZG9uZSBsaWtlIHRoYXQuICgjMTE3ODMpLlxuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gaW1hZ2UuZ2V0QXNjZW5kYW50KCdhJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobGluayAmJiB0aGlzLndyYXBwZXIuY29udGFpbnMobGluaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5saW5rID0gbGluaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gY29uZmlndXJhdGlvbiwgcmVhZCBzdHlsZS9jbGFzcyBmcm9tIGVsZW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgaXQuIFJlbW92ZWQgc3R5bGUvY2xhc3Mgd2lsbCBiZSBzZXQgb24gd3JhcHBlciBpbiAjZGF0YSBsaXN0ZW5lci5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBDZW50ZXIgYWxpZ25tZW50IGlzIGRldGVjdGVkIGR1cmluZyB1cGNhc3QsIHNvIG9ubHkgbGVmdC9yaWdodCBjYXNlc1xuICAgICAgICAgICAgICAgIC8vIGFyZSBjaGVja2VkIGJlbG93LlxuICAgICAgICAgICAgICAgIGlmICghZGF0YS5hbGlnbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxpZ25FbGVtZW50ID0gZGF0YS5oYXNDYXB0aW9uID8gdGhpcy5lbGVtZW50IDogaW1hZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgaW5pdGlhbCBsZWZ0L3JpZ2h0IGFsaWdubWVudCBmcm9tIHRoZSBjbGFzcyBzZXQgb24gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWduQ2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWduRWxlbWVudC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxpZ25FbGVtZW50Lmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuYWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkVsZW1lbnQucmVtb3ZlQ2xhc3MoYWxpZ25DbGFzc2VzW2FsaWdubWVudHNPYmpbZGF0YS5hbGlnbl1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hbGlnbiA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIGluaXRpYWwgZmxvYXQgc3R5bGUgZnJvbSBmaWd1cmUvaW1hZ2UgYW5kIHRoZW4gcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYWxpZ24gPSBhbGlnbkVsZW1lbnQuZ2V0U3R5bGUoJ2Zsb2F0JykgfHwgJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25FbGVtZW50LnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHJpZCBvZiBleHRyYSB2ZXJ0aWNhbCBzcGFjZSB3aGVuIHRoZXJlJ3Mgbm8gY2FwdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBJdCB3aWxsIGltcHJvdmUgdGhlIGxvb2sgb2YgdGhlIHJlc2l6ZXIuXG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyWyhkYXRhLmhhc0NhcHRpb24gPyAncmVtb3ZlJyA6ICdhZGQnKSArICdDbGFzcyddKCdja2VfaW1hZ2Vfbm9jYXB0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLmNvbmZpZy5pbWFnZTJfZGlzYWJsZVJlc2l6ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNpemVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBkZWZhdWx0IG1ldGhvZCB0byBoYW5kbGUgaW50ZXJuYWwgbXV0YWJpbGl0eSBvZiBJbWFnZTIuXG4gICAgICAgICAgICAvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2FkZENsYXNzXG4gICAgICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFsbG93ZWRDb250ZW50OiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpLFxuXG4gICAgICAgICAgICAvLyBUaGlzIHdpZGdldCBjb252ZXJ0cyBzdHlsZS1kcml2ZW4gZGltZW5zaW9ucyB0byBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgY29udGVudFRyYW5zZm9ybWF0aW9uczogW1xuICAgICAgICAgICAgICAgIFsnaW1nW3dpZHRoXTogc2l6ZVRvQXR0cmlidXRlJ11cbiAgICAgICAgICAgIF0sXG5cbiAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuXG4gICAgICAgICAgICAgICAgLy8gSW1hZ2UgY2FuJ3QgYmUgY2FwdGlvbmVkIHdoZW4gZmlnY2FwdGlvbiBpcyBkaXNhbGxvd2VkICgjMTEwMDQpLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGFzQ2FwdGlvbiAmJiAhZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoZmVhdHVyZXMuY2FwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmhhc0NhcHRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJbWFnZSBjYW4ndCBiZSBhbGlnbmVkIHdoZW4gZmxvYXRpbmcgaXMgZGlzYWxsb3dlZCAoIzExMDA0KS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLmFsaWduICE9ICdub25lJyAmJiAhZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoZmVhdHVyZXMuYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hbGlnbiA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd2lkZ2V0LnBhcnRzLmxpbmsgc2luY2UgaXQgd2lsbCBub3QgYXV0by11cGRhdGUgdW5sZXNzIHdpZGdldFxuICAgICAgICAgICAgICAgIC8vIGlzIGRlc3Ryb3llZCBhbmQgcmUtaW5pdGVkLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kYXRhLmxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFydHMubGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucGFydHMubGluaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJ0cy5saW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLmxpbmsgPSB0aGlzLnBhcnRzLmltYWdlLmdldFBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5pbWFnZS5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgYWx0OiB0aGlzLmRhdGEuYWx0LFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogdGhpcy5wYXJ0cy5pbWFnZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID8gdGhpcy5wYXJ0cy5pbWFnZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpIDogdHJ1ZSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGludGVybmFsIGlzIHJlcXVpcmVkIGJ5IHRoZSBlZGl0b3IuXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLWNrZS1zYXZlZC1zcmMnOiB0aGlzLmRhdGEuc3JjLFxuXG4gICAgICAgICAgICAgICAgICAgIHNyYzogdGhpcy5kYXRhLnNyY1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc2hpZnRpbmcgbm9uLWNhcHRpb25lZCAtPiBjYXB0aW9uZWQsIHJlbW92ZSBjbGFzc2VzXG4gICAgICAgICAgICAgICAgLy8gcmVsYXRlZCB0byBzdHlsZXMgZnJvbSA8aW1nLz4uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2xkRGF0YSAmJiAhdGhpcy5vbGREYXRhLmhhc0NhcHRpb24gJiYgdGhpcy5kYXRhLmhhc0NhcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyBpbiB0aGlzLmRhdGEuY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5pbWFnZS5yZW1vdmVDbGFzcyhjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNldCBkaW1lbnNpb25zIG9mIHRoZSBpbWFnZSBhY2NvcmRpbmcgdG8gZ2F0aGVyZWQgZGF0YS5cbiAgICAgICAgICAgICAgICAvLyBEbyBpdCBvbmx5IHdoZW4gdGhlIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWQgKCMxMTAwNCkuXG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmRpbWVuc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGltZW5zaW9ucyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWNoZSBjdXJyZW50IGRhdGEuXG4gICAgICAgICAgICAgICAgdGhpcy5vbGREYXRhID0gQ0tFRElUT1IudG9vbHMuZXh0ZW5kKHt9LCB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZG93bmNhc3Q6IGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpLFxuXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBUaGlzIHdpZGdldCBoYXMgYW4gZWRpdGFibGUgY2FwdGlvbi5cbiAgICAgICAgICAgIGVkaXRhYmxlczoge1xuICAgICAgICAgICAgICAgIGNhcHRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWdjYXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZENvbnRlbnQ6ICdiciBlbSBzdHJvbmcgc3ViIHN1cCB1IHM7IGFbIWhyZWYsdGFyZ2V0XSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmZWF0dXJlczogZ2V0V2lkZ2V0RmVhdHVyZXMoZWRpdG9yKSxcblxuICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIEltYWdlMi5cbiAgICAgICAgICAgIC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjZ2V0Q2xhc3Nlc1xuICAgICAgICAgICAgZ2V0Q2xhc3NlczogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIFtdLmNvbmNhdChjYXB0aW9uZWRDbGFzcywgYWxpZ25DbGFzc2VzKS5qb2luKCd8JykgKyAnKSQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5yZXBvc2l0b3J5LnBhcnNlRWxlbWVudENsYXNzZXMoZ2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5laXRoZXIgY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcyBub3IgY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGJlbG9uZyB0byBzdHlsZSBjbGFzc2VzLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjIGluIGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc1JlZ2V4LnRlc3QoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2xhc3Nlc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpLFxuXG4gICAgICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9ICh0aGlzLmRhdGEuYWx0IHx8ICcnKSArICcgJyArIHRoaXMucGF0aE5hbWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuICAgICAgICAgICAgLy8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNoYXNDbGFzc1xuICAgICAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5oYXNDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICBjYXB0aW9uOiAnZmlnY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgaW1hZ2U6ICdpbWcnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuICAgICAgICAgICAgLy8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNyZW1vdmVDbGFzc1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBnZXRTdHlsZWFibGVFbGVtZW50KHRoaXMpLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXF1aXJlZENvbnRlbnQ6ICdpbWdbc3JjLGFsdF0nLFxuXG4gICAgICAgICAgICBzdHlsZWFibGVFbGVtZW50czogJ2ltZyBmaWd1cmUnLFxuXG4gICAgICAgICAgICAvLyBUZW1wbGF0ZSBvZiB0aGUgd2lkZ2V0OiBwbGFpbiBpbWFnZS5cbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblxuICAgICAgICAgICAgdXBjYXN0OiB1cGNhc3RXaWRnZXRFbGVtZW50KGVkaXRvcilcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBFbmhhbmNlZCBJbWFnZSAoaW1hZ2UyKSBwbHVnaW4gaGVscGVycy5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBzaW5nbGV0b25cbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmltYWdlMiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IGltYWdlIHJhdGlvIG1hdGNoZXMgdGhlIG5hdHVyYWwgb25lXG4gICAgICAgICAqIGJ5IGNvbXBhcmluZyBkaW1lbnNpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrSGFzTmF0dXJhbFJhdGlvOiBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICAgIHZhciAkID0gaW1hZ2UuJCxcbiAgICAgICAgICAgICAgICBuYXR1cmFsID0gdGhpcy5nZXROYXR1cmFsKGltYWdlKTtcblxuICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiBmb3IgdHdvIGFsdGVybmF0aXZlIGNvbXBhcmlzb25zIGlzIHRoYXQgdGhlIHJvdW5kaW5nIGNhbiBjb21lIGZyb21cbiAgICAgICAgICAgIC8vIGJvdGggZGltZW5zaW9ucywgZS5nLiB0aGVyZSBhcmUgdHdvIGNhc2VzOlxuICAgICAgICAgICAgLy8gXHQxLiBoZWlnaHQgaXMgY29tcHV0ZWQgYXMgYSByb3VuZGVkIHJlbGF0aW9uIG9mIHRoZSByZWFsIGhlaWdodCBhbmQgdGhlIHZhbHVlIG9mIHdpZHRoLFxuICAgICAgICAgICAgLy9cdDIuIHdpZHRoIGlzIGNvbXB1dGVkIGFzIGEgcm91bmRlZCByZWxhdGlvbiBvZiB0aGUgcmVhbCB3aWR0aCBhbmQgdGhlIHZhbHVlIG9mIGhlaWdoLlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoJC5jbGllbnRXaWR0aCAvIG5hdHVyYWwud2lkdGggKiBuYXR1cmFsLmhlaWdodCkgPT0gJC5jbGllbnRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCQuY2xpZW50SGVpZ2h0IC8gbmF0dXJhbC5oZWlnaHQgKiBuYXR1cmFsLndpZHRoKSA9PSAkLmNsaWVudFdpZHRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIG5hdHVyYWwgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UuIEZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICogaXQgdXNlcyBuYXR1cmFsKFdpZHRofEhlaWdodCkuIEZvciBvbGQgb25lcyAoSUU4KSBpdCBjcmVhdGVzXG4gICAgICAgICAqIGEgbmV3IGltYWdlIGFuZCByZWFkcyB0aGUgZGltZW5zaW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldE5hdHVyYWw6IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnM7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZS4kLm5hdHVyYWxXaWR0aCkge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW1hZ2UuJC5uYXR1cmFsSGVpZ2gsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZS4kLm5hdHVyYWxXaWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWcuaGVpZ2gsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWcud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB3aWRnZXRzIGZyb20gYWxsIDxpbWc+IGFuZFxuICAgIC8vIDxmaWd1cmUgY2xhc3M9XCJ7Y29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzc31cIj4gZWxlbWVudHMuXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn0gZWRpdG9yXG4gICAgLy8gQHJldHVybnMge0Z1bmN0aW9ufVxuICAgIGZ1bmN0aW9uIHVwY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSB7XG4gICAgICAgIHZhciBpc0NlbnRlcldyYXBwZXIgPSBjZW50ZXJXcmFwcGVyQ2hlY2tlcihlZGl0b3IpO1xuXG4gICAgICAgIHZhciBjYXB0aW9uZWRDbGFzcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzO1xuXG4gICAgICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbFxuICAgICAgICAvLyBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDFcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBuYW1lID0gZWwubmFtZTtcblxuICAgICAgICAgICAgdmFyIGltYWdlO1xuXG4gICAgICAgICAgICAvLyAjMTExMTAgRG9uJ3QgaW5pdGlhbGl6ZSBvbiBwYXN0ZWQgZmFrZSBvYmplY3RzLlxuICAgICAgICAgICAgaWYgKGVsLmF0dHJpYnV0ZXNbJ2RhdGEtY2tlLXJlYWxlbGVtZW50J10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGEgY2VudGVyIHdyYXBwZXIgaXMgZm91bmQsIHRoZXJlIGFyZSAzIHBvc3NpYmxlIGNhc2VzOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDEuIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxmaWd1cmU+Li4uPC9maWd1cmU+PC9kaXY+LlxuICAgICAgICAgICAgLy8gICAgSW4gdGhpcyBjYXNlIGNlbnRlcmluZyBpcyBkb25lIHdpdGggYSBjbGFzcyBzZXQgb24gd2lkZ2V0LndyYXBwZXIuXG4gICAgICAgICAgICAvLyAgICBTaW1wbHkgcmVwbGFjZSBjZW50ZXJpbmcgd3JhcHBlciB3aXRoIGZpZ3VyZSAoaXQncyBubyBsb25nZXIgbmVjZXNzYXJ5KS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAyLiA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9wPi5cbiAgICAgICAgICAgIC8vICAgIE5vdGhpbmcgdG8gZG8gaGVyZTogPHA+IHJlbWFpbnMgZm9yIHN0eWxpbmcgcHVycG9zZXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMy4gPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9kaXY+LlxuICAgICAgICAgICAgLy8gICAgTm90aGluZyB0byBkbyBoZXJlICgyLikgYnV0IHRoYXQgY2FzZSBpcyBvbmx5IHBvc3NpYmxlIGluIGVudGVyTW9kZSBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vICAgIHRoYW4gRU5URVJfUC5cbiAgICAgICAgICAgIGlmIChpc0NlbnRlcldyYXBwZXIoZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gJ2RpdicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZ3VyZSA9IGVsLmdldEZpcnN0KCdmaWd1cmUnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYXNlICMxLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlndXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZXBsYWNlV2l0aChmaWd1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBmaWd1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FzZXMgIzIgYW5kICMzIChoYW5kbGVkIHRyYW5zcGFyZW50bHkpXG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY2VudGVyaW5nIHdyYXBwZXIsIHNhdmUgaXQgaW4gZGF0YS5cbiAgICAgICAgICAgICAgICBkYXRhLmFsaWduID0gJ2NlbnRlcic7XG5cbiAgICAgICAgICAgICAgICAvLyBJbWFnZSBjYW4gYmUgd3JhcHBlZCBpbiBsaW5rIDxhPjxpbWcvPjwvYT4uXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBlbC5nZXRGaXJzdCgnaW1nJykgfHwgZWwuZ2V0Rmlyc3QoJ2EnKS5nZXRGaXJzdCgnaW1nJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGNlbnRlciB3cmFwcGVyIGhhcyBiZWVuIGZvdW5kLlxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PSAnZmlndXJlJyAmJiBlbC5oYXNDbGFzcyhjYXB0aW9uZWRDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwY2FzdCBsaW5rZWQgaW1hZ2UgbGlrZSA8YT48aW1nLz48L2E+LlxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGVsKSkge1xuICAgICAgICAgICAgICAgIGltYWdlID0gZWwubmFtZSA9PSAnYScgPyBlbC5jaGlsZHJlblswXSA6IGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGltYWdlLCB0aGVuIGNvb2wsIHdlIGdvdCBhIHdpZGdldC5cbiAgICAgICAgICAgIC8vIE5vdyBqdXN0IHJlbW92ZSBkaW1lbnNpb24gYXR0cmlidXRlcyBleHByZXNzZWQgd2l0aCAlLlxuICAgICAgICAgICAgZm9yICh2YXIgZCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGltYWdlLmF0dHJpYnV0ZXNbZF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9uICYmIGRpbWVuc2lvbi5tYXRjaChyZWdleFBlcmNlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbWFnZS5hdHRyaWJ1dGVzW2RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0cmFuc2Zvcm1zIHRoZSB3aWRnZXQgdG8gdGhlIGV4dGVybmFsIGZvcm1hdFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG4gICAgZnVuY3Rpb24gZG93bmNhc3RXaWRnZXRFbGVtZW50KGVkaXRvcikge1xuICAgICAgICB2YXIgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzO1xuXG4gICAgICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIDxhPjxpbWcvPjwvYT4sIDxpbWcvPiBpcyB0aGUgZWxlbWVudCB0byBob2xkXG4gICAgICAgICAgICAvLyBpbmxpbmUgc3R5bGVzIG9yIGNsYXNzZXMgKGltYWdlMl9hbGlnbkNsYXNzZXMpLlxuICAgICAgICAgICAgdmFyIGF0dHJzSG9sZGVyID0gZWwubmFtZSA9PSAnYScgPyBlbC5nZXRGaXJzdCgpIDogZWw7XG5cbiAgICAgICAgICAgIHZhciBhdHRycyA9IGF0dHJzSG9sZGVyLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIHZhciBhbGlnbiA9IHRoaXMuZGF0YS5hbGlnbjtcblxuICAgICAgICAgICAgLy8gRGUtd3JhcCB0aGUgaW1hZ2UgZnJvbSByZXNpemUgaGFuZGxlIHdyYXBwZXIuXG4gICAgICAgICAgICAvLyBPbmx5IGJsb2NrIHdpZGdldHMgaGF2ZSBvbmUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZVdyYXBwZXIgPSBlbC5nZXRGaXJzdCgnc3BhbicpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZVdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplV3JhcHBlci5yZXBsYWNlV2l0aChyZXNpemVXcmFwcGVyLmdldEZpcnN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWc6IDFcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsaWduICYmIGFsaWduICE9ICdub25lJykge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSBDS0VESVRPUi50b29scy5wYXJzZUNzc1RleHQoYXR0cnMuc3R5bGUgfHwgJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgd2lkZ2V0IGlzIGNhcHRpb25lZCAoPGZpZ3VyZT4pIGFuZCBpbnRlcm5hbGx5IGNlbnRlcmluZyBpcyBkb25lXG4gICAgICAgICAgICAgICAgLy8gd2l0aCB3aWRnZXQncyB3cmFwcGVyIHN0eWxlL2NsYXNzLCBpbiB0aGUgZXh0ZXJuYWwgZGF0YSByZXByZXNlbnRhdGlvbixcbiAgICAgICAgICAgICAgICAvLyA8ZmlndXJlPiBtdXN0IGJlIHdyYXBwZWQgd2l0aCBhbiBlbGVtZW50IGhvbGRpbmcgYW4gc3R5bGUvY2xhc3M6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBcdDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPlxuICAgICAgICAgICAgICAgIC8vIFx0XHQ8ZmlndXJlIGNsYXNzPVwiaW1hZ2VcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrXCI+Li4uPC9maWd1cmU+XG4gICAgICAgICAgICAgICAgLy8gXHQ8L2Rpdj5cbiAgICAgICAgICAgICAgICAvLyBvclxuICAgICAgICAgICAgICAgIC8vIFx0PGRpdiBjbGFzcz1cInNvbWUtY2VudGVyLWNsYXNzXCI+XG4gICAgICAgICAgICAgICAgLy8gXHRcdDxmaWd1cmUgY2xhc3M9XCJpbWFnZVwiPi4uLjwvZmlndXJlPlxuICAgICAgICAgICAgICAgIC8vIFx0PC9kaXY+XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoYWxpZ24gPT0gJ2NlbnRlcicgJiYgZWwubmFtZSA9PSAnZmlndXJlJykge1xuICAgICAgICAgICAgICAgICAgICBlbCA9IGVsLndyYXBXaXRoKG5ldyBDS0VESVRPUi5odG1sUGFyc2VyLmVsZW1lbnQoJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkNsYXNzZXMgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogYWxpZ25DbGFzc2VzWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGV4dC1hbGlnbjpjZW50ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgbGVmdC9yaWdodCwgYWRkIGZsb2F0IHN0eWxlIHRvIHRoZSBkb3duY2FzdGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpZ24gaW4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAxXG4gICAgICAgICAgICAgICAgICAgIH0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWduQ2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNIb2xkZXIuYWRkQ2xhc3MoYWxpZ25DbGFzc2VzW2FsaWdubWVudHNPYmpbYWxpZ25dXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbJ2Zsb2F0J10gPSBhbGlnbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBlbGVtZW50IHN0eWxlcy5cbiAgICAgICAgICAgICAgICBpZiAoIWFsaWduQ2xhc3NlcyAmJiAhQ0tFRElUT1IudG9vbHMuaXNFbXB0eShzdHlsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnN0eWxlID0gQ0tFRElUT1IudG9vbHMud3JpdGVDc3NUZXh0KHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGFuIGVsZW1lbnQgaXMgYSBjZW50ZXJpbmcgd3JhcHBlci5cbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfSBlZGl0b3JcbiAgICAvLyBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgZnVuY3Rpb24gY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKSB7XG4gICAgICAgIHZhciBjYXB0aW9uZWRDbGFzcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzO1xuXG4gICAgICAgIHZhciBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXM7XG5cbiAgICAgICAgdmFyIHZhbGlkQ2hpbGRyZW4gPSB7XG4gICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgZmlndXJlOiAxLFxuICAgICAgICAgICAgaW1nOiAxXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gV3JhcHBlciBtdXN0IGJlIGVpdGhlciA8ZGl2PiBvciA8cD4uXG4gICAgICAgICAgICBpZiAoIShlbC5uYW1lIGluIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2OiAxLFxuICAgICAgICAgICAgICAgICAgICBwOiAxXG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXG4gICAgICAgICAgICAvLyBDZW50ZXJpbmcgd3JhcHBlciBjYW4gaGF2ZSBvbmx5IG9uZSBjaGlsZC5cbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICAvLyBPbmx5IDxmaWd1cmU+IG9yIDxpbWcgLz4gY2FuIGJlIGZpcnN0IChvbmx5KSBjaGlsZCBvZiBjZW50ZXJpbmcgd3JhcHBlcixcbiAgICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgaXRzIHR5cGUuXG4gICAgICAgICAgICBpZiAoIShjaGlsZC5uYW1lIGluIHZhbGlkQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBjZW50ZXJpbmcgd3JhcHBlciBpcyA8cD4sIG9ubHkgPGltZyAvPiBjYW4gYmUgdGhlIGNoaWxkLlxuICAgICAgICAgICAgLy8gICA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZyAvPjwvcD5cbiAgICAgICAgICAgIGlmIChlbC5uYW1lID09ICdwJykge1xuICAgICAgICAgICAgICAgIGlmICghaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENlbnRlcmluZyA8ZGl2PiBjYW4gaG9sZCA8aW1nLz4gb3IgPGZpZ3VyZT4sIGRlcGVuZGluZyBvbiBlbnRlck1vZGUuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIDxmaWd1cmU+IGlzIHRoZSBmaXJzdCAob25seSkgY2hpbGQsIGl0IG11c3QgaGF2ZSBhIGNsYXNzLlxuICAgICAgICAgICAgICAgIC8vICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGZpZ3VyZT4uLi48L2ZpZ3VyZT48ZGl2PlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5uYW1lID09ICdmaWd1cmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQuaGFzQ2xhc3MoY2FwdGlvbmVkQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXJpbmcgPGRpdj4gY2FuIGhvbGQgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4gb25seSB3aGVuIGVudGVyTW9kZVxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBFTlRFUl8oQlJ8RElWKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nIC8+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGE+PGltZyAvPjwvYT48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRvci5lbnRlck1vZGUgPT0gQ0tFRElUT1IuRU5URVJfUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiBlbnRlck1vZGUsIGEgY2hpbGQgd2hpY2ggaXMgbm90IDxmaWd1cmU+IG11c3QgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIDxpbWcvPiBvciA8YT48aW1nLz48L2E+LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENlbnRlcmluZyB3cmFwcGVyIGdvdCB0byBiZS4uLiBjZW50ZXJpbmcuIElmIGltYWdlMl9hbGlnbkNsYXNzZXMgYXJlIGRlZmluZWQsXG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgY2VudGVyaW5nIGNsYXNzLiBPdGhlcndpc2UsIGNoZWNrIHRoZSBzdHlsZS5cbiAgICAgICAgICAgIGlmIChhbGlnbkNsYXNzZXMgPyBlbC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMV0pIDpcbiAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5wYXJzZUNzc1RleHQoZWwuYXR0cmlidXRlcy5zdHlsZSB8fCAnJywgdHJ1ZSlbJ3RleHQtYWxpZ24nXSA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZWxlbWVudCBpcyA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPi5cbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fVxuICAgIGZ1bmN0aW9uIGlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoZWwpIHtcbiAgICAgICAgaWYgKGVsLm5hbWUgPT0gJ2ltZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsLm5hbWUgPT0gJ2EnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuY2hpbGRyZW4ubGVuZ3RoID09IDEgJiYgZWwuZ2V0Rmlyc3QoJ2ltZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNldHMgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgd2lkZ2V0IGltYWdlIGFjY29yZGluZyB0byBjdXJyZW50IHdpZGdldCBkYXRhLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH0gd2lkZ2V0XG4gICAgZnVuY3Rpb24gc2V0RGltZW5zaW9ucyh3aWRnZXQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB3aWRnZXQuZGF0YTtcblxuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIGhlaWdodDogZGF0YS5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogZGF0YS53aWR0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpbWFnZSA9IHdpZGdldC5wYXJ0cy5pbWFnZTtcblxuICAgICAgICBmb3IgKHZhciBkIGluIGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25zW2RdKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKGQsIGRpbWVuc2lvbnNbZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZpbmVzIGFsbCBmZWF0dXJlcyByZWxhdGVkIHRvIGRyYWctZHJpdmVuIGltYWdlIHJlc2l6aW5nLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH0gd2lkZ2V0XG4gICAgZnVuY3Rpb24gc2V0dXBSZXNpemVyKHdpZGdldCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gd2lkZ2V0LmVkaXRvcjtcblxuICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICB2YXIgZG9jID0gZWRpdG9yLmRvY3VtZW50O1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSByZXNpemVyIGluIGEgd2lkZ2V0IGZvciB0ZXN0aW5nICgjMTEwMDQpLlxuICAgICAgICB2YXIgcmVzaXplciA9IHdpZGdldC5yZXNpemVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuICAgICAgICByZXNpemVyLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcicpO1xuICAgICAgICByZXNpemVyLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl8nICsgY3Vyc29yW2VkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZV0pO1xuICAgICAgICByZXNpemVyLmFwcGVuZChuZXcgQ0tFRElUT1IuZG9tLnRleHQoJ1xcdTIwMGInLCBkb2MpKTtcblxuICAgICAgICAvLyBJbmxpbmUgd2lkZ2V0cyBkb24ndCBuZWVkIGEgcmVzaXplciB3cmFwcGVyIGFzIGFuIGltYWdlIHNwYW5zIHRoZSBlbnRpcmUgd2lkZ2V0LlxuICAgICAgICBpZiAoIXdpZGdldC5pbmxpbmUpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZU9yTGluayA9IHdpZGdldC5wYXJ0cy5saW5rIHx8IHdpZGdldC5wYXJ0cy5pbWFnZTtcblxuICAgICAgICAgICAgdmFyIG9sZFJlc2l6ZVdyYXBwZXIgPSBpbWFnZU9yTGluay5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgdmFyIHJlc2l6ZVdyYXBwZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgICAgICAgICByZXNpemVXcmFwcGVyLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl93cmFwcGVyJyk7XG4gICAgICAgICAgICByZXNpemVXcmFwcGVyLmFwcGVuZChpbWFnZU9yTGluayk7XG4gICAgICAgICAgICByZXNpemVXcmFwcGVyLmFwcGVuZChyZXNpemVyKTtcbiAgICAgICAgICAgIHdpZGdldC5lbGVtZW50LmFwcGVuZChyZXNpemVXcmFwcGVyLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgd3JhcHBlciB3aGljaCBjb3VsZCBjYW1lIGZyb20gZS5nLiBwYXN0ZWQgSFRNTFxuICAgICAgICAgICAgLy8gYW5kIHdoaWNoIGNvdWxkIGJlIGNvcnJ1cHRlZCAoZS5nLiByZXNpemVyIHNwYW4gaGFzIGJlZW4gbG9zdCkuXG4gICAgICAgICAgICBpZiAob2xkUmVzaXplV3JhcHBlci5pcygnc3BhbicpKSB7XG4gICAgICAgICAgICAgICAgb2xkUmVzaXplV3JhcHBlci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpZGdldC53cmFwcGVyLmFwcGVuZChyZXNpemVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB2YWx1ZXMgb2Ygc2l6ZSB2YXJpYWJsZXMgYW5kIG1vdXNlIG9mZnNldHMuXG4gICAgICAgIHJlc2l6ZXIub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHdpZGdldC5wYXJ0cy5pbWFnZTtcblxuICAgICAgICAgICAgLy8gXCJmYWN0b3JcIiBjYW4gYmUgZWl0aGVyIDEgb3IgLTEuIEkuZS46IEZvciByaWdodC1hbGlnbmVkIGltYWdlcywgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gc3VidHJhY3QgdGhlIGRpZmZlcmVuY2UgdG8gZ2V0IHByb3BlciB3aWR0aCwgZXRjLiBXaXRob3V0IFwiZmFjdG9yXCIsXG4gICAgICAgICAgICAvLyByZXNpemVyIHN0YXJ0cyB3b3JraW5nIHRoZSBvcHBvc2l0ZSB3YXkuXG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gd2lkZ2V0LmRhdGEuYWxpZ24gPT0gJ3JpZ2h0JyA/IC0xIDogMTtcblxuICAgICAgICAgICAgLy8gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgbW91c2UgcmVsYXRpdmUgdG8gdGhlIHNjcmVlblxuICAgICAgICAgICAgLy8gd2hlbiBidXR0b24gZ2V0cyBwcmVzc2VkLlxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGV2dC5kYXRhLiQuc2NyZWVuWDtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IGV2dC5kYXRhLiQuc2NyZWVuWTtcblxuICAgICAgICAgICAgLy8gVGhlIGluaXRpYWwgZGltZW5zaW9ucyBhbmQgYXNwZWN0IHJhdGlvIG9mIHRoZSBpbWFnZS5cbiAgICAgICAgICAgIHZhciBzdGFydFdpZHRoID0gaW1hZ2UuJC5jbGllbnRXaWR0aDtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0SGVpZ2h0ID0gaW1hZ2UuJC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQSBjbGFzcyBhcHBsaWVkIHRvIGVkaXRhYmxlIGR1cmluZyByZXNpemluZy5cbiAgICAgICAgICAgIHZhciBjdXJzb3JDbGFzcyA9ICdja2VfaW1hZ2VfcycgKyAoIX5mYWN0b3IgPyAndycgOiAnZScpO1xuXG4gICAgICAgICAgICB2YXIgbmF0aXZlRXZ0LCBuZXdXaWR0aCwgbmV3SGVpZ2h0LCB1cGRhdGVEYXRhO1xuXG4gICAgICAgICAgICB2YXIgbW92ZURpZmZYLCBtb3ZlRGlmZlksIG1vdmVSYXRpbztcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgdW5kbyBzbmFwc2hvdCBmaXJzdDogYmVmb3JlIHJlc2l6aW5nLlxuICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ3NhdmVTbmFwc2hvdCcpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZW1vdmUgbGlzdGVuZXJzIGFyZSByZW1vdmVkIG9uIG1vdXNldXAuXG4gICAgICAgICAgICBhdHRhY2hUb0RvY3VtZW50cygnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGxpc3RlbmVycyk7XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBtb3VzZW1vdmUgbGlzdGVuZXIuIFVwZGF0ZSB3aWRnZXQgZGF0YSBpZiB2YWxpZC5cbiAgICAgICAgICAgIGF0dGFjaFRvRG9jdW1lbnRzKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBsaXN0ZW5lcnMpO1xuXG4gICAgICAgICAgICAvLyBUaGUgZW50aXJlIGVkaXRhYmxlIHdpbGwgaGF2ZSB0aGUgc3BlY2lhbCBjdXJzb3Igd2hpbGUgcmVzaXppbmcgZ29lcyBvbi5cbiAgICAgICAgICAgIGVkaXRhYmxlLmFkZENsYXNzKGN1cnNvckNsYXNzKTtcblxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0byBhbHdheXMga2VlcCB0aGUgcmVzaXplciBlbGVtZW50IHZpc2libGUgd2hpbGUgcmVzaXppbmcuXG4gICAgICAgICAgICByZXNpemVyLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXppbmcnKTtcblxuICAgICAgICAgICAgLy8gQXR0YWNoZXMgYW4gZXZlbnQgdG8gYSBnbG9iYWwgZG9jdW1lbnQgaWYgaW5saW5lIGVkaXRvci5cbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWxseSwgaWYgY2xhc3NpYyAoYGlmcmFtZWAtYmFzZWQpIGVkaXRvciwgYWxzbyBhdHRhY2hlcyB0aGUgc2FtZSBldmVudCB0byBgaWZyYW1lYCdzIGRvY3VtZW50LlxuICAgICAgICAgICAgZnVuY3Rpb24gYXR0YWNoVG9Eb2N1bWVudHMobmFtZSwgY2FsbGJhY2ssIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsRG9jID0gQ0tFRElUT1IuZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRvYy5lcXVhbHMoZ2xvYmFsRG9jKSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChnbG9iYWxEb2Mub24obmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChkb2Mub24obmFtZSwgY2FsbGJhY2spKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2gobGlzdGVuZXJzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhpcyBpcyBob3cgdmFyaWFibGVzIHJlZmVyIHRvIHRoZSBnZW9tZXRyeS5cbiAgICAgICAgICAgIC8vIE5vdGU6IHggY29ycmVzcG9uZHMgdG8gbW92ZU9mZnNldCwgdGhpcyBpcyB0aGUgcG9zaXRpb24gb2YgbW91c2VcbiAgICAgICAgICAgIC8vIE5vdGU6IG8gY29ycmVzcG9uZHMgdG8gW3N0YXJ0WCwgc3RhcnRZXS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBcdCstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgIC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgLy8gXHR8ICAgICAgSSAgICAgICB8ICAgICAgSUkgICAgICB8XG4gICAgICAgICAgICAvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgIC8vIFx0Ky0tLS0tLS0tLS0tLS0gbyAtLS0tLS0tLS0tLS0tKyBfIF8gX1xuICAgICAgICAgICAgLy8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgXlxuXG4gICAgICAgICAgICAvLyBcdHwgICAgICBWSSAgICAgIHwgICAgIElJSSAgICAgIHwgICAgICB8IG1vdmVEaWZmWVxuICAgICAgICAgICAgLy8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgeCBfIF8gXyBfIF8gdlxuICAgICAgICAgICAgLy8gXHQrLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tfC0tLS0rXG4gICAgICAgICAgICAvLyBcdCAgICAgICAgICAgICAgIHwgICAgICAgICB8XG4gICAgICAgICAgICAvLyBcdCAgICAgICAgICAgICAgICA8LS0tLS0tLT5cbiAgICAgICAgICAgIC8vIFx0ICAgICAgICAgICAgICAgIG1vdmVEaWZmWFxuICAgICAgICAgICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlU2NhbGVSZXNpemUgPSBlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemU7XG5cbiAgICAgICAgICAgICAgICBuYXRpdmVFdnQgPSBldnQuZGF0YS4kO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBob3cgZmFyIHRoZSBtb3VzZSBpcyBmcm9tIHRoZSBwb2ludCB0aGUgYnV0dG9uIHdhcyBwcmVzc2VkLlxuICAgICAgICAgICAgICAgIG1vdmVEaWZmWCA9IG5hdGl2ZUV2dC5zY3JlZW5YIC0gc3RhcnRYO1xuICAgICAgICAgICAgICAgIG1vdmVEaWZmWSA9IHN0YXJ0WSAtIG5hdGl2ZUV2dC5zY3JlZW5ZO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBtb3ZlIGRpZmZlcmVuY2UuXG4gICAgICAgICAgICAgICAgbW92ZVJhdGlvID0gTWF0aC5hYnMobW92ZURpZmZYIC8gbW92ZURpZmZZKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbWFnZVNjYWxlUmVzaXplID09PSAnd2lkdGgnIHx8IGltYWdlU2NhbGVSZXNpemUgPT09ICdib3RoJyB8fCBpbWFnZVNjYWxlUmVzaXplID09PSAnc2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIGZhY3RvciAqIG1vdmVEaWZmWDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ2hlaWdodCcgfHwgaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHN0YXJ0SGVpZ2h0IC0gbW92ZURpZmZZO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbWFnZVNjYWxlUmVzaXplID09PSAnc2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdXaWR0aCA9IG5ld1dpZHRoIHx8IHN0YXJ0V2lkdGg7XG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0IHx8IHN0YXJ0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIGF0dHJpYnV0ZXMgaWYgbGVzcyB0aGFuIDEwLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBpbWFnZXMgdG8gdmlzdWFsbHkgZGlzYXBwZWFyLlxuICAgICAgICAgICAgICAgIGlmIChuZXdXaWR0aCA+PSAxNSAmJiAobmV3SGVpZ2h0ID49IDE1IHx8IG5ld0hlaWdodCA9PT0gJ2F1dG8nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGw7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGwgPSBsaXN0ZW5lcnMucG9wKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGwucmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGRlZmF1bHQgY3Vyc29yIGJ5IHJlbW92aW5nIHNwZWNpYWwgY2xhc3MuXG4gICAgICAgICAgICAgICAgZWRpdGFibGUucmVtb3ZlQ2xhc3MoY3Vyc29yQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0byBicmluZyBiYWNrIHRoZSByZWd1bGFyIGJlaGF2aW91ciBvZiB0aGUgcmVzaXplci5cbiAgICAgICAgICAgICAgICByZXNpemVyLnJlbW92ZUNsYXNzKCdja2VfaW1hZ2VfcmVzaXppbmcnKTtcblxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldC5zZXREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgYW5vdGhlciB1bmRvIHNuYXBzaG90OiBhZnRlciByZXNpemluZy5cbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ3NhdmVTbmFwc2hvdCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvbid0IHVwZGF0ZSBkYXRhIHR3aWNlIG9yIG1vcmUuXG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSB3aWRnZXQgcmVzaXplciB3aGVuIGRhdGEgY2hhbmdlcy5cbiAgICAgICAgd2lkZ2V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzaXplclt3aWRnZXQuZGF0YS5hbGlnbiA9PSAncmlnaHQnID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKCdja2VfaW1hZ2VfcmVzaXplcl9sZWZ0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdpZGdldC5wYXJ0cy5pbWFnZS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGVkaXRvci5fLmVkaXRhYmxlLmVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RFbGVtZW50KHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IGVkaXRvci5fLmVkaXRhYmxlLmVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25EYXRhOiBzZWxlY3Rpb25EYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIHNldCBvZiB3aWRnZXQgYWxsb3dlZENvbnRlbnQgcnVsZXMsIGRlcGVuZGluZ1xuICAgIC8vIG9uIGNvbmZpZ3VyYXRpb25zIGxpa2UgY29uZmlnI2ltYWdlMl9hbGlnbkNsYXNzZXMgb3JcbiAgICAvLyBjb25maWcjaW1hZ2UyX2NhcHRpb25lZENsYXNzLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG4gICAgLy8gQHJldHVybnMge09iamVjdH1cbiAgICBmdW5jdGlvbiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0ge1xuICAgICAgICAgICAgZmlnY2FwdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZpZ3VyZToge1xuICAgICAgICAgICAgICAgIGNsYXNzZXM6ICchJyArIGVkaXRvci5jb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1nOiB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogJyFzcmMsYWx0LHdpZHRoLGhlaWdodCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIHNldCBvZiB3aWRnZXQgZmVhdHVyZSBydWxlcywgZGVwZW5kaW5nXG4gICAgLy8gb24gZWRpdG9yIGNvbmZpZ3VyYXRpb24uIE5vdGUgdGhhdCB0aGUgZm9sbG93aW5nIG1heSBub3QgY292ZXJcbiAgICAvLyBhbGwgdGhlIHBvc3NpYmxlIGNhc2VzIHNpbmNlIHJlcXVpcmVkQ29udGVudCBzdXBwb3J0cyBhIHNpbmdsZVxuICAgIC8vIHRhZyBvbmx5LlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG4gICAgLy8gQHJldHVybnMge09iamVjdH1cbiAgICBmdW5jdGlvbiBnZXRXaWRnZXRGZWF0dXJlcyhlZGl0b3IpIHtcbiAgICAgICAgdmFyIGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuICAgICAgICB2YXIgZmVhdHVyZXMgPSB7XG4gICAgICAgICAgICBhbGlnbjoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGVudDogJ2ltZycgK1xuICAgICAgICAgICAgICAgICAgICAoYWxpZ25DbGFzc2VzID8gJygnICsgYWxpZ25DbGFzc2VzWzBdICsgJyknIDogJ3tmbG9hdH0nKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhcHRpb246IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZENvbnRlbnQ6ICdmaWdjYXB0aW9uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGVudDogJ2ltZ1t3aWR0aCxoZWlnaHRdJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGVsZW1lbnQgd2hpY2ggaXMgc3R5bGVkLCBjb25zaWRlcmluZyBjdXJyZW50XG4gICAgLy8gc3RhdGUgb2YgdGhlIHdpZGdldC5cbiAgICAvL1xuICAgIC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjYXBwbHlTdHlsZVxuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuICAgIC8vIEByZXR1cm5zIHtDS0VESVRPUi5kb20uZWxlbWVudH1cbiAgICBmdW5jdGlvbiBnZXRTdHlsZWFibGVFbGVtZW50KHdpZGdldCkge1xuICAgICAgICByZXR1cm4gd2lkZ2V0LmRhdGEuaGFzQ2FwdGlvbiA/IHdpZGdldC5lbGVtZW50IDogd2lkZ2V0LnBhcnRzLmltYWdlO1xuICAgIH1cbn0pKCk7XG5cbkNLRURJVE9SLmNvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3MgPSAnaW1hZ2UnOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2VtYmVkJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBSRUdFWF9IVFRQID0gL15odHRwcz8vO1xuXG4gICAgdmFyIFJFR0VYX0RFRkFVTFRfTElOSyA9IC88YSBocmVmPS87XG5cbiAgICB2YXIgUFJPVklERVJTID0gWyd5b3V0dWJlJywgJ3R3aXR0ZXInXTtcblxuICAgIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfVVJMX1RQTCA9ICdodHRwOi8vYWxsb3kuaWZyYW1lLmx5L2FwaS9vZW1iZWQ/dXJsPXt1cmx9JmNhbGxiYWNrPXtjYWxsYmFja30nO1xuICAgIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTCA9ICc8ZGl2IGRhdGEtYWUtZW1iZWQtdXJsPVwie3VybH1cIj48L2Rpdj4nO1xuICAgIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCA9ICc8YSBocmVmPVwie3VybH1cIj57dXJsfTwvYT4nO1xuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhZGRzIHRoZSBpbmZyYXN0cnVjdHVyZSB0byBlbWJlZCB1cmxzIGFzIG1lZGlhIG9iamVjdHMgdXNpbmcgYW4gb2VtYmVkXG4gICAgICogc2VydmljZS4gQnkgZGVmYXVsdCwgYW5kIGZvciBkZW1vaW5nIHB1cnBvc2VzIG9ubHksIHRoZSBvZW1iZWQgc2VydmljZSBpcyBob3N0ZWQgaW4gaWZyYW1lLmx5XG4gICAgICogYXQgLy9hbGxveS5pZnJhbWUubHkvYXBpL29lbWJlZD91cmw9e3VybH0mY2FsbGJhY2s9e2NhbGxiYWNrfS4gTm90ZSB0aGlzIHNob3VsZCBiZSBjaGFuZ2VkIHRvXG4gICAgICogYSBzZWxmLWhvc3RlZCBvciBwYWlkIHNlcnZpY2UgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMuIEFjY2VzcyB0byB0aGUgYWxsb3kuaWZyYW1lLmx5IGVuZHBvaW50XG4gICAgICogbWF5IGJlIHJlc3RyaWN0ZWQgcGVyIGRvbWFpbiBkdWUgdG8gc2lnbmlmaWNhbnQgdHJhZmZpYy5cbiAgICAgKlxuICAgICAqIFRoaXMgcGx1Z2luIGFkZHMgYW4gYGVtYmVkVXJsYCBjb21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgdG8gZWFzaWx5IGVtYmVkIGEgVVJMIGFuZCB0cmFuc2Zvcm0gaXRcbiAgICAgKiB0byBhbiBlbWJlZGRlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfZW1iZWRcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2VtYmVkJywge1xuICAgICAgICAgICAgcmVxdWlyZXM6ICd3aWRnZXQnLFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIEFFX0VNQkVEX1VSTF9UUEwgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoZWRpdG9yLmNvbmZpZy5lbWJlZFVybFRlbXBsYXRlIHx8IENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfVVJMX1RQTCk7XG4gICAgICAgICAgICAgICAgdmFyIEFFX0VNQkVEX1dJREdFVF9UUEwgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoZWRpdG9yLmNvbmZpZy5lbWJlZFdpZGdldFRwbCB8fCBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1dJREdFVF9UUEwpO1xuICAgICAgICAgICAgICAgIHZhciBBRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMID0gbmV3IENLRURJVE9SLnRlbXBsYXRlKGVkaXRvci5jb25maWcuZW1iZWRMaW5rRGVmYXVsdFRwbCB8fCBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBmdW5jdGlvbiB0byB1cGNhc3QgRE9NIGVsZW1lbnRzIHRvIGVtYmVkIHdpZGdldHMuXG4gICAgICAgICAgICAgICAgLy8gSXQgbWF0Y2hlcyBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1dJREdFVF9UUExcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm4gPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm5hbWUgPT09ICdkaXYnICYmIGVsZW1lbnQuYXR0cmlidXRlc1snZGF0YS1hZS1lbWJlZC11cmwnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS51cmwgPSBlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtYWUtZW1iZWQtdXJsJ107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGVtYmVkVXJsIGNvbW1hbmQgdGhhdCBjYW4gYmUgaW52b2tlZCB0byBlYXNpbHkgZW1iZWQgbWVkaWEgVVJMc1xuICAgICAgICAgICAgICAgIGVkaXRvci5hZGRDb21tYW5kKCdlbWJlZFVybCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaW5zZXJ0SHRtbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBRV9FTUJFRF9XSURHRVRfVFBMLm91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGF0YS51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgd2lkZ2V0IHRvIHByb3Blcmx5IGhhbmRsZSBlbWJlZCBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgZWRpdG9yLndpZGdldHMuYWRkKCdhZV9lbWJlZCcsIHtcblxuXG4gICAgICAgICAgICAgICAgICAgIG1hc2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGVudDogJ2RpdltkYXRhLWFlLWVtYmVkLXVybF0nLFxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBMaXN0ZW5lciB0byBiZSBleGVjdXRlZCBldmVyeSB0aW1lIHRoZSB3aWRnZXQncyBkYXRhIGNoYW5nZXMuIEl0IHRha2VzIGNhcmUgb2ZcbiAgICAgICAgICAgICAgICAgICAgICogcmVxdWVzdGluZyB0aGUgZW1iZWQgb2JqZWN0IHRvIHRoZSBjb25maWd1cmVkIG9lbWJlZCBzZXJ2aWNlIGFuZCByZW5kZXIgaXQgaW5cbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgRGF0YSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGV2ZW50LmRhdGEudXJsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0tFRElUT1IudG9vbHMuanNvbnAoQUVfRU1CRURfVVJMX1RQTCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGVuY29kZVVSSUNvbXBvbmVudCh1cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRUdFWF9ERUZBVUxUX0xJTksudGVzdChyZXNwb25zZS5odG1sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5jcmVhdGVBVGFnKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5lbGVtZW50LnNldEh0bWwocmVzcG9uc2UuaHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuY3JlYXRlQVRhZyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5jcmVhdGVBVGFnKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQVRhZzogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5leGVjQ29tbWFuZCgndW5kbycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYVRhZ0h0bWwgPSBBRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMLm91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5pbnNlcnRIdG1sKGFUYWdIdG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHVwY2FzdCBhbiBlbGVtZW50IHRvIGFlX2VtYmVkIHdpZGdldHMuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2QgdXBjYXN0XG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3aWRnZXRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHVwY2FzdDogZnVuY3Rpb24oZWxlbWVudCwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtYmVkV2lkZ2V0VXBjYXN0Rm4gPSBlZGl0b3IuY29uZmlnLmVtYmVkV2lkZ2V0VXBjYXN0Rm4gfHwgZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbWJlZFdpZGdldFVwY2FzdEZuKGVsZW1lbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBsaXN0ZW5lciB0byBoYW5kbGUgcGFzdGUgZXZlbnRzIGFuZCB0dXJuIGxpbmtzIGludG8gZW1iZWQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5vbigncGFzdGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmsgPSBldmVudC5kYXRhLmRhdGFWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFR0VYX0hUVFAudGVzdChsaW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3AoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnZW1iZWRVcmwnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZXZlbnQuZGF0YS5kYXRhVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBsaXN0ZW5lciB0byBoYW5kbGUgc2VsZWN0aW9uIGNoYW5nZSBldmVudHMgYW5kIHByb3Blcmx5IGRldGVjdCBlZGl0b3JcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmFjdGlvbnMgb24gdGhlIHdpZGdldHMgd2l0aG91dCBtZXNzaW5nIHdpdGggd2lkZ2V0IG5hdGl2ZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ3NlbGVjdGlvbkNoYW5nZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkZ2V0RWxlbWVudCA9IGVsZW1lbnQuZmluZE9uZSgnW2RhdGEtd2lkZ2V0PVwiYWVfZW1iZWRcIl0nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWRnZXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSBlbGVtZW50LmdldENsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyh3aW5kb3cpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5sZWZ0IC09IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi50b3AgKz0gc2Nyb2xsUG9zaXRpb24ueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHdpZGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBmaWx0ZXIgdG8gc2tpcCBmaWx0ZXJpbmcgd2lkZ2V0IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgZWRpdG9yLmZpbHRlci5hZGRFbGVtZW50Q2FsbGJhY2soZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2RhdGEtYWUtZW1iZWQtdXJsJyBpbiBlbGVtZW50LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDS0VESVRPUi5GSUxURVJfU0tJUF9UUkVFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCJpbXBvcnQgU2VsZWN0aW9uVGVzdCBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbi10ZXN0LmpzJztcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfaW1hZ2VhbGlnbm1lbnQnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW51bSBmb3Igc3VwcG9ydGVkIGltYWdlIGFsaWdubWVudHNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBJTUFHRV9BTElHTk1FTlQgPSB7XG4gICAgICAgIENFTlRFUjogJ2NlbnRlcicsXG4gICAgICAgIExFRlQ6ICdsZWZ0JyxcbiAgICAgICAgUklHSFQ6ICdyaWdodCdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW51bSB2YWx1ZXMgZm9yIHN1cHBvcnRlZCBpbWFnZSBhbGlnbm1lbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHZhciBBTElHTl9WQUxVRVMgPSBbXG4gICAgICAgIElNQUdFX0FMSUdOTUVOVC5MRUZULFxuICAgICAgICBJTUFHRV9BTElHTk1FTlQuUklHSFQsXG4gICAgICAgIElNQUdFX0FMSUdOTUVOVC5DRU5URVJcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogTmVjZXNzYXJ5IHN0eWxlcyBmb3IgdGhlIGNlbnRlciBhbGlnbm1lbnRcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICovXG4gICAgdmFyIENFTlRFUkVEX0lNQUdFX1NUWUxFID0gW3tcbiAgICAgICAgbmFtZTogJ2Rpc3BsYXknLFxuICAgICAgICB2YWx1ZTogJ2Jsb2NrJ1xuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ21hcmdpbi1sZWZ0JyxcbiAgICAgICAgdmFsdWU6ICdhdXRvJ1xuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ21hcmdpbi1yaWdodCcsXG4gICAgICAgIHZhbHVlOiAnYXV0bydcbiAgICB9XTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2UgVGhlIGltYWdlIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhbGlnbm1lbnQgdmFsdWVcbiAgICAgKi9cbiAgICB2YXIgZ2V0SW1hZ2VBbGlnbm1lbnQgPSBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgICB2YXIgaW1hZ2VBbGlnbm1lbnQgPSBpbWFnZS5nZXRTdHlsZSgnZmxvYXQnKTtcblxuICAgICAgICBpZiAoIWltYWdlQWxpZ25tZW50IHx8IGltYWdlQWxpZ25tZW50ID09PSAnaW5oZXJpdCcgfHwgaW1hZ2VBbGlnbm1lbnQgPT09ICdub25lJykge1xuICAgICAgICAgICAgaW1hZ2VBbGlnbm1lbnQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2FsaWduJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWltYWdlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyZWRJbWFnZSA9IENFTlRFUkVEX0lNQUdFX1NUWUxFLmV2ZXJ5KGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlQ2hlY2sgPSBpbWFnZS5nZXRTdHlsZShzdHlsZS5uYW1lKSA9PT0gc3R5bGUudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlQ2hlY2sgJiYgc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDaGVjayA9IHN0eWxlLnZlbmRvclByZWZpeGVzLnNvbWUoZnVuY3Rpb24odmVuZG9yUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2UuZ2V0U3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSkgPT09IHN0eWxlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVDaGVjaztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbWFnZUFsaWdubWVudCA9IGNlbnRlcmVkSW1hZ2UgPyBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbWFnZUFsaWdubWVudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZSBUaGUgaW1hZ2UgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbWFnZUFsaWdubWVudCBUaGUgaW1hZ2UgYWxpZ25tZW50IHZhbHVlIHRvIGJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICB2YXIgcmVtb3ZlSW1hZ2VBbGlnbm1lbnQgPSBmdW5jdGlvbihpbWFnZSwgaW1hZ2VBbGlnbm1lbnQpIHtcbiAgICAgICAgaWYgKGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuTEVGVCB8fCBpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULlJJR0hUKSB7XG4gICAgICAgICAgICBpbWFnZS5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcblxuICAgICAgICAgICAgaWYgKGltYWdlQWxpZ25tZW50ID09PSBnZXRJbWFnZUFsaWdubWVudChpbWFnZSkpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ2FsaWduJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5DRU5URVIpIHtcbiAgICAgICAgICAgIENFTlRFUkVEX0lNQUdFX1NUWUxFLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVTdHlsZShzdHlsZS5uYW1lKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS52ZW5kb3JQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHZlbmRvclByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UucmVtb3ZlU3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBpbWFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2UgVGhlIGltYWdlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VBbGlnbm1lbnQgVGhlIGltYWdlIGFsaWdubWVudCB2YWx1ZSB0byBiZSBzZXRcbiAgICAgKi9cbiAgICB2YXIgc2V0SW1hZ2VBbGlnbm1lbnQgPSBmdW5jdGlvbihpbWFnZSwgaW1hZ2VBbGlnbm1lbnQpIHtcbiAgICAgICAgcmVtb3ZlSW1hZ2VBbGlnbm1lbnQoaW1hZ2UsIGdldEltYWdlQWxpZ25tZW50KGltYWdlKSk7XG5cbiAgICAgICAgaWYgKGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuTEVGVCB8fCBpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULlJJR0hUKSB7XG4gICAgICAgICAgICBpbWFnZS5zZXRTdHlsZSgnZmxvYXQnLCBpbWFnZUFsaWdubWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5DRU5URVIpIHtcbiAgICAgICAgICAgIENFTlRFUkVEX0lNQUdFX1NUWUxFLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5zZXRTdHlsZShzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudmVuZG9yUHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbih2ZW5kb3JQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnNldFN0eWxlKHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUsIHN0eWxlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIG1vZGlmaWVzIHRoZSBqdXN0aWZ5IGNvbW1hbmRzIHRvIHByb3Blcmx5IGFsaWduIGltYWdlcy4gVGhpc1xuICAgICAqIHBsdWdpbiBpcyBhbiBleGNlcnB0IG9mIENLRWRpdG9yJ3Mgb3JpZ2luYWwgaW1hZ2Ugb25lIHRoYXQgY2FuIGJlIGZvdW5kIGF0XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yLWRldi9ibG9iL21hc3Rlci9wbHVnaW5zL2ltYWdlL3BsdWdpbi5qc1xuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfaW1hZ2VhbGlnbm1lbnRcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2ltYWdlYWxpZ25tZW50Jywge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ3Bhc3RlJyBldmVudCBvbiB0aGUgZWRpdGluZyBhcmVhLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgYWZ0ZXJJbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZnRlckluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgIEFMSUdOX1ZBTFVFUy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoJ2p1c3RpZnknICsgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLm9uKCdleGVjJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGF0YSAmJiBTZWxlY3Rpb25UZXN0LmltYWdlKHtkYXRhOiB7c2VsZWN0aW9uRGF0YTogc2VsZWN0aW9uRGF0YX19KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBzZWxlY3Rpb25EYXRhLmVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlQWxpZ25tZW50ID0gZ2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUFsaWdubWVudCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUltYWdlQWxpZ25tZW50KGltYWdlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJbWFnZUFsaWdubWVudChpbWFnZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoQ29tbWFuZHMoZWRpdG9yLCBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnRQYXRoKGltYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQub24oJ3JlZnJlc2gnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25EYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBldmVudC5kYXRhLnBhdGgubGFzdEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNlbGVjdGlvblRlc3QuaW1hZ2Uoe2RhdGE6IHtzZWxlY3Rpb25EYXRhOiBzZWxlY3Rpb25EYXRhfX0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUFsaWdubWVudCA9IGdldEltYWdlQWxpZ25tZW50KHNlbGVjdGlvbkRhdGEuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShpbWFnZUFsaWdubWVudCA9PT0gdmFsdWUgPyBDS0VESVRPUi5UUklTVEFURV9PTiA6IENLRURJVE9SLlRSSVNUQVRFX09GRik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yY2VzIGEgcmVmcmVzaCBvZiB0aGUgbW9kaWZpZWQganVzdGlmeSBjb21tYW5kcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYXBwbGllZCBjaGFuZ2VzXG4gICAgICAgICAgICAgKiBkbyBub3QgbW9kaWZ5IHRoZSBzZWxlY3Rpb24sIHNvIHRoZSByZWZyZXNoIGlzIG5ldmVyIHRyaWdnZXJlZCBhbmQgdGhlIFVJIGRvZXMgbm90IHVwZGF0ZVxuICAgICAgICAgICAgICogcHJvcGVybHkgdW50aWwgdGhlIG5leHQgc2VsZWN0aW9uQ2hhbmdlIGV2ZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfSBlZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudFBhdGh9IGVsZW1lbnRQYXRoIFRoZSBwYXRoIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZWZyZXNoQ29tbWFuZHM6IGZ1bmN0aW9uKGVkaXRvciwgZWxlbWVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICBBTElHTl9WQUxVRVMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKCdqdXN0aWZ5JyArIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5yZWZyZXNoKGVkaXRvciwgZWxlbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCJpbXBvcnQgYWRkaW1hZ2VzIGZyb20gJy4vYWRkaW1hZ2VzJztcbmltcG9ydCBhdXRvbGluayBmcm9tICcuL2F1dG9saW5rJztcbmltcG9ydCBhdXRvbGlzdCBmcm9tICcuL2F1dG9saXN0JztcbmltcG9ydCBkcmFncmVzaXplIGZyb20gJy4vZHJhZ3Jlc2l6ZSc7XG5pbXBvcnQgZHJhZ3Jlc2l6ZWllIGZyb20gJy4vZHJhZ3Jlc2l6ZV9pZSc7XG5pbXBvcnQgZW1iZWQgZnJvbSAnLi9lbWJlZCc7XG5pbXBvcnQgaW1hZ2VhbGlnbm1lbnQgZnJvbSAnLi9pbWFnZWFsaWdubWVudCc7XG5pbXBvcnQgcGFzdGVpbWFnZXMgZnJvbSAnLi9wYXN0ZWltYWdlcyc7XG5pbXBvcnQgcGxhY2Vob2xkZXIgZnJvbSAnLi9wbGFjZWhvbGRlcic7XG5pbXBvcnQgc2VsZWN0aW9ua2V5c3Ryb2tlcyBmcm9tICcuL3NlbGVjdGlvbmtleXN0cm9rZXMnO1xuaW1wb3J0IHRhYmxlcmVzaXplIGZyb20gJy4vdGFibGVyZXNpemUnO1xuaW1wb3J0IHRhYmxldG9vbHMgZnJvbSAnLi90YWJsZXRvb2xzJztcblxuZXhwb3J0IHtcbiAgICBhZGRpbWFnZXMsXG4gICAgYXV0b2xpbmssXG4gICAgYXV0b2xpc3QsXG4gICAgZHJhZ3Jlc2l6ZSxcbiAgICBkcmFncmVzaXplaWUsXG4gICAgZW1iZWQsXG4gICAgaW1hZ2VhbGlnbm1lbnQsXG4gICAgcGFzdGVpbWFnZXMsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgc2VsZWN0aW9ua2V5c3Ryb2tlcyxcbiAgICB0YWJsZXJlc2l6ZSxcbiAgICB0YWJsZXRvb2xzXG59OyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3Bhc3RlaW1hZ2VzJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhbGxvd3MgcGFzdGluZyBpbWFnZXMgZGlyZWN0bHkgaW50byB0aGUgZWRpdGFibGUgYXJlYS4gVGhlIGltYWdlIHdpbGwgYmUgZW5jb2RlZFxuICAgICAqIGFzIERhdGEgVVJJLiBBbiBldmVudCBgYmVmb3JlSW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgbGlzdCBvZiBwYXN0ZWQgaW1hZ2VzLiBJZiBhbnkgb2YgdGhlIGxpc3RlbmVyc1xuICAgICAqIHJldHVybnMgYGZhbHNlYCBvciBjYW5jZWxzIHRoZSBldmVudCwgdGhlIGltYWdlcyB3b24ndCBiZSBhZGRlZCB0byB0aGUgY29udGVudC4gT3RoZXJ3aXNlLFxuICAgICAqIGFuIGV2ZW50IGBpbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBpbnNlcnRlZCBlbGVtZW50IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9wYXN0ZWltYWdlc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYmVmb3JlIGFkZGluZyBpbWFnZXMgdG8gdGhlIGVkaXRvci5cbiAgICAgKiBAZXZlbnQgYmVmb3JlSW1hZ2VBZGRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbWFnZUZpbGVzIEFycmF5IG9mIGltYWdlIGZpbGVzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIGFkZGVkIHRvIHRoZSBlZGl0b3Igc3VjY2Vzc2Z1bGx5LlxuICAgICAqXG4gICAgICogQGV2ZW50IGltYWdlQWRkXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIGNyZWF0ZWQgaW1hZ2Ugd2l0aCBzcmMgYXMgRGF0YSBVUklcbiAgICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgVGhlIGltYWdlIGZpbGVcbiAgICAgKi9cblxuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKFxuICAgICAgICAnYWVfcGFzdGVpbWFnZXMnLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgYSAncGFzdGUnIGV2ZW50IG9uIHRoZSBlZGl0aW5nIGFyZWEuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ3Bhc3RlJywgdGhpcy5fb25QYXN0ZSwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gaW1nIGVsZW1lbnQgd2l0aCBzcmMgdGhlIGltYWdlIGRhdGEgYXMgRGF0YSBVUkkuXG4gICAgICAgICAgICAgKiBUaGVuLCBpdCBmaXJlcyBhbiAnaW1hZ2VBZGQnIGV2ZW50IHZpYSBDS0VkaXRvcidzIGV2ZW50IHN5c3RlbS4gVGhlIHBhc3NlZFxuICAgICAgICAgICAgICogcGFyYW1zIHdpbGwgYmU6XG4gICAgICAgICAgICAgKiAtIGBlbGAgLSB0aGUgY3JlYXRlZCBpbWcgZWxlbWVudFxuICAgICAgICAgICAgICogLSBgZmlsZWAgLSB0aGUgb3JpZ2luYWwgcGFzdGVkIGRhdGFcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9vblBhc3RlXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZXZlbnQgQSBgcGFzdGVgIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vblBhc3RlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFzdGVkRGF0YSA9IGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhLml0ZW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzdGVkRGF0YS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRmlsZSA9IHBhc3RlZERhdGEuZ2V0QXNGaWxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBlZGl0b3IuZmlyZSgnYmVmb3JlSW1hZ2VBZGQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRmlsZXM6IGltYWdlRmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKCc8aW1nIHNyYz1cIicgKyBldmVudC50YXJnZXQucmVzdWx0ICsgJ1wiPicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogaW1hZ2VGaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2ltYWdlQWRkJywgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9wbGFjZWhvbGRlcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VESVRPUiBlbnRlck1vZGUgY29uZmlnIHNldCB0aGUgYmVoYXZpb3Igb2YgcGFyYWdyYXBoc1xuICAgICAqIFdoZW4gdGhlIGNvbnRlbnQgaXMgZW1wdHkgQ0tFRElUT1Iga2VlcHMgdGhlIGVudGVyTW9kZSBzdHJpbmdcbiAgICAgKiBpbnRvIHRoZSBjb250ZW50XG4gICAgICogQHByb3BlcnR5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB2YXIgYnJGaWxsZXIgPSBDS0VESVRPUi5lbnYubmVlZHNCckZpbGxlciA/ICc8YnI+JyA6ICcnO1xuXG4gICAgdmFyIGVudGVyTW9kZUVtcHR5VmFsdWUgPSB7XG4gICAgICAgIDE6IFsnPHA+JyArIGJyRmlsbGVyICsgJzwvcD4nXSxcbiAgICAgICAgMjogWycnLCAnICcsIGJyRmlsbGVyXSxcbiAgICAgICAgMzogWyc8ZGl2PicgKyBickZpbGxlciArICc8L2Rpdj4nXVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWxsb3dzIGFkZGluZyBhIHBsYWNlaG9sZGVyIHRvIHRoZSBlZGl0b3IuIEluIHRoaXMgY2FzZSwgaWYgdGhlcmVcbiAgICAgKiBpcyBubyBjb250ZW50IHRvIHRoZSBlZGl0b3IsIHRoZXJlIHdpbGwgYmUgaGludCB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3BsYWNlaG9sZGVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHBsYWNlaG9sZGVyIGNsYXNzIHdoaWNoIGhhdmUgdG8gYmUgYWRlZCB0byBlZGl0b3Igd2hlbiBlZGl0b3IgaXMgbm90IGZvY3VzZWQuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyQ2xhc3NcbiAgICAgKiBAZGVmYXVsdCBhZV9wbGFjZWhvbGRlclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoXG4gICAgICAgICdhZV9wbGFjZWhvbGRlcicsIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ2JsdXInIGFuZCAnY29udGVudERvbScgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdibHVyJywgdGhpcy5fY2hlY2tFbXB0eURhdGEsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbignY2hhbmdlJywgdGhpcy5fY2hlY2tFbXB0eURhdGEsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbignZm9jdXMnLCB0aGlzLl9yZW1vdmVQbGFjZWhvbGRlckNsYXNzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIHRoaXMuX2NoZWNrRW1wdHlEYXRhLCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBhbnkgZGF0YSBmcm9tIHRoZSBjb250ZW50IGFuZCBhZGRzIGEgY2xhc3MsXG4gICAgICAgICAgICAgKiBzcGVjaWZpZWQgYnkgdGhlIFwicGxhY2Vob2xkZXJDbGFzc1wiIGNvbmZpZyBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICogQG1ldGhvZCBfY2hlY2tFbXB0eURhdGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBlZGl0b3IgZXZlbnQsIGZpcmVkIGZyb20gQ0tFZGl0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2NoZWNrRW1wdHlEYXRhOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBldmVudC5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGVOb2RlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJIdG1sID0gZWRpdGFibGVOb2RlLiQuaW5uZXJIVE1MLnRyaW0oKTtcblxuICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gZW50ZXJNb2RlRW1wdHlWYWx1ZVtlZGl0b3IuY29uZmlnLmVudGVyTW9kZV0uc29tZShmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckh0bWwgPT09IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZU5vZGUuYWRkQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZU5vZGUucmVtb3ZlQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSBwbGFjZWhvbGRlciBjbGFzcyB3aGVuIGlucHV0IGlzIGZvY3VzZWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9yZW1vdmVQbGFjZWhvbGRlckNsYXNzXG4gICAgICAgICAgICAgKyBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZWRpdG9yIGV2ZW50LCBmaXJlZCBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9yZW1vdmVQbGFjZWhvbGRlckNsYXNzOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBldmVudC5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yTm9kZSA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChlZGl0b3IuZWxlbWVudC4kKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvck5vZGUucmVtb3ZlQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3NlbGVjdGlvbmtleXN0cm9rZXMnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHRoYXQgc2ltdWxhdGVzIGVkaXRvciBpbnRlcmFjdGlvbiBldmVudHMgYmFzZWQgb24gbWFudWFsIGtleXN0cm9rZXMuIFRoaXNcbiAgICAgKiBjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGRpZmZlcmVudCByZWFjdGlvbnMgaW4gdGhlIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbmtleXN0cm9rZXNcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX3NlbGVjdGlvbmtleXN0cm9rZXMnLCB7XG4gICAgICAgICAgICByZXF1aXJlczogJ2FlX3NlbGVjdGlvbnJlZ2lvbicsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGFkZHMgYSBjb21tYW5kIHRvIHRoZSBlZGl0b3IgZm9yIGV2ZXJ5IGRlZmluZWQgc2VsZWN0aW9uS2V5c3Ryb2tlXG4gICAgICAgICAgICAgKiBpbiB0aGUgY29uZmlndXJhdGlvbiBhbmQgbWFwcyBpdCB0byB0aGUgc3BlY2lmaWVkIGtleXN0cm9rZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuY29uZmlnLnNlbGVjdGlvbktleXN0cm9rZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbmZpZy5zZWxlY3Rpb25LZXlzdHJva2VzLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IG5ldyBDS0VESVRPUi5jb21tYW5kKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZmlyZSgnZWRpdG9ySW50ZXJhY3Rpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW51YWxTZWxlY3Rpb246IHNlbGVjdGlvbktleXN0cm9rZS5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25EYXRhOiBlZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZE5hbWUgPSAnc2VsZWN0aW9uS2V5c3Ryb2tlJyArIHNlbGVjdGlvbktleXN0cm9rZS5zZWxlY3Rpb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5hZGRDb21tYW5kKGNvbW1hbmROYW1lLCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRLZXlzdHJva2Uoc2VsZWN0aW9uS2V5c3Ryb2tlLmtleXMsIGNvbW1hbmROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn0oKSk7IiwiLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAxNSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHA6Ly9ja2VkaXRvci5jb20vbGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3RhYmxlcmVzaXplJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBweFVuaXQgPSBDS0VESVRPUi50b29scy5jc3NMZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBnZXRXaWR0aChlbCkge1xuICAgICAgICByZXR1cm4gQ0tFRElUT1IuZW52LmllID8gZWwuJC5jbGllbnRXaWR0aCA6IHBhcnNlSW50KGVsLmdldENvbXB1dGVkU3R5bGUoJ3dpZHRoJyksIDEwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3JkZXJXaWR0aChlbGVtZW50LCBzaWRlKSB7XG4gICAgICAgIHZhciBjb21wdXRlZCA9IGVsZW1lbnQuZ2V0Q29tcHV0ZWRTdHlsZSgnYm9yZGVyLScgKyBzaWRlICsgJy13aWR0aCcpLFxuICAgICAgICAgICAgYm9yZGVyTWFwID0ge1xuICAgICAgICAgICAgICAgIHRoaW46ICcwcHgnLFxuICAgICAgICAgICAgICAgIG1lZGl1bTogJzFweCcsXG4gICAgICAgICAgICAgICAgdGhpY2s6ICcycHgnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb21wdXRlZC5pbmRleE9mKCdweCcpIDwgMCkge1xuICAgICAgICAgICAgLy8gbG9vayB1cCBrZXl3b3Jkc1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVkIGluIGJvcmRlck1hcCAmJiBlbGVtZW50LmdldENvbXB1dGVkU3R5bGUoJ2JvcmRlci1zdHlsZScpICE9ICdub25lJykge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gYm9yZGVyTWFwW2NvbXB1dGVkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbXB1dGVkLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gR2V0cyB0aGUgdGFibGUgcm93IHRoYXQgY29udGFpbnMgdGhlIG1vc3QgY29sdW1ucy5cbiAgICBmdW5jdGlvbiBnZXRNYXN0ZXJQaWxsYXJSb3codGFibGUpIHtcbiAgICAgICAgdmFyICRyb3dzID0gdGFibGUuJC5yb3dzLFxuICAgICAgICAgICAgbWF4Q2VsbHMgPSAwLFxuICAgICAgICAgICAgY2VsbHNDb3VudCwgJGVsZWN0ZWQsICR0cjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHJvd3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICR0ciA9ICRyb3dzW2ldO1xuICAgICAgICAgICAgY2VsbHNDb3VudCA9ICR0ci5jZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChjZWxsc0NvdW50ID4gbWF4Q2VsbHMpIHtcbiAgICAgICAgICAgICAgICBtYXhDZWxscyA9IGNlbGxzQ291bnQ7XG4gICAgICAgICAgICAgICAgJGVsZWN0ZWQgPSAkdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGVsZWN0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRUYWJsZUNvbHVtblBpbGxhcnModGFibGUpIHtcbiAgICAgICAgdmFyIHBpbGxhcnMgPSBbXSxcbiAgICAgICAgICAgIHBpbGxhckluZGV4ID0gLTEsXG4gICAgICAgICAgICBydGwgPSAodGFibGUuZ2V0Q29tcHV0ZWRTdHlsZSgnZGlyZWN0aW9uJykgPT09ICdydGwnKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHJhdyByb3cgZWxlbWVudCB0aGF0IGNvaW50YWlucyB0aGUgbW9zdCBjb2x1bW5zLlxuICAgICAgICB2YXIgJHRyID0gZ2V0TWFzdGVyUGlsbGFyUm93KHRhYmxlKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHRib2R5IGVsZW1lbnQgYW5kIHBvc2l0aW9uLCB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2V0IHRoZVxuICAgICAgICAvLyB0b3AgYW5kIGJvdHRvbSBib3VuZGFyaWVzLlxuICAgICAgICB2YXIgdGJvZHkgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC50Qm9kaWVzWzBdKSxcbiAgICAgICAgICAgIHRib2R5UG9zaXRpb24gPSB0Ym9keS5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG5cbiAgICAgICAgLy8gTG9vcCB0aG9ydWdoIGFsbCBjZWxscywgYnVpbGRpbmcgcGlsbGFycyBhZnRlciBlYWNoIG9uZSBvZiB0aGVtLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHRyLmNlbGxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHRoZSBjdXJyZW50IGNlbGwgYW5kIHRoZSBzdWNjZXNzaXZlIG9uZSB3aWxsIGJlIHVzZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBwaWxsYXIgc2l6ZSBjYWxjdWxhdGlvbi5cbiAgICAgICAgICAgIHZhciB0ZCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCgkdHIuY2VsbHNbaV0pLFxuICAgICAgICAgICAgICAgIG5leHRUZCA9ICR0ci5jZWxsc1tpICsgMV0gJiYgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCR0ci5jZWxsc1tpICsgMV0pO1xuXG4gICAgICAgICAgICBwaWxsYXJJbmRleCArPSB0ZC4kLmNvbFNwYW4gfHwgMTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwaWxsYXIgYm91bmRhcnkgcG9zaXRpb25zLlxuICAgICAgICAgICAgdmFyIHBpbGxhckxlZnQsIHBpbGxhclJpZ2h0LCBwaWxsYXJXaWR0aDtcblxuICAgICAgICAgICAgdmFyIHggPSB0ZC5nZXREb2N1bWVudFBvc2l0aW9uKCkueDtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgY3VycmVudCBjZWxsLlxuICAgICAgICAgICAgcnRsID8gcGlsbGFyUmlnaHQgPSB4ICsgZ2V0Qm9yZGVyV2lkdGgodGQsICdsZWZ0JykgOiBwaWxsYXJMZWZ0ID0geCArIHRkLiQub2Zmc2V0V2lkdGggLSBnZXRCb3JkZXJXaWR0aCh0ZCwgJ3JpZ2h0Jyk7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gdGhlIG5leHQgY2VsbCwgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgaWYgKG5leHRUZCkge1xuICAgICAgICAgICAgICAgIHggPSBuZXh0VGQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cbiAgICAgICAgICAgICAgICBydGwgPyBwaWxsYXJMZWZ0ID0geCArIG5leHRUZC4kLm9mZnNldFdpZHRoIC0gZ2V0Qm9yZGVyV2lkdGgobmV4dFRkLCAncmlnaHQnKSA6IHBpbGxhclJpZ2h0ID0geCArIGdldEJvcmRlcldpZHRoKG5leHRUZCwgJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcG9zaXRpb25zIGJhc2VkIG9uIHRoZSB0YWJsZSAoZm9yIGxhc3QgY2VsbCkuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gdGFibGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cbiAgICAgICAgICAgICAgICBydGwgPyBwaWxsYXJMZWZ0ID0geCA6IHBpbGxhclJpZ2h0ID0geCArIHRhYmxlLiQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBpbGxhcldpZHRoID0gTWF0aC5tYXgocGlsbGFyUmlnaHQgLSBwaWxsYXJMZWZ0LCA0KTtcblxuICAgICAgICAgICAgLy8gVGhlIHBpbGxhciBzaG91bGQgcmVmbGVjdHMgZXhhY3RseSB0aGUgc2hhcGUgb2YgdGhlIGhvdmVyZWRcbiAgICAgICAgICAgIC8vIGNvbHVtbiBib3JkZXIgbGluZS5cbiAgICAgICAgICAgIHBpbGxhcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgIGluZGV4OiBwaWxsYXJJbmRleCxcbiAgICAgICAgICAgICAgICB4OiBwaWxsYXJMZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHRib2R5UG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcGlsbGFyV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0Ym9keS4kLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICBydGw6IHJ0bFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGlsbGFycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQaWxsYXJBdFBvc2l0aW9uKHBpbGxhcnMsIHBvc2l0aW9uWCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGlsbGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBpbGxhciA9IHBpbGxhcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvblggPj0gcGlsbGFyLnggJiYgcG9zaXRpb25YIDw9IChwaWxsYXIueCArIHBpbGxhci53aWR0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlsbGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuY2VsKGV2dCkge1xuICAgICAgICAoZXZ0LmRhdGEgfHwgZXZ0KS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtblJlc2l6ZXIoZWRpdG9yKSB7XG4gICAgICAgIHZhciBwaWxsYXIsIGRvY3VtZW50LCByZXNpemVyLCBpc1Jlc2l6aW5nLCBzdGFydE9mZnNldCwgY3VycmVudFNoaWZ0O1xuXG4gICAgICAgIHZhciBsZWZ0U2lkZUNlbGxzLCByaWdodFNpZGVDZWxscywgbGVmdFNoaWZ0Qm91bmRhcnksIHJpZ2h0U2hpZnRCb3VuZGFyeTtcblxuICAgICAgICBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICAgICAgICBwaWxsYXIgPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudFNoaWZ0ID0gMDtcbiAgICAgICAgICAgIGlzUmVzaXppbmcgPSAwO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgICAgICByZXNpemVyLnJlbW92ZUxpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICByZXNpemVyLnJlbW92ZUxpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEJvZHkoKS5zZXRTdHlsZSgnY3Vyc29yJywgJ2F1dG8nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc2l6ZVN0YXJ0KCkge1xuICAgICAgICAgICAgLy8gQmVmb3JlIHN0YXJ0aW5nIHRvIHJlc2l6ZSwgZmlndXJlIG91dCB3aGljaCBjZWxscyB0byBjaGFuZ2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgYm91bmRhcmllcyBvZiB0aGlzIHJlc2l6aW5nIHNoaWZ0LlxuXG4gICAgICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBwaWxsYXIuaW5kZXgsXG4gICAgICAgICAgICAgICAgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcChwaWxsYXIudGFibGUpLFxuICAgICAgICAgICAgICAgIGxlZnRDb2x1bW5DZWxscyA9IFtdLFxuICAgICAgICAgICAgICAgIHJpZ2h0Q29sdW1uQ2VsbHMgPSBbXSxcbiAgICAgICAgICAgICAgICBsZWZ0TWluU2l6ZSA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgcmlnaHRNaW5TaXplID0gbGVmdE1pblNpemUsXG4gICAgICAgICAgICAgICAgcnRsID0gcGlsbGFyLnJ0bDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBtYXBbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxlZnRDZWxsID0gcm93W2NvbHVtbkluZGV4ICsgKHJ0bCA/IDEgOiAwKV0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2VsbCA9IHJvd1tjb2x1bW5JbmRleCArIChydGwgPyAwIDogMSldO1xuXG4gICAgICAgICAgICAgICAgbGVmdENlbGwgPSBsZWZ0Q2VsbCAmJiBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobGVmdENlbGwpO1xuICAgICAgICAgICAgICAgIHJpZ2h0Q2VsbCA9IHJpZ2h0Q2VsbCAmJiBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQocmlnaHRDZWxsKTtcblxuICAgICAgICAgICAgICAgIGlmICghbGVmdENlbGwgfHwgIXJpZ2h0Q2VsbCB8fCAhbGVmdENlbGwuZXF1YWxzKHJpZ2h0Q2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdENlbGwgJiYgKGxlZnRNaW5TaXplID0gTWF0aC5taW4obGVmdE1pblNpemUsIGdldFdpZHRoKGxlZnRDZWxsKSkpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENlbGwgJiYgKHJpZ2h0TWluU2l6ZSA9IE1hdGgubWluKHJpZ2h0TWluU2l6ZSwgZ2V0V2lkdGgocmlnaHRDZWxsKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxlZnRDb2x1bW5DZWxscy5wdXNoKGxlZnRDZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDb2x1bW5DZWxscy5wdXNoKHJpZ2h0Q2VsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWNoZSB0aGUgbGlzdCBvZiBjZWxscyB0byBiZSByZXNpemVkLlxuICAgICAgICAgICAgbGVmdFNpZGVDZWxscyA9IGxlZnRDb2x1bW5DZWxscztcbiAgICAgICAgICAgIHJpZ2h0U2lkZUNlbGxzID0gcmlnaHRDb2x1bW5DZWxscztcblxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHJlc2l6ZSBsaW1pdCBib3VuZGFyaWVzLlxuICAgICAgICAgICAgbGVmdFNoaWZ0Qm91bmRhcnkgPSBwaWxsYXIueCAtIGxlZnRNaW5TaXplO1xuICAgICAgICAgICAgcmlnaHRTaGlmdEJvdW5kYXJ5ID0gcGlsbGFyLnggKyByaWdodE1pblNpemU7XG5cbiAgICAgICAgICAgIHJlc2l6ZXIuc2V0T3BhY2l0eSgwLjUpO1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBwYXJzZUludChyZXNpemVyLmdldFN0eWxlKCdsZWZ0JyksIDEwKTtcbiAgICAgICAgICAgIGN1cnJlbnRTaGlmdCA9IDA7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nID0gMTtcblxuICAgICAgICAgICAgcmVzaXplci5vbignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IHRoZSBuYXRpdmUgZHJhZyBiZWhhdmlvciBvdGhlcndpc2UgJ21vdXNlbW92ZScgd29uJ3QgZmlyZS5cbiAgICAgICAgICAgIGRvY3VtZW50Lm9uKCdkcmFnc3RhcnQnLCBjYW5jZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzaXplRW5kKCkge1xuICAgICAgICAgICAgaXNSZXNpemluZyA9IDA7XG5cbiAgICAgICAgICAgIHJlc2l6ZXIuc2V0T3BhY2l0eSgwKTtcblxuICAgICAgICAgICAgY3VycmVudFNoaWZ0ICYmIHJlc2l6ZUNvbHVtbigpO1xuXG4gICAgICAgICAgICB2YXIgdGFibGUgPSBwaWxsYXIudGFibGU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRhYmxlLnJlbW92ZUN1c3RvbURhdGEoJ19ja2VfdGFibGVfcGlsbGFycycpO1xuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUxpc3RlbmVyKCdkcmFnc3RhcnQnLCBjYW5jZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzaXplQ29sdW1uKCkge1xuICAgICAgICAgICAgdmFyIHJ0bCA9IHBpbGxhci5ydGwsXG4gICAgICAgICAgICAgICAgY2VsbHNDb3VudCA9IHJ0bCA/IHJpZ2h0U2lkZUNlbGxzLmxlbmd0aCA6IGxlZnRTaWRlQ2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBhY3R1YWwgcmVzaXplIHRvIHRhYmxlIGNlbGxzLCBvbmx5IGZvciB0aG9zZSBieSBzaWRlIG9mIHRoZSBwaWxsYXIuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGxzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q2VsbCA9IGxlZnRTaWRlQ2VsbHNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2VsbCA9IHJpZ2h0U2lkZUNlbGxzW2ldLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHBpbGxhci50YWJsZTtcblxuICAgICAgICAgICAgICAgIC8vIERlZmVyIHRoZSByZXNpemluZyB0byBhdm9pZCBhbnkgaW50ZXJmZXJlbmNlIGFtb25nIGNlbGxzLlxuICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLnNldFRpbWVvdXQoZnVuY3Rpb24obGVmdENlbGwsIGxlZnRPbGRXaWR0aCwgcmlnaHRDZWxsLCByaWdodE9sZFdpZHRoLCB0YWJsZVdpZHRoLCBzaXplU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMXB4IGlzIHRoZSBtaW5pbXVtIHZhbGlkIHdpZHRoICgjMTE2MjYpLlxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2VsbCAmJiBsZWZ0Q2VsbC5zZXRTdHlsZSgnd2lkdGgnLCBweFVuaXQoTWF0aC5tYXgobGVmdE9sZFdpZHRoICsgc2l6ZVNoaWZ0LCAxKSkpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENlbGwgJiYgcmlnaHRDZWxsLnNldFN0eWxlKCd3aWR0aCcsIHB4VW5pdChNYXRoLm1heChyaWdodE9sZFdpZHRoIC0gc2l6ZVNoaWZ0LCAxKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBsYXN0IGNlbGwsIHdlIG5lZWQgdG8gcmVzaXplIHRoZSB0YWJsZSBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5zZXRTdHlsZSgnd2lkdGgnLCBweFVuaXQodGFibGVXaWR0aCArIHNpemVTaGlmdCAqIChydGwgPyAtMSA6IDEpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwLCB0aGlzLCBbXG4gICAgICAgICAgICAgICAgICAgIGxlZnRDZWxsLCBsZWZ0Q2VsbCAmJiBnZXRXaWR0aChsZWZ0Q2VsbCksXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2VsbCwgcmlnaHRDZWxsICYmIGdldFdpZHRoKHJpZ2h0Q2VsbCksICghbGVmdENlbGwgfHwgIXJpZ2h0Q2VsbCkgJiYgKGdldFdpZHRoKHRhYmxlKSArIGdldEJvcmRlcldpZHRoKHRhYmxlLCAnbGVmdCcpICsgZ2V0Qm9yZGVyV2lkdGgodGFibGUsICdyaWdodCcpKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNoaWZ0XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihldnQpIHtcbiAgICAgICAgICAgIGNhbmNlbChldnQpO1xuXG4gICAgICAgICAgICByZXNpemVTdGFydCgpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5vbignbW91c2V1cCcsIG9uTW91c2VVcCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlVXAoZXZ0KSB7XG4gICAgICAgICAgICBldnQucmVtb3ZlTGlzdGVuZXIoKTtcblxuICAgICAgICAgICAgcmVzaXplRW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldnQpIHtcbiAgICAgICAgICAgIG1vdmUoZXZ0LmRhdGEuZ2V0UGFnZU9mZnNldCgpLngpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQgPSBlZGl0b3IuZG9jdW1lbnQ7XG5cbiAgICAgICAgcmVzaXplciA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKCc8ZGl2IGRhdGEtY2tlLXRlbXA9MSBjb250ZW50ZWRpdGFibGU9ZmFsc2UgdW5zZWxlY3RhYmxlPW9uICcgK1xuICAgICAgICAgICAgJ3N0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7Y3Vyc29yOmNvbC1yZXNpemU7ZmlsdGVyOmFscGhhKG9wYWNpdHk9MCk7b3BhY2l0eTowOycgK1xuICAgICAgICAgICAgJ3BhZGRpbmc6MDtiYWNrZ3JvdW5kLWNvbG9yOiMwMDQ7YmFja2dyb3VuZC1pbWFnZTpub25lO2JvcmRlcjowcHggbm9uZTt6LWluZGV4OjEwXCI+PC9kaXY+JywgZG9jdW1lbnQpO1xuXG4gICAgICAgIC8vIENsZWFuIERPTSB3aGVuIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICAgIGVkaXRvci5vbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzaXplci5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUGxhY2UgdGhlIHJlc2l6ZXIgYWZ0ZXIgYm9keSB0byBwcmV2ZW50IGl0XG4gICAgICAgIC8vIGZyb20gYmVpbmcgZWRpdGFibGUuXG4gICAgICAgIGRvY3VtZW50LmdldERvY3VtZW50RWxlbWVudCgpLmFwcGVuZChyZXNpemVyKTtcblxuICAgICAgICB0aGlzLmF0dGFjaFRvID0gZnVuY3Rpb24odGFyZ2V0UGlsbGFyKSB7XG4gICAgICAgICAgICAvLyBBY2NlcHQgb25seSBvbmUgcGlsbGFyIGF0IGEgdGltZS5cbiAgICAgICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwaWxsYXIgPSB0YXJnZXRQaWxsYXI7XG5cbiAgICAgICAgICAgIHJlc2l6ZXIuc2V0U3R5bGVzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcHhVbml0KHRhcmdldFBpbGxhci53aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBweFVuaXQodGFyZ2V0UGlsbGFyLmhlaWdodCksXG4gICAgICAgICAgICAgICAgbGVmdDogcHhVbml0KHRhcmdldFBpbGxhci54KSxcbiAgICAgICAgICAgICAgICB0b3A6IHB4VW5pdCh0YXJnZXRQaWxsYXIueSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXNpemVyLm9uKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgdGhpcyk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEJvZHkoKS5zZXRTdHlsZSgnY3Vyc29yJywgJ2NvbC1yZXNpemUnKTtcblxuICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgcmVzaXplciB0byByZWNlaXZlIGV2ZW50cyBidXQgZG9uJ3Qgc2hvdyBpdCxcbiAgICAgICAgICAgIC8vIG9ubHkgY2hhbmdlIHRoZSBjdXJzb3IgdG8gcmVzaXphYmxlIHNoYXBlLlxuICAgICAgICAgICAgcmVzaXplci5zaG93KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1vdmUgPSB0aGlzLm1vdmUgPSBmdW5jdGlvbihwb3NYKSB7XG4gICAgICAgICAgICBpZiAoIXBpbGxhcil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNSZXNpemluZyAmJiAocG9zWCA8IHBpbGxhci54IHx8IHBvc1ggPiAocGlsbGFyLnggKyBwaWxsYXIud2lkdGgpKSkge1xuICAgICAgICAgICAgICAgIGRldGFjaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzaXplck5ld1Bvc2l0aW9uID0gcG9zWCAtIE1hdGgucm91bmQocmVzaXplci4kLm9mZnNldFdpZHRoIC8gMik7XG5cbiAgICAgICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZXJOZXdQb3NpdGlvbiA9PT0gbGVmdFNoaWZ0Qm91bmRhcnkgfHwgcmVzaXplck5ld1Bvc2l0aW9uID09PSByaWdodFNoaWZ0Qm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzaXplck5ld1Bvc2l0aW9uID0gTWF0aC5tYXgocmVzaXplck5ld1Bvc2l0aW9uLCBsZWZ0U2hpZnRCb3VuZGFyeSk7XG4gICAgICAgICAgICAgICAgcmVzaXplck5ld1Bvc2l0aW9uID0gTWF0aC5taW4ocmVzaXplck5ld1Bvc2l0aW9uLCByaWdodFNoaWZ0Qm91bmRhcnkpO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudFNoaWZ0ID0gcmVzaXplck5ld1Bvc2l0aW9uIC0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc2l6ZXIuc2V0U3R5bGUoJ2xlZnQnLCBweFVuaXQocmVzaXplck5ld1Bvc2l0aW9uKSk7XG5cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyUGlsbGFyc0NhY2hlKGV2dCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0LmRhdGEuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKGV2dC5uYW1lID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgICAgICAvLyBCeXBhc3MgaW50ZXJhbCBtb3VzZSBtb3ZlLlxuICAgICAgICAgICAgaWYgKCF0YXJnZXQuaXMoJ3RhYmxlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZXN0ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGV2dC5kYXRhLiQucmVsYXRlZFRhcmdldCB8fCBldnQuZGF0YS4kLnRvRWxlbWVudCk7XG4gICAgICAgICAgICB3aGlsZSAoZGVzdCAmJiBkZXN0LiQgJiYgIWRlc3QuZXF1YWxzKHRhcmdldCkgJiYgIWRlc3QuaXMoJ2JvZHknKSkge1xuICAgICAgICAgICAgICAgIGRlc3QgPSBkZXN0LmdldFBhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXN0IHx8IGRlc3QuZXF1YWxzKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQuZ2V0QXNjZW5kYW50KCd0YWJsZScsIDEpLnJlbW92ZUN1c3RvbURhdGEoJ19ja2VfdGFibGVfcGlsbGFycycpO1xuICAgICAgICBldnQucmVtb3ZlTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfdGFibGVyZXNpemUnLCB7XG4gICAgICAgIHJlcXVpcmVzOiAnYWVfdGFibGV0b29scycsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3Iub24oJ2NvbnRlbnREb20nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzaXplcixcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIEluIENsYXNzaWMgZWRpdG9yIGl0IGlzIGJldHRlciB0byB1c2UgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGVkaXRhYmxlIHNvIGV2ZW50IHdpbGwgd29yayBiZWxvdyBib2R5LlxuICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLmlzSW5saW5lKCkgPyBlZGl0YWJsZSA6IGVkaXRvci5kb2N1bWVudCwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBldnQgPSBldnQuZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0LmdldFRhcmdldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZGIG1heSByZXR1cm4gZG9jdW1lbnQgYW5kIElFOCBzb21lIFVGTyAob2JqZWN0IHdpdGggbm8gbm9kZVR5cGUgcHJvcGVydHkuLi4pXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgYW4gZWxlbWVudCAoIzExODIzKS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC50eXBlICE9PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWdlWCA9IGV2dC5nZXRQYWdlT2Zmc2V0KCkueDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGF0dGFjaGVkIHRvIGEgcGlsbGFyLCBzaW1wbHkgbW92ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzaXplci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2l6ZXIgJiYgcmVzaXplci5tb3ZlKHBhZ2VYKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKGV2dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlcmluZyB0YWJsZSwgdHIsIHRkLCB0Ym9keSBidXQgbm90aGluZyBlbHNlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUsIHBpbGxhcnM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaXMoJ3RhYmxlJykgJiYgIXRhcmdldC5nZXRBc2NlbmRhbnQoJ3Rib2R5JywgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdGFyZ2V0LmdldEFzY2VuZGFudCgndGFibGUnLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHRhYmxlIHdlIGZvdW5kIGlzIGluc2lkZSB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIChlZy4gd2Ugc2hvdWxkIG5vdCB1c2UgdGFibGVzIHRoZSBlZGl0b3IgaXMgZW1iZWRkZWQgd2l0aGluKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVkaXRvci5lZGl0YWJsZSgpLmNvbnRhaW5zKHRhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGlsbGFycyA9IHRhYmxlLmdldEN1c3RvbURhdGEoJ19ja2VfdGFibGVfcGlsbGFycycpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGFibGUgcGlsbGFycyBjYWxjdWxhdGlvbiByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5zZXRDdXN0b21EYXRhKCdfY2tlX3RhYmxlX3BpbGxhcnMnLCAocGlsbGFycyA9IGJ1aWxkVGFibGVDb2x1bW5QaWxsYXJzKHRhYmxlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUub24oJ21vdXNlb3V0JywgY2xlYXJQaWxsYXJzQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUub24oJ21vdXNlZG93bicsIGNsZWFyUGlsbGFyc0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaWxsYXIgPSBnZXRQaWxsYXJBdFBvc2l0aW9uKHBpbGxhcnMsIHBhZ2VYKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpbGxhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgIXJlc2l6ZXIgJiYgKHJlc2l6ZXIgPSBuZXcgY29sdW1uUmVzaXplcihlZGl0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZXIuYXR0YWNoVG8ocGlsbGFyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufSgpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMTUsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwOi8vY2tlZGl0b3IuY29tL2xpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCkge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3RhYmxldG9vbHMnKSl7XG5cdFx0cmV0dXJuO1xuICAgIH1cblxuXHR2YXIgY2VsbE5vZGVSZWdleCA9IC9eKD86dGR8dGgpJC87XG5cblx0ZnVuY3Rpb24gZ2V0U2VsZWN0ZWRDZWxscyggc2VsZWN0aW9uICkge1xuXHRcdHZhciByYW5nZXMgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKCk7XG5cdFx0dmFyIHJldHZhbCA9IFtdO1xuXHRcdHZhciBkYXRhYmFzZSA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gbW92ZU91dE9mQ2VsbEd1YXJkKCBub2RlICkge1xuXHRcdFx0Ly8gQXBwbHkgdG8gdGhlIGZpcnN0IGNlbGwgb25seS5cblx0XHRcdGlmICggcmV0dmFsLmxlbmd0aCA+IDAgKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIElmIHdlIGFyZSBleGl0aW5nIGZyb20gdGhlIGZpcnN0IDwvdGQ+LCB0aGVuIHRoZSB0ZCBzaG91bGQgZGVmaW5pdGVseSBiZVxuXHRcdFx0Ly8gaW5jbHVkZWQuXG5cdFx0XHRpZiAoIG5vZGUudHlwZSA9PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgJiYgY2VsbE5vZGVSZWdleC50ZXN0KCBub2RlLmdldE5hbWUoKSApICYmICFub2RlLmdldEN1c3RvbURhdGEoICdzZWxlY3RlZF9jZWxsJyApICkge1xuXHRcdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5zZXRNYXJrZXIoIGRhdGFiYXNlLCBub2RlLCAnc2VsZWN0ZWRfY2VsbCcsIHRydWUgKTtcblx0XHRcdFx0cmV0dmFsLnB1c2goIG5vZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR2YXIgcmFuZ2UgPSByYW5nZXNbIGkgXTtcblxuXHRcdFx0aWYgKCByYW5nZS5jb2xsYXBzZWQgKSB7XG5cdFx0XHRcdC8vIFdhbGtlciBkb2VzIG5vdCBoYW5kbGUgY29sbGFwc2VkIHJhbmdlcyB5ZXQgLSBmYWxsIGJhY2sgdG8gb2xkIEFQSS5cblx0XHRcdFx0dmFyIHN0YXJ0Tm9kZSA9IHJhbmdlLmdldENvbW1vbkFuY2VzdG9yKCk7XG5cdFx0XHRcdHZhciBuZWFyZXN0Q2VsbCA9IHN0YXJ0Tm9kZS5nZXRBc2NlbmRhbnQoICd0ZCcsIHRydWUgKSB8fCBzdGFydE5vZGUuZ2V0QXNjZW5kYW50KCAndGgnLCB0cnVlICk7XG5cdFx0XHRcdGlmICggbmVhcmVzdENlbGwgKVxuXHRcdFx0XHRcdHJldHZhbC5wdXNoKCBuZWFyZXN0Q2VsbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHdhbGtlciA9IG5ldyBDS0VESVRPUi5kb20ud2Fsa2VyKCByYW5nZSApO1xuXHRcdFx0XHR2YXIgbm9kZTtcblx0XHRcdFx0d2Fsa2VyLmd1YXJkID0gbW92ZU91dE9mQ2VsbEd1YXJkO1xuXG5cdFx0XHRcdHdoaWxlICggKCBub2RlID0gd2Fsa2VyLm5leHQoKSApICkge1xuXHRcdFx0XHRcdC8vIElmIG1heSBiZSBwb3NzaWJsZSBmb3IgdXMgdG8gaGF2ZSBhIHJhbmdlIGxpa2UgdGhpczpcblx0XHRcdFx0XHQvLyA8dGQ+XjE8L3RkPjx0ZD5eMjwvdGQ+XG5cdFx0XHRcdFx0Ly8gVGhlIDJuZCB0ZCBzaG91bGRuJ3QgYmUgaW5jbHVkZWQuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBTbyB3ZSBoYXZlIHRvIHRha2UgY2FyZSB0byBpbmNsdWRlIGEgdGQgd2UndmUgZW50ZXJlZCBvbmx5IHdoZW4gd2UndmVcblx0XHRcdFx0XHQvLyB3YWxrZWQgaW50byBpdHMgY2hpbGRyZW4uXG5cblx0XHRcdFx0XHRpZiAoIG5vZGUudHlwZSAhPSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgfHwgIW5vZGUuaXMoIENLRURJVE9SLmR0ZC50YWJsZSApICkge1xuXHRcdFx0XHRcdFx0dmFyIHBhcmVudCA9IG5vZGUuZ2V0QXNjZW5kYW50KCAndGQnLCB0cnVlICkgfHwgbm9kZS5nZXRBc2NlbmRhbnQoICd0aCcsIHRydWUgKTtcblx0XHRcdFx0XHRcdGlmICggcGFyZW50ICYmICFwYXJlbnQuZ2V0Q3VzdG9tRGF0YSggJ3NlbGVjdGVkX2NlbGwnICkgKSB7XG5cdFx0XHRcdFx0XHRcdENLRURJVE9SLmRvbS5lbGVtZW50LnNldE1hcmtlciggZGF0YWJhc2UsIHBhcmVudCwgJ3NlbGVjdGVkX2NlbGwnLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRcdHJldHZhbC5wdXNoKCBwYXJlbnQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5jbGVhckFsbE1hcmtlcnMoIGRhdGFiYXNlICk7XG5cblx0XHRyZXR1cm4gcmV0dmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Rm9jdXNFbGVtZW50QWZ0ZXJEZWxDZWxscyggY2VsbHNUb0RlbGV0ZSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsYXN0ID0gY2VsbHNUb0RlbGV0ZS5sZW5ndGggLSAxLFxuXHRcdFx0ZGF0YWJhc2UgPSB7fSxcblx0XHRcdGNlbGwsIGZvY3VzZWRDZWxsLCB0cjtcblxuXHRcdHdoaWxlICggKCBjZWxsID0gY2VsbHNUb0RlbGV0ZVsgaSsrIF0gKSApXG5cdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5zZXRNYXJrZXIoIGRhdGFiYXNlLCBjZWxsLCAnZGVsZXRlX2NlbGwnLCB0cnVlICk7XG5cblx0XHQvLyAxLmZpcnN0IHdlIGNoZWNrIGxlZnQgb3IgcmlnaHQgc2lkZSBmb2N1c2FibGUgY2VsbCByb3cgYnkgcm93O1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjZWxsID0gY2VsbHNUb0RlbGV0ZVsgaSsrIF0gKSApIHtcblx0XHRcdGlmICggKCBmb2N1c2VkQ2VsbCA9IGNlbGwuZ2V0UHJldmlvdXMoKSApICYmICFmb2N1c2VkQ2VsbC5nZXRDdXN0b21EYXRhKCAnZGVsZXRlX2NlbGwnICkgfHwgKCBmb2N1c2VkQ2VsbCA9IGNlbGwuZ2V0TmV4dCgpICkgJiYgIWZvY3VzZWRDZWxsLmdldEN1c3RvbURhdGEoICdkZWxldGVfY2VsbCcgKSApIHtcblx0XHRcdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuY2xlYXJBbGxNYXJrZXJzKCBkYXRhYmFzZSApO1xuXHRcdFx0XHRyZXR1cm4gZm9jdXNlZENlbGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuY2xlYXJBbGxNYXJrZXJzKCBkYXRhYmFzZSApO1xuXG5cdFx0Ly8gMi4gdGhlbiB3ZSBjaGVjayB0aGUgdG9wcGVzdCByb3cgKG91dHNpZGUgdGhlIHNlbGVjdGlvbiBhcmVhIHNxdWFyZSkgZm9jdXNhYmxlIGNlbGxcblx0XHR0ciA9IGNlbGxzVG9EZWxldGVbIDAgXS5nZXRQYXJlbnQoKTtcblx0XHRpZiAoICggdHIgPSB0ci5nZXRQcmV2aW91cygpICkgKVxuXHRcdFx0cmV0dXJuIHRyLmdldExhc3QoKTtcblxuXHRcdC8vIDMuIGxhc3Qgd2UgY2hlY2sgdGhlIGxvd2VyZXN0ICByb3cgZm9jdXNhYmxlIGNlbGxcblx0XHR0ciA9IGNlbGxzVG9EZWxldGVbIGxhc3QgXS5nZXRQYXJlbnQoKTtcblx0XHRpZiAoICggdHIgPSB0ci5nZXROZXh0KCkgKSApXG5cdFx0XHRyZXR1cm4gdHIuZ2V0Q2hpbGQoIDAgKTtcblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Um93KCBzZWxlY3Rpb24sIGluc2VydEJlZm9yZSApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb24gKSxcblx0XHRcdGZpcnN0Q2VsbCA9IGNlbGxzWyAwIF0sXG5cdFx0XHR0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoICd0YWJsZScgKSxcblx0XHRcdGRvYyA9IGZpcnN0Q2VsbC5nZXREb2N1bWVudCgpLFxuXHRcdFx0c3RhcnRSb3cgPSBjZWxsc1sgMCBdLmdldFBhcmVudCgpLFxuXHRcdFx0c3RhcnRSb3dJbmRleCA9IHN0YXJ0Um93LiQucm93SW5kZXgsXG5cdFx0XHRsYXN0Q2VsbCA9IGNlbGxzWyBjZWxscy5sZW5ndGggLSAxIF0sXG5cdFx0XHRlbmRSb3dJbmRleCA9IGxhc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXggKyBsYXN0Q2VsbC4kLnJvd1NwYW4gLSAxLFxuXHRcdFx0ZW5kUm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCB0YWJsZS4kLnJvd3NbIGVuZFJvd0luZGV4IF0gKSxcblx0XHRcdHJvd0luZGV4ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRSb3dJbmRleCA6IGVuZFJvd0luZGV4LFxuXHRcdFx0cm93ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRSb3cgOiBlbmRSb3c7XG5cblx0XHR2YXIgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCggdGFibGUgKSxcblx0XHRcdGNsb25lUm93ID0gbWFwWyByb3dJbmRleCBdLFxuXHRcdFx0bmV4dFJvdyA9IGluc2VydEJlZm9yZSA/IG1hcFsgcm93SW5kZXggLSAxIF0gOiBtYXBbIHJvd0luZGV4ICsgMSBdLFxuXHRcdFx0d2lkdGggPSBtYXBbIDAgXS5sZW5ndGg7XG5cblx0XHR2YXIgbmV3Um93ID0gZG9jLmNyZWF0ZUVsZW1lbnQoICd0cicgKTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGNsb25lUm93WyBpIF0gJiYgaSA8IHdpZHRoOyBpKysgKSB7XG5cdFx0XHR2YXIgY2VsbDtcblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgdGhlcmUncyBhIHNwYW5uaW5nIHJvdyBoZXJlLCBkbyBub3QgYnJlYWsgaXQuXG5cdFx0XHRpZiAoIGNsb25lUm93WyBpIF0ucm93U3BhbiA+IDEgJiYgbmV4dFJvdyAmJiBjbG9uZVJvd1sgaSBdID09IG5leHRSb3dbIGkgXSApIHtcblx0XHRcdFx0Y2VsbCA9IGNsb25lUm93WyBpIF07XG5cdFx0XHRcdGNlbGwucm93U3BhbiArPSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggY2xvbmVSb3dbIGkgXSApLmNsb25lKCk7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCAncm93U3BhbicgKTtcblx0XHRcdFx0Y2VsbC5hcHBlbmRCb2d1cygpO1xuXHRcdFx0XHRuZXdSb3cuYXBwZW5kKCBjZWxsICk7XG5cdFx0XHRcdGNlbGwgPSBjZWxsLiQ7XG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gY2VsbC5jb2xTcGFuIC0gMTtcblx0XHR9XG5cblx0XHRpbnNlcnRCZWZvcmUgPyBuZXdSb3cuaW5zZXJ0QmVmb3JlKCByb3cgKSA6IG5ld1Jvdy5pbnNlcnRBZnRlciggcm93ICk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWxldGVSb3dzKCBzZWxlY3Rpb25PclJvdyApIHtcblx0XHRpZiAoIHNlbGVjdGlvbk9yUm93IGluc3RhbmNlb2YgQ0tFRElUT1IuZG9tLnNlbGVjdGlvbiApIHtcblx0XHRcdHZhciBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbk9yUm93ICksXG5cdFx0XHRcdGZpcnN0Q2VsbCA9IGNlbGxzWyAwIF0sXG5cdFx0XHRcdHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0XHRtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKCB0YWJsZSApLFxuXHRcdFx0XHRzdGFydFJvdyA9IGNlbGxzWyAwIF0uZ2V0UGFyZW50KCksXG5cdFx0XHRcdHN0YXJ0Um93SW5kZXggPSBzdGFydFJvdy4kLnJvd0luZGV4LFxuXHRcdFx0XHRsYXN0Q2VsbCA9IGNlbGxzWyBjZWxscy5sZW5ndGggLSAxIF0sXG5cdFx0XHRcdGVuZFJvd0luZGV4ID0gbGFzdENlbGwuZ2V0UGFyZW50KCkuJC5yb3dJbmRleCArIGxhc3RDZWxsLiQucm93U3BhbiAtIDEsXG5cdFx0XHRcdHJvd3NUb0RlbGV0ZSA9IFtdO1xuXG5cdFx0XHQvLyBEZWxldGUgY2VsbCBvciByZWR1Y2UgY2VsbCBzcGFucyBieSBjaGVja2luZyB0aHJvdWdoIHRoZSB0YWJsZSBtYXAuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0Um93SW5kZXg7IGkgPD0gZW5kUm93SW5kZXg7IGkrKyApIHtcblx0XHRcdFx0dmFyIG1hcFJvdyA9IG1hcFsgaSBdLFxuXHRcdFx0XHRcdHJvdyA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggdGFibGUuJC5yb3dzWyBpIF0gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtYXBSb3cubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRcdFx0dmFyIGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIG1hcFJvd1sgaiBdICksXG5cdFx0XHRcdFx0XHRjZWxsUm93SW5kZXggPSBjZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXg7XG5cblx0XHRcdFx0XHRpZiAoIGNlbGwuJC5yb3dTcGFuID09IDEgKVxuXHRcdFx0XHRcdFx0Y2VsbC5yZW1vdmUoKTtcblx0XHRcdFx0XHQvLyBSb3cgc3Bhbm5lZCBjZWxsLlxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gU3BhbiByb3cgb2YgdGhlIGNlbGwsIHJlZHVjZSBzcGFubmluZy5cblx0XHRcdFx0XHRcdGNlbGwuJC5yb3dTcGFuIC09IDE7XG5cdFx0XHRcdFx0XHQvLyBSb290IHJvdyBvZiB0aGUgY2VsbCwgcm9vdCBjZWxsIHRvIG5leHQgcm93LlxuXHRcdFx0XHRcdFx0aWYgKCBjZWxsUm93SW5kZXggPT0gaSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5leHRNYXBSb3cgPSBtYXBbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRcdG5leHRNYXBSb3dbIGogLSAxIF0gPyBjZWxsLmluc2VydEFmdGVyKCBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIG5leHRNYXBSb3dbIGogLSAxIF0gKSApIDogbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCB0YWJsZS4kLnJvd3NbIGkgKyAxIF0gKS5hcHBlbmQoIGNlbGwsIDEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqICs9IGNlbGwuJC5jb2xTcGFuIC0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJvd3NUb0RlbGV0ZS5wdXNoKCByb3cgKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJvd3MgPSB0YWJsZS4kLnJvd3M7XG5cblx0XHRcdC8vIFdoZXJlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIHJvd3MgYmVlbiBkZWxldGVkP1xuXHRcdFx0Ly8gMS4gSW50byBuZXh0IHNpYmxpbmcgcm93IGlmIGFueTtcblx0XHRcdC8vIDIuIEludG8gcHJldmlvdXMgc2libGluZyByb3cgaWYgYW55O1xuXHRcdFx0Ly8gMy4gSW50byB0YWJsZSdzIHBhcmVudCBlbGVtZW50IGlmIGl0J3MgdGhlIHZlcnkgbGFzdCByb3cuXG5cdFx0XHR2YXIgY3Vyc29yUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIHJvd3NbIGVuZFJvd0luZGV4ICsgMSBdIHx8ICggc3RhcnRSb3dJbmRleCA+IDAgPyByb3dzWyBzdGFydFJvd0luZGV4IC0gMSBdIDogbnVsbCApIHx8IHRhYmxlLiQucGFyZW50Tm9kZSApO1xuXG5cdFx0XHRmb3IgKCBpID0gcm93c1RvRGVsZXRlLmxlbmd0aDsgaSA+PSAwOyBpLS0gKVxuXHRcdFx0XHRkZWxldGVSb3dzKCByb3dzVG9EZWxldGVbIGkgXSApO1xuXG5cdFx0XHRyZXR1cm4gY3Vyc29yUG9zaXRpb247XG5cdFx0fSBlbHNlIGlmICggc2VsZWN0aW9uT3JSb3cgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uZWxlbWVudCApIHtcblx0XHRcdHRhYmxlID0gc2VsZWN0aW9uT3JSb3cuZ2V0QXNjZW5kYW50KCAndGFibGUnICk7XG5cblx0XHRcdGlmICggdGFibGUuJC5yb3dzLmxlbmd0aCA9PSAxIClcblx0XHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHNlbGVjdGlvbk9yUm93LnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2VsbENvbEluZGV4KCBjZWxsLCBpc1N0YXJ0ICkge1xuXHRcdHZhciByb3cgPSBjZWxsLmdldFBhcmVudCgpLFxuXHRcdFx0cm93Q2VsbHMgPSByb3cuJC5jZWxscztcblxuXHRcdHZhciBjb2xJbmRleCA9IDA7XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcm93Q2VsbHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR2YXIgbWFwQ2VsbCA9IHJvd0NlbGxzWyBpIF07XG5cdFx0XHRjb2xJbmRleCArPSBpc1N0YXJ0ID8gMSA6IG1hcENlbGwuY29sU3Bhbjtcblx0XHRcdGlmICggbWFwQ2VsbCA9PSBjZWxsLiQgKVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sSW5kZXggLSAxO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29sdW1uc0luZGljZXMoIGNlbGxzLCBpc1N0YXJ0ICkge1xuXHRcdHZhciByZXR2YWwgPSBpc1N0YXJ0ID8gSW5maW5pdHkgOiAwO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0dmFyIGNvbEluZGV4ID0gZ2V0Q2VsbENvbEluZGV4KCBjZWxsc1sgaSBdLCBpc1N0YXJ0ICk7XG5cdFx0XHRpZiAoIGlzU3RhcnQgPyBjb2xJbmRleCA8IHJldHZhbCA6IGNvbEluZGV4ID4gcmV0dmFsIClcblx0XHRcdFx0cmV0dmFsID0gY29sSW5kZXg7XG5cdFx0fVxuXHRcdHJldHVybiByZXR2YWw7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnRDb2x1bW4oIHNlbGVjdGlvbiwgaW5zZXJ0QmVmb3JlICkge1xuXHRcdHZhciBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbiApLFxuXHRcdFx0Zmlyc3RDZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0c3RhcnRDb2wgPSBnZXRDb2x1bW5zSW5kaWNlcyggY2VsbHMsIDEgKSxcblx0XHRcdGxhc3RDb2wgPSBnZXRDb2x1bW5zSW5kaWNlcyggY2VsbHMgKSxcblx0XHRcdGNvbEluZGV4ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRDb2wgOiBsYXN0Q29sO1xuXG5cdFx0dmFyIG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAoIHRhYmxlICksXG5cdFx0XHRjbG9uZUNvbCA9IFtdLFxuXHRcdFx0bmV4dENvbCA9IFtdLFxuXHRcdFx0aGVpZ2h0ID0gbWFwLmxlbmd0aDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGhlaWdodDsgaSsrICkge1xuXHRcdFx0Y2xvbmVDb2wucHVzaCggbWFwWyBpIF1bIGNvbEluZGV4IF0gKTtcblx0XHRcdHZhciBuZXh0Q2VsbCA9IGluc2VydEJlZm9yZSA/IG1hcFsgaSBdWyBjb2xJbmRleCAtIDEgXSA6IG1hcFsgaSBdWyBjb2xJbmRleCArIDEgXTtcblx0XHRcdG5leHRDb2wucHVzaCggbmV4dENlbGwgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGhlaWdodDsgaSsrICkge1xuXHRcdFx0dmFyIGNlbGw7XG5cblx0XHRcdGlmICggIWNsb25lQ29sWyBpIF0gKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciB0aGVyZSdzIGEgc3Bhbm5pbmcgY29sdW1uIGhlcmUsIGRvIG5vdCBicmVhayBpdC5cblx0XHRcdGlmICggY2xvbmVDb2xbIGkgXS5jb2xTcGFuID4gMSAmJiBuZXh0Q29sWyBpIF0gPT0gY2xvbmVDb2xbIGkgXSApIHtcblx0XHRcdFx0Y2VsbCA9IGNsb25lQ29sWyBpIF07XG5cdFx0XHRcdGNlbGwuY29sU3BhbiArPSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggY2xvbmVDb2xbIGkgXSApLmNsb25lKCk7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCAnY29sU3BhbicgKTtcblx0XHRcdFx0Y2VsbC5hcHBlbmRCb2d1cygpO1xuXHRcdFx0XHRjZWxsWyBpbnNlcnRCZWZvcmUgPyAnaW5zZXJ0QmVmb3JlJyA6ICdpbnNlcnRBZnRlcicgXS5jYWxsKCBjZWxsLCBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIGNsb25lQ29sWyBpIF0gKSApO1xuXHRcdFx0XHRjZWxsID0gY2VsbC4kO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGNlbGwucm93U3BhbiAtIDE7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlQ29sdW1ucyggc2VsZWN0aW9uT3JDZWxsICkge1xuXHRcdHZhciBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbk9yQ2VsbCApLFxuXHRcdFx0Zmlyc3RDZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdGxhc3RDZWxsID0gY2VsbHNbIGNlbGxzLmxlbmd0aCAtIDEgXSxcblx0XHRcdHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0bWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCggdGFibGUgKSxcblx0XHRcdHN0YXJ0Q29sSW5kZXgsIGVuZENvbEluZGV4LFxuXHRcdFx0cm93c1RvRGVsZXRlID0gW107XG5cblx0XHQvLyBGaWd1cmUgb3V0IHNlbGVjdGVkIGNlbGxzJyBjb2x1bW4gaW5kaWNlcy5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIHJvd3MgPSBtYXAubGVuZ3RoOyBpIDwgcm93czsgaSsrICkge1xuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBjb2xzID0gbWFwWyBpIF0ubGVuZ3RoOyBqIDwgY29sczsgaisrICkge1xuXHRcdFx0XHRpZiAoIG1hcFsgaSBdWyBqIF0gPT0gZmlyc3RDZWxsLiQgKVxuXHRcdFx0XHRcdHN0YXJ0Q29sSW5kZXggPSBqO1xuXHRcdFx0XHRpZiAoIG1hcFsgaSBdWyBqIF0gPT0gbGFzdENlbGwuJCApXG5cdFx0XHRcdFx0ZW5kQ29sSW5kZXggPSBqO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERlbGV0ZSBjZWxsIG9yIHJlZHVjZSBjZWxsIHNwYW5zIGJ5IGNoZWNraW5nIHRocm91Z2ggdGhlIHRhYmxlIG1hcC5cblx0XHRmb3IgKCBpID0gc3RhcnRDb2xJbmRleDsgaSA8PSBlbmRDb2xJbmRleDsgaSsrICkge1xuXHRcdFx0Zm9yICggaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRcdHZhciBtYXBSb3cgPSBtYXBbIGogXSxcblx0XHRcdFx0XHRyb3cgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIHRhYmxlLiQucm93c1sgaiBdICksXG5cdFx0XHRcdFx0Y2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggbWFwUm93WyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIGNlbGwuJCApIHtcblx0XHRcdFx0XHRpZiAoIGNlbGwuJC5jb2xTcGFuID09IDEgKVxuXHRcdFx0XHRcdFx0Y2VsbC5yZW1vdmUoKTtcblx0XHRcdFx0XHQvLyBSZWR1Y2UgdGhlIGNvbCBzcGFucy5cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRjZWxsLiQuY29sU3BhbiAtPSAxO1xuXG5cdFx0XHRcdFx0aiArPSBjZWxsLiQucm93U3BhbiAtIDE7XG5cblx0XHRcdFx0XHRpZiAoICFyb3cuJC5jZWxscy5sZW5ndGggKVxuXHRcdFx0XHRcdFx0cm93c1RvRGVsZXRlLnB1c2goIHJvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0Um93Q2VsbHMgPSB0YWJsZS4kLnJvd3NbIDAgXSAmJiB0YWJsZS4kLnJvd3NbIDAgXS5jZWxscztcblxuXHRcdC8vIFdoZXJlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGNvbHVtbnMgYmVlbiBkZWxldGVkP1xuXHRcdC8vIDEuIEludG8gbmV4dCBjZWxsIG9mIHRoZSBmaXJzdCByb3cgaWYgYW55O1xuXHRcdC8vIDIuIEludG8gcHJldmlvdXMgY2VsbCBvZiB0aGUgZmlyc3Qgcm93IGlmIGFueTtcblx0XHQvLyAzLiBJbnRvIHRhYmxlJ3MgcGFyZW50IGVsZW1lbnQ7XG5cdFx0dmFyIGN1cnNvclBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBmaXJzdFJvd0NlbGxzWyBzdGFydENvbEluZGV4IF0gfHwgKCBzdGFydENvbEluZGV4ID8gZmlyc3RSb3dDZWxsc1sgc3RhcnRDb2xJbmRleCAtIDEgXSA6IHRhYmxlLiQucGFyZW50Tm9kZSApICk7XG5cblx0XHQvLyBEZWxldGUgdGFibGUgcm93cyBvbmx5IGlmIGFsbCBjb2x1bW5zIGFyZSBnb25lIChkbyBub3QgcmVtb3ZlIGVtcHR5IHJvdykuXG5cdFx0aWYgKCByb3dzVG9EZWxldGUubGVuZ3RoID09IHJvd3MgKVxuXHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cblx0XHRyZXR1cm4gY3Vyc29yUG9zaXRpb247XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnRDZWxsKCBzZWxlY3Rpb24sIGluc2VydEJlZm9yZSApIHtcblx0XHR2YXIgc3RhcnRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpO1xuXHRcdHZhciBjZWxsID0gc3RhcnRFbGVtZW50LmdldEFzY2VuZGFudCggJ3RkJywgMSApIHx8IHN0YXJ0RWxlbWVudC5nZXRBc2NlbmRhbnQoICd0aCcsIDEgKTtcblxuXHRcdGlmICggIWNlbGwgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBuZXcgY2VsbCBlbGVtZW50IHRvIGJlIGFkZGVkLlxuXHRcdHZhciBuZXdDZWxsID0gY2VsbC5jbG9uZSgpO1xuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGlmICggaW5zZXJ0QmVmb3JlIClcblx0XHRcdG5ld0NlbGwuaW5zZXJ0QmVmb3JlKCBjZWxsICk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3Q2VsbC5pbnNlcnRBZnRlciggY2VsbCApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlQ2VsbHMoIHNlbGVjdGlvbk9yQ2VsbCApIHtcblx0XHRpZiAoIHNlbGVjdGlvbk9yQ2VsbCBpbnN0YW5jZW9mIENLRURJVE9SLmRvbS5zZWxlY3Rpb24gKSB7XG5cdFx0XHR2YXIgY2VsbHNUb0RlbGV0ZSA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbk9yQ2VsbCApO1xuXHRcdFx0dmFyIHRhYmxlID0gY2VsbHNUb0RlbGV0ZVsgMCBdICYmIGNlbGxzVG9EZWxldGVbIDAgXS5nZXRBc2NlbmRhbnQoICd0YWJsZScgKTtcblx0XHRcdHZhciBjZWxsVG9Gb2N1cyA9IGdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMoIGNlbGxzVG9EZWxldGUgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSBjZWxsc1RvRGVsZXRlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tIClcblx0XHRcdFx0ZGVsZXRlQ2VsbHMoIGNlbGxzVG9EZWxldGVbIGkgXSApO1xuXG5cdFx0XHRpZiAoIGNlbGxUb0ZvY3VzIClcblx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIGNlbGxUb0ZvY3VzLCB0cnVlICk7XG5cdFx0XHRlbHNlIGlmICggdGFibGUgKVxuXHRcdFx0XHR0YWJsZS5yZW1vdmUoKTtcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rpb25PckNlbGwgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uZWxlbWVudCApIHtcblx0XHRcdHZhciB0ciA9IHNlbGVjdGlvbk9yQ2VsbC5nZXRQYXJlbnQoKTtcblx0XHRcdGlmICggdHIuZ2V0Q2hpbGRDb3VudCgpID09IDEgKVxuXHRcdFx0XHR0ci5yZW1vdmUoKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0c2VsZWN0aW9uT3JDZWxsLnJlbW92ZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSBmaWxsZXIgYXQgZW5kIGFuZCBlbXB0eSBzcGFjZXMgYXJvdW5kIHRoZSBjZWxsIGNvbnRlbnQuXG5cdGZ1bmN0aW9uIHRyaW1DZWxsKCBjZWxsICkge1xuXHRcdHZhciBib2d1cyA9IGNlbGwuZ2V0Qm9ndXMoKTtcblx0XHRib2d1cyAmJiBib2d1cy5yZW1vdmUoKTtcblx0XHRjZWxsLnRyaW0oKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBsYWNlQ3Vyc29ySW5DZWxsKCBjZWxsLCBwbGFjZUF0RW5kICkge1xuXHRcdHZhciBkb2NJbm5lciA9IGNlbGwuZ2V0RG9jdW1lbnQoKSxcblx0XHRcdGRvY091dGVyID0gQ0tFRElUT1IuZG9jdW1lbnQ7XG5cblx0XHQvLyBGaXhpbmcgXCJVbnNwZWNpZmllZCBlcnJvclwiIHRocm93biBpbiBJRTEwIGJ5IHJlc2V0dGluZ1xuXHRcdC8vIHNlbGVjdGlvbiB0aGUgZGlydHkgYW5kIHNoYW1lZnVsIHdheSAoIzEwMzA4KS5cblx0XHQvLyBXZSBjYW4gbm90IGFwcGx5IHRoaXMgaGFjayB0byBJRTggYmVjYXVzZVxuXHRcdC8vIGl0IGNhdXNlcyBlcnJvciAoIzExMDU4KS5cblx0XHRpZiAoIENLRURJVE9SLmVudi5pZSAmJiBDS0VESVRPUi5lbnYudmVyc2lvbiA9PSAxMCApIHtcblx0XHRcdGRvY091dGVyLmZvY3VzKCk7XG5cdFx0XHRkb2NJbm5lci5mb2N1cygpO1xuXHRcdH1cblxuXHRcdHZhciByYW5nZSA9IG5ldyBDS0VESVRPUi5kb20ucmFuZ2UoIGRvY0lubmVyICk7XG5cdFx0aWYgKCAhcmFuZ2VbICdtb3ZlVG9FbGVtZW50RWRpdCcgKyAoIHBsYWNlQXRFbmQgPyAnRW5kJyA6ICdTdGFydCcgKSBdKCBjZWxsICkgKSB7XG5cdFx0XHRyYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoIGNlbGwgKTtcblx0XHRcdHJhbmdlLmNvbGxhcHNlKCBwbGFjZUF0RW5kID8gZmFsc2UgOiB0cnVlICk7XG5cdFx0fVxuXHRcdHJhbmdlLnNlbGVjdCggdHJ1ZSApO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2VsbEluUm93KCB0YWJsZU1hcCwgcm93SW5kZXgsIGNlbGwgKSB7XG5cdFx0dmFyIG9Sb3cgPSB0YWJsZU1hcFsgcm93SW5kZXggXTtcblx0XHRpZiAoIHR5cGVvZiBjZWxsID09ICd1bmRlZmluZWQnIClcblx0XHRcdHJldHVybiBvUm93O1xuXG5cdFx0Zm9yICggdmFyIGMgPSAwOyBvUm93ICYmIGMgPCBvUm93Lmxlbmd0aDsgYysrICkge1xuXHRcdFx0aWYgKCBjZWxsLmlzICYmIG9Sb3dbIGMgXSA9PSBjZWxsLiQgKVxuXHRcdFx0XHRyZXR1cm4gYztcblx0XHRcdGVsc2UgaWYgKCBjID09IGNlbGwgKVxuXHRcdFx0XHRyZXR1cm4gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBvUm93WyBjIF0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNlbGwuaXMgPyAtMSA6IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBjZWxsSW5Db2woIHRhYmxlTWFwLCBjb2xJbmRleCApIHtcblx0XHR2YXIgb0NvbCA9IFtdO1xuXHRcdGZvciAoIHZhciByID0gMDsgciA8IHRhYmxlTWFwLmxlbmd0aDsgcisrICkge1xuXHRcdFx0dmFyIHJvdyA9IHRhYmxlTWFwWyByIF07XG5cdFx0XHRvQ29sLnB1c2goIHJvd1sgY29sSW5kZXggXSApO1xuXG5cdFx0XHQvLyBBdm9pZCBhZGRpbmcgZHVwbGljYXRlIGNlbGxzLlxuXHRcdFx0aWYgKCByb3dbIGNvbEluZGV4IF0ucm93U3BhbiA+IDEgKVxuXHRcdFx0XHRyICs9IHJvd1sgY29sSW5kZXggXS5yb3dTcGFuIC0gMTtcblx0XHR9XG5cdFx0cmV0dXJuIG9Db2w7XG5cdH1cblxuXHRmdW5jdGlvbiBtZXJnZUNlbGxzKCBzZWxlY3Rpb24sIG1lcmdlRGlyZWN0aW9uLCBpc0RldGVjdCApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb24gKTtcblxuXHRcdC8vIEludmFsaWQgbWVyZ2UgcmVxdWVzdCBpZjpcblx0XHQvLyAxLiBJbiBiYXRjaCBtb2RlIGRlc3BpdGUgdGhhdCBsZXNzIHRoYW4gdHdvIHNlbGVjdGVkLlxuXHRcdC8vIDIuIEluIHNvbG8gbW9kZSB3aGlsZSBub3QgZXhhY3RseSBvbmx5IG9uZSBzZWxlY3RlZC5cblx0XHQvLyAzLiBDZWxscyBkaXN0cmlidXRlZCBpbiBkaWZmZXJlbnQgdGFibGUgZ3JvdXBzIChlLmcuIGZyb20gYm90aCB0aGVhZCBhbmQgdGJvZHkpLlxuXHRcdHZhciBjb21tb25BbmNlc3Rvcjtcblx0XHRpZiAoICggbWVyZ2VEaXJlY3Rpb24gPyBjZWxscy5sZW5ndGggIT0gMSA6IGNlbGxzLmxlbmd0aCA8IDIgKSB8fCAoIGNvbW1vbkFuY2VzdG9yID0gc2VsZWN0aW9uLmdldENvbW1vbkFuY2VzdG9yKCkgKSAmJiBjb21tb25BbmNlc3Rvci50eXBlID09IENLRURJVE9SLk5PREVfRUxFTUVOVCAmJiBjb21tb25BbmNlc3Rvci5pcyggJ3RhYmxlJyApIClcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBjZWxsLFxuXHRcdFx0Zmlyc3RDZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0bWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCggdGFibGUgKSxcblx0XHRcdG1hcEhlaWdodCA9IG1hcC5sZW5ndGgsXG5cdFx0XHRtYXBXaWR0aCA9IG1hcFsgMCBdLmxlbmd0aCxcblx0XHRcdHN0YXJ0Um93ID0gZmlyc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXgsXG5cdFx0XHRzdGFydENvbHVtbiA9IGNlbGxJblJvdyggbWFwLCBzdGFydFJvdywgZmlyc3RDZWxsICk7XG5cblx0XHRpZiAoIG1lcmdlRGlyZWN0aW9uICkge1xuXHRcdFx0dmFyIHRhcmdldENlbGw7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgcm93c3BhbiA9IHBhcnNlSW50KCBmaXJzdENlbGwuZ2V0QXR0cmlidXRlKCAncm93c3BhbicgKSwgMTAgKSB8fCAxO1xuXHRcdFx0XHR2YXIgY29sc3BhbiA9IHBhcnNlSW50KCBmaXJzdENlbGwuZ2V0QXR0cmlidXRlKCAnY29sc3BhbicgKSwgMTAgKSB8fCAxO1xuXG5cdFx0XHRcdHRhcmdldENlbGwgPSBtYXBbIG1lcmdlRGlyZWN0aW9uID09ICd1cCcgPyAoIHN0YXJ0Um93IC0gcm93c3BhbiApIDogbWVyZ2VEaXJlY3Rpb24gPT0gJ2Rvd24nID8gKCBzdGFydFJvdyArIHJvd3NwYW4gKSA6IHN0YXJ0Um93IF1bXG5cdFx0XHRcdFx0bWVyZ2VEaXJlY3Rpb24gPT0gJ2xlZnQnID9cblx0XHRcdFx0XHRcdCggc3RhcnRDb2x1bW4gLSBjb2xzcGFuICkgOlxuXHRcdFx0XHRcdG1lcmdlRGlyZWN0aW9uID09ICdyaWdodCcgPyAoIHN0YXJ0Q29sdW1uICsgY29sc3BhbiApIDogc3RhcnRDb2x1bW4gXTtcblxuXHRcdFx0fSBjYXRjaCAoIGVyICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDEuIE5vIGNlbGwgY291bGQgYmUgbWVyZ2VkLlxuXHRcdFx0Ly8gMi4gU2FtZSBjZWxsIGFjdHVhbGx5LlxuXHRcdFx0aWYgKCAhdGFyZ2V0Q2VsbCB8fCBmaXJzdENlbGwuJCA9PSB0YXJnZXRDZWxsIClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBTb3J0IGluIG1hcCBvcmRlciByZWdhcmRsZXNzIG9mIHRoZSBET00gc2VxdWVuY2UuXG5cdFx0XHRjZWxsc1sgKCBtZXJnZURpcmVjdGlvbiA9PSAndXAnIHx8IG1lcmdlRGlyZWN0aW9uID09ICdsZWZ0JyApID8gJ3Vuc2hpZnQnIDogJ3B1c2gnIF0oIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggdGFyZ2V0Q2VsbCApICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RhcnQgZnJvbSBoZXJlIGFyZSBtZXJnaW5nIHdheSBpZ25vcmFuY2UgKG1lcmdlIHVwL3JpZ2h0LCBiYXRjaCBtZXJnZSkuXG5cdFx0dmFyIGRvYyA9IGZpcnN0Q2VsbC5nZXREb2N1bWVudCgpLFxuXHRcdFx0bGFzdFJvd0luZGV4ID0gc3RhcnRSb3csXG5cdFx0XHR0b3RhbFJvd1NwYW4gPSAwLFxuXHRcdFx0dG90YWxDb2xTcGFuID0gMCxcblx0XHRcdC8vIFVzZSBhIGRvY3VtZW50RnJhZ21lbnQgYXMgYnVmZmVyIHdoZW4gYXBwZW5kaW5nIGNlbGwgY29udGVudHMuXG5cdFx0XHRmcmFnID0gIWlzRGV0ZWN0ICYmIG5ldyBDS0VESVRPUi5kb20uZG9jdW1lbnRGcmFnbWVudCggZG9jICksXG5cdFx0XHRkaW1lbnNpb24gPSAwO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjZWxsID0gY2VsbHNbIGkgXTtcblxuXHRcdFx0dmFyIHRyID0gY2VsbC5nZXRQYXJlbnQoKSxcblx0XHRcdFx0Y2VsbEZpcnN0Q2hpbGQgPSBjZWxsLmdldEZpcnN0KCksXG5cdFx0XHRcdGNvbFNwYW4gPSBjZWxsLiQuY29sU3Bhbixcblx0XHRcdFx0cm93U3BhbiA9IGNlbGwuJC5yb3dTcGFuLFxuXHRcdFx0XHRyb3dJbmRleCA9IHRyLiQucm93SW5kZXgsXG5cdFx0XHRcdGNvbEluZGV4ID0gY2VsbEluUm93KCBtYXAsIHJvd0luZGV4LCBjZWxsICk7XG5cblx0XHRcdC8vIEFjY3VtdWxhdGVkIHRoZSBhY3R1YWwgcGxhY2VzIHRha2VuIGJ5IGFsbCBzZWxlY3RlZCBjZWxscy5cblx0XHRcdGRpbWVuc2lvbiArPSBjb2xTcGFuICogcm93U3Bhbjtcblx0XHRcdC8vIEFjY3VtdWxhdGVkIHRoZSBtYXhpbXVtIHZpcnR1YWwgc3BhbnMgZnJvbSBjb2x1bW4gYW5kIHJvdy5cblx0XHRcdHRvdGFsQ29sU3BhbiA9IE1hdGgubWF4KCB0b3RhbENvbFNwYW4sIGNvbEluZGV4IC0gc3RhcnRDb2x1bW4gKyBjb2xTcGFuICk7XG5cdFx0XHR0b3RhbFJvd1NwYW4gPSBNYXRoLm1heCggdG90YWxSb3dTcGFuLCByb3dJbmRleCAtIHN0YXJ0Um93ICsgcm93U3BhbiApO1xuXG5cdFx0XHRpZiAoICFpc0RldGVjdCApIHtcblx0XHRcdFx0Ly8gVHJpbSBhbGwgY2VsbCBmaWxsZXJzIGFuZCBjaGVjayB0byByZW1vdmUgZW1wdHkgY2VsbHMuXG5cdFx0XHRcdGlmICggdHJpbUNlbGwoIGNlbGwgKSwgY2VsbC5nZXRDaGlsZHJlbigpLmNvdW50KCkgKSB7XG5cdFx0XHRcdFx0Ly8gTWVyZ2UgdmVydGljYWxseSBjZWxscyBhcyB0d28gc2VwYXJhdGVkIHBhcmFncmFwaHMuXG5cdFx0XHRcdFx0aWYgKCByb3dJbmRleCAhPSBsYXN0Um93SW5kZXggJiYgY2VsbEZpcnN0Q2hpbGQgJiYgISggY2VsbEZpcnN0Q2hpbGQuaXNCbG9ja0JvdW5kYXJ5ICYmIGNlbGxGaXJzdENoaWxkLmlzQmxvY2tCb3VuZGFyeSggeyBicjogMSB9ICkgKSApIHtcblx0XHRcdFx0XHRcdHZhciBsYXN0ID0gZnJhZy5nZXRMYXN0KCBDS0VESVRPUi5kb20ud2Fsa2VyLndoaXRlc3BhY2VzKCB0cnVlICkgKTtcblx0XHRcdFx0XHRcdGlmICggbGFzdCAmJiAhKCBsYXN0LmlzICYmIGxhc3QuaXMoICdicicgKSApIClcblx0XHRcdFx0XHRcdFx0ZnJhZy5hcHBlbmQoICdicicgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjZWxsLm1vdmVDaGlsZHJlbiggZnJhZyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPyBjZWxsLnJlbW92ZSgpIDogY2VsbC5zZXRIdG1sKCAnJyApO1xuXHRcdFx0fVxuXHRcdFx0bGFzdFJvd0luZGV4ID0gcm93SW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhaXNEZXRlY3QgKSB7XG5cdFx0XHRmcmFnLm1vdmVDaGlsZHJlbiggZmlyc3RDZWxsICk7XG5cblx0XHRcdGZpcnN0Q2VsbC5hcHBlbmRCb2d1cygpO1xuXG5cdFx0XHRpZiAoIHRvdGFsQ29sU3BhbiA+PSBtYXBXaWR0aCApXG5cdFx0XHRcdGZpcnN0Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoICdyb3dTcGFuJyApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmaXJzdENlbGwuJC5yb3dTcGFuID0gdG90YWxSb3dTcGFuO1xuXG5cdFx0XHRpZiAoIHRvdGFsUm93U3BhbiA+PSBtYXBIZWlnaHQgKVxuXHRcdFx0XHRmaXJzdENlbGwucmVtb3ZlQXR0cmlidXRlKCAnY29sU3BhbicgKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0Zmlyc3RDZWxsLiQuY29sU3BhbiA9IHRvdGFsQ29sU3BhbjtcblxuXHRcdFx0Ly8gU3dpcCBlbXB0eSA8dHI+IGxlZnQgYXQgdGhlIGVuZCBvZiB0YWJsZSBkdWUgdG8gdGhlIG1lcmdpbmcuXG5cdFx0XHR2YXIgdHJzID0gbmV3IENLRURJVE9SLmRvbS5ub2RlTGlzdCggdGFibGUuJC5yb3dzICksXG5cdFx0XHRcdGNvdW50ID0gdHJzLmNvdW50KCk7XG5cblx0XHRcdGZvciAoIGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXHRcdFx0XHR2YXIgdGFpbFRyID0gdHJzLmdldEl0ZW0oIGkgKTtcblx0XHRcdFx0aWYgKCAhdGFpbFRyLiQuY2VsbHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRhaWxUci5yZW1vdmUoKTtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmaXJzdENlbGw7XG5cdFx0fVxuXHRcdC8vIEJlIGFibGUgdG8gbWVyZ2UgY2VsbHMgb25seSBpZiBhY3R1YWwgZGltZW5zaW9uIG9mIHNlbGVjdGVkXG5cdFx0Ly8gY2VsbHMgZXF1YWxzIHRvIHRoZSBjYWN1bGF0ZWQgcmVjdGFuZ2xlLlxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICggdG90YWxSb3dTcGFuICogdG90YWxDb2xTcGFuICkgPT0gZGltZW5zaW9uO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHZlcnRpY2FsU3BsaXRDZWxsKCBzZWxlY3Rpb24sIGlzRGV0ZWN0ICkge1xuXHRcdHZhciBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbiApO1xuXHRcdGlmICggY2VsbHMubGVuZ3RoID4gMSApXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0ZWxzZSBpZiAoIGlzRGV0ZWN0IClcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0dmFyIGNlbGwgPSBjZWxsc1sgMCBdLFxuXHRcdFx0dHIgPSBjZWxsLmdldFBhcmVudCgpLFxuXHRcdFx0dGFibGUgPSB0ci5nZXRBc2NlbmRhbnQoICd0YWJsZScgKSxcblx0XHRcdG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAoIHRhYmxlICksXG5cdFx0XHRyb3dJbmRleCA9IHRyLiQucm93SW5kZXgsXG5cdFx0XHRjb2xJbmRleCA9IGNlbGxJblJvdyggbWFwLCByb3dJbmRleCwgY2VsbCApLFxuXHRcdFx0cm93U3BhbiA9IGNlbGwuJC5yb3dTcGFuLFxuXHRcdFx0bmV3Q2VsbCwgbmV3Um93U3BhbiwgbmV3Q2VsbFJvd1NwYW4sIG5ld1Jvd0luZGV4O1xuXG5cdFx0aWYgKCByb3dTcGFuID4gMSApIHtcblx0XHRcdG5ld1Jvd1NwYW4gPSBNYXRoLmNlaWwoIHJvd1NwYW4gLyAyICk7XG5cdFx0XHRuZXdDZWxsUm93U3BhbiA9IE1hdGguZmxvb3IoIHJvd1NwYW4gLyAyICk7XG5cdFx0XHRuZXdSb3dJbmRleCA9IHJvd0luZGV4ICsgbmV3Um93U3Bhbjtcblx0XHRcdHZhciBuZXdDZWxsVHIgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIHRhYmxlLiQucm93c1sgbmV3Um93SW5kZXggXSApLFxuXHRcdFx0XHRuZXdDZWxsUm93ID0gY2VsbEluUm93KCBtYXAsIG5ld1Jvd0luZGV4ICksXG5cdFx0XHRcdGNhbmRpZGF0ZUNlbGw7XG5cblx0XHRcdG5ld0NlbGwgPSBjZWxsLmNsb25lKCk7XG5cblx0XHRcdC8vIEZpZ3VyZSBvdXQgd2hlcmUgdG8gaW5zZXJ0IHRoZSBuZXcgY2VsbCBieSBjaGVja2luZyB0aGUgdml0dWFsIHJvdy5cblx0XHRcdGZvciAoIHZhciBjID0gMDsgYyA8IG5ld0NlbGxSb3cubGVuZ3RoOyBjKysgKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZUNlbGwgPSBuZXdDZWxsUm93WyBjIF07XG5cdFx0XHRcdC8vIENhdGNoIGZpcnN0IGNlbGwgYWN0dWFsbHkgZm9sbG93aW5nIHRoZSBjb2x1bW4uXG5cdFx0XHRcdGlmICggY2FuZGlkYXRlQ2VsbC5wYXJlbnROb2RlID09IG5ld0NlbGxUci4kICYmIGMgPiBjb2xJbmRleCApIHtcblx0XHRcdFx0XHRuZXdDZWxsLmluc2VydEJlZm9yZSggbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBjYW5kaWRhdGVDZWxsICkgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYW5kaWRhdGVDZWxsID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZGVzdGluYXRpb24gcm93IGlzIGVtcHR5LCBhcHBlbmQgYXQgd2lsbC5cblx0XHRcdGlmICggIWNhbmRpZGF0ZUNlbGwgKVxuXHRcdFx0XHRuZXdDZWxsVHIuYXBwZW5kKCBuZXdDZWxsICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0NlbGxSb3dTcGFuID0gbmV3Um93U3BhbiA9IDE7XG5cblx0XHRcdG5ld0NlbGxUciA9IHRyLmNsb25lKCk7XG5cdFx0XHRuZXdDZWxsVHIuaW5zZXJ0QWZ0ZXIoIHRyICk7XG5cdFx0XHRuZXdDZWxsVHIuYXBwZW5kKCBuZXdDZWxsID0gY2VsbC5jbG9uZSgpICk7XG5cblx0XHRcdHZhciBjZWxsc0luU2FtZVJvdyA9IGNlbGxJblJvdyggbWFwLCByb3dJbmRleCApO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2VsbHNJblNhbWVSb3cubGVuZ3RoOyBpKysgKVxuXHRcdFx0XHRjZWxsc0luU2FtZVJvd1sgaSBdLnJvd1NwYW4rKztcblx0XHR9XG5cblx0XHRuZXdDZWxsLmFwcGVuZEJvZ3VzKCk7XG5cblx0XHRjZWxsLiQucm93U3BhbiA9IG5ld1Jvd1NwYW47XG5cdFx0bmV3Q2VsbC4kLnJvd1NwYW4gPSBuZXdDZWxsUm93U3Bhbjtcblx0XHRpZiAoIG5ld1Jvd1NwYW4gPT0gMSApXG5cdFx0XHRjZWxsLnJlbW92ZUF0dHJpYnV0ZSggJ3Jvd1NwYW4nICk7XG5cdFx0aWYgKCBuZXdDZWxsUm93U3BhbiA9PSAxIClcblx0XHRcdG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCAncm93U3BhbicgKTtcblxuXHRcdHJldHVybiBuZXdDZWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaG9yaXpvbnRhbFNwbGl0Q2VsbCggc2VsZWN0aW9uLCBpc0RldGVjdCApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb24gKTtcblx0XHRpZiAoIGNlbGxzLmxlbmd0aCA+IDEgKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGVsc2UgaWYgKCBpc0RldGVjdCApXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdHZhciBjZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdHRyID0gY2VsbC5nZXRQYXJlbnQoKSxcblx0XHRcdHRhYmxlID0gdHIuZ2V0QXNjZW5kYW50KCAndGFibGUnICksXG5cdFx0XHRtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKCB0YWJsZSApLFxuXHRcdFx0cm93SW5kZXggPSB0ci4kLnJvd0luZGV4LFxuXHRcdFx0Y29sSW5kZXggPSBjZWxsSW5Sb3coIG1hcCwgcm93SW5kZXgsIGNlbGwgKSxcblx0XHRcdGNvbFNwYW4gPSBjZWxsLiQuY29sU3Bhbixcblx0XHRcdG5ld0NlbGwsIG5ld0NvbFNwYW4sIG5ld0NlbGxDb2xTcGFuO1xuXG5cdFx0aWYgKCBjb2xTcGFuID4gMSApIHtcblx0XHRcdG5ld0NvbFNwYW4gPSBNYXRoLmNlaWwoIGNvbFNwYW4gLyAyICk7XG5cdFx0XHRuZXdDZWxsQ29sU3BhbiA9IE1hdGguZmxvb3IoIGNvbFNwYW4gLyAyICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0NlbGxDb2xTcGFuID0gbmV3Q29sU3BhbiA9IDE7XG5cdFx0XHR2YXIgY2VsbHNJblNhbWVDb2wgPSBjZWxsSW5Db2woIG1hcCwgY29sSW5kZXggKTtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNlbGxzSW5TYW1lQ29sLmxlbmd0aDsgaSsrIClcblx0XHRcdFx0Y2VsbHNJblNhbWVDb2xbIGkgXS5jb2xTcGFuKys7XG5cdFx0fVxuXHRcdG5ld0NlbGwgPSBjZWxsLmNsb25lKCk7XG5cdFx0bmV3Q2VsbC5pbnNlcnRBZnRlciggY2VsbCApO1xuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGNlbGwuJC5jb2xTcGFuID0gbmV3Q29sU3Bhbjtcblx0XHRuZXdDZWxsLiQuY29sU3BhbiA9IG5ld0NlbGxDb2xTcGFuO1xuXHRcdGlmICggbmV3Q29sU3BhbiA9PSAxIClcblx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCAnY29sU3BhbicgKTtcblx0XHRpZiAoIG5ld0NlbGxDb2xTcGFuID09IDEgKVxuXHRcdFx0bmV3Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoICdjb2xTcGFuJyApO1xuXG5cdFx0cmV0dXJuIG5ld0NlbGw7XG5cdH1cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfdGFibGV0b29scycsIHtcblx0XHRpbml0OiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0dmFyIGxhbmcgPSBlZGl0b3IubGFuZy50YWJsZTtcblxuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlRGVmKCBkZWYgKSB7XG5cdFx0XHRcdHJldHVybiBDS0VESVRPUi50b29scy5leHRlbmQoIGRlZiB8fCB7fSwge1xuXHRcdFx0XHRcdGNvbnRleHRTZW5zaXRpdmU6IDEsXG5cdFx0XHRcdFx0cmVmcmVzaDogZnVuY3Rpb24oIGVkaXRvciwgcGF0aCApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoIHBhdGguY29udGFpbnMoIHsgdGQ6IDEsIHRoOiAxIH0sIDEgKSA/IENLRURJVE9SLlRSSVNUQVRFX09GRiA6IENLRURJVE9SLlRSSVNUQVRFX0RJU0FCTEVEICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBhZGRDbWQoIG5hbWUsIGRlZiApIHtcblx0XHRcdFx0dmFyIGNtZCA9IGVkaXRvci5nZXRDb21tYW5kKG5hbWUpO1xuXG5cdFx0XHRcdGlmIChjbWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjbWQgPSBlZGl0b3IuYWRkQ29tbWFuZChuYW1lLCBkZWYpO1xuXHRcdFx0XHRlZGl0b3IuYWRkRmVhdHVyZShjbWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRhZGRDbWQoICdyb3dEZWxldGUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIGRlbGV0ZVJvd3MoIHNlbGVjdGlvbiApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdyb3dJbnNlcnRCZWZvcmUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0aW5zZXJ0Um93KCBzZWxlY3Rpb24sIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ3Jvd0luc2VydEFmdGVyJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdGluc2VydFJvdyggc2VsZWN0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjb2x1bW5EZWxldGUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSBkZWxldGVDb2x1bW5zKCBzZWxlY3Rpb24gKTtcblx0XHRcdFx0XHRlbGVtZW50ICYmIHBsYWNlQ3Vyc29ySW5DZWxsKCBlbGVtZW50LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjb2x1bW5JbnNlcnRCZWZvcmUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0aW5zZXJ0Q29sdW1uKCBzZWxlY3Rpb24sIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NvbHVtbkluc2VydEFmdGVyJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdGluc2VydENvbHVtbiggc2VsZWN0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjZWxsRGVsZXRlJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdGRlbGV0ZUNlbGxzKCBzZWxlY3Rpb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxNZXJnZScsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW2NvbHNwYW4scm93c3Bhbl0nLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuLHJvd3NwYW5dJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbCggbWVyZ2VDZWxscyggZWRpdG9yLmdldFNlbGVjdGlvbigpICksIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxNZXJnZVJpZ2h0JywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuXScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIG1lcmdlQ2VsbHMoIGVkaXRvci5nZXRTZWxlY3Rpb24oKSwgJ3JpZ2h0JyApLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjZWxsTWVyZ2VEb3duJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtyb3dzcGFuXScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIG1lcmdlQ2VsbHMoIGVkaXRvci5nZXRTZWxlY3Rpb24oKSwgJ2Rvd24nICksIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxWZXJ0aWNhbFNwbGl0JywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtyb3dzcGFuXScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIHZlcnRpY2FsU3BsaXRDZWxsKCBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAnY2VsbEhvcml6b250YWxTcGxpdCcsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW2NvbHNwYW5dJyxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKCBob3Jpem9udGFsU3BsaXRDZWxsKCBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAnY2VsbEluc2VydEJlZm9yZScsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRpbnNlcnRDZWxsKCBzZWxlY3Rpb24sIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxJbnNlcnRBZnRlcicsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRpbnNlcnRDZWxsKCBzZWxlY3Rpb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fSxcblxuXHRcdGdldFNlbGVjdGVkQ2VsbHM6IGdldFNlbGVjdGVkQ2VsbHNcblxuXHR9KTtcbn0gKSgpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHR3by1kaW1lbnNpb24gYXJyYXkgdGhhdCByZWZsZWN0cyB0aGUgYWN0dWFsIGxheW91dCBvZiB0YWJsZSBjZWxscyxcbiAqIHdpdGggY2VsbCBzcGFucywgd2l0aCBtYXBwaW5ncyB0byB0aGUgb3JpZ2luYWwgdGQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGVcbiAqIEBtZW1iZXIgQ0tFRElUT1IudG9vbHNcbiAqL1xuQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCA9IGZ1bmN0aW9uKCB0YWJsZSApIHtcblx0dmFyIGFSb3dzID0gdGFibGUuJC5yb3dzO1xuXG5cdC8vIFJvdyBhbmQgQ29sdW1uIGNvdW50ZXJzLlxuXHR2YXIgciA9IC0xO1xuXG5cdHZhciBhTWFwID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYVJvd3MubGVuZ3RoOyBpKysgKSB7XG5cdFx0cisrO1xuXHRcdCFhTWFwWyByIF0gJiYgKCBhTWFwWyByIF0gPSBbXSApO1xuXG5cdFx0dmFyIGMgPSAtMTtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGFSb3dzWyBpIF0uY2VsbHMubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHR2YXIgb0NlbGwgPSBhUm93c1sgaSBdLmNlbGxzWyBqIF07XG5cblx0XHRcdGMrKztcblx0XHRcdHdoaWxlICggYU1hcFsgciBdWyBjIF0gKVxuXHRcdFx0XHRjKys7XG5cblx0XHRcdHZhciBpQ29sU3BhbiA9IGlzTmFOKCBvQ2VsbC5jb2xTcGFuICkgPyAxIDogb0NlbGwuY29sU3Bhbjtcblx0XHRcdHZhciBpUm93U3BhbiA9IGlzTmFOKCBvQ2VsbC5yb3dTcGFuICkgPyAxIDogb0NlbGwucm93U3BhbjtcblxuXHRcdFx0Zm9yICggdmFyIHJzID0gMDsgcnMgPCBpUm93U3BhbjsgcnMrKyApIHtcblx0XHRcdFx0aWYgKCAhYU1hcFsgciArIHJzIF0gKVxuXHRcdFx0XHRcdGFNYXBbIHIgKyBycyBdID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGNzID0gMDsgY3MgPCBpQ29sU3BhbjsgY3MrKyApIHtcblx0XHRcdFx0XHRhTWFwWyByICsgcnMgXVsgYyArIGNzIF0gPSBhUm93c1sgaSBdLmNlbGxzWyBqIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YyArPSBpQ29sU3BhbiAtIDE7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhTWFwO1xufTtcbiIsInZhciB0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnYWUtYXJyb3ctYm94IGFlLWFycm93LWJveC1ib3R0b20nO1xufTtcblxuY29uc3QgU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzID0ge1xuICAgIHRhYmxlOiB0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3Nlc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzOyIsImltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vLyBEZWZhdWx0IGd1dHRlciB2YWx1ZSBmb3IgdG9vbGJhciBwb3NpdGlvbmluZ1xudmFyIERFRkFVTFRfR1VUVEVSID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG59O1xuXG4vKipcbiAqIENlbnRlcnMgYSBUb29sYmFyIGFjY29yZGluZyB0byBnaXZlbiByZWN0YW5nbGVcbiAqXG4gKiBAbWV0aG9kIGNlbnRlclRvb2xiYXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b29sYmFyIFRoZSB0b29sYmFyIHRvIGJlIGNlbnRlcmVkXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCBUaGUgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB3aGljaCB0aGUgVG9vbGJhciB3aWxsIGJlIGNlbnRlcmVkXG4gKi9cbnZhciBjZW50ZXJUb29sYmFyID0gZnVuY3Rpb24odG9vbGJhciwgcmVjdCkge1xuICAgIHZhciB0b29sYmFyTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRvb2xiYXIpO1xuXG4gICAgdmFyIGhhbGZOb2RlV2lkdGggPSB0b29sYmFyTm9kZS5vZmZzZXRXaWR0aCAvIDI7XG4gICAgdmFyIHNjcm9sbFBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3cod2luZG93KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXG4gICAgdmFyIGd1dHRlciA9IHRvb2xiYXIucHJvcHMuZ3V0dGVyIHx8IERFRkFVTFRfR1VUVEVSO1xuXG4gICAgdmFyIHdpZGdldFhZID0gdG9vbGJhci5nZXRXaWRnZXRYWVBvaW50KHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyIC0gc2Nyb2xsUG9zaXRpb24ueCwgcmVjdC50b3AgKyBzY3JvbGxQb3NpdGlvbi55LCBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCk7XG5cbiAgICB0b29sYmFyLm1vdmVUb1BvaW50KFtcbiAgICAgICAgd2lkZ2V0WFlbMF0sXG4gICAgICAgIHdpZGdldFhZWzFdXG4gICAgXSwgW1xuICAgICAgICByZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiAtIGhhbGZOb2RlV2lkdGggLSBzY3JvbGxQb3NpdGlvbi54LFxuICAgICAgICByZWN0LnRvcCAtIHRvb2xiYXJOb2RlLm9mZnNldEhlaWdodCArIHNjcm9sbFBvc2l0aW9uLnkgLSBndXR0ZXIudG9wXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgdG9vbGJhciBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICpcbiAqIEBtZXRob2QgaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgUGF5bG9hZCwgc2hvdWxkIGNvbnRhaW4gdGhlIHNlbGVjdGlvbiBkYXRhIGZvciByZXRyaWV2aW5nIHRoZVxuICogY2xpZW50IHJlY3RhbmdsZSBvZiB0aGUgc2VsZWN0ZWQgaW1hZ2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUsIGluIGFsbCBjYXNlc1xuICovXG52YXIgaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICBjZW50ZXJUb29sYmFyKHRoaXMsIHBheWxvYWQuc2VsZWN0aW9uRGF0YS5lbGVtZW50LmdldENsaWVudFJlY3QoKSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcG9zaXRpb24gb2YgYSB0b29sYmFyIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIGltYWdlXG4gKlxuICogQG1ldGhvZCB0YWJsZVNlbGVjdGlvblNldFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCBPYmplY3QsIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWxlY3Rpb24gZGF0YSBmb3IgcmV0cmlldmluZyB0aGVcbiAqIGNsaWVudCByZWN0YW5nbGUgb2YgdGhlIHNlbGVjdGVkIHRhYmxlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlLCBpbiBhbGwgY2FzZXNcbiAqL1xudmFyIHRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb24gPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgdmFyIG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICB2YXIgdGFibGUgPSBuZXcgQ0tFRElUT1IuVGFibGUobmF0aXZlRWRpdG9yKS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cbiAgICBjZW50ZXJUb29sYmFyKHRoaXMsIHRhYmxlLmdldENsaWVudFJlY3QoKSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IFNlbGVjdGlvblNldFBvc2l0aW9uID0ge1xuICAgIGltYWdlOiBpbWFnZVNlbGVjdGlvblNldFBvc2l0aW9uLFxuICAgIHRhYmxlOiB0YWJsZVNlbGVjdGlvblNldFBvc2l0aW9uXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Rpb25TZXRQb3NpdGlvbjsiLCJ2YXIgX2lzUmFuZ2VBdEVsZW1lbnRFbmQgPSBmdW5jdGlvbihyYW5nZSwgZWxlbWVudCkge1xuICAgIC8vIEZpbmRpbmcgaWYgYSByYW5nZSBpcyBhdCB0aGUgZW5kIG9mIGFuIGVsZW1lbnQgaXMgc29tZXdoYXQgdHJpY2t5IGR1ZSB0byBob3cgQ0tFZGl0b3IgaGFuZGxlc1xuICAgIC8vIHJhbmdlcy4gSXQgbWlnaHQgZGVwZW5kIG9uIHdldGhlciBhIHNvdXJjZSBub2RlIGluc2lkZSB0aGUgZWxlbWVudCBpcyBzZWxlY3RlZCBvciBub3QuIEZvciBub3csXG4gICAgLy8gd2UgbmVlZCB0byBjb3ZlciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgIC8vXG4gICAgLy8gLSBUaGUgdGV4dCBsZW5ndGggb2YgdGhlIGVsZW1lbnQgaXMgdGhlIHNhbWUgYXMgdGhlIGVuZE9mZnNldCBvZiB0aGUgcmFuZ2VcbiAgICAvLyAtIEJvdGggc3RhcnQgYW5kIGVuZCBjb250YWluZXJzIG1hdGNoIHRoZSBlbGVtZW50IGFuZCB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGFyZSAxXG5cbiAgICByZXR1cm4gZWxlbWVudC5nZXRUZXh0KCkubGVuZ3RoID09PSByYW5nZS5lbmRPZmZzZXQgfHxcbiAgICAgICAgKFxuICAgICAgICAgICAgZWxlbWVudC5lcXVhbHMocmFuZ2Uuc3RhcnRDb250YWluZXIpICYmXG4gICAgICAgICAgICBlbGVtZW50LmVxdWFscyhyYW5nZS5lbmRDb250YWluZXIpICYmXG4gICAgICAgICAgICByYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2UuZW5kT2Zmc2V0ICYmXG4gICAgICAgICAgICByYW5nZS5lbmRPZmZzZXQgPT09IDFcbiAgICAgICAgKTtcbn07XG5cbnZhciBlbWJlZFNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgdmFyIHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblxuICAgIHJldHVybiAhIShcbiAgICAgICAgc2VsZWN0aW9uRGF0YS5lbGVtZW50ICYmXG4gICAgICAgIHNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtd2lkZ2V0JykgPT09ICdhZV9lbWJlZCdcbiAgICApO1xufTtcblxudmFyIGxpbmtTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIHZhciBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgIHZhciByYW5nZSA9IG5hdGl2ZUVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcblxuICAgIHZhciBlbGVtZW50O1xuXG4gICAgcmV0dXJuICEhKFxuICAgICAgICBuYXRpdmVFZGl0b3IuaXNTZWxlY3Rpb25FbXB0eSgpICYmXG4gICAgICAgIChlbGVtZW50ID0gKG5ldyBDS0VESVRPUi5MaW5rKG5hdGl2ZUVkaXRvcikpLmdldEZyb21TZWxlY3Rpb24oKSkgJiZcbiAgICAgICAgZWxlbWVudC5nZXRUZXh0KCkubGVuZ3RoICE9PSByYW5nZS5lbmRPZmZzZXQgJiZcbiAgICAgICAgIWVsZW1lbnQuaXNSZWFkT25seSgpICYmXG4gICAgICAgICFfaXNSYW5nZUF0RWxlbWVudEVuZChyYW5nZSwgZWxlbWVudClcbiAgICApO1xufTtcblxudmFyIGltYWdlU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IHBheWxvYWQuZGF0YS5zZWxlY3Rpb25EYXRhO1xuXG4gICAgcmV0dXJuICEhKFxuICAgICAgICBzZWxlY3Rpb25EYXRhLmVsZW1lbnQgJiZcbiAgICAgICAgc2VsZWN0aW9uRGF0YS5lbGVtZW50LmdldE5hbWUoKSA9PT0gJ2ltZycgJiZcbiAgICAgICAgIXNlbGVjdGlvbkRhdGEuZWxlbWVudC5pc1JlYWRPbmx5KClcbiAgICApO1xufTtcblxudmFyIHRleHRTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIHZhciBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgdmFyIHNlbGVjdGlvbkVtcHR5ID0gbmF0aXZlRWRpdG9yLmlzU2VsZWN0aW9uRW1wdHkoKTtcblxuICAgIHZhciBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cbiAgICByZXR1cm4gISEoXG4gICAgICAgICFzZWxlY3Rpb25EYXRhLmVsZW1lbnQgJiZcbiAgICAgICAgc2VsZWN0aW9uRGF0YS5yZWdpb24gJiZcbiAgICAgICAgIXNlbGVjdGlvbkVtcHR5ICYmXG4gICAgICAgICFuYXRpdmVFZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0Q29tbW9uQW5jZXN0b3IoKS5pc1JlYWRPbmx5KClcbiAgICApO1xufTtcblxudmFyIHRhYmxlU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICB2YXIgbmF0aXZlRWRpdG9yID0gcGF5bG9hZC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgIHZhciB0YWJsZSA9IG5ldyBDS0VESVRPUi5UYWJsZShuYXRpdmVFZGl0b3IpO1xuICAgIHZhciBlbGVtZW50ID0gdGFibGUuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgcmV0dXJuICEhKGVsZW1lbnQgJiYgdGFibGUuaXNFZGl0YWJsZShlbGVtZW50KSk7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25UZXN0ID0ge1xuICAgIGVtYmVkOiBlbWJlZFNlbGVjdGlvblRlc3QsXG4gICAgaW1hZ2U6IGltYWdlU2VsZWN0aW9uVGVzdCxcbiAgICBsaW5rOiBsaW5rU2VsZWN0aW9uVGVzdCxcbiAgICB0YWJsZTogdGFibGVTZWxlY3Rpb25UZXN0LFxuICAgIHRleHQ6IHRleHRTZWxlY3Rpb25UZXN0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Rpb25UZXN0OyIsImltcG9ydCBTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgZnJvbSAnLi9zZWxlY3Rpb24tYXJyb3dib3guanMnO1xuaW1wb3J0IFNlbGVjdGlvblNldFBvc2l0aW9uIGZyb20gJy4vc2VsZWN0aW9uLXBvc2l0aW9uLmpzJztcbmltcG9ydCBTZWxlY3Rpb25UZXN0IGZyb20gJy4vc2VsZWN0aW9uLXRlc3QuanMnO1xuXG5jb25zdCBTZWxlY3Rpb25zID0gW3tcbiAgICBuYW1lOiAnZW1iZWQnLFxuICAgIGJ1dHRvbnM6IFsnZW1iZWRSZW1vdmUnLCAnZW1iZWRFZGl0J10sXG4gICAgdGVzdDogU2VsZWN0aW9uVGVzdC5lbWJlZFxufSwge1xuICAgIG5hbWU6ICdsaW5rJyxcbiAgICBidXR0b25zOiBbJ2xpbmtFZGl0J10sXG4gICAgdGVzdDogU2VsZWN0aW9uVGVzdC5saW5rXG59LCB7XG4gICAgbmFtZTogJ2ltYWdlJyxcbiAgICBidXR0b25zOiBbJ2ltYWdlTGVmdCcsICdpbWFnZUNlbnRlcicsICdpbWFnZVJpZ2h0J10sXG4gICAgc2V0UG9zaXRpb246IFNlbGVjdGlvblNldFBvc2l0aW9uLmltYWdlLFxuICAgIHRlc3Q6IFNlbGVjdGlvblRlc3QuaW1hZ2Vcbn0sIHtcbiAgICBuYW1lOiAndGV4dCcsXG4gICAgYnV0dG9uczogWydzdHlsZXMnLCAnYm9sZCcsICdpdGFsaWMnLCAndW5kZXJsaW5lJywgJ2xpbmsnLCAndHdpdHRlciddLFxuICAgIHRlc3Q6IFNlbGVjdGlvblRlc3QudGV4dFxufSwge1xuICAgIG5hbWU6ICd0YWJsZScsXG4gICAgYnV0dG9uczogWyd0YWJsZUhlYWRpbmcnLCAndGFibGVSb3cnLCAndGFibGVDb2x1bW4nLCAndGFibGVDZWxsJywgJ3RhYmxlUmVtb3ZlJ10sXG4gICAgZ2V0QXJyb3dCb3hDbGFzc2VzOiBTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMudGFibGUsXG4gICAgc2V0UG9zaXRpb246IFNlbGVjdGlvblNldFBvc2l0aW9uLnRhYmxlLFxuICAgIHRlc3Q6IFNlbGVjdGlvblRlc3QudGFibGVcbn1dO1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Rpb25zOyIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJSZWFjdFwiXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiUmVhY3RET01cIl07IH0oKSk7Il0sInNvdXJjZVJvb3QiOiIifQ==